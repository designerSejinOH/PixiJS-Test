/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_components_canvas_Scene_tsx",{

/***/ "./node_modules/@pixi/react/dist/index.es-dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/react/dist/index.es-dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimatedSprite\": function() { return /* binding */ AnimatedSprite; },\n/* harmony export */   \"AppConsumer\": function() { return /* binding */ AppConsumer; },\n/* harmony export */   \"AppContext\": function() { return /* binding */ Context; },\n/* harmony export */   \"AppProvider\": function() { return /* binding */ AppProvider; },\n/* harmony export */   \"BitmapText\": function() { return /* binding */ BitmapText; },\n/* harmony export */   \"Container\": function() { return /* binding */ Container; },\n/* harmony export */   \"Graphics\": function() { return /* binding */ Graphics; },\n/* harmony export */   \"NineSlicePlane\": function() { return /* binding */ NineSlicePlane; },\n/* harmony export */   \"ParticleContainer\": function() { return /* binding */ ParticleContainer; },\n/* harmony export */   \"PixiComponent\": function() { return /* binding */ PixiComponent; },\n/* harmony export */   \"PixiFiber\": function() { return /* binding */ PixiFiber; },\n/* harmony export */   \"SimpleMesh\": function() { return /* binding */ SimpleMesh; },\n/* harmony export */   \"SimpleRope\": function() { return /* binding */ SimpleRope; },\n/* harmony export */   \"Sprite\": function() { return /* binding */ Sprite; },\n/* harmony export */   \"Stage\": function() { return /* binding */ Stage$1; },\n/* harmony export */   \"TYPES\": function() { return /* binding */ TYPES; },\n/* harmony export */   \"Text\": function() { return /* binding */ Text; },\n/* harmony export */   \"TilingSprite\": function() { return /* binding */ TilingSprite; },\n/* harmony export */   \"applyDefaultProps\": function() { return /* binding */ applyDefaultProps; },\n/* harmony export */   \"createRoot\": function() { return /* binding */ createRoot; },\n/* harmony export */   \"eventHandlers\": function() { return /* binding */ eventHandlers; },\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* binding */ unmountComponentAtNode; },\n/* harmony export */   \"useApp\": function() { return /* binding */ useApp; },\n/* harmony export */   \"useTick\": function() { return /* binding */ useTick; },\n/* harmony export */   \"withFilters\": function() { return /* binding */ withFilters; },\n/* harmony export */   \"withPixiApp\": function() { return /* binding */ withPixiApp; }\n/* harmony export */ });\n/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ \"./node_modules/@pixi/core/lib/index.mjs\");\n/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ \"./node_modules/@pixi/display/lib/index.mjs\");\n/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/lib/index.mjs\");\n/* harmony import */ var _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/text-bitmap */ \"./node_modules/@pixi/text-bitmap/lib/index.mjs\");\n/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/graphics */ \"./node_modules/@pixi/graphics/lib/index.mjs\");\n/* harmony import */ var _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/mesh-extras */ \"./node_modules/@pixi/mesh-extras/lib/index.mjs\");\n/* harmony import */ var _pixi_particle_container__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/particle-container */ \"./node_modules/@pixi/particle-container/lib/index.mjs\");\n/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pixi/sprite */ \"./node_modules/@pixi/sprite/lib/index.mjs\");\n/* harmony import */ var _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pixi/sprite-animated */ \"./node_modules/@pixi/sprite-animated/lib/index.mjs\");\n/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @pixi/text */ \"./node_modules/@pixi/text/lib/index.mjs\");\n/* harmony import */ var _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi/sprite-tiling */ \"./node_modules/@pixi/sprite-tiling/lib/index.mjs\");\n/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/constants */ \"./node_modules/@pixi/constants/lib/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _pixi_app__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @pixi/app */ \"./node_modules/@pixi/app/lib/index.mjs\");\n/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @pixi/ticker */ \"./node_modules/@pixi/ticker/lib/index.mjs\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_15__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\n// borrowed from fbjs\nfunction invariant(condition, format) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return String(args[argIndex++]);\n      }));\n      error.name = 'Invariant Violation';\n    }\n    error.framesToPop = 1; // Skip invariant's own stack frame.\n    throw error;\n  }\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n/**\n * lodash 4.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nvar lodash_isnil = isNil;\n\n/**\n * Parse PIXI point value to array of coordinates\n *\n * @param {*} value\n * @returns {Array}\n */\nfunction parsePoint(value) {\n  var arr = [];\n  if (typeof value === 'undefined') {\n    return arr;\n  } else if (typeof value === 'string') {\n    arr = value.split(',');\n  } else if (typeof value === 'number') {\n    arr = [value];\n  } else if (Array.isArray(value)) {\n    arr = _toConsumableArray(value);\n  } else if (value !== null && _typeof(value) === 'object') {\n    var x = value && (value === null || value === void 0 ? void 0 : value.x) || 0;\n    var y = value && (value === null || value === void 0 ? void 0 : value.y) || 0;\n    arr = [x, y];\n  } else {\n    return arr;\n  }\n  return arr.filter(function (p) {\n    return !lodash_isnil(p) && !isNaN(p);\n  }).map(Number);\n}\n\n/**\n * Check if two points are equal\n *\n * @param {*} oldValue\n * @param {*} newValue\n * @returns {boolean}\n */\nfunction pointsAreEqual(oldValue, newValue) {\n  if (oldValue.length !== newValue.length) {\n    return false;\n  }\n  for (var i = 0; i < oldValue.length; i++) {\n    if (oldValue[i] !== newValue[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Determine value is type of Point or ObservablePoint\n * See https://github.com/michalochman/react-pixi-fiber/blob/a4dbddbef0ffbf0f563c64d30766ea28222a51ea/src/utils.js#L48\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isPointType(value) {\n  return value instanceof _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Point || value instanceof _pixi_math__WEBPACK_IMPORTED_MODULE_2__.ObservablePoint;\n}\n\n/**\n * Event handlers\n *\n * @type {string[]}\n */\nvar eventHandlers = ['click', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mouseupoutside', 'tap', 'touchstart', 'touchmove', 'touchend', 'touchendoutside', 'pointercancel', 'pointerout', 'pointerover', 'pointertap', 'pointerdown', 'pointerup', 'pointerupoutside', 'pointermove', 'rightclick', 'rightdown', 'rightup', 'rightupoutside', 'touchcancel', 'touchendoutside', 'touchmove', 'touchstart'];\n\n/**\n * Set value on a PIXI.DisplayObject\n * See https://github.com/Izzimach/react-pixi/blob/a25196251a13ed9bb116a8576d93e9fceac2a14c/src/ReactPIXI.js#L114\n *\n * @param {PIXI.DisplayObject} instance\n * @param {string} prop\n * @param {*} value\n */\nfunction setValue(instance, prop, value) {\n  if (isPointType(instance[prop]) && isPointType(value)) {\n    // copy value\n    instance[prop].copyFrom(value);\n  } else if (isPointType(instance[prop])) {\n    // parse value if a non-Point type is being assigned to a Point type\n    var coordinates = parsePoint(value);\n    invariant(typeof coordinates !== 'undefined' && coordinates.length > 0 && coordinates.length < 3, 'The property `%s` is a `PIXI.Point` or `PIXI.ObservablePoint` and must be set to a comma-separated string of ' + 'either 1 or 2 coordinates, a 1 or 2 element array containing coordinates, or a PIXI Point/ObservablePoint. ' + 'If only one coordinate is given then X and Y will be set to the provided value. Received: `%s` of type `%s`.', prop, JSON.stringify(value), _typeof(value));\n    instance[prop].set(coordinates.shift(), coordinates.shift());\n  } else {\n    // just hard assign value\n    instance[prop] = value;\n  }\n}\n\nvar isFunction = function isFunction() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args.every(function (v) {\n    return typeof v === 'function';\n  });\n};\nvar isObject = function isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n};\nvar hasKey = function hasKey(collection) {\n  var coll = collection;\n  if (!Array.isArray(coll)) {\n    if (isObject(collection)) {\n      coll = Object.keys(collection);\n    } else {\n      throw new Error('collection needs to be an Array or Object');\n    }\n  }\n  var index = {};\n  coll.forEach(function (key) {\n    index[key] = true;\n  });\n  return function (key) {\n    return typeof index[key] !== 'undefined';\n  };\n};\nvar not = function not(boolFn) {\n  return function () {\n    return !boolFn.apply(void 0, arguments);\n  };\n};\n\nvar _PROPS_RESERVED;\nvar CHILDREN = 'children';\n/**\n * Reserved props\n *\n * @type {Object}\n */\nvar PROPS_RESERVED = (_PROPS_RESERVED = {}, _defineProperty(_PROPS_RESERVED, CHILDREN, true), _defineProperty(_PROPS_RESERVED, \"parent\", true), _defineProperty(_PROPS_RESERVED, \"worldAlpha\", true), _defineProperty(_PROPS_RESERVED, \"worldTransform\", true), _defineProperty(_PROPS_RESERVED, \"worldVisible\", true), _PROPS_RESERVED);\n\n/**\n * Default display object props\n * See https://github.com/michalochman/react-pixi-fiber/blob/a4dbddbef0ffbf0f563c64d30766ea28222a51ea/src/props.js#L9\n *\n * @type {Object}\n */\nvar PROPS_DISPLAY_OBJECT = {\n  alpha: 1,\n  buttonMode: false,\n  cacheAsBitmap: false,\n  cursor: null,\n  filterArea: null,\n  filters: null,\n  hitArea: null,\n  interactive: false,\n  mask: null,\n  pivot: 0,\n  position: 0,\n  renderable: true,\n  rotation: 0,\n  scale: 1,\n  skew: 0,\n  transform: null,\n  visible: true,\n  x: 0,\n  y: 0\n};\n\n/**\n * Helper util for fetching the texture from props\n * Can be either texture or image\n *\n * @param {string} elementType\n * @param {PIXI.Container} root\n * @param {object} props\n * @returns {PIXI.Texture|null}\n */\nvar getTextureFromProps = function getTextureFromProps(elementType, root) {\n  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var emitChange = function emitChange(texture) {\n    return requestAnimationFrame(function () {\n      var _texture$__reactpixi, _texture$__reactpixi$;\n      texture === null || texture === void 0 ? void 0 : (_texture$__reactpixi = texture.__reactpixi) === null || _texture$__reactpixi === void 0 ? void 0 : (_texture$__reactpixi$ = _texture$__reactpixi.root) === null || _texture$__reactpixi$ === void 0 ? void 0 : _texture$__reactpixi$.emit(\"__REACT_PIXI_REQUEST_RENDER__\");\n    });\n  };\n\n  // eslint-disable-next-line consistent-return\n  var check = function check(inType, validator) {\n    if (props.hasOwnProperty(inType)) {\n      var valid = validator.typeofs.some(function (t) {\n        return _typeof(props[inType]) === t;\n      }) || validator.instanceofs.some(function (i) {\n        return props[inType] instanceof i;\n      });\n      invariant(valid, \"\".concat(elementType, \" \").concat(inType, \" prop is invalid\"));\n      return props[inType];\n    }\n  };\n  if (props.texture) {\n    invariant(props.texture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture, \"\".concat(elementType, \" texture needs to be typeof `Texture`\"));\n    return props.texture;\n  }\n  var result = check('image', {\n    typeofs: ['string'],\n    instanceofs: [HTMLImageElement]\n  }) || check('video', {\n    typeofs: ['string'],\n    instanceofs: [HTMLVideoElement]\n  }) || check('source', {\n    typeofs: ['string', 'number'],\n    instanceofs: [HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture]\n  });\n  invariant(!!result, \"\".concat(elementType, \" could not get texture from props\"));\n  var texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(result);\n  texture.__reactpixi = {\n    root: root\n  };\n  texture.once('update', emitChange);\n  texture.once('loaded', emitChange);\n  if (texture.valid) {\n    emitChange(texture);\n  }\n  return texture;\n};\nvar filterProps = not(hasKey([].concat(_toConsumableArray(Object.keys(PROPS_RESERVED)), _toConsumableArray(eventHandlers))));\n\n/**\n * Apply default props on Display Object instance (which are all components)\n *\n * @param {PIXI.DisplayObject} instance\n * @param {Object} oldProps\n * @param {Object} newProps\n */\nfunction applyDefaultProps(instance, oldProps, newProps) {\n  var changed = false;\n  invariant(_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype.isPrototypeOf(instance), 'instance needs to be typeof `DisplayObject`, got `%s`', _typeof(instance));\n\n  // update event handlers\n  if (!newProps.ignoreEvents) {\n    var hasRemoveListener = typeof instance.removeListener === 'function';\n    var hasOn = typeof instance.on === 'function';\n    for (var i = 0; i < eventHandlers.length; i++) {\n      var evt = eventHandlers[i];\n      if (oldProps[evt] !== newProps[evt]) {\n        changed = true;\n        if (typeof oldProps[evt] === 'function' && hasRemoveListener) {\n          instance.removeListener(evt, oldProps[evt]);\n        }\n        if (typeof newProps[evt] === 'function' && hasOn) {\n          instance.on(evt, newProps[evt]);\n        }\n      }\n    }\n  }\n  var newPropKeys = Object.keys(newProps || {});\n\n  // hard overwrite all props? can speed up performance\n  if (newProps.overwriteProps) {\n    for (var _i = 0; _i < newPropKeys.length; _i++) {\n      var p = newPropKeys[_i];\n      if (oldProps[p] !== newProps[p]) {\n        changed = true;\n        setValue(instance, p, newProps[p]);\n      }\n    }\n\n    // TODO: previously this returned nothing ie. falsy, should we explicitly return false here instead or was it always\n    // a subtle bug, test the intention\n    return changed;\n  }\n  var props = newPropKeys.filter(filterProps);\n  for (var _i2 = 0; _i2 < props.length; _i2++) {\n    var prop = props[_i2];\n    var value = newProps[prop];\n    if (newProps[prop] !== oldProps[prop]) {\n      changed = true;\n    }\n    if (value !== undefined) {\n      // set value if defined\n      setValue(instance, prop, value);\n    } else if (prop in PROPS_DISPLAY_OBJECT) {\n      // is a default value, use that\n      console.warn(\"setting default value: \".concat(prop, \", from: \").concat(instance[prop], \" to: \").concat(value, \" for\"), instance);\n      changed = true;\n      setValue(instance, prop, PROPS_DISPLAY_OBJECT[prop]);\n    } else {\n      console.warn(\"ignoring prop: \".concat(prop, \", from \").concat(instance[prop], \" to \").concat(value, \" for\"), instance);\n    }\n  }\n  return changed;\n}\n\nvar BitmapText$1 = function BitmapText(root, props) {\n  var text = props.text,\n    style = props.style;\n  return new _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_3__.BitmapText(text, style);\n};\nvar BitmapText$2 = BitmapText$1;\n\nvar Container$1 = function Container() {\n  return new _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container();\n};\nvar Container$2 = Container$1;\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded$7 = [\"draw\", \"geometry\"];\nvar Graphics$1 = function Graphics(root, _ref) {\n  var geometry = _ref.geometry;\n  invariant(!geometry || geometry instanceof _pixi_graphics__WEBPACK_IMPORTED_MODULE_4__.Graphics, \"Graphics geometry needs to be a `PIXI.Graphics`\");\n  var g = geometry ? new _pixi_graphics__WEBPACK_IMPORTED_MODULE_4__.Graphics(geometry.geometry) : new _pixi_graphics__WEBPACK_IMPORTED_MODULE_4__.Graphics();\n  g.applyProps = function (instance, oldProps, newProps) {\n    var draw = newProps.draw;\n      newProps.geometry;\n      var props = _objectWithoutProperties(newProps, _excluded$7);\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (oldProps.draw !== draw && typeof draw === 'function') {\n      changed = true;\n      draw.call(g, g);\n    }\n    return changed;\n  };\n  return g;\n};\nvar Graphics$2 = Graphics$1;\n\nvar _excluded$6 = [\"image\", \"texture\"];\nvar NineSlicePlane$1 = function NineSlicePlane(root, props) {\n  var _props$leftWidth = props.leftWidth,\n    leftWidth = _props$leftWidth === void 0 ? 10 : _props$leftWidth,\n    _props$topHeight = props.topHeight,\n    topHeight = _props$topHeight === void 0 ? 10 : _props$topHeight,\n    _props$rightWidth = props.rightWidth,\n    rightWidth = _props$rightWidth === void 0 ? 10 : _props$rightWidth,\n    _props$bottomHeight = props.bottomHeight,\n    bottomHeight = _props$bottomHeight === void 0 ? 10 : _props$bottomHeight;\n  var texture = getTextureFromProps('NineSlicePlane', root, props);\n  var nineSlicePlane = new _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_5__.NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight);\n  nineSlicePlane.applyProps = function (instance, oldProps, newProps) {\n    var image = newProps.image,\n      texture = newProps.texture,\n      props = _objectWithoutProperties(newProps, _excluded$6);\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (image || texture) {\n      // change = true not required for image, getTextureFromProps will call update\n      if (texture !== oldProps.texture) {\n        changed = true;\n      }\n      instance.texture = getTextureFromProps('NineSlicePlane', root, newProps);\n    }\n    return changed;\n  };\n  return nineSlicePlane;\n};\nvar NineSlicePlane$2 = NineSlicePlane$1;\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar ParticleContainer$1 = function ParticleContainer(root, props) {\n  var _props$maxSize = props.maxSize,\n    maxSize = _props$maxSize === void 0 ? 1500 : _props$maxSize,\n    _props$batchSize = props.batchSize,\n    batchSize = _props$batchSize === void 0 ? 16384 : _props$batchSize,\n    _props$autoResize = props.autoResize,\n    autoResize = _props$autoResize === void 0 ? false : _props$autoResize;\n  var properties = _objectSpread$3(_objectSpread$3({}, {\n    vertices: false,\n    scale: true,\n    position: true,\n    rotation: true,\n    uvs: true,\n    tint: true\n  }), props.properties || {});\n  var destroyOptions = _objectSpread$3(_objectSpread$3({}, {\n    children: false,\n    texture: false,\n    baseTexture: false\n  }), props.destroyOptions || {});\n  var container = new _pixi_particle_container__WEBPACK_IMPORTED_MODULE_6__.ParticleContainer(maxSize, properties, batchSize, autoResize);\n  container.willUnmount = function (instance, child, parent) {\n    instance.destroy(destroyOptions);\n  };\n  return container;\n};\nvar ParticleContainer$2 = ParticleContainer$1;\n\nvar _excluded$5 = [\"image\", \"texture\"];\nvar Sprite$1 = function Sprite(root, props) {\n  var sprite = new _pixi_sprite__WEBPACK_IMPORTED_MODULE_7__.Sprite(getTextureFromProps('Sprite', root, props));\n  sprite.applyProps = function (instance, oldProps, newProps) {\n    var image = newProps.image,\n      texture = newProps.texture,\n      props = _objectWithoutProperties(newProps, _excluded$5);\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (texture && oldProps.texture !== newProps.texture || image && oldProps.image !== newProps.image) {\n      // getTextureFromProps will call update for image\n      if (oldProps.texture !== newProps.texture) {\n        changed = true;\n      }\n      instance.texture = getTextureFromProps('Sprite', root, newProps);\n    }\n    return changed;\n  };\n  return sprite;\n};\nvar Sprite$2 = Sprite$1;\n\nvar _excluded$4 = [\"textures\", \"isPlaying\", \"initialFrame\"];\nvar AnimatedSprite$1 = function AnimatedSprite(root, props) {\n  var textures = props.textures,\n    images = props.images,\n    _props$isPlaying = props.isPlaying,\n    isPlaying = _props$isPlaying === void 0 ? true : _props$isPlaying,\n    initialFrame = props.initialFrame;\n  var makeTexture = function makeTexture(textures) {\n    return textures.map(function (texture) {\n      invariant(texture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture || (texture === null || texture === void 0 ? void 0 : texture.texture), \"AnimationSprite texture needs to be an array of `PIXI.Texture` or `{ texture: PIXI.Texture, time:\\n                number }`\");\n      return texture;\n    });\n  };\n  var animatedSprite = images ? _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_8__.AnimatedSprite.fromImages(images) : new _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_8__.AnimatedSprite(makeTexture(textures));\n  animatedSprite[isPlaying ? 'gotoAndPlay' : 'gotoAndStop'](initialFrame || 0);\n  animatedSprite.applyProps = function (instance, oldProps, newProps) {\n    var textures = newProps.textures,\n      isPlaying = newProps.isPlaying,\n      initialFrame = newProps.initialFrame,\n      props = _objectWithoutProperties(newProps, _excluded$4);\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (textures && oldProps.textures !== textures) {\n      instance.textures = makeTexture(textures);\n      changed = true;\n    }\n    if (isPlaying !== oldProps.isPlaying || initialFrame !== oldProps.initialFrame) {\n      var frame = typeof initialFrame === 'number' ? initialFrame : animatedSprite.currentFrame || 0;\n      animatedSprite[isPlaying ? 'gotoAndPlay' : 'gotoAndStop'](frame);\n      changed = true;\n    }\n    return changed;\n  };\n  return animatedSprite;\n};\nvar AnimatedSprite$2 = AnimatedSprite$1;\n\nvar Text$1 = function Text(root, props) {\n  var _props$text = props.text,\n    text = _props$text === void 0 ? '' : _props$text,\n    _props$style = props.style,\n    style = _props$style === void 0 ? {} : _props$style,\n    isSprite = props.isSprite;\n  var pixiText = new _pixi_text__WEBPACK_IMPORTED_MODULE_9__.Text(text, style);\n  if (isSprite) {\n    pixiText.updateText();\n    return new _pixi_sprite__WEBPACK_IMPORTED_MODULE_7__.Sprite(pixiText.texture);\n  }\n  return pixiText;\n};\nvar Text$2 = Text$1;\n\nvar _excluded$3 = [\"tileScale\", \"tilePosition\", \"image\", \"texture\"];\nvar TilingSprite$1 = function TilingSprite(root, props) {\n  var _props$width = props.width,\n    width = _props$width === void 0 ? 100 : _props$width,\n    _props$height = props.height,\n    height = _props$height === void 0 ? 100 : _props$height;\n  var texture = getTextureFromProps('TilingSprite', root, props);\n  var ts = new _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_10__.TilingSprite(texture, width, height);\n  ts.applyProps = function (instance, oldProps, newProps) {\n    var tileScale = newProps.tileScale,\n      tilePosition = newProps.tilePosition,\n      image = newProps.image,\n      texture = newProps.texture,\n      props = _objectWithoutProperties(newProps, _excluded$3);\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (tilePosition) {\n      var _instance$tilePositio;\n      var newTilePosition = parsePoint(tilePosition);\n      (_instance$tilePositio = instance.tilePosition).set.apply(_instance$tilePositio, _toConsumableArray(newTilePosition));\n      changed = !pointsAreEqual(parsePoint(oldProps.tilePosition), newTilePosition) || changed;\n    }\n    if (tileScale) {\n      var _instance$tileScale;\n      var newTileScale = parsePoint(tileScale);\n      (_instance$tileScale = instance.tileScale).set.apply(_instance$tileScale, _toConsumableArray(newTileScale));\n      changed = !pointsAreEqual(parsePoint(oldProps.tileScale), newTileScale) || changed;\n    }\n    if (image || texture) {\n      // change = true not required for image, getTextureFromProps will call update\n      if (texture !== oldProps.texture) {\n        changed = true;\n      }\n      instance.texture = getTextureFromProps('Sprite', root, newProps);\n    }\n    return changed;\n  };\n  return ts;\n};\nvar TilingSprite$2 = TilingSprite$1;\n\nvar _excluded$2 = [\"image\", \"texture\"];\nvar SimpleMesh$1 = function SimpleMesh(root, props) {\n  var texture = getTextureFromProps('Mesh', root, props);\n  var vertices = props.vertices,\n    uvs = props.uvs,\n    indices = props.indices,\n    _props$drawMode = props.drawMode,\n    drawMode = _props$drawMode === void 0 ? _pixi_constants__WEBPACK_IMPORTED_MODULE_11__.DRAW_MODES.TRIANGLES : _props$drawMode;\n  var simpleMesh = new _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_5__.SimpleMesh(texture, vertices, uvs, indices, drawMode);\n  simpleMesh.applyProps = function (instance, oldProps, newProps) {\n    var image = newProps.image,\n      texture = newProps.texture,\n      props = _objectWithoutProperties(newProps, _excluded$2);\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (image || texture) {\n      // change = true not required for image, getTextureFromProps will call update\n      if (texture !== oldProps.texture) {\n        changed = true;\n      }\n      instance.texture = getTextureFromProps('Mesh', root, newProps);\n    }\n    return changed;\n  };\n  return simpleMesh;\n};\nvar SimpleMesh$2 = SimpleMesh$1;\n\nvar _excluded$1 = [\"image\", \"texture\"];\nvar SimpleRope$1 = function SimpleRope(root, props) {\n  var texture = getTextureFromProps('SimpleRope', root, props);\n  var points = props.points;\n  var rope = new _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_5__.SimpleRope(texture, points);\n  rope.applyProps = function (instance, oldProps, newProps) {\n    var image = newProps.image,\n      texture = newProps.texture,\n      props = _objectWithoutProperties(newProps, _excluded$1);\n    invariant(Array.isArray(newProps.points), 'SimpleRope points needs to be %s', 'Array<PIXI.Point>');\n    var changed = applyDefaultProps(instance, oldProps, props);\n    if (image || texture) {\n      if (texture !== oldProps.texture) {\n        changed = true;\n      }\n      instance.texture = getTextureFromProps('SimpleRope', root, newProps);\n    }\n    return changed;\n  };\n  return rope;\n};\nvar SimpleRope$2 = SimpleRope$1;\n\nvar components = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BitmapText: BitmapText$2,\n  Container: Container$2,\n  Graphics: Graphics$2,\n  NineSlicePlane: NineSlicePlane$2,\n  ParticleContainer: ParticleContainer$2,\n  Sprite: Sprite$2,\n  Text: Text$2,\n  TilingSprite: TilingSprite$2,\n  SimpleMesh: SimpleMesh$2,\n  SimpleRope: SimpleRope$2,\n  AnimatedSprite: AnimatedSprite$2\n});\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n/**\n * Available tag types\n *\n * @type {Object}\n */\nvar TYPES = {\n  BitmapText: 'BitmapText',\n  Container: 'Container',\n  Graphics: 'Graphics',\n  NineSlicePlane: 'NineSlicePlane',\n  ParticleContainer: 'ParticleContainer',\n  Sprite: 'Sprite',\n  AnimatedSprite: 'AnimatedSprite',\n  Text: 'Text',\n  TilingSprite: 'TilingSprite',\n  SimpleMesh: 'SimpleMesh',\n  SimpleRope: 'SimpleRope'\n};\nvar ELEMENTS = Object.keys(TYPES).reduce(function (elements, type) {\n  return _objectSpread$2(_objectSpread$2({}, elements), {}, _defineProperty({}, type, components[type]));\n}, {});\n\n/**\n * Inject types\n *\n * @type {Object}\n */\nvar TYPES_INJECTED = {};\n\n/**\n * Create an element based on tag type\n * Similar to react-dom's `React.createElement()`\n *\n * @param {string} type Element type\n * @param {Object} props Component props\n * @param {Object} root Root instance\n */\nfunction createElement(type) {\n  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var fn = ELEMENTS[type];\n  var instance;\n  var applyProps;\n  if (typeof fn === 'function') {\n    instance = fn(root, props);\n  }\n  if (!instance) {\n    // not found, is there any injected custom component?\n    var injected = TYPES_INJECTED[type];\n    if (injected) {\n      instance = injected.create(props);\n      instance.didMount = injected.didMount ? injected.didMount.bind(instance) : undefined;\n      instance.willUnmount = injected.willUnmount ? injected.willUnmount.bind(instance) : undefined;\n      instance.applyProps = injected.applyProps ? injected.applyProps.bind(instance) : undefined;\n      instance.config = injected.config;\n    }\n  }\n\n  // apply initial props!\n  if (instance) {\n    var _instance;\n    applyProps = typeof ((_instance = instance) === null || _instance === void 0 ? void 0 : _instance.applyProps) === 'function' ? instance.applyProps : applyDefaultProps;\n    applyProps(instance, {}, props);\n    instance.__reactpixi = {\n      root: root\n    };\n  }\n  return instance;\n}\n\n/**\n * Create Component\n *\n * @param {string} type\n * @param {Object} lifecycle methods\n */\nfunction PixiComponent(type, lifecycle) {\n  invariant(!!type, 'Expect type to be defined, got `%s`', type);\n  invariant(!TYPES[type], 'Component `%s` could not be created, already exists in default components.', type);\n  TYPES_INJECTED[type] = lifecycle;\n  return type;\n}\n\nvar reactReconcilerExports = {};\nvar reactReconciler = {\n  get exports(){ return reactReconcilerExports; },\n  set exports(v){ reactReconcilerExports = v; },\n};\n\nvar schedulerExports = {};\nvar scheduler = {\n  get exports(){ return schedulerExports; },\n  set exports(v){ schedulerExports = v; },\n};\n\nvar scheduler_development = {};\n\n/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredScheduler_development;\n\nfunction requireScheduler_development () {\n\tif (hasRequiredScheduler_development) return scheduler_development;\n\thasRequiredScheduler_development = 1;\n\t(function (exports) {\n\n\t\t{\n\t\t  (function() {\n\n\t\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\tif (\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t\t    'function'\n\t\t) {\n\t\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t\t}\n\t\t          var enableSchedulerDebugging = false;\n\t\tvar enableProfiling = false;\n\t\tvar frameYieldMs = 5;\n\n\t\tfunction push(heap, node) {\n\t\t  var index = heap.length;\n\t\t  heap.push(node);\n\t\t  siftUp(heap, node, index);\n\t\t}\n\t\tfunction peek(heap) {\n\t\t  return heap.length === 0 ? null : heap[0];\n\t\t}\n\t\tfunction pop(heap) {\n\t\t  if (heap.length === 0) {\n\t\t    return null;\n\t\t  }\n\n\t\t  var first = heap[0];\n\t\t  var last = heap.pop();\n\n\t\t  if (last !== first) {\n\t\t    heap[0] = last;\n\t\t    siftDown(heap, last, 0);\n\t\t  }\n\n\t\t  return first;\n\t\t}\n\n\t\tfunction siftUp(heap, node, i) {\n\t\t  var index = i;\n\n\t\t  while (index > 0) {\n\t\t    var parentIndex = index - 1 >>> 1;\n\t\t    var parent = heap[parentIndex];\n\n\t\t    if (compare(parent, node) > 0) {\n\t\t      // The parent is larger. Swap positions.\n\t\t      heap[parentIndex] = node;\n\t\t      heap[index] = parent;\n\t\t      index = parentIndex;\n\t\t    } else {\n\t\t      // The parent is smaller. Exit.\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction siftDown(heap, node, i) {\n\t\t  var index = i;\n\t\t  var length = heap.length;\n\t\t  var halfLength = length >>> 1;\n\n\t\t  while (index < halfLength) {\n\t\t    var leftIndex = (index + 1) * 2 - 1;\n\t\t    var left = heap[leftIndex];\n\t\t    var rightIndex = leftIndex + 1;\n\t\t    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n\t\t    if (compare(left, node) < 0) {\n\t\t      if (rightIndex < length && compare(right, left) < 0) {\n\t\t        heap[index] = right;\n\t\t        heap[rightIndex] = node;\n\t\t        index = rightIndex;\n\t\t      } else {\n\t\t        heap[index] = left;\n\t\t        heap[leftIndex] = node;\n\t\t        index = leftIndex;\n\t\t      }\n\t\t    } else if (rightIndex < length && compare(right, node) < 0) {\n\t\t      heap[index] = right;\n\t\t      heap[rightIndex] = node;\n\t\t      index = rightIndex;\n\t\t    } else {\n\t\t      // Neither child is smaller. Exit.\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction compare(a, b) {\n\t\t  // Compare sort index first, then task id.\n\t\t  var diff = a.sortIndex - b.sortIndex;\n\t\t  return diff !== 0 ? diff : a.id - b.id;\n\t\t}\n\n\t\t// TODO: Use symbols?\n\t\tvar ImmediatePriority = 1;\n\t\tvar UserBlockingPriority = 2;\n\t\tvar NormalPriority = 3;\n\t\tvar LowPriority = 4;\n\t\tvar IdlePriority = 5;\n\n\t\tfunction markTaskErrored(task, ms) {\n\t\t}\n\n\t\t/* eslint-disable no-var */\n\n\t\tvar hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\n\t\tif (hasPerformanceNow) {\n\t\t  var localPerformance = performance;\n\n\t\t  exports.unstable_now = function () {\n\t\t    return localPerformance.now();\n\t\t  };\n\t\t} else {\n\t\t  var localDate = Date;\n\t\t  var initialTime = localDate.now();\n\n\t\t  exports.unstable_now = function () {\n\t\t    return localDate.now() - initialTime;\n\t\t  };\n\t\t} // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n\t\t// Math.pow(2, 30) - 1\n\t\t// 0b111111111111111111111111111111\n\n\n\t\tvar maxSigned31BitInt = 1073741823; // Times out immediately\n\n\t\tvar IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n\t\tvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n\t\tvar NORMAL_PRIORITY_TIMEOUT = 5000;\n\t\tvar LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n\t\tvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n\t\tvar taskQueue = [];\n\t\tvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n\t\tvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n\t\tvar currentTask = null;\n\t\tvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n\t\tvar isPerformingWork = false;\n\t\tvar isHostCallbackScheduled = false;\n\t\tvar isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n\t\tvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n\t\tvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n\t\tvar localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n\t\ttypeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n\n\t\tfunction advanceTimers(currentTime) {\n\t\t  // Check for tasks that are no longer delayed and add them to the queue.\n\t\t  var timer = peek(timerQueue);\n\n\t\t  while (timer !== null) {\n\t\t    if (timer.callback === null) {\n\t\t      // Timer was cancelled.\n\t\t      pop(timerQueue);\n\t\t    } else if (timer.startTime <= currentTime) {\n\t\t      // Timer fired. Transfer to the task queue.\n\t\t      pop(timerQueue);\n\t\t      timer.sortIndex = timer.expirationTime;\n\t\t      push(taskQueue, timer);\n\t\t    } else {\n\t\t      // Remaining timers are pending.\n\t\t      return;\n\t\t    }\n\n\t\t    timer = peek(timerQueue);\n\t\t  }\n\t\t}\n\n\t\tfunction handleTimeout(currentTime) {\n\t\t  isHostTimeoutScheduled = false;\n\t\t  advanceTimers(currentTime);\n\n\t\t  if (!isHostCallbackScheduled) {\n\t\t    if (peek(taskQueue) !== null) {\n\t\t      isHostCallbackScheduled = true;\n\t\t      requestHostCallback(flushWork);\n\t\t    } else {\n\t\t      var firstTimer = peek(timerQueue);\n\n\t\t      if (firstTimer !== null) {\n\t\t        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction flushWork(hasTimeRemaining, initialTime) {\n\n\n\t\t  isHostCallbackScheduled = false;\n\n\t\t  if (isHostTimeoutScheduled) {\n\t\t    // We scheduled a timeout but it's no longer needed. Cancel it.\n\t\t    isHostTimeoutScheduled = false;\n\t\t    cancelHostTimeout();\n\t\t  }\n\n\t\t  isPerformingWork = true;\n\t\t  var previousPriorityLevel = currentPriorityLevel;\n\n\t\t  try {\n\t\t    var currentTime; if (enableProfiling) ; else {\n\t\t      // No catch in prod code path.\n\t\t      return workLoop(hasTimeRemaining, initialTime);\n\t\t    }\n\t\t  } finally {\n\t\t    currentTask = null;\n\t\t    currentPriorityLevel = previousPriorityLevel;\n\t\t    isPerformingWork = false;\n\t\t  }\n\t\t}\n\n\t\tfunction workLoop(hasTimeRemaining, initialTime) {\n\t\t  var currentTime = initialTime;\n\t\t  advanceTimers(currentTime);\n\t\t  currentTask = peek(taskQueue);\n\n\t\t  while (currentTask !== null && !(enableSchedulerDebugging )) {\n\t\t    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n\t\t      // This currentTask hasn't expired, and we've reached the deadline.\n\t\t      break;\n\t\t    }\n\n\t\t    var callback = currentTask.callback;\n\n\t\t    if (typeof callback === 'function') {\n\t\t      currentTask.callback = null;\n\t\t      currentPriorityLevel = currentTask.priorityLevel;\n\t\t      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n\t\t      var continuationCallback = callback(didUserCallbackTimeout);\n\t\t      currentTime = exports.unstable_now();\n\n\t\t      if (typeof continuationCallback === 'function') {\n\t\t        currentTask.callback = continuationCallback;\n\t\t      } else {\n\n\t\t        if (currentTask === peek(taskQueue)) {\n\t\t          pop(taskQueue);\n\t\t        }\n\t\t      }\n\n\t\t      advanceTimers(currentTime);\n\t\t    } else {\n\t\t      pop(taskQueue);\n\t\t    }\n\n\t\t    currentTask = peek(taskQueue);\n\t\t  } // Return whether there's additional work\n\n\n\t\t  if (currentTask !== null) {\n\t\t    return true;\n\t\t  } else {\n\t\t    var firstTimer = peek(timerQueue);\n\n\t\t    if (firstTimer !== null) {\n\t\t      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n\t\t    }\n\n\t\t    return false;\n\t\t  }\n\t\t}\n\n\t\tfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n\t\t  switch (priorityLevel) {\n\t\t    case ImmediatePriority:\n\t\t    case UserBlockingPriority:\n\t\t    case NormalPriority:\n\t\t    case LowPriority:\n\t\t    case IdlePriority:\n\t\t      break;\n\n\t\t    default:\n\t\t      priorityLevel = NormalPriority;\n\t\t  }\n\n\t\t  var previousPriorityLevel = currentPriorityLevel;\n\t\t  currentPriorityLevel = priorityLevel;\n\n\t\t  try {\n\t\t    return eventHandler();\n\t\t  } finally {\n\t\t    currentPriorityLevel = previousPriorityLevel;\n\t\t  }\n\t\t}\n\n\t\tfunction unstable_next(eventHandler) {\n\t\t  var priorityLevel;\n\n\t\t  switch (currentPriorityLevel) {\n\t\t    case ImmediatePriority:\n\t\t    case UserBlockingPriority:\n\t\t    case NormalPriority:\n\t\t      // Shift down to normal priority\n\t\t      priorityLevel = NormalPriority;\n\t\t      break;\n\n\t\t    default:\n\t\t      // Anything lower than normal priority should remain at the current level.\n\t\t      priorityLevel = currentPriorityLevel;\n\t\t      break;\n\t\t  }\n\n\t\t  var previousPriorityLevel = currentPriorityLevel;\n\t\t  currentPriorityLevel = priorityLevel;\n\n\t\t  try {\n\t\t    return eventHandler();\n\t\t  } finally {\n\t\t    currentPriorityLevel = previousPriorityLevel;\n\t\t  }\n\t\t}\n\n\t\tfunction unstable_wrapCallback(callback) {\n\t\t  var parentPriorityLevel = currentPriorityLevel;\n\t\t  return function () {\n\t\t    // This is a fork of runWithPriority, inlined for performance.\n\t\t    var previousPriorityLevel = currentPriorityLevel;\n\t\t    currentPriorityLevel = parentPriorityLevel;\n\n\t\t    try {\n\t\t      return callback.apply(this, arguments);\n\t\t    } finally {\n\t\t      currentPriorityLevel = previousPriorityLevel;\n\t\t    }\n\t\t  };\n\t\t}\n\n\t\tfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n\t\t  var currentTime = exports.unstable_now();\n\t\t  var startTime;\n\n\t\t  if (typeof options === 'object' && options !== null) {\n\t\t    var delay = options.delay;\n\n\t\t    if (typeof delay === 'number' && delay > 0) {\n\t\t      startTime = currentTime + delay;\n\t\t    } else {\n\t\t      startTime = currentTime;\n\t\t    }\n\t\t  } else {\n\t\t    startTime = currentTime;\n\t\t  }\n\n\t\t  var timeout;\n\n\t\t  switch (priorityLevel) {\n\t\t    case ImmediatePriority:\n\t\t      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n\t\t      break;\n\n\t\t    case UserBlockingPriority:\n\t\t      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n\t\t      break;\n\n\t\t    case IdlePriority:\n\t\t      timeout = IDLE_PRIORITY_TIMEOUT;\n\t\t      break;\n\n\t\t    case LowPriority:\n\t\t      timeout = LOW_PRIORITY_TIMEOUT;\n\t\t      break;\n\n\t\t    case NormalPriority:\n\t\t    default:\n\t\t      timeout = NORMAL_PRIORITY_TIMEOUT;\n\t\t      break;\n\t\t  }\n\n\t\t  var expirationTime = startTime + timeout;\n\t\t  var newTask = {\n\t\t    id: taskIdCounter++,\n\t\t    callback: callback,\n\t\t    priorityLevel: priorityLevel,\n\t\t    startTime: startTime,\n\t\t    expirationTime: expirationTime,\n\t\t    sortIndex: -1\n\t\t  };\n\n\t\t  if (startTime > currentTime) {\n\t\t    // This is a delayed task.\n\t\t    newTask.sortIndex = startTime;\n\t\t    push(timerQueue, newTask);\n\n\t\t    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n\t\t      // All tasks are delayed, and this is the task with the earliest delay.\n\t\t      if (isHostTimeoutScheduled) {\n\t\t        // Cancel an existing timeout.\n\t\t        cancelHostTimeout();\n\t\t      } else {\n\t\t        isHostTimeoutScheduled = true;\n\t\t      } // Schedule a timeout.\n\n\n\t\t      requestHostTimeout(handleTimeout, startTime - currentTime);\n\t\t    }\n\t\t  } else {\n\t\t    newTask.sortIndex = expirationTime;\n\t\t    push(taskQueue, newTask);\n\t\t    // wait until the next time we yield.\n\n\n\t\t    if (!isHostCallbackScheduled && !isPerformingWork) {\n\t\t      isHostCallbackScheduled = true;\n\t\t      requestHostCallback(flushWork);\n\t\t    }\n\t\t  }\n\n\t\t  return newTask;\n\t\t}\n\n\t\tfunction unstable_pauseExecution() {\n\t\t}\n\n\t\tfunction unstable_continueExecution() {\n\n\t\t  if (!isHostCallbackScheduled && !isPerformingWork) {\n\t\t    isHostCallbackScheduled = true;\n\t\t    requestHostCallback(flushWork);\n\t\t  }\n\t\t}\n\n\t\tfunction unstable_getFirstCallbackNode() {\n\t\t  return peek(taskQueue);\n\t\t}\n\n\t\tfunction unstable_cancelCallback(task) {\n\t\t  // remove from the queue because you can't remove arbitrary nodes from an\n\t\t  // array based heap, only the first one.)\n\n\n\t\t  task.callback = null;\n\t\t}\n\n\t\tfunction unstable_getCurrentPriorityLevel() {\n\t\t  return currentPriorityLevel;\n\t\t}\n\n\t\tvar isMessageLoopRunning = false;\n\t\tvar scheduledHostCallback = null;\n\t\tvar taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n\t\t// thread, like user events. By default, it yields multiple times per frame.\n\t\t// It does not attempt to align with frame boundaries, since most tasks don't\n\t\t// need to be frame aligned; for those that do, use requestAnimationFrame.\n\n\t\tvar frameInterval = frameYieldMs;\n\t\tvar startTime = -1;\n\n\t\tfunction shouldYieldToHost() {\n\t\t  var timeElapsed = exports.unstable_now() - startTime;\n\n\t\t  if (timeElapsed < frameInterval) {\n\t\t    // The main thread has only been blocked for a really short amount of time;\n\t\t    // smaller than a single frame. Don't yield yet.\n\t\t    return false;\n\t\t  } // The main thread has been blocked for a non-negligible amount of time. We\n\n\n\t\t  return true;\n\t\t}\n\n\t\tfunction requestPaint() {\n\n\t\t}\n\n\t\tfunction forceFrameRate(fps) {\n\t\t  if (fps < 0 || fps > 125) {\n\t\t    // Using console['error'] to evade Babel and ESLint\n\t\t    console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n\t\t    return;\n\t\t  }\n\n\t\t  if (fps > 0) {\n\t\t    frameInterval = Math.floor(1000 / fps);\n\t\t  } else {\n\t\t    // reset the framerate\n\t\t    frameInterval = frameYieldMs;\n\t\t  }\n\t\t}\n\n\t\tvar performWorkUntilDeadline = function () {\n\t\t  if (scheduledHostCallback !== null) {\n\t\t    var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n\t\t    // has been blocked.\n\n\t\t    startTime = currentTime;\n\t\t    var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n\t\t    // error can be observed.\n\t\t    //\n\t\t    // Intentionally not using a try-catch, since that makes some debugging\n\t\t    // techniques harder. Instead, if `scheduledHostCallback` errors, then\n\t\t    // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n\t\t    var hasMoreWork = true;\n\n\t\t    try {\n\t\t      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n\t\t    } finally {\n\t\t      if (hasMoreWork) {\n\t\t        // If there's more work, schedule the next message event at the end\n\t\t        // of the preceding one.\n\t\t        schedulePerformWorkUntilDeadline();\n\t\t      } else {\n\t\t        isMessageLoopRunning = false;\n\t\t        scheduledHostCallback = null;\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    isMessageLoopRunning = false;\n\t\t  } // Yielding to the browser will give it a chance to paint, so we can\n\t\t};\n\n\t\tvar schedulePerformWorkUntilDeadline;\n\n\t\tif (typeof localSetImmediate === 'function') {\n\t\t  // Node.js and old IE.\n\t\t  // There's a few reasons for why we prefer setImmediate.\n\t\t  //\n\t\t  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n\t\t  // (Even though this is a DOM fork of the Scheduler, you could get here\n\t\t  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n\t\t  // https://github.com/facebook/react/issues/20756\n\t\t  //\n\t\t  // But also, it runs earlier which is the semantic we want.\n\t\t  // If other browsers ever implement it, it's better to use it.\n\t\t  // Although both of these would be inferior to native scheduling.\n\t\t  schedulePerformWorkUntilDeadline = function () {\n\t\t    localSetImmediate(performWorkUntilDeadline);\n\t\t  };\n\t\t} else if (typeof MessageChannel !== 'undefined') {\n\t\t  // DOM and Worker environments.\n\t\t  // We prefer MessageChannel because of the 4ms setTimeout clamping.\n\t\t  var channel = new MessageChannel();\n\t\t  var port = channel.port2;\n\t\t  channel.port1.onmessage = performWorkUntilDeadline;\n\n\t\t  schedulePerformWorkUntilDeadline = function () {\n\t\t    port.postMessage(null);\n\t\t  };\n\t\t} else {\n\t\t  // We should only fallback here in non-browser environments.\n\t\t  schedulePerformWorkUntilDeadline = function () {\n\t\t    localSetTimeout(performWorkUntilDeadline, 0);\n\t\t  };\n\t\t}\n\n\t\tfunction requestHostCallback(callback) {\n\t\t  scheduledHostCallback = callback;\n\n\t\t  if (!isMessageLoopRunning) {\n\t\t    isMessageLoopRunning = true;\n\t\t    schedulePerformWorkUntilDeadline();\n\t\t  }\n\t\t}\n\n\t\tfunction requestHostTimeout(callback, ms) {\n\t\t  taskTimeoutID = localSetTimeout(function () {\n\t\t    callback(exports.unstable_now());\n\t\t  }, ms);\n\t\t}\n\n\t\tfunction cancelHostTimeout() {\n\t\t  localClearTimeout(taskTimeoutID);\n\t\t  taskTimeoutID = -1;\n\t\t}\n\n\t\tvar unstable_requestPaint = requestPaint;\n\t\tvar unstable_Profiling =  null;\n\n\t\texports.unstable_IdlePriority = IdlePriority;\n\t\texports.unstable_ImmediatePriority = ImmediatePriority;\n\t\texports.unstable_LowPriority = LowPriority;\n\t\texports.unstable_NormalPriority = NormalPriority;\n\t\texports.unstable_Profiling = unstable_Profiling;\n\t\texports.unstable_UserBlockingPriority = UserBlockingPriority;\n\t\texports.unstable_cancelCallback = unstable_cancelCallback;\n\t\texports.unstable_continueExecution = unstable_continueExecution;\n\t\texports.unstable_forceFrameRate = forceFrameRate;\n\t\texports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n\t\texports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n\t\texports.unstable_next = unstable_next;\n\t\texports.unstable_pauseExecution = unstable_pauseExecution;\n\t\texports.unstable_requestPaint = unstable_requestPaint;\n\t\texports.unstable_runWithPriority = unstable_runWithPriority;\n\t\texports.unstable_scheduleCallback = unstable_scheduleCallback;\n\t\texports.unstable_shouldYield = shouldYieldToHost;\n\t\texports.unstable_wrapCallback = unstable_wrapCallback;\n\t\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\tif (\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t\t    'function'\n\t\t) {\n\t\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t\t}\n\t\t        \n\t\t  })();\n\t\t}\n} (scheduler_development));\n\treturn scheduler_development;\n}\n\nvar hasRequiredScheduler;\n\nfunction requireScheduler () {\n\tif (hasRequiredScheduler) return schedulerExports;\n\thasRequiredScheduler = 1;\n\t(function (module) {\n\n\t\t{\n\t\t  module.exports = requireScheduler_development();\n\t\t}\n} (scheduler));\n\treturn schedulerExports;\n}\n\nvar reactReconciler_developmentExports = {};\nvar reactReconciler_development = {\n  get exports(){ return reactReconciler_developmentExports; },\n  set exports(v){ reactReconciler_developmentExports = v; },\n};\n\n/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredReactReconciler_development;\n\nfunction requireReactReconciler_development () {\n\tif (hasRequiredReactReconciler_development) return reactReconciler_developmentExports;\n\thasRequiredReactReconciler_development = 1;\n\n\t{\n\t  reactReconciler_development.exports = function $$$reconciler($$$hostConfig) {\n\t    var exports = {};\n\n\tvar React$1 = (react__WEBPACK_IMPORTED_MODULE_12___default());\n\tvar Scheduler = requireScheduler();\n\n\tvar ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n\tvar suppressWarning = false;\n\tfunction setSuppressWarning(newSuppressWarning) {\n\t  {\n\t    suppressWarning = newSuppressWarning;\n\t  }\n\t} // In DEV, calls to console.warn and console.error get replaced\n\t// by calls to these methods by a Babel plugin.\n\t//\n\t// In PROD (or in packages without access to React internals),\n\t// they are left as they are instead.\n\n\tfunction warn(format) {\n\t  {\n\t    if (!suppressWarning) {\n\t      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        args[_key - 1] = arguments[_key];\n\t      }\n\n\t      printWarning('warn', format, args);\n\t    }\n\t  }\n\t}\n\tfunction error(format) {\n\t  {\n\t    if (!suppressWarning) {\n\t      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t        args[_key2 - 1] = arguments[_key2];\n\t      }\n\n\t      printWarning('error', format, args);\n\t    }\n\t  }\n\t}\n\n\tfunction printWarning(level, format, args) {\n\t  // When changing this logic, you might want to also\n\t  // update consoleWithStackDev.www.js as well.\n\t  {\n\t    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\t    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n\t    if (stack !== '') {\n\t      format += '%s';\n\t      args = args.concat([stack]);\n\t    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n\t    var argsWithFormat = args.map(function (item) {\n\t      return String(item);\n\t    }); // Careful: RN currently depends on this prefix\n\n\t    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n\t    // breaks IE9: https://github.com/facebook/react/issues/13610\n\t    // eslint-disable-next-line react-internal/no-production-logging\n\n\t    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\t  }\n\t}\n\n\tvar assign = Object.assign;\n\n\t/**\n\t * `ReactInstanceMap` maintains a mapping from a public facing stateful\n\t * instance (key) and the internal representation (value). This allows public\n\t * methods to accept the user facing instance as an argument and map them back\n\t * to internal methods.\n\t *\n\t * Note that this module is currently shared and assumed to be stateless.\n\t * If this becomes an actual Map, that will break.\n\t */\n\tfunction get(key) {\n\t  return key._reactInternals;\n\t}\n\tfunction set(key, value) {\n\t  key._reactInternals = value;\n\t}\n\n\t// -----------------------------------------------------------------------------\n\t// the react-reconciler package.\n\n\tvar enableNewReconciler = false; // Support legacy Primer support on internal FB www\n\n\tvar enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n\n\tvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\n\tvar enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\n\tvar warnAboutStringRefs = false; // -----------------------------------------------------------------------------\n\t// Debugging and DevTools\n\t// -----------------------------------------------------------------------------\n\t// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n\t// for an experimental timeline tool.\n\n\tvar enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n\n\tvar enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n\n\tvar enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\n\tvar FunctionComponent = 0;\n\tvar ClassComponent = 1;\n\tvar IndeterminateComponent = 2; // Before we know whether it is function or class\n\n\tvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\n\tvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\n\tvar HostComponent = 5;\n\tvar HostText = 6;\n\tvar Fragment = 7;\n\tvar Mode = 8;\n\tvar ContextConsumer = 9;\n\tvar ContextProvider = 10;\n\tvar ForwardRef = 11;\n\tvar Profiler = 12;\n\tvar SuspenseComponent = 13;\n\tvar MemoComponent = 14;\n\tvar SimpleMemoComponent = 15;\n\tvar LazyComponent = 16;\n\tvar IncompleteClassComponent = 17;\n\tvar DehydratedFragment = 18;\n\tvar SuspenseListComponent = 19;\n\tvar ScopeComponent = 21;\n\tvar OffscreenComponent = 22;\n\tvar LegacyHiddenComponent = 23;\n\tvar CacheComponent = 24;\n\tvar TracingMarkerComponent = 25;\n\n\t// ATTENTION\n\t// When adding new symbols to this file,\n\t// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\t// The Symbol used to tag the ReactElement-like types.\n\tvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\n\tvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\n\tvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n\tvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n\tvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n\tvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n\tvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\n\tvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n\tvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n\tvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n\tvar REACT_MEMO_TYPE = Symbol.for('react.memo');\n\tvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\n\tvar REACT_SCOPE_TYPE = Symbol.for('react.scope');\n\tvar REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\n\tvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\tvar REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\n\tvar REACT_CACHE_TYPE = Symbol.for('react.cache');\n\tvar REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\n\tvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n\tvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\tfunction getIteratorFn(maybeIterable) {\n\t  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n\t    return null;\n\t  }\n\n\t  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n\t  if (typeof maybeIterator === 'function') {\n\t    return maybeIterator;\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction getWrappedName(outerType, innerType, wrapperName) {\n\t  var displayName = outerType.displayName;\n\n\t  if (displayName) {\n\t    return displayName;\n\t  }\n\n\t  var functionName = innerType.displayName || innerType.name || '';\n\t  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n\t} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n\tfunction getContextName(type) {\n\t  return type.displayName || 'Context';\n\t} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n\tfunction getComponentNameFromType(type) {\n\t  if (type == null) {\n\t    // Host root, text node or just invalid type.\n\t    return null;\n\t  }\n\n\t  {\n\t    if (typeof type.tag === 'number') {\n\t      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n\t    }\n\t  }\n\n\t  if (typeof type === 'function') {\n\t    return type.displayName || type.name || null;\n\t  }\n\n\t  if (typeof type === 'string') {\n\t    return type;\n\t  }\n\n\t  switch (type) {\n\t    case REACT_FRAGMENT_TYPE:\n\t      return 'Fragment';\n\n\t    case REACT_PORTAL_TYPE:\n\t      return 'Portal';\n\n\t    case REACT_PROFILER_TYPE:\n\t      return 'Profiler';\n\n\t    case REACT_STRICT_MODE_TYPE:\n\t      return 'StrictMode';\n\n\t    case REACT_SUSPENSE_TYPE:\n\t      return 'Suspense';\n\n\t    case REACT_SUSPENSE_LIST_TYPE:\n\t      return 'SuspenseList';\n\n\t  }\n\n\t  if (typeof type === 'object') {\n\t    switch (type.$$typeof) {\n\t      case REACT_CONTEXT_TYPE:\n\t        var context = type;\n\t        return getContextName(context) + '.Consumer';\n\n\t      case REACT_PROVIDER_TYPE:\n\t        var provider = type;\n\t        return getContextName(provider._context) + '.Provider';\n\n\t      case REACT_FORWARD_REF_TYPE:\n\t        return getWrappedName(type, type.render, 'ForwardRef');\n\n\t      case REACT_MEMO_TYPE:\n\t        var outerName = type.displayName || null;\n\n\t        if (outerName !== null) {\n\t          return outerName;\n\t        }\n\n\t        return getComponentNameFromType(type.type) || 'Memo';\n\n\t      case REACT_LAZY_TYPE:\n\t        {\n\t          var lazyComponent = type;\n\t          var payload = lazyComponent._payload;\n\t          var init = lazyComponent._init;\n\n\t          try {\n\t            return getComponentNameFromType(init(payload));\n\t          } catch (x) {\n\t            return null;\n\t          }\n\t        }\n\n\t      // eslint-disable-next-line no-fallthrough\n\t    }\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction getWrappedName$1(outerType, innerType, wrapperName) {\n\t  var functionName = innerType.displayName || innerType.name || '';\n\t  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n\t} // Keep in sync with shared/getComponentNameFromType\n\n\n\tfunction getContextName$1(type) {\n\t  return type.displayName || 'Context';\n\t}\n\n\tfunction getComponentNameFromFiber(fiber) {\n\t  var tag = fiber.tag,\n\t      type = fiber.type;\n\n\t  switch (tag) {\n\t    case CacheComponent:\n\t      return 'Cache';\n\n\t    case ContextConsumer:\n\t      var context = type;\n\t      return getContextName$1(context) + '.Consumer';\n\n\t    case ContextProvider:\n\t      var provider = type;\n\t      return getContextName$1(provider._context) + '.Provider';\n\n\t    case DehydratedFragment:\n\t      return 'DehydratedFragment';\n\n\t    case ForwardRef:\n\t      return getWrappedName$1(type, type.render, 'ForwardRef');\n\n\t    case Fragment:\n\t      return 'Fragment';\n\n\t    case HostComponent:\n\t      // Host component type is the display name (e.g. \"div\", \"View\")\n\t      return type;\n\n\t    case HostPortal:\n\t      return 'Portal';\n\n\t    case HostRoot:\n\t      return 'Root';\n\n\t    case HostText:\n\t      return 'Text';\n\n\t    case LazyComponent:\n\t      // Name comes from the type in this case; we don't have a tag.\n\t      return getComponentNameFromType(type);\n\n\t    case Mode:\n\t      if (type === REACT_STRICT_MODE_TYPE) {\n\t        // Don't be less specific than shared/getComponentNameFromType\n\t        return 'StrictMode';\n\t      }\n\n\t      return 'Mode';\n\n\t    case OffscreenComponent:\n\t      return 'Offscreen';\n\n\t    case Profiler:\n\t      return 'Profiler';\n\n\t    case ScopeComponent:\n\t      return 'Scope';\n\n\t    case SuspenseComponent:\n\t      return 'Suspense';\n\n\t    case SuspenseListComponent:\n\t      return 'SuspenseList';\n\n\t    case TracingMarkerComponent:\n\t      return 'TracingMarker';\n\t    // The display name for this tags come from the user-provided type:\n\n\t    case ClassComponent:\n\t    case FunctionComponent:\n\t    case IncompleteClassComponent:\n\t    case IndeterminateComponent:\n\t    case MemoComponent:\n\t    case SimpleMemoComponent:\n\t      if (typeof type === 'function') {\n\t        return type.displayName || type.name || null;\n\t      }\n\n\t      if (typeof type === 'string') {\n\t        return type;\n\t      }\n\n\t      break;\n\n\t  }\n\n\t  return null;\n\t}\n\n\t// Don't change these two values. They're used by React Dev Tools.\n\tvar NoFlags =\n\t/*                      */\n\t0;\n\tvar PerformedWork =\n\t/*                */\n\t1; // You can change the rest (and add more).\n\n\tvar Placement =\n\t/*                    */\n\t2;\n\tvar Update =\n\t/*                       */\n\t4;\n\tvar ChildDeletion =\n\t/*                */\n\t16;\n\tvar ContentReset =\n\t/*                 */\n\t32;\n\tvar Callback =\n\t/*                     */\n\t64;\n\tvar DidCapture =\n\t/*                   */\n\t128;\n\tvar ForceClientRender =\n\t/*            */\n\t256;\n\tvar Ref =\n\t/*                          */\n\t512;\n\tvar Snapshot =\n\t/*                     */\n\t1024;\n\tvar Passive =\n\t/*                      */\n\t2048;\n\tvar Hydrating =\n\t/*                    */\n\t4096;\n\tvar Visibility =\n\t/*                   */\n\t8192;\n\tvar StoreConsistency =\n\t/*             */\n\t16384;\n\tvar LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n\n\tvar HostEffectMask =\n\t/*               */\n\t32767; // These are not really side effects, but we still reuse this field.\n\n\tvar Incomplete =\n\t/*                   */\n\t32768;\n\tvar ShouldCapture =\n\t/*                */\n\t65536;\n\tvar ForceUpdateForLegacySuspense =\n\t/* */\n\t131072;\n\tvar Forked =\n\t/*                       */\n\t1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n\t// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n\t// This enables us to defer more work in the unmount case,\n\t// since we can defer traversing the tree during layout to look for Passive effects,\n\t// and instead rely on the static flag as a signal that there may be cleanup work.\n\n\tvar RefStatic =\n\t/*                    */\n\t2097152;\n\tvar LayoutStatic =\n\t/*                 */\n\t4194304;\n\tvar PassiveStatic =\n\t/*                */\n\t8388608; // These flags allow us to traverse to fibers that have effects on mount\n\t// without traversing the entire tree after every commit for\n\t// double invoking\n\n\tvar MountLayoutDev =\n\t/*               */\n\t16777216;\n\tvar MountPassiveDev =\n\t/*              */\n\t33554432; // Groups of flags that are used in the commit phase to skip over trees that\n\t// don't contain effects, by checking subtreeFlags.\n\n\tvar BeforeMutationMask = // TODO: Remove Update flag from before mutation phase by re-landing Visibility\n\t// flag logic (see #20043)\n\tUpdate | Snapshot | ( 0);\n\tvar MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n\tvar LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n\n\tvar PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n\t// This allows certain concepts to persist without recalculating them,\n\t// e.g. whether a subtree contains passive effects or portals.\n\n\tvar StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n\n\tvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\tfunction getNearestMountedFiber(fiber) {\n\t  var node = fiber;\n\t  var nearestMounted = fiber;\n\n\t  if (!fiber.alternate) {\n\t    // If there is no alternate, this might be a new tree that isn't inserted\n\t    // yet. If it is, then it will have a pending insertion effect on it.\n\t    var nextNode = node;\n\n\t    do {\n\t      node = nextNode;\n\n\t      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n\t        // This is an insertion or in-progress hydration. The nearest possible\n\t        // mounted fiber is the parent but we need to continue to figure out\n\t        // if that one is still mounted.\n\t        nearestMounted = node.return;\n\t      }\n\n\t      nextNode = node.return;\n\t    } while (nextNode);\n\t  } else {\n\t    while (node.return) {\n\t      node = node.return;\n\t    }\n\t  }\n\n\t  if (node.tag === HostRoot) {\n\t    // TODO: Check if this was a nested HostRoot when used with\n\t    // renderContainerIntoSubtree.\n\t    return nearestMounted;\n\t  } // If we didn't hit the root, that means that we're in an disconnected tree\n\t  // that has been unmounted.\n\n\n\t  return null;\n\t}\n\tfunction isFiberMounted(fiber) {\n\t  return getNearestMountedFiber(fiber) === fiber;\n\t}\n\tfunction isMounted(component) {\n\t  {\n\t    var owner = ReactCurrentOwner.current;\n\n\t    if (owner !== null && owner.tag === ClassComponent) {\n\t      var ownerFiber = owner;\n\t      var instance = ownerFiber.stateNode;\n\n\t      if (!instance._warnedAboutRefsInRender) {\n\t        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n\t      }\n\n\t      instance._warnedAboutRefsInRender = true;\n\t    }\n\t  }\n\n\t  var fiber = get(component);\n\n\t  if (!fiber) {\n\t    return false;\n\t  }\n\n\t  return getNearestMountedFiber(fiber) === fiber;\n\t}\n\n\tfunction assertIsMounted(fiber) {\n\t  if (getNearestMountedFiber(fiber) !== fiber) {\n\t    throw new Error('Unable to find node on an unmounted component.');\n\t  }\n\t}\n\n\tfunction findCurrentFiberUsingSlowPath(fiber) {\n\t  var alternate = fiber.alternate;\n\n\t  if (!alternate) {\n\t    // If there is no alternate, then we only need to check if it is mounted.\n\t    var nearestMounted = getNearestMountedFiber(fiber);\n\n\t    if (nearestMounted === null) {\n\t      throw new Error('Unable to find node on an unmounted component.');\n\t    }\n\n\t    if (nearestMounted !== fiber) {\n\t      return null;\n\t    }\n\n\t    return fiber;\n\t  } // If we have two possible branches, we'll walk backwards up to the root\n\t  // to see what path the root points to. On the way we may hit one of the\n\t  // special cases and we'll deal with them.\n\n\n\t  var a = fiber;\n\t  var b = alternate;\n\n\t  while (true) {\n\t    var parentA = a.return;\n\n\t    if (parentA === null) {\n\t      // We're at the root.\n\t      break;\n\t    }\n\n\t    var parentB = parentA.alternate;\n\n\t    if (parentB === null) {\n\t      // There is no alternate. This is an unusual case. Currently, it only\n\t      // happens when a Suspense component is hidden. An extra fragment fiber\n\t      // is inserted in between the Suspense fiber and its children. Skip\n\t      // over this extra fragment fiber and proceed to the next parent.\n\t      var nextParent = parentA.return;\n\n\t      if (nextParent !== null) {\n\t        a = b = nextParent;\n\t        continue;\n\t      } // If there's no parent, we're at the root.\n\n\n\t      break;\n\t    } // If both copies of the parent fiber point to the same child, we can\n\t    // assume that the child is current. This happens when we bailout on low\n\t    // priority: the bailed out fiber's child reuses the current child.\n\n\n\t    if (parentA.child === parentB.child) {\n\t      var child = parentA.child;\n\n\t      while (child) {\n\t        if (child === a) {\n\t          // We've determined that A is the current branch.\n\t          assertIsMounted(parentA);\n\t          return fiber;\n\t        }\n\n\t        if (child === b) {\n\t          // We've determined that B is the current branch.\n\t          assertIsMounted(parentA);\n\t          return alternate;\n\t        }\n\n\t        child = child.sibling;\n\t      } // We should never have an alternate for any mounting node. So the only\n\t      // way this could possibly happen is if this was unmounted, if at all.\n\n\n\t      throw new Error('Unable to find node on an unmounted component.');\n\t    }\n\n\t    if (a.return !== b.return) {\n\t      // The return pointer of A and the return pointer of B point to different\n\t      // fibers. We assume that return pointers never criss-cross, so A must\n\t      // belong to the child set of A.return, and B must belong to the child\n\t      // set of B.return.\n\t      a = parentA;\n\t      b = parentB;\n\t    } else {\n\t      // The return pointers point to the same fiber. We'll have to use the\n\t      // default, slow path: scan the child sets of each parent alternate to see\n\t      // which child belongs to which set.\n\t      //\n\t      // Search parent A's child set\n\t      var didFindChild = false;\n\t      var _child = parentA.child;\n\n\t      while (_child) {\n\t        if (_child === a) {\n\t          didFindChild = true;\n\t          a = parentA;\n\t          b = parentB;\n\t          break;\n\t        }\n\n\t        if (_child === b) {\n\t          didFindChild = true;\n\t          b = parentA;\n\t          a = parentB;\n\t          break;\n\t        }\n\n\t        _child = _child.sibling;\n\t      }\n\n\t      if (!didFindChild) {\n\t        // Search parent B's child set\n\t        _child = parentB.child;\n\n\t        while (_child) {\n\t          if (_child === a) {\n\t            didFindChild = true;\n\t            a = parentB;\n\t            b = parentA;\n\t            break;\n\t          }\n\n\t          if (_child === b) {\n\t            didFindChild = true;\n\t            b = parentB;\n\t            a = parentA;\n\t            break;\n\t          }\n\n\t          _child = _child.sibling;\n\t        }\n\n\t        if (!didFindChild) {\n\t          throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n\t        }\n\t      }\n\t    }\n\n\t    if (a.alternate !== b) {\n\t      throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n\t    }\n\t  } // If the root is not a host container, we're in a disconnected tree. I.e.\n\t  // unmounted.\n\n\n\t  if (a.tag !== HostRoot) {\n\t    throw new Error('Unable to find node on an unmounted component.');\n\t  }\n\n\t  if (a.stateNode.current === a) {\n\t    // We've determined that A is the current branch.\n\t    return fiber;\n\t  } // Otherwise B has to be current branch.\n\n\n\t  return alternate;\n\t}\n\tfunction findCurrentHostFiber(parent) {\n\t  var currentParent = findCurrentFiberUsingSlowPath(parent);\n\t  return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n\t}\n\n\tfunction findCurrentHostFiberImpl(node) {\n\t  // Next we'll drill down this component to find the first HostComponent/Text.\n\t  if (node.tag === HostComponent || node.tag === HostText) {\n\t    return node;\n\t  }\n\n\t  var child = node.child;\n\n\t  while (child !== null) {\n\t    var match = findCurrentHostFiberImpl(child);\n\n\t    if (match !== null) {\n\t      return match;\n\t    }\n\n\t    child = child.sibling;\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction findCurrentHostFiberWithNoPortals(parent) {\n\t  var currentParent = findCurrentFiberUsingSlowPath(parent);\n\t  return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n\t}\n\n\tfunction findCurrentHostFiberWithNoPortalsImpl(node) {\n\t  // Next we'll drill down this component to find the first HostComponent/Text.\n\t  if (node.tag === HostComponent || node.tag === HostText) {\n\t    return node;\n\t  }\n\n\t  var child = node.child;\n\n\t  while (child !== null) {\n\t    if (child.tag !== HostPortal) {\n\t      var match = findCurrentHostFiberWithNoPortalsImpl(child);\n\n\t      if (match !== null) {\n\t        return match;\n\t      }\n\t    }\n\n\t    child = child.sibling;\n\t  }\n\n\t  return null;\n\t}\n\n\tvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n\tfunction isArray(a) {\n\t  return isArrayImpl(a);\n\t}\n\n\t// This is a host config that's used for the `react-reconciler` package on npm.\n\t// It is only used by third-party renderers.\n\t//\n\t// Its API lets you pass the host config as an argument.\n\t// However, inside the `react-reconciler` we treat host config as a module.\n\t// This file is a shim between two worlds.\n\t//\n\t// It works because the `react-reconciler` bundle is wrapped in something like:\n\t//\n\t// module.exports = function ($$$config) {\n\t//   /* reconciler code */\n\t// }\n\t//\n\t// So `$$$config` looks like a global variable, but it's\n\t// really an argument to a top-level wrapping function.\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\t// eslint-disable-line no-undef\n\tvar getPublicInstance = $$$hostConfig.getPublicInstance;\n\tvar getRootHostContext = $$$hostConfig.getRootHostContext;\n\tvar getChildHostContext = $$$hostConfig.getChildHostContext;\n\tvar prepareForCommit = $$$hostConfig.prepareForCommit;\n\tvar resetAfterCommit = $$$hostConfig.resetAfterCommit;\n\tvar createInstance = $$$hostConfig.createInstance;\n\tvar appendInitialChild = $$$hostConfig.appendInitialChild;\n\tvar finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\n\tvar prepareUpdate = $$$hostConfig.prepareUpdate;\n\tvar shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\n\tvar createTextInstance = $$$hostConfig.createTextInstance;\n\tvar scheduleTimeout = $$$hostConfig.scheduleTimeout;\n\tvar cancelTimeout = $$$hostConfig.cancelTimeout;\n\tvar noTimeout = $$$hostConfig.noTimeout;\n\tvar isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\n\tvar warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\n\tvar supportsMutation = $$$hostConfig.supportsMutation;\n\tvar supportsPersistence = $$$hostConfig.supportsPersistence;\n\tvar supportsHydration = $$$hostConfig.supportsHydration;\n\tvar getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\n\t$$$hostConfig.beforeActiveInstanceBlur;\n\t$$$hostConfig.afterActiveInstanceBlur;\n\tvar preparePortalMount = $$$hostConfig.preparePortalMount;\n\t$$$hostConfig.prepareScopeUpdate;\n\t$$$hostConfig.getInstanceFromScope;\n\tvar getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\n\tvar detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n\t//      Microtasks\n\t//     (optional)\n\t// -------------------\n\n\tvar supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\n\tvar scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n\t//      Test selectors\n\t//     (optional)\n\t// -------------------\n\n\tvar supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\n\tvar findFiberRoot = $$$hostConfig.findFiberRoot;\n\tvar getBoundingRect = $$$hostConfig.getBoundingRect;\n\tvar getTextContent = $$$hostConfig.getTextContent;\n\tvar isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\n\tvar matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\n\tvar setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\n\tvar setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n\t//      Mutation\n\t//     (optional)\n\t// -------------------\n\n\tvar appendChild = $$$hostConfig.appendChild;\n\tvar appendChildToContainer = $$$hostConfig.appendChildToContainer;\n\tvar commitTextUpdate = $$$hostConfig.commitTextUpdate;\n\tvar commitMount = $$$hostConfig.commitMount;\n\tvar commitUpdate = $$$hostConfig.commitUpdate;\n\tvar insertBefore = $$$hostConfig.insertBefore;\n\tvar insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\n\tvar removeChild = $$$hostConfig.removeChild;\n\tvar removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\n\tvar resetTextContent = $$$hostConfig.resetTextContent;\n\tvar hideInstance = $$$hostConfig.hideInstance;\n\tvar hideTextInstance = $$$hostConfig.hideTextInstance;\n\tvar unhideInstance = $$$hostConfig.unhideInstance;\n\tvar unhideTextInstance = $$$hostConfig.unhideTextInstance;\n\tvar clearContainer = $$$hostConfig.clearContainer; // -------------------\n\t//     Persistence\n\t//     (optional)\n\t// -------------------\n\n\tvar cloneInstance = $$$hostConfig.cloneInstance;\n\tvar createContainerChildSet = $$$hostConfig.createContainerChildSet;\n\tvar appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\n\tvar finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\n\tvar replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\n\tvar cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\n\tvar cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n\t//     Hydration\n\t//     (optional)\n\t// -------------------\n\n\tvar canHydrateInstance = $$$hostConfig.canHydrateInstance;\n\tvar canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\n\tvar canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\n\tvar isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\n\tvar isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\n\tvar getSuspenseInstanceFallbackErrorDetails = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails;\n\tvar registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\n\tvar getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\n\tvar getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\n\tvar getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\n\tvar getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\n\tvar hydrateInstance = $$$hostConfig.hydrateInstance;\n\tvar hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\n\tvar hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\n\tvar getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\n\tvar commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\n\tvar commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\n\tvar clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\n\tvar clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\n\tvar shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\n\tvar didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\n\tvar didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\n\tvar didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\n\tvar didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\n\tvar didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\n\tvar didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\n\tvar didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\n\tvar didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\n\tvar didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\n\tvar didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\n\tvar didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\n\tvar didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\n\tvar didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\n\tvar didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\n\tvar errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n\n\t// Helpers to patch console.logs to avoid logging during side-effect free\n\t// replaying on render function. This currently only patches the object\n\t// lazily which won't cover if the log function was extracted eagerly.\n\t// We could also eagerly patch the method.\n\tvar disabledDepth = 0;\n\tvar prevLog;\n\tvar prevInfo;\n\tvar prevWarn;\n\tvar prevError;\n\tvar prevGroup;\n\tvar prevGroupCollapsed;\n\tvar prevGroupEnd;\n\n\tfunction disabledLog() {}\n\n\tdisabledLog.__reactDisabledLog = true;\n\tfunction disableLogs() {\n\t  {\n\t    if (disabledDepth === 0) {\n\t      /* eslint-disable react-internal/no-production-logging */\n\t      prevLog = console.log;\n\t      prevInfo = console.info;\n\t      prevWarn = console.warn;\n\t      prevError = console.error;\n\t      prevGroup = console.group;\n\t      prevGroupCollapsed = console.groupCollapsed;\n\t      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n\t      var props = {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value: disabledLog,\n\t        writable: true\n\t      }; // $FlowFixMe Flow thinks console is immutable.\n\n\t      Object.defineProperties(console, {\n\t        info: props,\n\t        log: props,\n\t        warn: props,\n\t        error: props,\n\t        group: props,\n\t        groupCollapsed: props,\n\t        groupEnd: props\n\t      });\n\t      /* eslint-enable react-internal/no-production-logging */\n\t    }\n\n\t    disabledDepth++;\n\t  }\n\t}\n\tfunction reenableLogs() {\n\t  {\n\t    disabledDepth--;\n\n\t    if (disabledDepth === 0) {\n\t      /* eslint-disable react-internal/no-production-logging */\n\t      var props = {\n\t        configurable: true,\n\t        enumerable: true,\n\t        writable: true\n\t      }; // $FlowFixMe Flow thinks console is immutable.\n\n\t      Object.defineProperties(console, {\n\t        log: assign({}, props, {\n\t          value: prevLog\n\t        }),\n\t        info: assign({}, props, {\n\t          value: prevInfo\n\t        }),\n\t        warn: assign({}, props, {\n\t          value: prevWarn\n\t        }),\n\t        error: assign({}, props, {\n\t          value: prevError\n\t        }),\n\t        group: assign({}, props, {\n\t          value: prevGroup\n\t        }),\n\t        groupCollapsed: assign({}, props, {\n\t          value: prevGroupCollapsed\n\t        }),\n\t        groupEnd: assign({}, props, {\n\t          value: prevGroupEnd\n\t        })\n\t      });\n\t      /* eslint-enable react-internal/no-production-logging */\n\t    }\n\n\t    if (disabledDepth < 0) {\n\t      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n\t    }\n\t  }\n\t}\n\n\tvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\tvar prefix;\n\tfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n\t  {\n\t    if (prefix === undefined) {\n\t      // Extract the VM specific prefix used by each line.\n\t      try {\n\t        throw Error();\n\t      } catch (x) {\n\t        var match = x.stack.trim().match(/\\n( *(at )?)/);\n\t        prefix = match && match[1] || '';\n\t      }\n\t    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n\t    return '\\n' + prefix + name;\n\t  }\n\t}\n\tvar reentry = false;\n\tvar componentFrameCache;\n\n\t{\n\t  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\t  componentFrameCache = new PossiblyWeakMap();\n\t}\n\n\tfunction describeNativeComponentFrame(fn, construct) {\n\t  // If something asked for a stack inside a fake render, it should get ignored.\n\t  if ( !fn || reentry) {\n\t    return '';\n\t  }\n\n\t  {\n\t    var frame = componentFrameCache.get(fn);\n\n\t    if (frame !== undefined) {\n\t      return frame;\n\t    }\n\t  }\n\n\t  var control;\n\t  reentry = true;\n\t  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n\t  Error.prepareStackTrace = undefined;\n\t  var previousDispatcher;\n\n\t  {\n\t    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n\t    // for warnings.\n\n\t    ReactCurrentDispatcher.current = null;\n\t    disableLogs();\n\t  }\n\n\t  try {\n\t    // This should throw.\n\t    if (construct) {\n\t      // Something should be setting the props in the constructor.\n\t      var Fake = function () {\n\t        throw Error();\n\t      }; // $FlowFixMe\n\n\n\t      Object.defineProperty(Fake.prototype, 'props', {\n\t        set: function () {\n\t          // We use a throwing setter instead of frozen or non-writable props\n\t          // because that won't throw in a non-strict mode function.\n\t          throw Error();\n\t        }\n\t      });\n\n\t      if (typeof Reflect === 'object' && Reflect.construct) {\n\t        // We construct a different control for this case to include any extra\n\t        // frames added by the construct call.\n\t        try {\n\t          Reflect.construct(Fake, []);\n\t        } catch (x) {\n\t          control = x;\n\t        }\n\n\t        Reflect.construct(fn, [], Fake);\n\t      } else {\n\t        try {\n\t          Fake.call();\n\t        } catch (x) {\n\t          control = x;\n\t        }\n\n\t        fn.call(Fake.prototype);\n\t      }\n\t    } else {\n\t      try {\n\t        throw Error();\n\t      } catch (x) {\n\t        control = x;\n\t      }\n\n\t      fn();\n\t    }\n\t  } catch (sample) {\n\t    // This is inlined manually because closure doesn't do it for us.\n\t    if (sample && control && typeof sample.stack === 'string') {\n\t      // This extracts the first frame from the sample that isn't also in the control.\n\t      // Skipping one frame that we assume is the frame that calls the two.\n\t      var sampleLines = sample.stack.split('\\n');\n\t      var controlLines = control.stack.split('\\n');\n\t      var s = sampleLines.length - 1;\n\t      var c = controlLines.length - 1;\n\n\t      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n\t        // We expect at least one stack frame to be shared.\n\t        // Typically this will be the root most one. However, stack frames may be\n\t        // cut off due to maximum stack limits. In this case, one maybe cut off\n\t        // earlier than the other. We assume that the sample is longer or the same\n\t        // and there for cut off earlier. So we should find the root most frame in\n\t        // the sample somewhere in the control.\n\t        c--;\n\t      }\n\n\t      for (; s >= 1 && c >= 0; s--, c--) {\n\t        // Next we find the first one that isn't the same which should be the\n\t        // frame that called our sample function and the control.\n\t        if (sampleLines[s] !== controlLines[c]) {\n\t          // In V8, the first line is describing the message but other VMs don't.\n\t          // If we're about to return the first line, and the control is also on the same\n\t          // line, that's a pretty good indicator that our sample threw at same line as\n\t          // the control. I.e. before we entered the sample frame. So we ignore this result.\n\t          // This can happen if you passed a class to function component, or non-function.\n\t          if (s !== 1 || c !== 1) {\n\t            do {\n\t              s--;\n\t              c--; // We may still have similar intermediate frames from the construct call.\n\t              // The next one that isn't the same should be our match though.\n\n\t              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n\t                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n\t                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n\t                // but we have a user-provided \"displayName\"\n\t                // splice it in to make the stack more readable.\n\n\n\t                if (fn.displayName && _frame.includes('<anonymous>')) {\n\t                  _frame = _frame.replace('<anonymous>', fn.displayName);\n\t                }\n\n\t                {\n\t                  if (typeof fn === 'function') {\n\t                    componentFrameCache.set(fn, _frame);\n\t                  }\n\t                } // Return the line we found.\n\n\n\t                return _frame;\n\t              }\n\t            } while (s >= 1 && c >= 0);\n\t          }\n\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  } finally {\n\t    reentry = false;\n\n\t    {\n\t      ReactCurrentDispatcher.current = previousDispatcher;\n\t      reenableLogs();\n\t    }\n\n\t    Error.prepareStackTrace = previousPrepareStackTrace;\n\t  } // Fallback to just using the name if we couldn't make it throw.\n\n\n\t  var name = fn ? fn.displayName || fn.name : '';\n\t  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n\t  {\n\t    if (typeof fn === 'function') {\n\t      componentFrameCache.set(fn, syntheticFrame);\n\t    }\n\t  }\n\n\t  return syntheticFrame;\n\t}\n\n\tfunction describeClassComponentFrame(ctor, source, ownerFn) {\n\t  {\n\t    return describeNativeComponentFrame(ctor, true);\n\t  }\n\t}\n\tfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n\t  {\n\t    return describeNativeComponentFrame(fn, false);\n\t  }\n\t}\n\n\tfunction shouldConstruct(Component) {\n\t  var prototype = Component.prototype;\n\t  return !!(prototype && prototype.isReactComponent);\n\t}\n\n\tfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n\t  if (type == null) {\n\t    return '';\n\t  }\n\n\t  if (typeof type === 'function') {\n\t    {\n\t      return describeNativeComponentFrame(type, shouldConstruct(type));\n\t    }\n\t  }\n\n\t  if (typeof type === 'string') {\n\t    return describeBuiltInComponentFrame(type);\n\t  }\n\n\t  switch (type) {\n\t    case REACT_SUSPENSE_TYPE:\n\t      return describeBuiltInComponentFrame('Suspense');\n\n\t    case REACT_SUSPENSE_LIST_TYPE:\n\t      return describeBuiltInComponentFrame('SuspenseList');\n\t  }\n\n\t  if (typeof type === 'object') {\n\t    switch (type.$$typeof) {\n\t      case REACT_FORWARD_REF_TYPE:\n\t        return describeFunctionComponentFrame(type.render);\n\n\t      case REACT_MEMO_TYPE:\n\t        // Memo may contain any component type so we recursively resolve it.\n\t        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n\t      case REACT_LAZY_TYPE:\n\t        {\n\t          var lazyComponent = type;\n\t          var payload = lazyComponent._payload;\n\t          var init = lazyComponent._init;\n\n\t          try {\n\t            // Lazy may contain any component type so we recursively resolve it.\n\t            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n\t          } catch (x) {}\n\t        }\n\t    }\n\t  }\n\n\t  return '';\n\t}\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\tvar loggedTypeFailures = {};\n\tvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n\tfunction setCurrentlyValidatingElement(element) {\n\t  {\n\t    if (element) {\n\t      var owner = element._owner;\n\t      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n\t      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n\t    } else {\n\t      ReactDebugCurrentFrame.setExtraStackFrame(null);\n\t    }\n\t  }\n\t}\n\n\tfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n\t  {\n\t    // $FlowFixMe This is okay but Flow doesn't know it.\n\t    var has = Function.call.bind(hasOwnProperty);\n\n\t    for (var typeSpecName in typeSpecs) {\n\t      if (has(typeSpecs, typeSpecName)) {\n\t        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n\t        // fail the render phase where it didn't fail before. So we log it.\n\t        // After these have been cleaned up, we'll let them throw.\n\n\t        try {\n\t          // This is intentionally an invariant that gets caught. It's the same\n\t          // behavior as without this statement except with a better message.\n\t          if (typeof typeSpecs[typeSpecName] !== 'function') {\n\t            // eslint-disable-next-line react-internal/prod-error-codes\n\t            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n\t            err.name = 'Invariant Violation';\n\t            throw err;\n\t          }\n\n\t          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n\t        } catch (ex) {\n\t          error$1 = ex;\n\t        }\n\n\t        if (error$1 && !(error$1 instanceof Error)) {\n\t          setCurrentlyValidatingElement(element);\n\n\t          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n\t          setCurrentlyValidatingElement(null);\n\t        }\n\n\t        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n\t          // Only monitor this failure once because there tends to be a lot of the\n\t          // same error.\n\t          loggedTypeFailures[error$1.message] = true;\n\t          setCurrentlyValidatingElement(element);\n\n\t          error('Failed %s type: %s', location, error$1.message);\n\n\t          setCurrentlyValidatingElement(null);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tvar valueStack = [];\n\tvar fiberStack;\n\n\t{\n\t  fiberStack = [];\n\t}\n\n\tvar index = -1;\n\n\tfunction createCursor(defaultValue) {\n\t  return {\n\t    current: defaultValue\n\t  };\n\t}\n\n\tfunction pop(cursor, fiber) {\n\t  if (index < 0) {\n\t    {\n\t      error('Unexpected pop.');\n\t    }\n\n\t    return;\n\t  }\n\n\t  {\n\t    if (fiber !== fiberStack[index]) {\n\t      error('Unexpected Fiber popped.');\n\t    }\n\t  }\n\n\t  cursor.current = valueStack[index];\n\t  valueStack[index] = null;\n\n\t  {\n\t    fiberStack[index] = null;\n\t  }\n\n\t  index--;\n\t}\n\n\tfunction push(cursor, value, fiber) {\n\t  index++;\n\t  valueStack[index] = cursor.current;\n\n\t  {\n\t    fiberStack[index] = fiber;\n\t  }\n\n\t  cursor.current = value;\n\t}\n\n\tvar warnedAboutMissingGetChildContext;\n\n\t{\n\t  warnedAboutMissingGetChildContext = {};\n\t}\n\n\tvar emptyContextObject = {};\n\n\t{\n\t  Object.freeze(emptyContextObject);\n\t} // A cursor to the current merged context object on the stack.\n\n\n\tvar contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\n\tvar didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n\t// We use this to get access to the parent context after we have already\n\t// pushed the next context provider, and now need to merge their contexts.\n\n\tvar previousContext = emptyContextObject;\n\n\tfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n\t  {\n\t    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n\t      // If the fiber is a context provider itself, when we read its context\n\t      // we may have already pushed its own child context on the stack. A context\n\t      // provider should not \"see\" its own child context. Therefore we read the\n\t      // previous (parent) context instead for a context provider.\n\t      return previousContext;\n\t    }\n\n\t    return contextStackCursor.current;\n\t  }\n\t}\n\n\tfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n\t  {\n\t    var instance = workInProgress.stateNode;\n\t    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n\t    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n\t  }\n\t}\n\n\tfunction getMaskedContext(workInProgress, unmaskedContext) {\n\t  {\n\t    var type = workInProgress.type;\n\t    var contextTypes = type.contextTypes;\n\n\t    if (!contextTypes) {\n\t      return emptyContextObject;\n\t    } // Avoid recreating masked context unless unmasked context has changed.\n\t    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n\t    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n\t    var instance = workInProgress.stateNode;\n\n\t    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n\t      return instance.__reactInternalMemoizedMaskedChildContext;\n\t    }\n\n\t    var context = {};\n\n\t    for (var key in contextTypes) {\n\t      context[key] = unmaskedContext[key];\n\t    }\n\n\t    {\n\t      var name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n\t      checkPropTypes(contextTypes, context, 'context', name);\n\t    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n\t    // Context is created before the class component is instantiated so check for instance.\n\n\n\t    if (instance) {\n\t      cacheContext(workInProgress, unmaskedContext, context);\n\t    }\n\n\t    return context;\n\t  }\n\t}\n\n\tfunction hasContextChanged() {\n\t  {\n\t    return didPerformWorkStackCursor.current;\n\t  }\n\t}\n\n\tfunction isContextProvider(type) {\n\t  {\n\t    var childContextTypes = type.childContextTypes;\n\t    return childContextTypes !== null && childContextTypes !== undefined;\n\t  }\n\t}\n\n\tfunction popContext(fiber) {\n\t  {\n\t    pop(didPerformWorkStackCursor, fiber);\n\t    pop(contextStackCursor, fiber);\n\t  }\n\t}\n\n\tfunction popTopLevelContextObject(fiber) {\n\t  {\n\t    pop(didPerformWorkStackCursor, fiber);\n\t    pop(contextStackCursor, fiber);\n\t  }\n\t}\n\n\tfunction pushTopLevelContextObject(fiber, context, didChange) {\n\t  {\n\t    if (contextStackCursor.current !== emptyContextObject) {\n\t      throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t    }\n\n\t    push(contextStackCursor, context, fiber);\n\t    push(didPerformWorkStackCursor, didChange, fiber);\n\t  }\n\t}\n\n\tfunction processChildContext(fiber, type, parentContext) {\n\t  {\n\t    var instance = fiber.stateNode;\n\t    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n\t    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n\t    if (typeof instance.getChildContext !== 'function') {\n\t      {\n\t        var componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n\t        if (!warnedAboutMissingGetChildContext[componentName]) {\n\t          warnedAboutMissingGetChildContext[componentName] = true;\n\n\t          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n\t        }\n\t      }\n\n\t      return parentContext;\n\t    }\n\n\t    var childContext = instance.getChildContext();\n\n\t    for (var contextKey in childContext) {\n\t      if (!(contextKey in childContextTypes)) {\n\t        throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + \".getChildContext(): key \\\"\" + contextKey + \"\\\" is not defined in childContextTypes.\");\n\t      }\n\t    }\n\n\t    {\n\t      var name = getComponentNameFromFiber(fiber) || 'Unknown';\n\t      checkPropTypes(childContextTypes, childContext, 'child context', name);\n\t    }\n\n\t    return assign({}, parentContext, childContext);\n\t  }\n\t}\n\n\tfunction pushContextProvider(workInProgress) {\n\t  {\n\t    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n\t    // If the instance does not exist yet, we will push null at first,\n\t    // and replace it on the stack later when invalidating the context.\n\n\t    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n\t    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n\t    previousContext = contextStackCursor.current;\n\t    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n\t    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\t    return true;\n\t  }\n\t}\n\n\tfunction invalidateContextProvider(workInProgress, type, didChange) {\n\t  {\n\t    var instance = workInProgress.stateNode;\n\n\t    if (!instance) {\n\t      throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t    }\n\n\t    if (didChange) {\n\t      // Merge parent and own context.\n\t      // Skip this if we're not updating due to sCU.\n\t      // This avoids unnecessarily recomputing memoized values.\n\t      var mergedContext = processChildContext(workInProgress, type, previousContext);\n\t      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n\t      // It is important to unwind the context in the reverse order.\n\n\t      pop(didPerformWorkStackCursor, workInProgress);\n\t      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n\t      push(contextStackCursor, mergedContext, workInProgress);\n\t      push(didPerformWorkStackCursor, didChange, workInProgress);\n\t    } else {\n\t      pop(didPerformWorkStackCursor, workInProgress);\n\t      push(didPerformWorkStackCursor, didChange, workInProgress);\n\t    }\n\t  }\n\t}\n\n\tfunction findCurrentUnmaskedContext(fiber) {\n\t  {\n\t    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n\t    // makes sense elsewhere\n\t    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n\t      throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t    }\n\n\t    var node = fiber;\n\n\t    do {\n\t      switch (node.tag) {\n\t        case HostRoot:\n\t          return node.stateNode.context;\n\n\t        case ClassComponent:\n\t          {\n\t            var Component = node.type;\n\n\t            if (isContextProvider(Component)) {\n\t              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n\t            }\n\n\t            break;\n\t          }\n\t      }\n\n\t      node = node.return;\n\t    } while (node !== null);\n\n\t    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\t}\n\n\tvar LegacyRoot = 0;\n\tvar ConcurrentRoot = 1;\n\n\tvar NoMode =\n\t/*                         */\n\t0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n\n\tvar ConcurrentMode =\n\t/*                 */\n\t1;\n\tvar ProfileMode =\n\t/*                    */\n\t2;\n\tvar StrictLegacyMode =\n\t/*               */\n\t8;\n\tvar StrictEffectsMode =\n\t/*              */\n\t16;\n\n\t// TODO: This is pretty well supported by browsers. Maybe we can drop it.\n\tvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n\t// Based on:\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n\tvar log = Math.log;\n\tvar LN2 = Math.LN2;\n\n\tfunction clz32Fallback(x) {\n\t  var asUint = x >>> 0;\n\n\t  if (asUint === 0) {\n\t    return 32;\n\t  }\n\n\t  return 31 - (log(asUint) / LN2 | 0) | 0;\n\t}\n\n\t// If those values are changed that package should be rebuilt and redeployed.\n\n\tvar TotalLanes = 31;\n\tvar NoLanes =\n\t/*                        */\n\t0;\n\tvar NoLane =\n\t/*                          */\n\t0;\n\tvar SyncLane =\n\t/*                        */\n\t1;\n\tvar InputContinuousHydrationLane =\n\t/*    */\n\t2;\n\tvar InputContinuousLane =\n\t/*             */\n\t4;\n\tvar DefaultHydrationLane =\n\t/*            */\n\t8;\n\tvar DefaultLane =\n\t/*                     */\n\t16;\n\tvar TransitionHydrationLane =\n\t/*                */\n\t32;\n\tvar TransitionLanes =\n\t/*                       */\n\t4194240;\n\tvar TransitionLane1 =\n\t/*                        */\n\t64;\n\tvar TransitionLane2 =\n\t/*                        */\n\t128;\n\tvar TransitionLane3 =\n\t/*                        */\n\t256;\n\tvar TransitionLane4 =\n\t/*                        */\n\t512;\n\tvar TransitionLane5 =\n\t/*                        */\n\t1024;\n\tvar TransitionLane6 =\n\t/*                        */\n\t2048;\n\tvar TransitionLane7 =\n\t/*                        */\n\t4096;\n\tvar TransitionLane8 =\n\t/*                        */\n\t8192;\n\tvar TransitionLane9 =\n\t/*                        */\n\t16384;\n\tvar TransitionLane10 =\n\t/*                       */\n\t32768;\n\tvar TransitionLane11 =\n\t/*                       */\n\t65536;\n\tvar TransitionLane12 =\n\t/*                       */\n\t131072;\n\tvar TransitionLane13 =\n\t/*                       */\n\t262144;\n\tvar TransitionLane14 =\n\t/*                       */\n\t524288;\n\tvar TransitionLane15 =\n\t/*                       */\n\t1048576;\n\tvar TransitionLane16 =\n\t/*                       */\n\t2097152;\n\tvar RetryLanes =\n\t/*                            */\n\t130023424;\n\tvar RetryLane1 =\n\t/*                             */\n\t4194304;\n\tvar RetryLane2 =\n\t/*                             */\n\t8388608;\n\tvar RetryLane3 =\n\t/*                             */\n\t16777216;\n\tvar RetryLane4 =\n\t/*                             */\n\t33554432;\n\tvar RetryLane5 =\n\t/*                             */\n\t67108864;\n\tvar SomeRetryLane = RetryLane1;\n\tvar SelectiveHydrationLane =\n\t/*          */\n\t134217728;\n\tvar NonIdleLanes =\n\t/*                          */\n\t268435455;\n\tvar IdleHydrationLane =\n\t/*               */\n\t268435456;\n\tvar IdleLane =\n\t/*                        */\n\t536870912;\n\tvar OffscreenLane =\n\t/*                   */\n\t1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n\t// It should be kept in sync with the Lanes values above.\n\n\tfunction getLabelForLane(lane) {\n\t  {\n\t    if (lane & SyncLane) {\n\t      return 'Sync';\n\t    }\n\n\t    if (lane & InputContinuousHydrationLane) {\n\t      return 'InputContinuousHydration';\n\t    }\n\n\t    if (lane & InputContinuousLane) {\n\t      return 'InputContinuous';\n\t    }\n\n\t    if (lane & DefaultHydrationLane) {\n\t      return 'DefaultHydration';\n\t    }\n\n\t    if (lane & DefaultLane) {\n\t      return 'Default';\n\t    }\n\n\t    if (lane & TransitionHydrationLane) {\n\t      return 'TransitionHydration';\n\t    }\n\n\t    if (lane & TransitionLanes) {\n\t      return 'Transition';\n\t    }\n\n\t    if (lane & RetryLanes) {\n\t      return 'Retry';\n\t    }\n\n\t    if (lane & SelectiveHydrationLane) {\n\t      return 'SelectiveHydration';\n\t    }\n\n\t    if (lane & IdleHydrationLane) {\n\t      return 'IdleHydration';\n\t    }\n\n\t    if (lane & IdleLane) {\n\t      return 'Idle';\n\t    }\n\n\t    if (lane & OffscreenLane) {\n\t      return 'Offscreen';\n\t    }\n\t  }\n\t}\n\tvar NoTimestamp = -1;\n\tvar nextTransitionLane = TransitionLane1;\n\tvar nextRetryLane = RetryLane1;\n\n\tfunction getHighestPriorityLanes(lanes) {\n\t  switch (getHighestPriorityLane(lanes)) {\n\t    case SyncLane:\n\t      return SyncLane;\n\n\t    case InputContinuousHydrationLane:\n\t      return InputContinuousHydrationLane;\n\n\t    case InputContinuousLane:\n\t      return InputContinuousLane;\n\n\t    case DefaultHydrationLane:\n\t      return DefaultHydrationLane;\n\n\t    case DefaultLane:\n\t      return DefaultLane;\n\n\t    case TransitionHydrationLane:\n\t      return TransitionHydrationLane;\n\n\t    case TransitionLane1:\n\t    case TransitionLane2:\n\t    case TransitionLane3:\n\t    case TransitionLane4:\n\t    case TransitionLane5:\n\t    case TransitionLane6:\n\t    case TransitionLane7:\n\t    case TransitionLane8:\n\t    case TransitionLane9:\n\t    case TransitionLane10:\n\t    case TransitionLane11:\n\t    case TransitionLane12:\n\t    case TransitionLane13:\n\t    case TransitionLane14:\n\t    case TransitionLane15:\n\t    case TransitionLane16:\n\t      return lanes & TransitionLanes;\n\n\t    case RetryLane1:\n\t    case RetryLane2:\n\t    case RetryLane3:\n\t    case RetryLane4:\n\t    case RetryLane5:\n\t      return lanes & RetryLanes;\n\n\t    case SelectiveHydrationLane:\n\t      return SelectiveHydrationLane;\n\n\t    case IdleHydrationLane:\n\t      return IdleHydrationLane;\n\n\t    case IdleLane:\n\t      return IdleLane;\n\n\t    case OffscreenLane:\n\t      return OffscreenLane;\n\n\t    default:\n\t      {\n\t        error('Should have found matching lanes. This is a bug in React.');\n\t      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n\t      return lanes;\n\t  }\n\t}\n\n\tfunction getNextLanes(root, wipLanes) {\n\t  // Early bailout if there's no pending work left.\n\t  var pendingLanes = root.pendingLanes;\n\n\t  if (pendingLanes === NoLanes) {\n\t    return NoLanes;\n\t  }\n\n\t  var nextLanes = NoLanes;\n\t  var suspendedLanes = root.suspendedLanes;\n\t  var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n\t  // even if the work is suspended.\n\n\t  var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n\t  if (nonIdlePendingLanes !== NoLanes) {\n\t    var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n\t    if (nonIdleUnblockedLanes !== NoLanes) {\n\t      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n\t    } else {\n\t      var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n\t      if (nonIdlePingedLanes !== NoLanes) {\n\t        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n\t      }\n\t    }\n\t  } else {\n\t    // The only remaining work is Idle.\n\t    var unblockedLanes = pendingLanes & ~suspendedLanes;\n\n\t    if (unblockedLanes !== NoLanes) {\n\t      nextLanes = getHighestPriorityLanes(unblockedLanes);\n\t    } else {\n\t      if (pingedLanes !== NoLanes) {\n\t        nextLanes = getHighestPriorityLanes(pingedLanes);\n\t      }\n\t    }\n\t  }\n\n\t  if (nextLanes === NoLanes) {\n\t    // This should only be reachable if we're suspended\n\t    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n\t    return NoLanes;\n\t  } // If we're already in the middle of a render, switching lanes will interrupt\n\t  // it and we'll lose our progress. We should only do this if the new lanes are\n\t  // higher priority.\n\n\n\t  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n\t  // bother waiting until the root is complete.\n\t  (wipLanes & suspendedLanes) === NoLanes) {\n\t    var nextLane = getHighestPriorityLane(nextLanes);\n\t    var wipLane = getHighestPriorityLane(wipLanes);\n\n\t    if ( // Tests whether the next lane is equal or lower priority than the wip\n\t    // one. This works because the bits decrease in priority as you go left.\n\t    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n\t    // only difference between default updates and transition updates is that\n\t    // default updates do not support refresh transitions.\n\t    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n\t      // Keep working on the existing in-progress tree. Do not interrupt.\n\t      return wipLanes;\n\t    }\n\t  }\n\n\t  if ((nextLanes & InputContinuousLane) !== NoLanes) {\n\t    // When updates are sync by default, we entangle continuous priority updates\n\t    // and default updates, so they render in the same batch. The only reason\n\t    // they use separate lanes is because continuous updates should interrupt\n\t    // transitions, but default updates should not.\n\t    nextLanes |= pendingLanes & DefaultLane;\n\t  } // Check for entangled lanes and add them to the batch.\n\t  //\n\t  // A lane is said to be entangled with another when it's not allowed to render\n\t  // in a batch that does not also include the other lane. Typically we do this\n\t  // when multiple updates have the same source, and we only want to respond to\n\t  // the most recent event from that source.\n\t  //\n\t  // Note that we apply entanglements *after* checking for partial work above.\n\t  // This means that if a lane is entangled during an interleaved event while\n\t  // it's already rendering, we won't interrupt it. This is intentional, since\n\t  // entanglement is usually \"best effort\": we'll try our best to render the\n\t  // lanes in the same batch, but it's not worth throwing out partially\n\t  // completed work in order to do it.\n\t  // TODO: Reconsider this. The counter-argument is that the partial work\n\t  // represents an intermediate state, which we don't want to show to the user.\n\t  // And by spending extra time finishing it, we're increasing the amount of\n\t  // time it takes to show the final state, which is what they are actually\n\t  // waiting for.\n\t  //\n\t  // For those exceptions where entanglement is semantically important, like\n\t  // useMutableSource, we should ensure that there is no partial work at the\n\t  // time we apply the entanglement.\n\n\n\t  var entangledLanes = root.entangledLanes;\n\n\t  if (entangledLanes !== NoLanes) {\n\t    var entanglements = root.entanglements;\n\t    var lanes = nextLanes & entangledLanes;\n\n\t    while (lanes > 0) {\n\t      var index = pickArbitraryLaneIndex(lanes);\n\t      var lane = 1 << index;\n\t      nextLanes |= entanglements[index];\n\t      lanes &= ~lane;\n\t    }\n\t  }\n\n\t  return nextLanes;\n\t}\n\tfunction getMostRecentEventTime(root, lanes) {\n\t  var eventTimes = root.eventTimes;\n\t  var mostRecentEventTime = NoTimestamp;\n\n\t  while (lanes > 0) {\n\t    var index = pickArbitraryLaneIndex(lanes);\n\t    var lane = 1 << index;\n\t    var eventTime = eventTimes[index];\n\n\t    if (eventTime > mostRecentEventTime) {\n\t      mostRecentEventTime = eventTime;\n\t    }\n\n\t    lanes &= ~lane;\n\t  }\n\n\t  return mostRecentEventTime;\n\t}\n\n\tfunction computeExpirationTime(lane, currentTime) {\n\t  switch (lane) {\n\t    case SyncLane:\n\t    case InputContinuousHydrationLane:\n\t    case InputContinuousLane:\n\t      // User interactions should expire slightly more quickly.\n\t      //\n\t      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n\t      // When we made it larger, a product metric in www regressed, suggesting\n\t      // there's a user interaction that's being starved by a series of\n\t      // synchronous updates. If that theory is correct, the proper solution is\n\t      // to fix the starvation. However, this scenario supports the idea that\n\t      // expiration times are an important safeguard when starvation\n\t      // does happen.\n\t      return currentTime + 250;\n\n\t    case DefaultHydrationLane:\n\t    case DefaultLane:\n\t    case TransitionHydrationLane:\n\t    case TransitionLane1:\n\t    case TransitionLane2:\n\t    case TransitionLane3:\n\t    case TransitionLane4:\n\t    case TransitionLane5:\n\t    case TransitionLane6:\n\t    case TransitionLane7:\n\t    case TransitionLane8:\n\t    case TransitionLane9:\n\t    case TransitionLane10:\n\t    case TransitionLane11:\n\t    case TransitionLane12:\n\t    case TransitionLane13:\n\t    case TransitionLane14:\n\t    case TransitionLane15:\n\t    case TransitionLane16:\n\t      return currentTime + 5000;\n\n\t    case RetryLane1:\n\t    case RetryLane2:\n\t    case RetryLane3:\n\t    case RetryLane4:\n\t    case RetryLane5:\n\t      // TODO: Retries should be allowed to expire if they are CPU bound for\n\t      // too long, but when I made this change it caused a spike in browser\n\t      // crashes. There must be some other underlying bug; not super urgent but\n\t      // ideally should figure out why and fix it. Unfortunately we don't have\n\t      // a repro for the crashes, only detected via production metrics.\n\t      return NoTimestamp;\n\n\t    case SelectiveHydrationLane:\n\t    case IdleHydrationLane:\n\t    case IdleLane:\n\t    case OffscreenLane:\n\t      // Anything idle priority or lower should never expire.\n\t      return NoTimestamp;\n\n\t    default:\n\t      {\n\t        error('Should have found matching lanes. This is a bug in React.');\n\t      }\n\n\t      return NoTimestamp;\n\t  }\n\t}\n\n\tfunction markStarvedLanesAsExpired(root, currentTime) {\n\t  // TODO: This gets called every time we yield. We can optimize by storing\n\t  // the earliest expiration time on the root. Then use that to quickly bail out\n\t  // of this function.\n\t  var pendingLanes = root.pendingLanes;\n\t  var suspendedLanes = root.suspendedLanes;\n\t  var pingedLanes = root.pingedLanes;\n\t  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n\t  // expiration time. If so, we'll assume the update is being starved and mark\n\t  // it as expired to force it to finish.\n\n\t  var lanes = pendingLanes;\n\n\t  while (lanes > 0) {\n\t    var index = pickArbitraryLaneIndex(lanes);\n\t    var lane = 1 << index;\n\t    var expirationTime = expirationTimes[index];\n\n\t    if (expirationTime === NoTimestamp) {\n\t      // Found a pending lane with no expiration time. If it's not suspended, or\n\t      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n\t      // using the current time.\n\t      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n\t        // Assumes timestamps are monotonically increasing.\n\t        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n\t      }\n\t    } else if (expirationTime <= currentTime) {\n\t      // This lane expired\n\t      root.expiredLanes |= lane;\n\t    }\n\n\t    lanes &= ~lane;\n\t  }\n\t} // This returns the highest priority pending lanes regardless of whether they\n\t// are suspended.\n\n\tfunction getHighestPriorityPendingLanes(root) {\n\t  return getHighestPriorityLanes(root.pendingLanes);\n\t}\n\tfunction getLanesToRetrySynchronouslyOnError(root) {\n\t  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n\t  if (everythingButOffscreen !== NoLanes) {\n\t    return everythingButOffscreen;\n\t  }\n\n\t  if (everythingButOffscreen & OffscreenLane) {\n\t    return OffscreenLane;\n\t  }\n\n\t  return NoLanes;\n\t}\n\tfunction includesSyncLane(lanes) {\n\t  return (lanes & SyncLane) !== NoLanes;\n\t}\n\tfunction includesNonIdleWork(lanes) {\n\t  return (lanes & NonIdleLanes) !== NoLanes;\n\t}\n\tfunction includesOnlyRetries(lanes) {\n\t  return (lanes & RetryLanes) === lanes;\n\t}\n\tfunction includesOnlyNonUrgentLanes(lanes) {\n\t  var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n\t  return (lanes & UrgentLanes) === NoLanes;\n\t}\n\tfunction includesOnlyTransitions(lanes) {\n\t  return (lanes & TransitionLanes) === lanes;\n\t}\n\tfunction includesBlockingLane(root, lanes) {\n\n\t  var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n\t  return (lanes & SyncDefaultLanes) !== NoLanes;\n\t}\n\tfunction includesExpiredLane(root, lanes) {\n\t  // This is a separate check from includesBlockingLane because a lane can\n\t  // expire after a render has already started.\n\t  return (lanes & root.expiredLanes) !== NoLanes;\n\t}\n\tfunction isTransitionLane(lane) {\n\t  return (lane & TransitionLanes) !== NoLanes;\n\t}\n\tfunction claimNextTransitionLane() {\n\t  // Cycle through the lanes, assigning each new transition to the next lane.\n\t  // In most cases, this means every transition gets its own lane, until we\n\t  // run out of lanes and cycle back to the beginning.\n\t  var lane = nextTransitionLane;\n\t  nextTransitionLane <<= 1;\n\n\t  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n\t    nextTransitionLane = TransitionLane1;\n\t  }\n\n\t  return lane;\n\t}\n\tfunction claimNextRetryLane() {\n\t  var lane = nextRetryLane;\n\t  nextRetryLane <<= 1;\n\n\t  if ((nextRetryLane & RetryLanes) === NoLanes) {\n\t    nextRetryLane = RetryLane1;\n\t  }\n\n\t  return lane;\n\t}\n\tfunction getHighestPriorityLane(lanes) {\n\t  return lanes & -lanes;\n\t}\n\tfunction pickArbitraryLane(lanes) {\n\t  // This wrapper function gets inlined. Only exists so to communicate that it\n\t  // doesn't matter which bit is selected; you can pick any bit without\n\t  // affecting the algorithms where its used. Here I'm using\n\t  // getHighestPriorityLane because it requires the fewest operations.\n\t  return getHighestPriorityLane(lanes);\n\t}\n\n\tfunction pickArbitraryLaneIndex(lanes) {\n\t  return 31 - clz32(lanes);\n\t}\n\n\tfunction laneToIndex(lane) {\n\t  return pickArbitraryLaneIndex(lane);\n\t}\n\n\tfunction includesSomeLane(a, b) {\n\t  return (a & b) !== NoLanes;\n\t}\n\tfunction isSubsetOfLanes(set, subset) {\n\t  return (set & subset) === subset;\n\t}\n\tfunction mergeLanes(a, b) {\n\t  return a | b;\n\t}\n\tfunction removeLanes(set, subset) {\n\t  return set & ~subset;\n\t}\n\tfunction intersectLanes(a, b) {\n\t  return a & b;\n\t} // Seems redundant, but it changes the type from a single lane (used for\n\t// updates) to a group of lanes (used for flushing work).\n\n\tfunction laneToLanes(lane) {\n\t  return lane;\n\t}\n\tfunction higherPriorityLane(a, b) {\n\t  // This works because the bit ranges decrease in priority as you go left.\n\t  return a !== NoLane && a < b ? a : b;\n\t}\n\tfunction createLaneMap(initial) {\n\t  // Intentionally pushing one by one.\n\t  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n\t  var laneMap = [];\n\n\t  for (var i = 0; i < TotalLanes; i++) {\n\t    laneMap.push(initial);\n\t  }\n\n\t  return laneMap;\n\t}\n\tfunction markRootUpdated(root, updateLane, eventTime) {\n\t  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n\t  // could unblock them. Clear the suspended lanes so that we can try rendering\n\t  // them again.\n\t  //\n\t  // TODO: We really only need to unsuspend only lanes that are in the\n\t  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n\t  // path. This would exclude suspended updates in an unrelated sibling tree,\n\t  // since there's no way for this update to unblock it.\n\t  //\n\t  // We don't do this if the incoming update is idle, because we never process\n\t  // idle updates until after all the regular updates have finished; there's no\n\t  // way it could unblock a transition.\n\n\t  if (updateLane !== IdleLane) {\n\t    root.suspendedLanes = NoLanes;\n\t    root.pingedLanes = NoLanes;\n\t  }\n\n\t  var eventTimes = root.eventTimes;\n\t  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n\t  // recent event, and we assume time is monotonically increasing.\n\n\t  eventTimes[index] = eventTime;\n\t}\n\tfunction markRootSuspended(root, suspendedLanes) {\n\t  root.suspendedLanes |= suspendedLanes;\n\t  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n\t  var expirationTimes = root.expirationTimes;\n\t  var lanes = suspendedLanes;\n\n\t  while (lanes > 0) {\n\t    var index = pickArbitraryLaneIndex(lanes);\n\t    var lane = 1 << index;\n\t    expirationTimes[index] = NoTimestamp;\n\t    lanes &= ~lane;\n\t  }\n\t}\n\tfunction markRootPinged(root, pingedLanes, eventTime) {\n\t  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n\t}\n\tfunction markRootFinished(root, remainingLanes) {\n\t  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n\t  root.pendingLanes = remainingLanes; // Let's try everything again\n\n\t  root.suspendedLanes = NoLanes;\n\t  root.pingedLanes = NoLanes;\n\t  root.expiredLanes &= remainingLanes;\n\t  root.mutableReadLanes &= remainingLanes;\n\t  root.entangledLanes &= remainingLanes;\n\t  var entanglements = root.entanglements;\n\t  var eventTimes = root.eventTimes;\n\t  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n\n\t  var lanes = noLongerPendingLanes;\n\n\t  while (lanes > 0) {\n\t    var index = pickArbitraryLaneIndex(lanes);\n\t    var lane = 1 << index;\n\t    entanglements[index] = NoLanes;\n\t    eventTimes[index] = NoTimestamp;\n\t    expirationTimes[index] = NoTimestamp;\n\t    lanes &= ~lane;\n\t  }\n\t}\n\tfunction markRootEntangled(root, entangledLanes) {\n\t  // In addition to entangling each of the given lanes with each other, we also\n\t  // have to consider _transitive_ entanglements. For each lane that is already\n\t  // entangled with *any* of the given lanes, that lane is now transitively\n\t  // entangled with *all* the given lanes.\n\t  //\n\t  // Translated: If C is entangled with A, then entangling A with B also\n\t  // entangles C with B.\n\t  //\n\t  // If this is hard to grasp, it might help to intentionally break this\n\t  // function and look at the tests that fail in ReactTransition-test.js. Try\n\t  // commenting out one of the conditions below.\n\t  var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n\t  var entanglements = root.entanglements;\n\t  var lanes = rootEntangledLanes;\n\n\t  while (lanes) {\n\t    var index = pickArbitraryLaneIndex(lanes);\n\t    var lane = 1 << index;\n\n\t    if ( // Is this one of the newly entangled lanes?\n\t    lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n\t    entanglements[index] & entangledLanes) {\n\t      entanglements[index] |= entangledLanes;\n\t    }\n\n\t    lanes &= ~lane;\n\t  }\n\t}\n\tfunction getBumpedLaneForHydration(root, renderLanes) {\n\t  var renderLane = getHighestPriorityLane(renderLanes);\n\t  var lane;\n\n\t  switch (renderLane) {\n\t    case InputContinuousLane:\n\t      lane = InputContinuousHydrationLane;\n\t      break;\n\n\t    case DefaultLane:\n\t      lane = DefaultHydrationLane;\n\t      break;\n\n\t    case TransitionLane1:\n\t    case TransitionLane2:\n\t    case TransitionLane3:\n\t    case TransitionLane4:\n\t    case TransitionLane5:\n\t    case TransitionLane6:\n\t    case TransitionLane7:\n\t    case TransitionLane8:\n\t    case TransitionLane9:\n\t    case TransitionLane10:\n\t    case TransitionLane11:\n\t    case TransitionLane12:\n\t    case TransitionLane13:\n\t    case TransitionLane14:\n\t    case TransitionLane15:\n\t    case TransitionLane16:\n\t    case RetryLane1:\n\t    case RetryLane2:\n\t    case RetryLane3:\n\t    case RetryLane4:\n\t    case RetryLane5:\n\t      lane = TransitionHydrationLane;\n\t      break;\n\n\t    case IdleLane:\n\t      lane = IdleHydrationLane;\n\t      break;\n\n\t    default:\n\t      // Everything else is already either a hydration lane, or shouldn't\n\t      // be retried at a hydration lane.\n\t      lane = NoLane;\n\t      break;\n\t  } // Check if the lane we chose is suspended. If so, that indicates that we\n\t  // already attempted and failed to hydrate at that level. Also check if we're\n\t  // already rendering that lane, which is rare but could happen.\n\n\n\t  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n\t    // Give up trying to hydrate and fall back to client render.\n\t    return NoLane;\n\t  }\n\n\t  return lane;\n\t}\n\tfunction addFiberToLanesMap(root, fiber, lanes) {\n\n\t  if (!isDevToolsPresent) {\n\t    return;\n\t  }\n\n\t  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n\t  while (lanes > 0) {\n\t    var index = laneToIndex(lanes);\n\t    var lane = 1 << index;\n\t    var updaters = pendingUpdatersLaneMap[index];\n\t    updaters.add(fiber);\n\t    lanes &= ~lane;\n\t  }\n\t}\n\tfunction movePendingFibersToMemoized(root, lanes) {\n\n\t  if (!isDevToolsPresent) {\n\t    return;\n\t  }\n\n\t  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\t  var memoizedUpdaters = root.memoizedUpdaters;\n\n\t  while (lanes > 0) {\n\t    var index = laneToIndex(lanes);\n\t    var lane = 1 << index;\n\t    var updaters = pendingUpdatersLaneMap[index];\n\n\t    if (updaters.size > 0) {\n\t      updaters.forEach(function (fiber) {\n\t        var alternate = fiber.alternate;\n\n\t        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n\t          memoizedUpdaters.add(fiber);\n\t        }\n\t      });\n\t      updaters.clear();\n\t    }\n\n\t    lanes &= ~lane;\n\t  }\n\t}\n\tfunction getTransitionsForLanes(root, lanes) {\n\t  {\n\t    return null;\n\t  }\n\t}\n\n\tvar DiscreteEventPriority = SyncLane;\n\tvar ContinuousEventPriority = InputContinuousLane;\n\tvar DefaultEventPriority = DefaultLane;\n\tvar IdleEventPriority = IdleLane;\n\tvar currentUpdatePriority = NoLane;\n\tfunction getCurrentUpdatePriority() {\n\t  return currentUpdatePriority;\n\t}\n\tfunction setCurrentUpdatePriority(newPriority) {\n\t  currentUpdatePriority = newPriority;\n\t}\n\tfunction runWithPriority(priority, fn) {\n\t  var previousPriority = currentUpdatePriority;\n\n\t  try {\n\t    currentUpdatePriority = priority;\n\t    return fn();\n\t  } finally {\n\t    currentUpdatePriority = previousPriority;\n\t  }\n\t}\n\tfunction higherEventPriority(a, b) {\n\t  return a !== 0 && a < b ? a : b;\n\t}\n\tfunction lowerEventPriority(a, b) {\n\t  return a === 0 || a > b ? a : b;\n\t}\n\tfunction isHigherEventPriority(a, b) {\n\t  return a !== 0 && a < b;\n\t}\n\tfunction lanesToEventPriority(lanes) {\n\t  var lane = getHighestPriorityLane(lanes);\n\n\t  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n\t    return DiscreteEventPriority;\n\t  }\n\n\t  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n\t    return ContinuousEventPriority;\n\t  }\n\n\t  if (includesNonIdleWork(lane)) {\n\t    return DefaultEventPriority;\n\t  }\n\n\t  return IdleEventPriority;\n\t}\n\n\t// This module only exists as an ESM wrapper around the external CommonJS\n\tvar scheduleCallback = Scheduler.unstable_scheduleCallback;\n\tvar cancelCallback = Scheduler.unstable_cancelCallback;\n\tvar shouldYield = Scheduler.unstable_shouldYield;\n\tvar requestPaint = Scheduler.unstable_requestPaint;\n\tvar now = Scheduler.unstable_now;\n\tvar ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n\tvar UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n\tvar NormalPriority = Scheduler.unstable_NormalPriority;\n\tvar IdlePriority = Scheduler.unstable_IdlePriority;\n\t// this doesn't actually exist on the scheduler, but it *does*\n\t// on scheduler/unstable_mock, which we'll need for internal testing\n\tvar unstable_yieldValue = Scheduler.unstable_yieldValue;\n\tvar unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n\n\tvar rendererID = null;\n\tvar injectedHook = null;\n\tvar injectedProfilingHooks = null;\n\tvar hasLoggedError = false;\n\tvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n\tfunction injectInternals(internals) {\n\t  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n\t    // No DevTools\n\t    return false;\n\t  }\n\n\t  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n\t  if (hook.isDisabled) {\n\t    // This isn't a real property on the hook, but it can be set to opt out\n\t    // of DevTools integration and associated warnings and logs.\n\t    // https://github.com/facebook/react/issues/3877\n\t    return true;\n\t  }\n\n\t  if (!hook.supportsFiber) {\n\t    {\n\t      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');\n\t    } // DevTools exists, even though it doesn't support Fiber.\n\n\n\t    return true;\n\t  }\n\n\t  try {\n\t    if (enableSchedulingProfiler) {\n\t      // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n\t      // This gives DevTools a way to feature detect that isn't tied to version number\n\t      // (since profiling and timeline are controlled by different feature flags).\n\t      internals = assign({}, internals, {\n\t        getLaneLabelMap: getLaneLabelMap,\n\t        injectProfilingHooks: injectProfilingHooks\n\t      });\n\t    }\n\n\t    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n\t    injectedHook = hook;\n\t  } catch (err) {\n\t    // Catch all errors because it is unsafe to throw during initialization.\n\t    {\n\t      error('React instrumentation encountered an error: %s.', err);\n\t    }\n\t  }\n\n\t  if (hook.checkDCE) {\n\t    // This is the real DevTools.\n\t    return true;\n\t  } else {\n\t    // This is likely a hook installed by Fast Refresh runtime.\n\t    return false;\n\t  }\n\t}\n\tfunction onScheduleRoot(root, children) {\n\t  {\n\t    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n\t      try {\n\t        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n\t      } catch (err) {\n\t        if ( !hasLoggedError) {\n\t          hasLoggedError = true;\n\n\t          error('React instrumentation encountered an error: %s', err);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\tfunction onCommitRoot(root, eventPriority) {\n\t  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n\t    try {\n\t      var didError = (root.current.flags & DidCapture) === DidCapture;\n\n\t      if (enableProfilerTimer) {\n\t        var schedulerPriority;\n\n\t        switch (eventPriority) {\n\t          case DiscreteEventPriority:\n\t            schedulerPriority = ImmediatePriority;\n\t            break;\n\n\t          case ContinuousEventPriority:\n\t            schedulerPriority = UserBlockingPriority;\n\t            break;\n\n\t          case DefaultEventPriority:\n\t            schedulerPriority = NormalPriority;\n\t            break;\n\n\t          case IdleEventPriority:\n\t            schedulerPriority = IdlePriority;\n\t            break;\n\n\t          default:\n\t            schedulerPriority = NormalPriority;\n\t            break;\n\t        }\n\n\t        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n\t      }\n\t    } catch (err) {\n\t      {\n\t        if (!hasLoggedError) {\n\t          hasLoggedError = true;\n\n\t          error('React instrumentation encountered an error: %s', err);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\tfunction onPostCommitRoot(root) {\n\t  if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n\t    try {\n\t      injectedHook.onPostCommitFiberRoot(rendererID, root);\n\t    } catch (err) {\n\t      {\n\t        if (!hasLoggedError) {\n\t          hasLoggedError = true;\n\n\t          error('React instrumentation encountered an error: %s', err);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\tfunction onCommitUnmount(fiber) {\n\t  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n\t    try {\n\t      injectedHook.onCommitFiberUnmount(rendererID, fiber);\n\t    } catch (err) {\n\t      {\n\t        if (!hasLoggedError) {\n\t          hasLoggedError = true;\n\n\t          error('React instrumentation encountered an error: %s', err);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\tfunction setIsStrictModeForDevtools(newIsStrictMode) {\n\t  {\n\t    if (typeof unstable_yieldValue === 'function') {\n\t      // We're in a test because Scheduler.unstable_yieldValue only exists\n\t      // in SchedulerMock. To reduce the noise in strict mode tests,\n\t      // suppress warnings and disable scheduler yielding during the double render\n\t      unstable_setDisableYieldValue(newIsStrictMode);\n\t      setSuppressWarning(newIsStrictMode);\n\t    }\n\n\t    if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n\t      try {\n\t        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n\t      } catch (err) {\n\t        {\n\t          if (!hasLoggedError) {\n\t            hasLoggedError = true;\n\n\t            error('React instrumentation encountered an error: %s', err);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t} // Profiler API hooks\n\n\tfunction injectProfilingHooks(profilingHooks) {\n\t  injectedProfilingHooks = profilingHooks;\n\t}\n\n\tfunction getLaneLabelMap() {\n\t  {\n\t    var map = new Map();\n\t    var lane = 1;\n\n\t    for (var index = 0; index < TotalLanes; index++) {\n\t      var label = getLabelForLane(lane);\n\t      map.set(lane, label);\n\t      lane *= 2;\n\t    }\n\n\t    return map;\n\t  }\n\t}\n\n\tfunction markCommitStarted(lanes) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n\t      injectedProfilingHooks.markCommitStarted(lanes);\n\t    }\n\t  }\n\t}\n\tfunction markCommitStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n\t      injectedProfilingHooks.markCommitStopped();\n\t    }\n\t  }\n\t}\n\tfunction markComponentRenderStarted(fiber) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n\t      injectedProfilingHooks.markComponentRenderStarted(fiber);\n\t    }\n\t  }\n\t}\n\tfunction markComponentRenderStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n\t      injectedProfilingHooks.markComponentRenderStopped();\n\t    }\n\t  }\n\t}\n\tfunction markComponentPassiveEffectMountStarted(fiber) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n\t      injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n\t    }\n\t  }\n\t}\n\tfunction markComponentPassiveEffectMountStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n\t      injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n\t    }\n\t  }\n\t}\n\tfunction markComponentPassiveEffectUnmountStarted(fiber) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n\t      injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n\t    }\n\t  }\n\t}\n\tfunction markComponentPassiveEffectUnmountStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n\t      injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n\t    }\n\t  }\n\t}\n\tfunction markComponentLayoutEffectMountStarted(fiber) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n\t      injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n\t    }\n\t  }\n\t}\n\tfunction markComponentLayoutEffectMountStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n\t      injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n\t    }\n\t  }\n\t}\n\tfunction markComponentLayoutEffectUnmountStarted(fiber) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n\t      injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n\t    }\n\t  }\n\t}\n\tfunction markComponentLayoutEffectUnmountStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n\t      injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n\t    }\n\t  }\n\t}\n\tfunction markComponentErrored(fiber, thrownValue, lanes) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n\t      injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n\t    }\n\t  }\n\t}\n\tfunction markComponentSuspended(fiber, wakeable, lanes) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n\t      injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n\t    }\n\t  }\n\t}\n\tfunction markLayoutEffectsStarted(lanes) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n\t      injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n\t    }\n\t  }\n\t}\n\tfunction markLayoutEffectsStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n\t      injectedProfilingHooks.markLayoutEffectsStopped();\n\t    }\n\t  }\n\t}\n\tfunction markPassiveEffectsStarted(lanes) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n\t      injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n\t    }\n\t  }\n\t}\n\tfunction markPassiveEffectsStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n\t      injectedProfilingHooks.markPassiveEffectsStopped();\n\t    }\n\t  }\n\t}\n\tfunction markRenderStarted(lanes) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n\t      injectedProfilingHooks.markRenderStarted(lanes);\n\t    }\n\t  }\n\t}\n\tfunction markRenderYielded() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n\t      injectedProfilingHooks.markRenderYielded();\n\t    }\n\t  }\n\t}\n\tfunction markRenderStopped() {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n\t      injectedProfilingHooks.markRenderStopped();\n\t    }\n\t  }\n\t}\n\tfunction markRenderScheduled(lane) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n\t      injectedProfilingHooks.markRenderScheduled(lane);\n\t    }\n\t  }\n\t}\n\tfunction markForceUpdateScheduled(fiber, lane) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n\t      injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n\t    }\n\t  }\n\t}\n\tfunction markStateUpdateScheduled(fiber, lane) {\n\t  {\n\t    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n\t      injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\tvar syncQueue = null;\n\tvar includesLegacySyncCallbacks = false;\n\tvar isFlushingSyncQueue = false;\n\tfunction scheduleSyncCallback(callback) {\n\t  // Push this callback into an internal queue. We'll flush these either in\n\t  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n\t  if (syncQueue === null) {\n\t    syncQueue = [callback];\n\t  } else {\n\t    // Push onto existing queue. Don't need to schedule a callback because\n\t    // we already scheduled one when we created the queue.\n\t    syncQueue.push(callback);\n\t  }\n\t}\n\tfunction scheduleLegacySyncCallback(callback) {\n\t  includesLegacySyncCallbacks = true;\n\t  scheduleSyncCallback(callback);\n\t}\n\tfunction flushSyncCallbacksOnlyInLegacyMode() {\n\t  // Only flushes the queue if there's a legacy sync callback scheduled.\n\t  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n\t  // it might make more sense for the queue to be a list of roots instead of a\n\t  // list of generic callbacks. Then we can have two: one for legacy roots, one\n\t  // for concurrent roots. And this method would only flush the legacy ones.\n\t  if (includesLegacySyncCallbacks) {\n\t    flushSyncCallbacks();\n\t  }\n\t}\n\tfunction flushSyncCallbacks() {\n\t  if (!isFlushingSyncQueue && syncQueue !== null) {\n\t    // Prevent re-entrance.\n\t    isFlushingSyncQueue = true;\n\t    var i = 0;\n\t    var previousUpdatePriority = getCurrentUpdatePriority();\n\n\t    try {\n\t      var isSync = true;\n\t      var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n\t      // queue is in the render or commit phases.\n\n\t      setCurrentUpdatePriority(DiscreteEventPriority);\n\n\t      for (; i < queue.length; i++) {\n\t        var callback = queue[i];\n\n\t        do {\n\t          callback = callback(isSync);\n\t        } while (callback !== null);\n\t      }\n\n\t      syncQueue = null;\n\t      includesLegacySyncCallbacks = false;\n\t    } catch (error) {\n\t      // If something throws, leave the remaining callbacks on the queue.\n\t      if (syncQueue !== null) {\n\t        syncQueue = syncQueue.slice(i + 1);\n\t      } // Resume flushing in the next tick\n\n\n\t      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n\t      throw error;\n\t    } finally {\n\t      setCurrentUpdatePriority(previousUpdatePriority);\n\t      isFlushingSyncQueue = false;\n\t    }\n\t  }\n\n\t  return null;\n\t}\n\n\t// This is imported by the event replaying implementation in React DOM. It's\n\t// in a separate file to break a circular dependency between the renderer and\n\t// the reconciler.\n\tfunction isRootDehydrated(root) {\n\t  var currentState = root.current.memoizedState;\n\t  return currentState.isDehydrated;\n\t}\n\n\t// TODO: Use the unified fiber stack module instead of this local one?\n\t// Intentionally not using it yet to derisk the initial implementation, because\n\t// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n\t// rather the ids be wrong than crash the whole reconciler.\n\tvar forkStack = [];\n\tvar forkStackIndex = 0;\n\tvar treeForkProvider = null;\n\tvar treeForkCount = 0;\n\tvar idStack = [];\n\tvar idStackIndex = 0;\n\tvar treeContextProvider = null;\n\tvar treeContextId = 1;\n\tvar treeContextOverflow = '';\n\tfunction isForkedChild(workInProgress) {\n\t  warnIfNotHydrating();\n\t  return (workInProgress.flags & Forked) !== NoFlags;\n\t}\n\tfunction getForksAtLevel(workInProgress) {\n\t  warnIfNotHydrating();\n\t  return treeForkCount;\n\t}\n\tfunction getTreeId() {\n\t  var overflow = treeContextOverflow;\n\t  var idWithLeadingBit = treeContextId;\n\t  var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n\t  return id.toString(32) + overflow;\n\t}\n\tfunction pushTreeFork(workInProgress, totalChildren) {\n\t  // This is called right after we reconcile an array (or iterator) of child\n\t  // fibers, because that's the only place where we know how many children in\n\t  // the whole set without doing extra work later, or storing addtional\n\t  // information on the fiber.\n\t  //\n\t  // That's why this function is separate from pushTreeId  it's called during\n\t  // the render phase of the fork parent, not the child, which is where we push\n\t  // the other context values.\n\t  //\n\t  // In the Fizz implementation this is much simpler because the child is\n\t  // rendered in the same callstack as the parent.\n\t  //\n\t  // It might be better to just add a `forks` field to the Fiber type. It would\n\t  // make this module simpler.\n\t  warnIfNotHydrating();\n\t  forkStack[forkStackIndex++] = treeForkCount;\n\t  forkStack[forkStackIndex++] = treeForkProvider;\n\t  treeForkProvider = workInProgress;\n\t  treeForkCount = totalChildren;\n\t}\n\tfunction pushTreeId(workInProgress, totalChildren, index) {\n\t  warnIfNotHydrating();\n\t  idStack[idStackIndex++] = treeContextId;\n\t  idStack[idStackIndex++] = treeContextOverflow;\n\t  idStack[idStackIndex++] = treeContextProvider;\n\t  treeContextProvider = workInProgress;\n\t  var baseIdWithLeadingBit = treeContextId;\n\t  var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n\t  // of the id; we use it to account for leading 0s.\n\n\t  var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n\t  var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n\t  var slot = index + 1;\n\t  var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n\t  // consideration the leading 1 we use to mark the end of the sequence.\n\n\t  if (length > 30) {\n\t    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n\t    // This branch assumes the length of the base id is greater than 5; it won't\n\t    // work for smaller ids, because you need 5 bits per character.\n\t    //\n\t    // We encode the id in multiple steps: first the base id, then the\n\t    // remaining digits.\n\t    //\n\t    // Each 5 bit sequence corresponds to a single base 32 character. So for\n\t    // example, if the current id is 23 bits long, we can convert 20 of those\n\t    // bits into a string of 4 characters, with 3 bits left over.\n\t    //\n\t    // First calculate how many bits in the base id represent a complete\n\t    // sequence of characters.\n\t    var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n\n\t    var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n\n\t    var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n\n\t    var restOfBaseId = baseId >> numberOfOverflowBits;\n\t    var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n\t    // we made more room, this time it won't overflow.\n\n\t    var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n\t    var restOfNewBits = slot << restOfBaseLength;\n\t    var id = restOfNewBits | restOfBaseId;\n\t    var overflow = newOverflow + baseOverflow;\n\t    treeContextId = 1 << restOfLength | id;\n\t    treeContextOverflow = overflow;\n\t  } else {\n\t    // Normal path\n\t    var newBits = slot << baseLength;\n\n\t    var _id = newBits | baseId;\n\n\t    var _overflow = baseOverflow;\n\t    treeContextId = 1 << length | _id;\n\t    treeContextOverflow = _overflow;\n\t  }\n\t}\n\tfunction pushMaterializedTreeId(workInProgress) {\n\t  warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n\t  // in its children.\n\n\t  var returnFiber = workInProgress.return;\n\n\t  if (returnFiber !== null) {\n\t    var numberOfForks = 1;\n\t    var slotIndex = 0;\n\t    pushTreeFork(workInProgress, numberOfForks);\n\t    pushTreeId(workInProgress, numberOfForks, slotIndex);\n\t  }\n\t}\n\n\tfunction getBitLength(number) {\n\t  return 32 - clz32(number);\n\t}\n\n\tfunction getLeadingBit(id) {\n\t  return 1 << getBitLength(id) - 1;\n\t}\n\n\tfunction popTreeContext(workInProgress) {\n\t  // Restore the previous values.\n\t  // This is a bit more complicated than other context-like modules in Fiber\n\t  // because the same Fiber may appear on the stack multiple times and for\n\t  // different reasons. We have to keep popping until the work-in-progress is\n\t  // no longer at the top of the stack.\n\t  while (workInProgress === treeForkProvider) {\n\t    treeForkProvider = forkStack[--forkStackIndex];\n\t    forkStack[forkStackIndex] = null;\n\t    treeForkCount = forkStack[--forkStackIndex];\n\t    forkStack[forkStackIndex] = null;\n\t  }\n\n\t  while (workInProgress === treeContextProvider) {\n\t    treeContextProvider = idStack[--idStackIndex];\n\t    idStack[idStackIndex] = null;\n\t    treeContextOverflow = idStack[--idStackIndex];\n\t    idStack[idStackIndex] = null;\n\t    treeContextId = idStack[--idStackIndex];\n\t    idStack[idStackIndex] = null;\n\t  }\n\t}\n\tfunction getSuspendedTreeContext() {\n\t  warnIfNotHydrating();\n\n\t  if (treeContextProvider !== null) {\n\t    return {\n\t      id: treeContextId,\n\t      overflow: treeContextOverflow\n\t    };\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\tfunction restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n\t  warnIfNotHydrating();\n\t  idStack[idStackIndex++] = treeContextId;\n\t  idStack[idStackIndex++] = treeContextOverflow;\n\t  idStack[idStackIndex++] = treeContextProvider;\n\t  treeContextId = suspendedContext.id;\n\t  treeContextOverflow = suspendedContext.overflow;\n\t  treeContextProvider = workInProgress;\n\t}\n\n\tfunction warnIfNotHydrating() {\n\t  {\n\t    if (!getIsHydrating()) {\n\t      error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n\t    }\n\t  }\n\t}\n\n\t// This may have been an insertion or a hydration.\n\n\tvar hydrationParentFiber = null;\n\tvar nextHydratableInstance = null;\n\tvar isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n\t// due to earlier mismatches or a suspended fiber.\n\n\tvar didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary\n\n\tvar hydrationErrors = null;\n\n\tfunction warnIfHydrating() {\n\t  {\n\t    if (isHydrating) {\n\t      error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n\t    }\n\t  }\n\t}\n\n\tfunction markDidThrowWhileHydratingDEV() {\n\t  {\n\t    didSuspendOrErrorDEV = true;\n\t  }\n\t}\n\tfunction didSuspendOrErrorWhileHydratingDEV() {\n\t  {\n\t    return didSuspendOrErrorDEV;\n\t  }\n\t}\n\n\tfunction enterHydrationState(fiber) {\n\t  if (!supportsHydration) {\n\t    return false;\n\t  }\n\n\t  var parentInstance = fiber.stateNode.containerInfo;\n\t  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n\t  hydrationParentFiber = fiber;\n\t  isHydrating = true;\n\t  hydrationErrors = null;\n\t  didSuspendOrErrorDEV = false;\n\t  return true;\n\t}\n\n\tfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n\t  if (!supportsHydration) {\n\t    return false;\n\t  }\n\n\t  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n\t  hydrationParentFiber = fiber;\n\t  isHydrating = true;\n\t  hydrationErrors = null;\n\t  didSuspendOrErrorDEV = false;\n\n\t  if (treeContext !== null) {\n\t    restoreSuspendedTreeContext(fiber, treeContext);\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction warnUnhydratedInstance(returnFiber, instance) {\n\t  {\n\t    switch (returnFiber.tag) {\n\t      case HostRoot:\n\t        {\n\t          didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n\t          break;\n\t        }\n\n\t      case HostComponent:\n\t        {\n\t          var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\t          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, // TODO: Delete this argument when we remove the legacy root API.\n\t          isConcurrentMode);\n\t          break;\n\t        }\n\n\t      case SuspenseComponent:\n\t        {\n\t          var suspenseState = returnFiber.memoizedState;\n\t          if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n\t          break;\n\t        }\n\t    }\n\t  }\n\t}\n\n\tfunction deleteHydratableInstance(returnFiber, instance) {\n\t  warnUnhydratedInstance(returnFiber, instance);\n\t  var childToDelete = createFiberFromHostInstanceForDeletion();\n\t  childToDelete.stateNode = instance;\n\t  childToDelete.return = returnFiber;\n\t  var deletions = returnFiber.deletions;\n\n\t  if (deletions === null) {\n\t    returnFiber.deletions = [childToDelete];\n\t    returnFiber.flags |= ChildDeletion;\n\t  } else {\n\t    deletions.push(childToDelete);\n\t  }\n\t}\n\n\tfunction warnNonhydratedInstance(returnFiber, fiber) {\n\t  {\n\t    if (didSuspendOrErrorDEV) {\n\t      // Inside a boundary that already suspended. We're currently rendering the\n\t      // siblings of a suspended node. The mismatch may be due to the missing\n\t      // data, so it's probably a false positive.\n\t      return;\n\t    }\n\n\t    switch (returnFiber.tag) {\n\t      case HostRoot:\n\t        {\n\t          var parentContainer = returnFiber.stateNode.containerInfo;\n\n\t          switch (fiber.tag) {\n\t            case HostComponent:\n\t              var type = fiber.type;\n\t              var props = fiber.pendingProps;\n\t              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n\t              break;\n\n\t            case HostText:\n\t              var text = fiber.pendingProps;\n\t              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n\t              break;\n\n\t            case SuspenseComponent:\n\t              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n\t              break;\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostComponent:\n\t        {\n\t          var parentType = returnFiber.type;\n\t          var parentProps = returnFiber.memoizedProps;\n\t          var parentInstance = returnFiber.stateNode;\n\n\t          switch (fiber.tag) {\n\t            case HostComponent:\n\t              {\n\t                var _type = fiber.type;\n\t                var _props = fiber.pendingProps;\n\t                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\t                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, // TODO: Delete this argument when we remove the legacy root API.\n\t                isConcurrentMode);\n\t                break;\n\t              }\n\n\t            case HostText:\n\t              {\n\t                var _text = fiber.pendingProps;\n\n\t                var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n\t                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, // TODO: Delete this argument when we remove the legacy root API.\n\t                _isConcurrentMode);\n\t                break;\n\t              }\n\n\t            case SuspenseComponent:\n\t              {\n\t                didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n\t                break;\n\t              }\n\t          }\n\n\t          break;\n\t        }\n\n\t      case SuspenseComponent:\n\t        {\n\t          var suspenseState = returnFiber.memoizedState;\n\t          var _parentInstance = suspenseState.dehydrated;\n\t          if (_parentInstance !== null) switch (fiber.tag) {\n\t            case HostComponent:\n\t              var _type2 = fiber.type;\n\t              var _props2 = fiber.pendingProps;\n\t              didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n\t              break;\n\n\t            case HostText:\n\t              var _text2 = fiber.pendingProps;\n\t              didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n\t              break;\n\n\t            case SuspenseComponent:\n\t              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n\t              break;\n\t          }\n\t          break;\n\t        }\n\n\t      default:\n\t        return;\n\t    }\n\t  }\n\t}\n\n\tfunction insertNonHydratedInstance(returnFiber, fiber) {\n\t  fiber.flags = fiber.flags & ~Hydrating | Placement;\n\t  warnNonhydratedInstance(returnFiber, fiber);\n\t}\n\n\tfunction tryHydrate(fiber, nextInstance) {\n\t  switch (fiber.tag) {\n\t    case HostComponent:\n\t      {\n\t        var type = fiber.type;\n\t        var props = fiber.pendingProps;\n\t        var instance = canHydrateInstance(nextInstance, type, props);\n\n\t        if (instance !== null) {\n\t          fiber.stateNode = instance;\n\t          hydrationParentFiber = fiber;\n\t          nextHydratableInstance = getFirstHydratableChild(instance);\n\t          return true;\n\t        }\n\n\t        return false;\n\t      }\n\n\t    case HostText:\n\t      {\n\t        var text = fiber.pendingProps;\n\t        var textInstance = canHydrateTextInstance(nextInstance, text);\n\n\t        if (textInstance !== null) {\n\t          fiber.stateNode = textInstance;\n\t          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n\t          nextHydratableInstance = null;\n\t          return true;\n\t        }\n\n\t        return false;\n\t      }\n\n\t    case SuspenseComponent:\n\t      {\n\t        var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n\t        if (suspenseInstance !== null) {\n\t          var suspenseState = {\n\t            dehydrated: suspenseInstance,\n\t            treeContext: getSuspendedTreeContext(),\n\t            retryLane: OffscreenLane\n\t          };\n\t          fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n\t          // This simplifies the code for getHostSibling and deleting nodes,\n\t          // since it doesn't have to consider all Suspense boundaries and\n\t          // check if they're dehydrated ones or not.\n\n\t          var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n\t          dehydratedFragment.return = fiber;\n\t          fiber.child = dehydratedFragment;\n\t          hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n\t          // it during the first pass. Instead, we'll reenter it later.\n\n\t          nextHydratableInstance = null;\n\t          return true;\n\t        }\n\n\t        return false;\n\t      }\n\n\t    default:\n\t      return false;\n\t  }\n\t}\n\n\tfunction shouldClientRenderOnMismatch(fiber) {\n\t  return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n\t}\n\n\tfunction throwOnHydrationMismatch(fiber) {\n\t  throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');\n\t}\n\n\tfunction tryToClaimNextHydratableInstance(fiber) {\n\t  if (!isHydrating) {\n\t    return;\n\t  }\n\n\t  var nextInstance = nextHydratableInstance;\n\n\t  if (!nextInstance) {\n\t    if (shouldClientRenderOnMismatch(fiber)) {\n\t      warnNonhydratedInstance(hydrationParentFiber, fiber);\n\t      throwOnHydrationMismatch();\n\t    } // Nothing to hydrate. Make it an insertion.\n\n\n\t    insertNonHydratedInstance(hydrationParentFiber, fiber);\n\t    isHydrating = false;\n\t    hydrationParentFiber = fiber;\n\t    return;\n\t  }\n\n\t  var firstAttemptedInstance = nextInstance;\n\n\t  if (!tryHydrate(fiber, nextInstance)) {\n\t    if (shouldClientRenderOnMismatch(fiber)) {\n\t      warnNonhydratedInstance(hydrationParentFiber, fiber);\n\t      throwOnHydrationMismatch();\n\t    } // If we can't hydrate this instance let's try the next one.\n\t    // We use this as a heuristic. It's based on intuition and not data so it\n\t    // might be flawed or unnecessary.\n\n\n\t    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n\t    var prevHydrationParentFiber = hydrationParentFiber;\n\n\t    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n\t      // Nothing to hydrate. Make it an insertion.\n\t      insertNonHydratedInstance(hydrationParentFiber, fiber);\n\t      isHydrating = false;\n\t      hydrationParentFiber = fiber;\n\t      return;\n\t    } // We matched the next one, we'll now assume that the first one was\n\t    // superfluous and we'll delete it. Since we can't eagerly delete it\n\t    // we'll have to schedule a deletion. To do that, this node needs a dummy\n\t    // fiber associated with it.\n\n\n\t    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n\t  }\n\t}\n\n\tfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n\t  if (!supportsHydration) {\n\t    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\n\t  var instance = fiber.stateNode;\n\t  var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n\t  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n\n\t  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n\t  // is a new ref we mark this as an update.\n\n\t  if (updatePayload !== null) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t}\n\n\tfunction prepareToHydrateHostTextInstance(fiber) {\n\t  if (!supportsHydration) {\n\t    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\n\t  var textInstance = fiber.stateNode;\n\t  var textContent = fiber.memoizedProps;\n\t  var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n\t  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n\n\t  if (shouldUpdate) {\n\t    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n\t    // hydration parent is the parent host component of this host text.\n\t    var returnFiber = hydrationParentFiber;\n\n\t    if (returnFiber !== null) {\n\t      switch (returnFiber.tag) {\n\t        case HostRoot:\n\t          {\n\t            var parentContainer = returnFiber.stateNode.containerInfo;\n\t            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\t            didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n\t            isConcurrentMode);\n\t            break;\n\t          }\n\n\t        case HostComponent:\n\t          {\n\t            var parentType = returnFiber.type;\n\t            var parentProps = returnFiber.memoizedProps;\n\t            var parentInstance = returnFiber.stateNode;\n\n\t            var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n\t            didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n\t            _isConcurrentMode2);\n\t            break;\n\t          }\n\t      }\n\t    }\n\t  }\n\n\t  return shouldUpdate;\n\t}\n\n\tfunction prepareToHydrateHostSuspenseInstance(fiber) {\n\t  if (!supportsHydration) {\n\t    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\n\t  var suspenseState = fiber.memoizedState;\n\t  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n\t  if (!suspenseInstance) {\n\t    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\n\t  hydrateSuspenseInstance(suspenseInstance, fiber);\n\t}\n\n\tfunction skipPastDehydratedSuspenseInstance(fiber) {\n\t  if (!supportsHydration) {\n\t    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\n\t  var suspenseState = fiber.memoizedState;\n\t  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n\t  if (!suspenseInstance) {\n\t    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t  }\n\n\t  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n\t}\n\n\tfunction popToNextHostParent(fiber) {\n\t  var parent = fiber.return;\n\n\t  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n\t    parent = parent.return;\n\t  }\n\n\t  hydrationParentFiber = parent;\n\t}\n\n\tfunction popHydrationState(fiber) {\n\t  if (!supportsHydration) {\n\t    return false;\n\t  }\n\n\t  if (fiber !== hydrationParentFiber) {\n\t    // We're deeper than the current hydration context, inside an inserted\n\t    // tree.\n\t    return false;\n\t  }\n\n\t  if (!isHydrating) {\n\t    // If we're not currently hydrating but we're in a hydration context, then\n\t    // we were an insertion and now need to pop up reenter hydration of our\n\t    // siblings.\n\t    popToNextHostParent(fiber);\n\t    isHydrating = true;\n\t    return false;\n\t  } // If we have any remaining hydratable nodes, we need to delete them now.\n\t  // We only do this deeper than head and body since they tend to have random\n\t  // other nodes in them. We also ignore components with pure text content in\n\t  // side of them. We also don't delete anything inside the root container.\n\n\n\t  if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n\t    var nextInstance = nextHydratableInstance;\n\n\t    if (nextInstance) {\n\t      if (shouldClientRenderOnMismatch(fiber)) {\n\t        warnIfUnhydratedTailNodes(fiber);\n\t        throwOnHydrationMismatch();\n\t      } else {\n\t        while (nextInstance) {\n\t          deleteHydratableInstance(fiber, nextInstance);\n\t          nextInstance = getNextHydratableSibling(nextInstance);\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  popToNextHostParent(fiber);\n\n\t  if (fiber.tag === SuspenseComponent) {\n\t    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n\t  } else {\n\t    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction hasUnhydratedTailNodes() {\n\t  return isHydrating && nextHydratableInstance !== null;\n\t}\n\n\tfunction warnIfUnhydratedTailNodes(fiber) {\n\t  var nextInstance = nextHydratableInstance;\n\n\t  while (nextInstance) {\n\t    warnUnhydratedInstance(fiber, nextInstance);\n\t    nextInstance = getNextHydratableSibling(nextInstance);\n\t  }\n\t}\n\n\tfunction resetHydrationState() {\n\t  if (!supportsHydration) {\n\t    return;\n\t  }\n\n\t  hydrationParentFiber = null;\n\t  nextHydratableInstance = null;\n\t  isHydrating = false;\n\t  didSuspendOrErrorDEV = false;\n\t}\n\n\tfunction upgradeHydrationErrorsToRecoverable() {\n\t  if (hydrationErrors !== null) {\n\t    // Successfully completed a forced client render. The errors that occurred\n\t    // during the hydration attempt are now recovered. We will log them in\n\t    // commit phase, once the entire tree has finished.\n\t    queueRecoverableErrors(hydrationErrors);\n\t    hydrationErrors = null;\n\t  }\n\t}\n\n\tfunction getIsHydrating() {\n\t  return isHydrating;\n\t}\n\n\tfunction queueHydrationError(error) {\n\t  if (hydrationErrors === null) {\n\t    hydrationErrors = [error];\n\t  } else {\n\t    hydrationErrors.push(error);\n\t  }\n\t}\n\n\tvar ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n\tvar NoTransition = null;\n\tfunction requestCurrentTransition() {\n\t  return ReactCurrentBatchConfig.transition;\n\t}\n\n\t/**\n\t * Performs equality by iterating through keys on an object and returning false\n\t * when any key has values which are not strictly equal between the arguments.\n\t * Returns true when the values of all keys are strictly equal.\n\t */\n\n\tfunction shallowEqual(objA, objB) {\n\t  if (objectIs(objA, objB)) {\n\t    return true;\n\t  }\n\n\t  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n\t    return false;\n\t  }\n\n\t  var keysA = Object.keys(objA);\n\t  var keysB = Object.keys(objB);\n\n\t  if (keysA.length !== keysB.length) {\n\t    return false;\n\t  } // Test for A's keys different from B.\n\n\n\t  for (var i = 0; i < keysA.length; i++) {\n\t    var currentKey = keysA[i];\n\n\t    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction describeFiber(fiber) {\n\t  fiber._debugOwner ? fiber._debugOwner.type : null ;\n\t  fiber._debugSource ;\n\n\t  switch (fiber.tag) {\n\t    case HostComponent:\n\t      return describeBuiltInComponentFrame(fiber.type);\n\n\t    case LazyComponent:\n\t      return describeBuiltInComponentFrame('Lazy');\n\n\t    case SuspenseComponent:\n\t      return describeBuiltInComponentFrame('Suspense');\n\n\t    case SuspenseListComponent:\n\t      return describeBuiltInComponentFrame('SuspenseList');\n\n\t    case FunctionComponent:\n\t    case IndeterminateComponent:\n\t    case SimpleMemoComponent:\n\t      return describeFunctionComponentFrame(fiber.type);\n\n\t    case ForwardRef:\n\t      return describeFunctionComponentFrame(fiber.type.render);\n\n\t    case ClassComponent:\n\t      return describeClassComponentFrame(fiber.type);\n\n\t    default:\n\t      return '';\n\t  }\n\t}\n\n\tfunction getStackByFiberInDevAndProd(workInProgress) {\n\t  try {\n\t    var info = '';\n\t    var node = workInProgress;\n\n\t    do {\n\t      info += describeFiber(node);\n\t      node = node.return;\n\t    } while (node);\n\n\t    return info;\n\t  } catch (x) {\n\t    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n\t  }\n\t}\n\n\tvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\tvar current = null;\n\tvar isRendering = false;\n\tfunction getCurrentFiberOwnerNameInDevOrNull() {\n\t  {\n\t    if (current === null) {\n\t      return null;\n\t    }\n\n\t    var owner = current._debugOwner;\n\n\t    if (owner !== null && typeof owner !== 'undefined') {\n\t      return getComponentNameFromFiber(owner);\n\t    }\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction getCurrentFiberStackInDev() {\n\t  {\n\t    if (current === null) {\n\t      return '';\n\t    } // Safe because if current fiber exists, we are reconciling,\n\t    // and it is guaranteed to be the work-in-progress version.\n\n\n\t    return getStackByFiberInDevAndProd(current);\n\t  }\n\t}\n\n\tfunction resetCurrentFiber() {\n\t  {\n\t    ReactDebugCurrentFrame$1.getCurrentStack = null;\n\t    current = null;\n\t    isRendering = false;\n\t  }\n\t}\n\tfunction setCurrentFiber(fiber) {\n\t  {\n\t    ReactDebugCurrentFrame$1.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n\t    current = fiber;\n\t    isRendering = false;\n\t  }\n\t}\n\tfunction getCurrentFiber() {\n\t  {\n\t    return current;\n\t  }\n\t}\n\tfunction setIsRendering(rendering) {\n\t  {\n\t    isRendering = rendering;\n\t  }\n\t}\n\n\tvar ReactStrictModeWarnings = {\n\t  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n\t  flushPendingUnsafeLifecycleWarnings: function () {},\n\t  recordLegacyContextWarning: function (fiber, instance) {},\n\t  flushLegacyContextWarning: function () {},\n\t  discardPendingWarnings: function () {}\n\t};\n\n\t{\n\t  var findStrictRoot = function (fiber) {\n\t    var maybeStrictRoot = null;\n\t    var node = fiber;\n\n\t    while (node !== null) {\n\t      if (node.mode & StrictLegacyMode) {\n\t        maybeStrictRoot = node;\n\t      }\n\n\t      node = node.return;\n\t    }\n\n\t    return maybeStrictRoot;\n\t  };\n\n\t  var setToSortedString = function (set) {\n\t    var array = [];\n\t    set.forEach(function (value) {\n\t      array.push(value);\n\t    });\n\t    return array.sort().join(', ');\n\t  };\n\n\t  var pendingComponentWillMountWarnings = [];\n\t  var pendingUNSAFE_ComponentWillMountWarnings = [];\n\t  var pendingComponentWillReceivePropsWarnings = [];\n\t  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n\t  var pendingComponentWillUpdateWarnings = [];\n\t  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n\n\t  var didWarnAboutUnsafeLifecycles = new Set();\n\n\t  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n\t    // Dedupe strategy: Warn once per component.\n\t    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n\t      return;\n\t    }\n\n\t    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n\t    instance.componentWillMount.__suppressDeprecationWarning !== true) {\n\t      pendingComponentWillMountWarnings.push(fiber);\n\t    }\n\n\t    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n\t      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n\t    }\n\n\t    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n\t      pendingComponentWillReceivePropsWarnings.push(fiber);\n\t    }\n\n\t    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n\t      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n\t    }\n\n\t    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n\t      pendingComponentWillUpdateWarnings.push(fiber);\n\t    }\n\n\t    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n\t      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n\t    }\n\t  };\n\n\t  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n\t    // We do an initial pass to gather component names\n\t    var componentWillMountUniqueNames = new Set();\n\n\t    if (pendingComponentWillMountWarnings.length > 0) {\n\t      pendingComponentWillMountWarnings.forEach(function (fiber) {\n\t        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutUnsafeLifecycles.add(fiber.type);\n\t      });\n\t      pendingComponentWillMountWarnings = [];\n\t    }\n\n\t    var UNSAFE_componentWillMountUniqueNames = new Set();\n\n\t    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n\t      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {\n\t        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutUnsafeLifecycles.add(fiber.type);\n\t      });\n\t      pendingUNSAFE_ComponentWillMountWarnings = [];\n\t    }\n\n\t    var componentWillReceivePropsUniqueNames = new Set();\n\n\t    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n\t      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n\t        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutUnsafeLifecycles.add(fiber.type);\n\t      });\n\t      pendingComponentWillReceivePropsWarnings = [];\n\t    }\n\n\t    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n\n\t    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n\t      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {\n\t        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutUnsafeLifecycles.add(fiber.type);\n\t      });\n\t      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n\t    }\n\n\t    var componentWillUpdateUniqueNames = new Set();\n\n\t    if (pendingComponentWillUpdateWarnings.length > 0) {\n\t      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n\t        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutUnsafeLifecycles.add(fiber.type);\n\t      });\n\t      pendingComponentWillUpdateWarnings = [];\n\t    }\n\n\t    var UNSAFE_componentWillUpdateUniqueNames = new Set();\n\n\t    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n\t      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {\n\t        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutUnsafeLifecycles.add(fiber.type);\n\t      });\n\t      pendingUNSAFE_ComponentWillUpdateWarnings = [];\n\t    } // Finally, we flush all the warnings\n\t    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n\n\n\t    if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n\t      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n\n\t      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n\t    }\n\n\t    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n\t      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n\n\t      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n\t    }\n\n\t    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n\t      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n\n\t      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n\t    }\n\n\t    if (componentWillMountUniqueNames.size > 0) {\n\t      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n\n\t      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n\t    }\n\n\t    if (componentWillReceivePropsUniqueNames.size > 0) {\n\t      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n\n\t      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n\t    }\n\n\t    if (componentWillUpdateUniqueNames.size > 0) {\n\t      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n\n\t      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n\t    }\n\t  };\n\n\t  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n\n\t  var didWarnAboutLegacyContext = new Set();\n\n\t  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n\t    var strictRoot = findStrictRoot(fiber);\n\n\t    if (strictRoot === null) {\n\t      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\n\t      return;\n\t    } // Dedup strategy: Warn once per component.\n\n\n\t    if (didWarnAboutLegacyContext.has(fiber.type)) {\n\t      return;\n\t    }\n\n\t    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n\t    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n\t      if (warningsForRoot === undefined) {\n\t        warningsForRoot = [];\n\t        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n\t      }\n\n\t      warningsForRoot.push(fiber);\n\t    }\n\t  };\n\n\t  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n\t    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n\t      if (fiberArray.length === 0) {\n\t        return;\n\t      }\n\n\t      var firstFiber = fiberArray[0];\n\t      var uniqueNames = new Set();\n\t      fiberArray.forEach(function (fiber) {\n\t        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n\t        didWarnAboutLegacyContext.add(fiber.type);\n\t      });\n\t      var sortedNames = setToSortedString(uniqueNames);\n\n\t      try {\n\t        setCurrentFiber(firstFiber);\n\n\t        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);\n\t      } finally {\n\t        resetCurrentFiber();\n\t      }\n\t    });\n\t  };\n\n\t  ReactStrictModeWarnings.discardPendingWarnings = function () {\n\t    pendingComponentWillMountWarnings = [];\n\t    pendingUNSAFE_ComponentWillMountWarnings = [];\n\t    pendingComponentWillReceivePropsWarnings = [];\n\t    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n\t    pendingComponentWillUpdateWarnings = [];\n\t    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n\t    pendingLegacyContextWarning = new Map();\n\t  };\n\t}\n\n\t/*\n\t * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n\t * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n\t *\n\t * The functions in this module will throw an easier-to-understand,\n\t * easier-to-debug exception with a clear errors message message explaining the\n\t * problem. (Instead of a confusing exception thrown inside the implementation\n\t * of the `value` object).\n\t */\n\t// $FlowFixMe only called in DEV, so void return is not possible.\n\tfunction typeName(value) {\n\t  {\n\t    // toStringTag is needed for namespaced types like Temporal.Instant\n\t    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n\t    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n\t    return type;\n\t  }\n\t} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n\tfunction willCoercionThrow(value) {\n\t  {\n\t    try {\n\t      testStringCoercion(value);\n\t      return false;\n\t    } catch (e) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\n\tfunction testStringCoercion(value) {\n\t  // If you ended up here by following an exception call stack, here's what's\n\t  // happened: you supplied an object or symbol value to React (as a prop, key,\n\t  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n\t  // coerce it to a string using `'' + value`, an exception was thrown.\n\t  //\n\t  // The most common types that will cause this exception are `Symbol` instances\n\t  // and Temporal objects like `Temporal.Instant`. But any object that has a\n\t  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n\t  // exception. (Library authors do this to prevent users from using built-in\n\t  // numeric operators like `+` or comparison operators like `>=` because custom\n\t  // methods are needed to perform accurate arithmetic or comparison.)\n\t  //\n\t  // To fix the problem, coerce this object or symbol value to a string before\n\t  // passing it to React. The most reliable way is usually `String(value)`.\n\t  //\n\t  // To find which value is throwing, check the browser or debugger console.\n\t  // Before this exception was thrown, there should be `console.error` output\n\t  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n\t  // problem and how that type was used: key, atrribute, input value prop, etc.\n\t  // In most cases, this console output also shows the component and its\n\t  // ancestor components where the exception happened.\n\t  //\n\t  // eslint-disable-next-line react-internal/safe-string-coercion\n\t  return '' + value;\n\t}\n\tfunction checkKeyStringCoercion(value) {\n\t  {\n\t    if (willCoercionThrow(value)) {\n\t      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n\t      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n\t    }\n\t  }\n\t}\n\tfunction checkPropStringCoercion(value, propName) {\n\t  {\n\t    if (willCoercionThrow(value)) {\n\t      error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));\n\n\t      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n\t    }\n\t  }\n\t}\n\n\tfunction resolveDefaultProps(Component, baseProps) {\n\t  if (Component && Component.defaultProps) {\n\t    // Resolve default props. Taken from ReactElement\n\t    var props = assign({}, baseProps);\n\t    var defaultProps = Component.defaultProps;\n\n\t    for (var propName in defaultProps) {\n\t      if (props[propName] === undefined) {\n\t        props[propName] = defaultProps[propName];\n\t      }\n\t    }\n\n\t    return props;\n\t  }\n\n\t  return baseProps;\n\t}\n\n\tvar valueCursor = createCursor(null);\n\tvar rendererSigil;\n\n\t{\n\t  // Use this to detect multiple renderers using the same context\n\t  rendererSigil = {};\n\t}\n\n\tvar currentlyRenderingFiber = null;\n\tvar lastContextDependency = null;\n\tvar lastFullyObservedContext = null;\n\tvar isDisallowedContextReadInDEV = false;\n\tfunction resetContextDependencies() {\n\t  // This is called right before React yields execution, to ensure `readContext`\n\t  // cannot be called outside the render phase.\n\t  currentlyRenderingFiber = null;\n\t  lastContextDependency = null;\n\t  lastFullyObservedContext = null;\n\n\t  {\n\t    isDisallowedContextReadInDEV = false;\n\t  }\n\t}\n\tfunction enterDisallowedContextReadInDEV() {\n\t  {\n\t    isDisallowedContextReadInDEV = true;\n\t  }\n\t}\n\tfunction exitDisallowedContextReadInDEV() {\n\t  {\n\t    isDisallowedContextReadInDEV = false;\n\t  }\n\t}\n\tfunction pushProvider(providerFiber, context, nextValue) {\n\t  if (isPrimaryRenderer) {\n\t    push(valueCursor, context._currentValue, providerFiber);\n\t    context._currentValue = nextValue;\n\n\t    {\n\t      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n\t        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n\t      }\n\n\t      context._currentRenderer = rendererSigil;\n\t    }\n\t  } else {\n\t    push(valueCursor, context._currentValue2, providerFiber);\n\t    context._currentValue2 = nextValue;\n\n\t    {\n\t      if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n\t        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n\t      }\n\n\t      context._currentRenderer2 = rendererSigil;\n\t    }\n\t  }\n\t}\n\tfunction popProvider(context, providerFiber) {\n\t  var currentValue = valueCursor.current;\n\t  pop(valueCursor, providerFiber);\n\n\t  if (isPrimaryRenderer) {\n\t    {\n\t      context._currentValue = currentValue;\n\t    }\n\t  } else {\n\t    {\n\t      context._currentValue2 = currentValue;\n\t    }\n\t  }\n\t}\n\tfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n\t  // Update the child lanes of all the ancestors, including the alternates.\n\t  var node = parent;\n\n\t  while (node !== null) {\n\t    var alternate = node.alternate;\n\n\t    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n\t      node.childLanes = mergeLanes(node.childLanes, renderLanes);\n\n\t      if (alternate !== null) {\n\t        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n\t      }\n\t    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n\t      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n\t    }\n\n\t    if (node === propagationRoot) {\n\t      break;\n\t    }\n\n\t    node = node.return;\n\t  }\n\n\t  {\n\t    if (node !== propagationRoot) {\n\t      error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t    }\n\t  }\n\t}\n\tfunction propagateContextChange(workInProgress, context, renderLanes) {\n\t  {\n\t    propagateContextChange_eager(workInProgress, context, renderLanes);\n\t  }\n\t}\n\n\tfunction propagateContextChange_eager(workInProgress, context, renderLanes) {\n\n\t  var fiber = workInProgress.child;\n\n\t  if (fiber !== null) {\n\t    // Set the return pointer of the child to the work-in-progress fiber.\n\t    fiber.return = workInProgress;\n\t  }\n\n\t  while (fiber !== null) {\n\t    var nextFiber = void 0; // Visit this fiber.\n\n\t    var list = fiber.dependencies;\n\n\t    if (list !== null) {\n\t      nextFiber = fiber.child;\n\t      var dependency = list.firstContext;\n\n\t      while (dependency !== null) {\n\t        // Check if the context matches.\n\t        if (dependency.context === context) {\n\t          // Match! Schedule an update on this fiber.\n\t          if (fiber.tag === ClassComponent) {\n\t            // Schedule a force update on the work-in-progress.\n\t            var lane = pickArbitraryLane(renderLanes);\n\t            var update = createUpdate(NoTimestamp, lane);\n\t            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n\t            // update to the current fiber, too, which means it will persist even if\n\t            // this render is thrown away. Since it's a race condition, not sure it's\n\t            // worth fixing.\n\t            // Inlined `enqueueUpdate` to remove interleaved update check\n\n\t            var updateQueue = fiber.updateQueue;\n\n\t            if (updateQueue === null) ; else {\n\t              var sharedQueue = updateQueue.shared;\n\t              var pending = sharedQueue.pending;\n\n\t              if (pending === null) {\n\t                // This is the first update. Create a circular list.\n\t                update.next = update;\n\t              } else {\n\t                update.next = pending.next;\n\t                pending.next = update;\n\t              }\n\n\t              sharedQueue.pending = update;\n\t            }\n\t          }\n\n\t          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n\t          var alternate = fiber.alternate;\n\n\t          if (alternate !== null) {\n\t            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n\t          }\n\n\t          scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n\n\t          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n\t          // dependency list.\n\n\t          break;\n\t        }\n\n\t        dependency = dependency.next;\n\t      }\n\t    } else if (fiber.tag === ContextProvider) {\n\t      // Don't scan deeper if this is a matching provider\n\t      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n\t    } else if (fiber.tag === DehydratedFragment) {\n\t      // If a dehydrated suspense boundary is in this subtree, we don't know\n\t      // if it will have any context consumers in it. The best we can do is\n\t      // mark it as having updates.\n\t      var parentSuspense = fiber.return;\n\n\t      if (parentSuspense === null) {\n\t        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n\t      }\n\n\t      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n\t      var _alternate = parentSuspense.alternate;\n\n\t      if (_alternate !== null) {\n\t        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n\t      } // This is intentionally passing this fiber as the parent\n\t      // because we want to schedule this fiber as having work\n\t      // on its children. We'll use the childLanes on\n\t      // this fiber to indicate that a context has changed.\n\n\n\t      scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n\t      nextFiber = fiber.sibling;\n\t    } else {\n\t      // Traverse down.\n\t      nextFiber = fiber.child;\n\t    }\n\n\t    if (nextFiber !== null) {\n\t      // Set the return pointer of the child to the work-in-progress fiber.\n\t      nextFiber.return = fiber;\n\t    } else {\n\t      // No child. Traverse to next sibling.\n\t      nextFiber = fiber;\n\n\t      while (nextFiber !== null) {\n\t        if (nextFiber === workInProgress) {\n\t          // We're back to the root of this subtree. Exit.\n\t          nextFiber = null;\n\t          break;\n\t        }\n\n\t        var sibling = nextFiber.sibling;\n\n\t        if (sibling !== null) {\n\t          // Set the return pointer of the sibling to the work-in-progress fiber.\n\t          sibling.return = nextFiber.return;\n\t          nextFiber = sibling;\n\t          break;\n\t        } // No more siblings. Traverse up.\n\n\n\t        nextFiber = nextFiber.return;\n\t      }\n\t    }\n\n\t    fiber = nextFiber;\n\t  }\n\t}\n\tfunction prepareToReadContext(workInProgress, renderLanes) {\n\t  currentlyRenderingFiber = workInProgress;\n\t  lastContextDependency = null;\n\t  lastFullyObservedContext = null;\n\t  var dependencies = workInProgress.dependencies;\n\n\t  if (dependencies !== null) {\n\t    {\n\t      var firstContext = dependencies.firstContext;\n\n\t      if (firstContext !== null) {\n\t        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n\t          // Context list has a pending update. Mark that this fiber performed work.\n\t          markWorkInProgressReceivedUpdate();\n\t        } // Reset the work-in-progress list\n\n\n\t        dependencies.firstContext = null;\n\t      }\n\t    }\n\t  }\n\t}\n\tfunction readContext(context) {\n\t  {\n\t    // This warning would fire if you read context inside a Hook like useMemo.\n\t    // Unlike the class check below, it's not enforced in production for perf.\n\t    if (isDisallowedContextReadInDEV) {\n\t      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n\t    }\n\t  }\n\n\t  var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n\n\t  if (lastFullyObservedContext === context) ; else {\n\t    var contextItem = {\n\t      context: context,\n\t      memoizedValue: value,\n\t      next: null\n\t    };\n\n\t    if (lastContextDependency === null) {\n\t      if (currentlyRenderingFiber === null) {\n\t        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n\t      } // This is the first dependency for this component. Create a new list.\n\n\n\t      lastContextDependency = contextItem;\n\t      currentlyRenderingFiber.dependencies = {\n\t        lanes: NoLanes,\n\t        firstContext: contextItem\n\t      };\n\t    } else {\n\t      // Append a new context item.\n\t      lastContextDependency = lastContextDependency.next = contextItem;\n\t    }\n\t  }\n\n\t  return value;\n\t}\n\n\t// render. When this render exits, either because it finishes or because it is\n\t// interrupted, the interleaved updates will be transferred onto the main part\n\t// of the queue.\n\n\tvar concurrentQueues = null;\n\tfunction pushConcurrentUpdateQueue(queue) {\n\t  if (concurrentQueues === null) {\n\t    concurrentQueues = [queue];\n\t  } else {\n\t    concurrentQueues.push(queue);\n\t  }\n\t}\n\tfunction finishQueueingConcurrentUpdates() {\n\t  // Transfer the interleaved updates onto the main queue. Each queue has a\n\t  // `pending` field and an `interleaved` field. When they are not null, they\n\t  // point to the last node in a circular linked list. We need to append the\n\t  // interleaved list to the end of the pending list by joining them into a\n\t  // single, circular list.\n\t  if (concurrentQueues !== null) {\n\t    for (var i = 0; i < concurrentQueues.length; i++) {\n\t      var queue = concurrentQueues[i];\n\t      var lastInterleavedUpdate = queue.interleaved;\n\n\t      if (lastInterleavedUpdate !== null) {\n\t        queue.interleaved = null;\n\t        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n\t        var lastPendingUpdate = queue.pending;\n\n\t        if (lastPendingUpdate !== null) {\n\t          var firstPendingUpdate = lastPendingUpdate.next;\n\t          lastPendingUpdate.next = firstInterleavedUpdate;\n\t          lastInterleavedUpdate.next = firstPendingUpdate;\n\t        }\n\n\t        queue.pending = lastInterleavedUpdate;\n\t      }\n\t    }\n\n\t    concurrentQueues = null;\n\t  }\n\t}\n\tfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n\t  var interleaved = queue.interleaved;\n\n\t  if (interleaved === null) {\n\t    // This is the first update. Create a circular list.\n\t    update.next = update; // At the end of the current render, this queue's interleaved updates will\n\t    // be transferred to the pending queue.\n\n\t    pushConcurrentUpdateQueue(queue);\n\t  } else {\n\t    update.next = interleaved.next;\n\t    interleaved.next = update;\n\t  }\n\n\t  queue.interleaved = update;\n\t  return markUpdateLaneFromFiberToRoot(fiber, lane);\n\t}\n\tfunction enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {\n\t  var interleaved = queue.interleaved;\n\n\t  if (interleaved === null) {\n\t    // This is the first update. Create a circular list.\n\t    update.next = update; // At the end of the current render, this queue's interleaved updates will\n\t    // be transferred to the pending queue.\n\n\t    pushConcurrentUpdateQueue(queue);\n\t  } else {\n\t    update.next = interleaved.next;\n\t    interleaved.next = update;\n\t  }\n\n\t  queue.interleaved = update;\n\t}\n\tfunction enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n\t  var interleaved = queue.interleaved;\n\n\t  if (interleaved === null) {\n\t    // This is the first update. Create a circular list.\n\t    update.next = update; // At the end of the current render, this queue's interleaved updates will\n\t    // be transferred to the pending queue.\n\n\t    pushConcurrentUpdateQueue(queue);\n\t  } else {\n\t    update.next = interleaved.next;\n\t    interleaved.next = update;\n\t  }\n\n\t  queue.interleaved = update;\n\t  return markUpdateLaneFromFiberToRoot(fiber, lane);\n\t}\n\tfunction enqueueConcurrentRenderForLane(fiber, lane) {\n\t  return markUpdateLaneFromFiberToRoot(fiber, lane);\n\t} // Calling this function outside this module should only be done for backwards\n\t// compatibility and should always be accompanied by a warning.\n\n\tvar unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;\n\n\tfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n\t  // Update the source fiber's lanes\n\t  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n\t  var alternate = sourceFiber.alternate;\n\n\t  if (alternate !== null) {\n\t    alternate.lanes = mergeLanes(alternate.lanes, lane);\n\t  }\n\n\t  {\n\t    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n\t      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n\t    }\n\t  } // Walk the parent path to the root and update the child lanes.\n\n\n\t  var node = sourceFiber;\n\t  var parent = sourceFiber.return;\n\n\t  while (parent !== null) {\n\t    parent.childLanes = mergeLanes(parent.childLanes, lane);\n\t    alternate = parent.alternate;\n\n\t    if (alternate !== null) {\n\t      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n\t    } else {\n\t      {\n\t        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n\t          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n\t        }\n\t      }\n\t    }\n\n\t    node = parent;\n\t    parent = parent.return;\n\t  }\n\n\t  if (node.tag === HostRoot) {\n\t    var root = node.stateNode;\n\t    return root;\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\n\tvar UpdateState = 0;\n\tvar ReplaceState = 1;\n\tvar ForceUpdate = 2;\n\tvar CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n\t// It should only be read right after calling `processUpdateQueue`, via\n\t// `checkHasForceUpdateAfterProcessing`.\n\n\tvar hasForceUpdate = false;\n\tvar didWarnUpdateInsideUpdate;\n\tvar currentlyProcessingQueue;\n\n\t{\n\t  didWarnUpdateInsideUpdate = false;\n\t  currentlyProcessingQueue = null;\n\t}\n\n\tfunction initializeUpdateQueue(fiber) {\n\t  var queue = {\n\t    baseState: fiber.memoizedState,\n\t    firstBaseUpdate: null,\n\t    lastBaseUpdate: null,\n\t    shared: {\n\t      pending: null,\n\t      interleaved: null,\n\t      lanes: NoLanes\n\t    },\n\t    effects: null\n\t  };\n\t  fiber.updateQueue = queue;\n\t}\n\tfunction cloneUpdateQueue(current, workInProgress) {\n\t  // Clone the update queue from current. Unless it's already a clone.\n\t  var queue = workInProgress.updateQueue;\n\t  var currentQueue = current.updateQueue;\n\n\t  if (queue === currentQueue) {\n\t    var clone = {\n\t      baseState: currentQueue.baseState,\n\t      firstBaseUpdate: currentQueue.firstBaseUpdate,\n\t      lastBaseUpdate: currentQueue.lastBaseUpdate,\n\t      shared: currentQueue.shared,\n\t      effects: currentQueue.effects\n\t    };\n\t    workInProgress.updateQueue = clone;\n\t  }\n\t}\n\tfunction createUpdate(eventTime, lane) {\n\t  var update = {\n\t    eventTime: eventTime,\n\t    lane: lane,\n\t    tag: UpdateState,\n\t    payload: null,\n\t    callback: null,\n\t    next: null\n\t  };\n\t  return update;\n\t}\n\tfunction enqueueUpdate(fiber, update, lane) {\n\t  var updateQueue = fiber.updateQueue;\n\n\t  if (updateQueue === null) {\n\t    // Only occurs if the fiber has been unmounted.\n\t    return null;\n\t  }\n\n\t  var sharedQueue = updateQueue.shared;\n\n\t  {\n\t    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n\t      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n\n\t      didWarnUpdateInsideUpdate = true;\n\t    }\n\t  }\n\n\t  if (isUnsafeClassRenderPhaseUpdate()) {\n\t    // This is an unsafe render phase update. Add directly to the update\n\t    // queue so we can process it immediately during the current render.\n\t    var pending = sharedQueue.pending;\n\n\t    if (pending === null) {\n\t      // This is the first update. Create a circular list.\n\t      update.next = update;\n\t    } else {\n\t      update.next = pending.next;\n\t      pending.next = update;\n\t    }\n\n\t    sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n\t    // this fiber. This is for backwards compatibility in the case where you\n\t    // update a different component during render phase than the one that is\n\t    // currently renderings (a pattern that is accompanied by a warning).\n\n\t    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n\t  } else {\n\t    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n\t  }\n\t}\n\tfunction entangleTransitions(root, fiber, lane) {\n\t  var updateQueue = fiber.updateQueue;\n\n\t  if (updateQueue === null) {\n\t    // Only occurs if the fiber has been unmounted.\n\t    return;\n\t  }\n\n\t  var sharedQueue = updateQueue.shared;\n\n\t  if (isTransitionLane(lane)) {\n\t    var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n\t    // have finished. We can remove them from the shared queue, which represents\n\t    // a superset of the actually pending lanes. In some cases we may entangle\n\t    // more than we need to, but that's OK. In fact it's worse if we *don't*\n\t    // entangle when we should.\n\n\t    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n\t    var newQueueLanes = mergeLanes(queueLanes, lane);\n\t    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n\t    // the lane finished since the last time we entangled it. So we need to\n\t    // entangle it again, just to be sure.\n\n\t    markRootEntangled(root, newQueueLanes);\n\t  }\n\t}\n\tfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n\t  // Captured updates are updates that are thrown by a child during the render\n\t  // phase. They should be discarded if the render is aborted. Therefore,\n\t  // we should only put them on the work-in-progress queue, not the current one.\n\t  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n\t  var current = workInProgress.alternate;\n\n\t  if (current !== null) {\n\t    var currentQueue = current.updateQueue;\n\n\t    if (queue === currentQueue) {\n\t      // The work-in-progress queue is the same as current. This happens when\n\t      // we bail out on a parent fiber that then captures an error thrown by\n\t      // a child. Since we want to append the update only to the work-in\n\t      // -progress queue, we need to clone the updates. We usually clone during\n\t      // processUpdateQueue, but that didn't happen in this case because we\n\t      // skipped over the parent when we bailed out.\n\t      var newFirst = null;\n\t      var newLast = null;\n\t      var firstBaseUpdate = queue.firstBaseUpdate;\n\n\t      if (firstBaseUpdate !== null) {\n\t        // Loop through the updates and clone them.\n\t        var update = firstBaseUpdate;\n\n\t        do {\n\t          var clone = {\n\t            eventTime: update.eventTime,\n\t            lane: update.lane,\n\t            tag: update.tag,\n\t            payload: update.payload,\n\t            callback: update.callback,\n\t            next: null\n\t          };\n\n\t          if (newLast === null) {\n\t            newFirst = newLast = clone;\n\t          } else {\n\t            newLast.next = clone;\n\t            newLast = clone;\n\t          }\n\n\t          update = update.next;\n\t        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n\t        if (newLast === null) {\n\t          newFirst = newLast = capturedUpdate;\n\t        } else {\n\t          newLast.next = capturedUpdate;\n\t          newLast = capturedUpdate;\n\t        }\n\t      } else {\n\t        // There are no base updates.\n\t        newFirst = newLast = capturedUpdate;\n\t      }\n\n\t      queue = {\n\t        baseState: currentQueue.baseState,\n\t        firstBaseUpdate: newFirst,\n\t        lastBaseUpdate: newLast,\n\t        shared: currentQueue.shared,\n\t        effects: currentQueue.effects\n\t      };\n\t      workInProgress.updateQueue = queue;\n\t      return;\n\t    }\n\t  } // Append the update to the end of the list.\n\n\n\t  var lastBaseUpdate = queue.lastBaseUpdate;\n\n\t  if (lastBaseUpdate === null) {\n\t    queue.firstBaseUpdate = capturedUpdate;\n\t  } else {\n\t    lastBaseUpdate.next = capturedUpdate;\n\t  }\n\n\t  queue.lastBaseUpdate = capturedUpdate;\n\t}\n\n\tfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n\t  switch (update.tag) {\n\t    case ReplaceState:\n\t      {\n\t        var payload = update.payload;\n\n\t        if (typeof payload === 'function') {\n\t          // Updater function\n\t          {\n\t            enterDisallowedContextReadInDEV();\n\t          }\n\n\t          var nextState = payload.call(instance, prevState, nextProps);\n\n\t          {\n\t            if ( workInProgress.mode & StrictLegacyMode) {\n\t              setIsStrictModeForDevtools(true);\n\n\t              try {\n\t                payload.call(instance, prevState, nextProps);\n\t              } finally {\n\t                setIsStrictModeForDevtools(false);\n\t              }\n\t            }\n\n\t            exitDisallowedContextReadInDEV();\n\t          }\n\n\t          return nextState;\n\t        } // State object\n\n\n\t        return payload;\n\t      }\n\n\t    case CaptureUpdate:\n\t      {\n\t        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n\t      }\n\t    // Intentional fallthrough\n\n\t    case UpdateState:\n\t      {\n\t        var _payload = update.payload;\n\t        var partialState;\n\n\t        if (typeof _payload === 'function') {\n\t          // Updater function\n\t          {\n\t            enterDisallowedContextReadInDEV();\n\t          }\n\n\t          partialState = _payload.call(instance, prevState, nextProps);\n\n\t          {\n\t            if ( workInProgress.mode & StrictLegacyMode) {\n\t              setIsStrictModeForDevtools(true);\n\n\t              try {\n\t                _payload.call(instance, prevState, nextProps);\n\t              } finally {\n\t                setIsStrictModeForDevtools(false);\n\t              }\n\t            }\n\n\t            exitDisallowedContextReadInDEV();\n\t          }\n\t        } else {\n\t          // Partial state object\n\t          partialState = _payload;\n\t        }\n\n\t        if (partialState === null || partialState === undefined) {\n\t          // Null and undefined are treated as no-ops.\n\t          return prevState;\n\t        } // Merge the partial state and the previous state.\n\n\n\t        return assign({}, prevState, partialState);\n\t      }\n\n\t    case ForceUpdate:\n\t      {\n\t        hasForceUpdate = true;\n\t        return prevState;\n\t      }\n\t  }\n\n\t  return prevState;\n\t}\n\n\tfunction processUpdateQueue(workInProgress, props, instance, renderLanes) {\n\t  // This is always non-null on a ClassComponent or HostRoot\n\t  var queue = workInProgress.updateQueue;\n\t  hasForceUpdate = false;\n\n\t  {\n\t    currentlyProcessingQueue = queue.shared;\n\t  }\n\n\t  var firstBaseUpdate = queue.firstBaseUpdate;\n\t  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n\t  var pendingQueue = queue.shared.pending;\n\n\t  if (pendingQueue !== null) {\n\t    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n\t    // and last so that it's non-circular.\n\n\t    var lastPendingUpdate = pendingQueue;\n\t    var firstPendingUpdate = lastPendingUpdate.next;\n\t    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n\t    if (lastBaseUpdate === null) {\n\t      firstBaseUpdate = firstPendingUpdate;\n\t    } else {\n\t      lastBaseUpdate.next = firstPendingUpdate;\n\t    }\n\n\t    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n\t    // we need to transfer the updates to that queue, too. Because the base\n\t    // queue is a singly-linked list with no cycles, we can append to both\n\t    // lists and take advantage of structural sharing.\n\t    // TODO: Pass `current` as argument\n\n\t    var current = workInProgress.alternate;\n\n\t    if (current !== null) {\n\t      // This is always non-null on a ClassComponent or HostRoot\n\t      var currentQueue = current.updateQueue;\n\t      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n\t      if (currentLastBaseUpdate !== lastBaseUpdate) {\n\t        if (currentLastBaseUpdate === null) {\n\t          currentQueue.firstBaseUpdate = firstPendingUpdate;\n\t        } else {\n\t          currentLastBaseUpdate.next = firstPendingUpdate;\n\t        }\n\n\t        currentQueue.lastBaseUpdate = lastPendingUpdate;\n\t      }\n\t    }\n\t  } // These values may change as we process the queue.\n\n\n\t  if (firstBaseUpdate !== null) {\n\t    // Iterate through the list of updates to compute the result.\n\t    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n\t    // from the original lanes.\n\n\t    var newLanes = NoLanes;\n\t    var newBaseState = null;\n\t    var newFirstBaseUpdate = null;\n\t    var newLastBaseUpdate = null;\n\t    var update = firstBaseUpdate;\n\n\t    do {\n\t      var updateLane = update.lane;\n\t      var updateEventTime = update.eventTime;\n\n\t      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n\t        // Priority is insufficient. Skip this update. If this is the first\n\t        // skipped update, the previous update/state is the new base\n\t        // update/state.\n\t        var clone = {\n\t          eventTime: updateEventTime,\n\t          lane: updateLane,\n\t          tag: update.tag,\n\t          payload: update.payload,\n\t          callback: update.callback,\n\t          next: null\n\t        };\n\n\t        if (newLastBaseUpdate === null) {\n\t          newFirstBaseUpdate = newLastBaseUpdate = clone;\n\t          newBaseState = newState;\n\t        } else {\n\t          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n\t        } // Update the remaining priority in the queue.\n\n\n\t        newLanes = mergeLanes(newLanes, updateLane);\n\t      } else {\n\t        // This update does have sufficient priority.\n\t        if (newLastBaseUpdate !== null) {\n\t          var _clone = {\n\t            eventTime: updateEventTime,\n\t            // This update is going to be committed so we never want uncommit\n\t            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n\t            // this will never be skipped by the check above.\n\t            lane: NoLane,\n\t            tag: update.tag,\n\t            payload: update.payload,\n\t            callback: update.callback,\n\t            next: null\n\t          };\n\t          newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n\t        } // Process this update.\n\n\n\t        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n\t        var callback = update.callback;\n\n\t        if (callback !== null && // If the update was already committed, we should not queue its\n\t        // callback again.\n\t        update.lane !== NoLane) {\n\t          workInProgress.flags |= Callback;\n\t          var effects = queue.effects;\n\n\t          if (effects === null) {\n\t            queue.effects = [update];\n\t          } else {\n\t            effects.push(update);\n\t          }\n\t        }\n\t      }\n\n\t      update = update.next;\n\n\t      if (update === null) {\n\t        pendingQueue = queue.shared.pending;\n\n\t        if (pendingQueue === null) {\n\t          break;\n\t        } else {\n\t          // An update was scheduled from inside a reducer. Add the new\n\t          // pending updates to the end of the list and keep processing.\n\t          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n\t          // unravel them when transferring them to the base queue.\n\n\t          var _firstPendingUpdate = _lastPendingUpdate.next;\n\t          _lastPendingUpdate.next = null;\n\t          update = _firstPendingUpdate;\n\t          queue.lastBaseUpdate = _lastPendingUpdate;\n\t          queue.shared.pending = null;\n\t        }\n\t      }\n\t    } while (true);\n\n\t    if (newLastBaseUpdate === null) {\n\t      newBaseState = newState;\n\t    }\n\n\t    queue.baseState = newBaseState;\n\t    queue.firstBaseUpdate = newFirstBaseUpdate;\n\t    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n\t    // process them during this render, but we do need to track which lanes\n\t    // are remaining.\n\n\t    var lastInterleaved = queue.shared.interleaved;\n\n\t    if (lastInterleaved !== null) {\n\t      var interleaved = lastInterleaved;\n\n\t      do {\n\t        newLanes = mergeLanes(newLanes, interleaved.lane);\n\t        interleaved = interleaved.next;\n\t      } while (interleaved !== lastInterleaved);\n\t    } else if (firstBaseUpdate === null) {\n\t      // `queue.lanes` is used for entangling transitions. We can set it back to\n\t      // zero once the queue is empty.\n\t      queue.shared.lanes = NoLanes;\n\t    } // Set the remaining expiration time to be whatever is remaining in the queue.\n\t    // This should be fine because the only two other things that contribute to\n\t    // expiration time are props and context. We're already in the middle of the\n\t    // begin phase by the time we start processing the queue, so we've already\n\t    // dealt with the props. Context in components that specify\n\t    // shouldComponentUpdate is tricky; but we'll have to account for\n\t    // that regardless.\n\n\n\t    markSkippedUpdateLanes(newLanes);\n\t    workInProgress.lanes = newLanes;\n\t    workInProgress.memoizedState = newState;\n\t  }\n\n\t  {\n\t    currentlyProcessingQueue = null;\n\t  }\n\t}\n\n\tfunction callCallback(callback, context) {\n\t  if (typeof callback !== 'function') {\n\t    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n\t  }\n\n\t  callback.call(context);\n\t}\n\n\tfunction resetHasForceUpdateBeforeProcessing() {\n\t  hasForceUpdate = false;\n\t}\n\tfunction checkHasForceUpdateAfterProcessing() {\n\t  return hasForceUpdate;\n\t}\n\tfunction commitUpdateQueue(finishedWork, finishedQueue, instance) {\n\t  // Commit the effects\n\t  var effects = finishedQueue.effects;\n\t  finishedQueue.effects = null;\n\n\t  if (effects !== null) {\n\t    for (var i = 0; i < effects.length; i++) {\n\t      var effect = effects[i];\n\t      var callback = effect.callback;\n\n\t      if (callback !== null) {\n\t        effect.callback = null;\n\t        callCallback(callback, instance);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tvar fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n\t// We'll use it to determine whether we need to initialize legacy refs.\n\n\tvar emptyRefsObject = new React$1.Component().refs;\n\tvar didWarnAboutStateAssignmentForComponent;\n\tvar didWarnAboutUninitializedState;\n\tvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n\tvar didWarnAboutLegacyLifecyclesAndDerivedState;\n\tvar didWarnAboutUndefinedDerivedState;\n\tvar warnOnUndefinedDerivedState;\n\tvar warnOnInvalidCallback;\n\tvar didWarnAboutDirectlyAssigningPropsToState;\n\tvar didWarnAboutContextTypeAndContextTypes;\n\tvar didWarnAboutInvalidateContextType;\n\n\t{\n\t  didWarnAboutStateAssignmentForComponent = new Set();\n\t  didWarnAboutUninitializedState = new Set();\n\t  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n\t  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n\t  didWarnAboutDirectlyAssigningPropsToState = new Set();\n\t  didWarnAboutUndefinedDerivedState = new Set();\n\t  didWarnAboutContextTypeAndContextTypes = new Set();\n\t  didWarnAboutInvalidateContextType = new Set();\n\t  var didWarnOnInvalidCallback = new Set();\n\n\t  warnOnInvalidCallback = function (callback, callerName) {\n\t    if (callback === null || typeof callback === 'function') {\n\t      return;\n\t    }\n\n\t    var key = callerName + '_' + callback;\n\n\t    if (!didWarnOnInvalidCallback.has(key)) {\n\t      didWarnOnInvalidCallback.add(key);\n\n\t      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n\t    }\n\t  };\n\n\t  warnOnUndefinedDerivedState = function (type, partialState) {\n\t    if (partialState === undefined) {\n\t      var componentName = getComponentNameFromType(type) || 'Component';\n\n\t      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n\t        didWarnAboutUndefinedDerivedState.add(componentName);\n\n\t        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n\t      }\n\t    }\n\t  }; // This is so gross but it's at least non-critical and can be removed if\n\t  // it causes problems. This is meant to give a nicer error message for\n\t  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n\t  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n\t  // exception.\n\n\n\t  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n\t    enumerable: false,\n\t    value: function () {\n\t      throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n\t    }\n\t  });\n\t  Object.freeze(fakeInternalInstance);\n\t}\n\n\tfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n\t  var prevState = workInProgress.memoizedState;\n\t  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n\t  {\n\t    if ( workInProgress.mode & StrictLegacyMode) {\n\t      setIsStrictModeForDevtools(true);\n\n\t      try {\n\t        // Invoke the function an extra time to help detect side-effects.\n\t        partialState = getDerivedStateFromProps(nextProps, prevState);\n\t      } finally {\n\t        setIsStrictModeForDevtools(false);\n\t      }\n\t    }\n\n\t    warnOnUndefinedDerivedState(ctor, partialState);\n\t  } // Merge the partial state and the previous state.\n\n\n\t  var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n\t  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n\t  // base state.\n\n\t  if (workInProgress.lanes === NoLanes) {\n\t    // Queue is always non-null for classes\n\t    var updateQueue = workInProgress.updateQueue;\n\t    updateQueue.baseState = memoizedState;\n\t  }\n\t}\n\n\tvar classComponentUpdater = {\n\t  isMounted: isMounted,\n\t  enqueueSetState: function (inst, payload, callback) {\n\t    var fiber = get(inst);\n\t    var eventTime = requestEventTime();\n\t    var lane = requestUpdateLane(fiber);\n\t    var update = createUpdate(eventTime, lane);\n\t    update.payload = payload;\n\n\t    if (callback !== undefined && callback !== null) {\n\t      {\n\t        warnOnInvalidCallback(callback, 'setState');\n\t      }\n\n\t      update.callback = callback;\n\t    }\n\n\t    var root = enqueueUpdate(fiber, update, lane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t      entangleTransitions(root, fiber, lane);\n\t    }\n\n\t    {\n\t      markStateUpdateScheduled(fiber, lane);\n\t    }\n\t  },\n\t  enqueueReplaceState: function (inst, payload, callback) {\n\t    var fiber = get(inst);\n\t    var eventTime = requestEventTime();\n\t    var lane = requestUpdateLane(fiber);\n\t    var update = createUpdate(eventTime, lane);\n\t    update.tag = ReplaceState;\n\t    update.payload = payload;\n\n\t    if (callback !== undefined && callback !== null) {\n\t      {\n\t        warnOnInvalidCallback(callback, 'replaceState');\n\t      }\n\n\t      update.callback = callback;\n\t    }\n\n\t    var root = enqueueUpdate(fiber, update, lane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t      entangleTransitions(root, fiber, lane);\n\t    }\n\n\t    {\n\t      markStateUpdateScheduled(fiber, lane);\n\t    }\n\t  },\n\t  enqueueForceUpdate: function (inst, callback) {\n\t    var fiber = get(inst);\n\t    var eventTime = requestEventTime();\n\t    var lane = requestUpdateLane(fiber);\n\t    var update = createUpdate(eventTime, lane);\n\t    update.tag = ForceUpdate;\n\n\t    if (callback !== undefined && callback !== null) {\n\t      {\n\t        warnOnInvalidCallback(callback, 'forceUpdate');\n\t      }\n\n\t      update.callback = callback;\n\t    }\n\n\t    var root = enqueueUpdate(fiber, update, lane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t      entangleTransitions(root, fiber, lane);\n\t    }\n\n\t    {\n\t      markForceUpdateScheduled(fiber, lane);\n\t    }\n\t  }\n\t};\n\n\tfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n\t  var instance = workInProgress.stateNode;\n\n\t  if (typeof instance.shouldComponentUpdate === 'function') {\n\t    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\n\t    {\n\t      if ( workInProgress.mode & StrictLegacyMode) {\n\t        setIsStrictModeForDevtools(true);\n\n\t        try {\n\t          // Invoke the function an extra time to help detect side-effects.\n\t          shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\t        } finally {\n\t          setIsStrictModeForDevtools(false);\n\t        }\n\t      }\n\n\t      if (shouldUpdate === undefined) {\n\t        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n\t      }\n\t    }\n\n\t    return shouldUpdate;\n\t  }\n\n\t  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n\t    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction checkClassInstance(workInProgress, ctor, newProps) {\n\t  var instance = workInProgress.stateNode;\n\n\t  {\n\t    var name = getComponentNameFromType(ctor) || 'Component';\n\t    var renderPresent = instance.render;\n\n\t    if (!renderPresent) {\n\t      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n\t        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n\t      } else {\n\t        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n\t      }\n\t    }\n\n\t    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n\t      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n\t    }\n\n\t    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n\t      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n\t    }\n\n\t    if (instance.propTypes) {\n\t      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n\t    }\n\n\t    if (instance.contextType) {\n\t      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n\t    }\n\n\t    {\n\t      if (instance.contextTypes) {\n\t        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n\t      }\n\n\t      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n\t        didWarnAboutContextTypeAndContextTypes.add(ctor);\n\n\t        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n\t      }\n\t    }\n\n\t    if (typeof instance.componentShouldUpdate === 'function') {\n\t      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n\t    }\n\n\t    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n\t      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n\t    }\n\n\t    if (typeof instance.componentDidUnmount === 'function') {\n\t      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n\t    }\n\n\t    if (typeof instance.componentDidReceiveProps === 'function') {\n\t      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n\t    }\n\n\t    if (typeof instance.componentWillRecieveProps === 'function') {\n\t      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n\t    }\n\n\t    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n\t      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n\t    }\n\n\t    var hasMutatedProps = instance.props !== newProps;\n\n\t    if (instance.props !== undefined && hasMutatedProps) {\n\t      error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n\t    }\n\n\t    if (instance.defaultProps) {\n\t      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n\t    }\n\n\t    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n\t      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n\n\t      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n\t    }\n\n\t    if (typeof instance.getDerivedStateFromProps === 'function') {\n\t      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n\t    }\n\n\t    if (typeof instance.getDerivedStateFromError === 'function') {\n\t      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n\t    }\n\n\t    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n\t      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n\t    }\n\n\t    var _state = instance.state;\n\n\t    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n\t      error('%s.state: must be set to an object or null', name);\n\t    }\n\n\t    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n\t      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n\t    }\n\t  }\n\t}\n\n\tfunction adoptClassInstance(workInProgress, instance) {\n\t  instance.updater = classComponentUpdater;\n\t  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n\t  set(instance, workInProgress);\n\n\t  {\n\t    instance._reactInternalInstance = fakeInternalInstance;\n\t  }\n\t}\n\n\tfunction constructClassInstance(workInProgress, ctor, props) {\n\t  var isLegacyContextConsumer = false;\n\t  var unmaskedContext = emptyContextObject;\n\t  var context = emptyContextObject;\n\t  var contextType = ctor.contextType;\n\n\t  {\n\t    if ('contextType' in ctor) {\n\t      var isValid = // Allow null for conditional declaration\n\t      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n\t      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n\t        didWarnAboutInvalidateContextType.add(ctor);\n\t        var addendum = '';\n\n\t        if (contextType === undefined) {\n\t          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n\t        } else if (typeof contextType !== 'object') {\n\t          addendum = ' However, it is set to a ' + typeof contextType + '.';\n\t        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n\t          addendum = ' Did you accidentally pass the Context.Provider instead?';\n\t        } else if (contextType._context !== undefined) {\n\t          // <Context.Consumer>\n\t          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n\t        } else {\n\t          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n\t        }\n\n\t        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n\t      }\n\t    }\n\t  }\n\n\t  if (typeof contextType === 'object' && contextType !== null) {\n\t    context = readContext(contextType);\n\t  } else {\n\t    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\t    var contextTypes = ctor.contextTypes;\n\t    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n\t    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n\t  }\n\n\t  var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n\n\t  {\n\t    if ( workInProgress.mode & StrictLegacyMode) {\n\t      setIsStrictModeForDevtools(true);\n\n\t      try {\n\t        instance = new ctor(props, context); // eslint-disable-line no-new\n\t      } finally {\n\t        setIsStrictModeForDevtools(false);\n\t      }\n\t    }\n\t  }\n\n\t  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n\t  adoptClassInstance(workInProgress, instance);\n\n\t  {\n\t    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n\t      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n\t      if (!didWarnAboutUninitializedState.has(componentName)) {\n\t        didWarnAboutUninitializedState.add(componentName);\n\n\t        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n\t      }\n\t    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n\t    // Warn about these lifecycles if they are present.\n\t    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n\t    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n\t      var foundWillMountName = null;\n\t      var foundWillReceivePropsName = null;\n\t      var foundWillUpdateName = null;\n\n\t      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n\t        foundWillMountName = 'componentWillMount';\n\t      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n\t        foundWillMountName = 'UNSAFE_componentWillMount';\n\t      }\n\n\t      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n\t        foundWillReceivePropsName = 'componentWillReceiveProps';\n\t      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n\t        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n\t      }\n\n\t      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n\t        foundWillUpdateName = 'componentWillUpdate';\n\t      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n\t        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n\t      }\n\n\t      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n\t        var _componentName = getComponentNameFromType(ctor) || 'Component';\n\n\t        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n\t        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n\t          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n\n\t          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n\t        }\n\t      }\n\t    }\n\t  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n\t  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n\t  if (isLegacyContextConsumer) {\n\t    cacheContext(workInProgress, unmaskedContext, context);\n\t  }\n\n\t  return instance;\n\t}\n\n\tfunction callComponentWillMount(workInProgress, instance) {\n\t  var oldState = instance.state;\n\n\t  if (typeof instance.componentWillMount === 'function') {\n\t    instance.componentWillMount();\n\t  }\n\n\t  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n\t    instance.UNSAFE_componentWillMount();\n\t  }\n\n\t  if (oldState !== instance.state) {\n\t    {\n\t      error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n\t    }\n\n\t    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n\t  }\n\t}\n\n\tfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n\t  var oldState = instance.state;\n\n\t  if (typeof instance.componentWillReceiveProps === 'function') {\n\t    instance.componentWillReceiveProps(newProps, nextContext);\n\t  }\n\n\t  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n\t    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n\t  }\n\n\t  if (instance.state !== oldState) {\n\t    {\n\t      var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n\n\t      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n\t        didWarnAboutStateAssignmentForComponent.add(componentName);\n\n\t        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n\t      }\n\t    }\n\n\t    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n\t  }\n\t} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\n\tfunction mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n\t  {\n\t    checkClassInstance(workInProgress, ctor, newProps);\n\t  }\n\n\t  var instance = workInProgress.stateNode;\n\t  instance.props = newProps;\n\t  instance.state = workInProgress.memoizedState;\n\t  instance.refs = emptyRefsObject;\n\t  initializeUpdateQueue(workInProgress);\n\t  var contextType = ctor.contextType;\n\n\t  if (typeof contextType === 'object' && contextType !== null) {\n\t    instance.context = readContext(contextType);\n\t  } else {\n\t    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\t    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\t  }\n\n\t  {\n\t    if (instance.state === newProps) {\n\t      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n\t      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n\t        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n\n\t        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n\t      }\n\t    }\n\n\t    if (workInProgress.mode & StrictLegacyMode) {\n\t      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n\t    }\n\n\t    {\n\t      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n\t    }\n\t  }\n\n\t  instance.state = workInProgress.memoizedState;\n\t  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n\t  if (typeof getDerivedStateFromProps === 'function') {\n\t    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n\t    instance.state = workInProgress.memoizedState;\n\t  } // In order to support react-lifecycles-compat polyfilled components,\n\t  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n\t  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n\t    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n\t    // process them now.\n\n\t    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n\t    instance.state = workInProgress.memoizedState;\n\t  }\n\n\t  if (typeof instance.componentDidMount === 'function') {\n\t    var fiberFlags = Update;\n\n\t    {\n\t      fiberFlags |= LayoutStatic;\n\t    }\n\n\t    if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n\t      fiberFlags |= MountLayoutDev;\n\t    }\n\n\t    workInProgress.flags |= fiberFlags;\n\t  }\n\t}\n\n\tfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n\t  var instance = workInProgress.stateNode;\n\t  var oldProps = workInProgress.memoizedProps;\n\t  instance.props = oldProps;\n\t  var oldContext = instance.context;\n\t  var contextType = ctor.contextType;\n\t  var nextContext = emptyContextObject;\n\n\t  if (typeof contextType === 'object' && contextType !== null) {\n\t    nextContext = readContext(contextType);\n\t  } else {\n\t    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\t    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n\t  }\n\n\t  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\t  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n\t  // ever the previously attempted to render - not the \"current\". However,\n\t  // during componentDidUpdate we pass the \"current\" props.\n\t  // In order to support react-lifecycles-compat polyfilled components,\n\t  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\t  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n\t    if (oldProps !== newProps || oldContext !== nextContext) {\n\t      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n\t    }\n\t  }\n\n\t  resetHasForceUpdateBeforeProcessing();\n\t  var oldState = workInProgress.memoizedState;\n\t  var newState = instance.state = oldState;\n\t  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n\t  newState = workInProgress.memoizedState;\n\n\t  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n\t    // If an update was already in progress, we should schedule an Update\n\t    // effect even though we're bailing out, so that cWU/cDU are called.\n\t    if (typeof instance.componentDidMount === 'function') {\n\t      var fiberFlags = Update;\n\n\t      {\n\t        fiberFlags |= LayoutStatic;\n\t      }\n\n\t      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n\t        fiberFlags |= MountLayoutDev;\n\t      }\n\n\t      workInProgress.flags |= fiberFlags;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (typeof getDerivedStateFromProps === 'function') {\n\t    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n\t    newState = workInProgress.memoizedState;\n\t  }\n\n\t  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n\t  if (shouldUpdate) {\n\t    // In order to support react-lifecycles-compat polyfilled components,\n\t    // Unsafe lifecycles should not be invoked for components using the new APIs.\n\t    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n\t      if (typeof instance.componentWillMount === 'function') {\n\t        instance.componentWillMount();\n\t      }\n\n\t      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n\t        instance.UNSAFE_componentWillMount();\n\t      }\n\t    }\n\n\t    if (typeof instance.componentDidMount === 'function') {\n\t      var _fiberFlags = Update;\n\n\t      {\n\t        _fiberFlags |= LayoutStatic;\n\t      }\n\n\t      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n\t        _fiberFlags |= MountLayoutDev;\n\t      }\n\n\t      workInProgress.flags |= _fiberFlags;\n\t    }\n\t  } else {\n\t    // If an update was already in progress, we should schedule an Update\n\t    // effect even though we're bailing out, so that cWU/cDU are called.\n\t    if (typeof instance.componentDidMount === 'function') {\n\t      var _fiberFlags2 = Update;\n\n\t      {\n\t        _fiberFlags2 |= LayoutStatic;\n\t      }\n\n\t      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n\t        _fiberFlags2 |= MountLayoutDev;\n\t      }\n\n\t      workInProgress.flags |= _fiberFlags2;\n\t    } // If shouldComponentUpdate returned false, we should still update the\n\t    // memoized state to indicate that this work can be reused.\n\n\n\t    workInProgress.memoizedProps = newProps;\n\t    workInProgress.memoizedState = newState;\n\t  } // Update the existing instance's state, props, and context pointers even\n\t  // if shouldComponentUpdate returns false.\n\n\n\t  instance.props = newProps;\n\t  instance.state = newState;\n\t  instance.context = nextContext;\n\t  return shouldUpdate;\n\t} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\n\tfunction updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n\t  var instance = workInProgress.stateNode;\n\t  cloneUpdateQueue(current, workInProgress);\n\t  var unresolvedOldProps = workInProgress.memoizedProps;\n\t  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n\t  instance.props = oldProps;\n\t  var unresolvedNewProps = workInProgress.pendingProps;\n\t  var oldContext = instance.context;\n\t  var contextType = ctor.contextType;\n\t  var nextContext = emptyContextObject;\n\n\t  if (typeof contextType === 'object' && contextType !== null) {\n\t    nextContext = readContext(contextType);\n\t  } else {\n\t    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\t    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n\t  }\n\n\t  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\t  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n\t  // ever the previously attempted to render - not the \"current\". However,\n\t  // during componentDidUpdate we pass the \"current\" props.\n\t  // In order to support react-lifecycles-compat polyfilled components,\n\t  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\t  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n\t    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n\t      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n\t    }\n\t  }\n\n\t  resetHasForceUpdateBeforeProcessing();\n\t  var oldState = workInProgress.memoizedState;\n\t  var newState = instance.state = oldState;\n\t  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n\t  newState = workInProgress.memoizedState;\n\n\t  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation   )) {\n\t    // If an update was already in progress, we should schedule an Update\n\t    // effect even though we're bailing out, so that cWU/cDU are called.\n\t    if (typeof instance.componentDidUpdate === 'function') {\n\t      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n\t        workInProgress.flags |= Update;\n\t      }\n\t    }\n\n\t    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n\t      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n\t        workInProgress.flags |= Snapshot;\n\t      }\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (typeof getDerivedStateFromProps === 'function') {\n\t    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n\t    newState = workInProgress.memoizedState;\n\t  }\n\n\t  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n\t  // both before and after `shouldComponentUpdate` has been called. Not ideal,\n\t  // but I'm loath to refactor this function. This only happens for memoized\n\t  // components so it's not that common.\n\t  enableLazyContextPropagation   ;\n\n\t  if (shouldUpdate) {\n\t    // In order to support react-lifecycles-compat polyfilled components,\n\t    // Unsafe lifecycles should not be invoked for components using the new APIs.\n\t    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n\t      if (typeof instance.componentWillUpdate === 'function') {\n\t        instance.componentWillUpdate(newProps, newState, nextContext);\n\t      }\n\n\t      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n\t        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n\t      }\n\t    }\n\n\t    if (typeof instance.componentDidUpdate === 'function') {\n\t      workInProgress.flags |= Update;\n\t    }\n\n\t    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n\t      workInProgress.flags |= Snapshot;\n\t    }\n\t  } else {\n\t    // If an update was already in progress, we should schedule an Update\n\t    // effect even though we're bailing out, so that cWU/cDU are called.\n\t    if (typeof instance.componentDidUpdate === 'function') {\n\t      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n\t        workInProgress.flags |= Update;\n\t      }\n\t    }\n\n\t    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n\t      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n\t        workInProgress.flags |= Snapshot;\n\t      }\n\t    } // If shouldComponentUpdate returned false, we should still update the\n\t    // memoized props/state to indicate that this work can be reused.\n\n\n\t    workInProgress.memoizedProps = newProps;\n\t    workInProgress.memoizedState = newState;\n\t  } // Update the existing instance's state, props, and context pointers even\n\t  // if shouldComponentUpdate returns false.\n\n\n\t  instance.props = newProps;\n\t  instance.state = newState;\n\t  instance.context = nextContext;\n\t  return shouldUpdate;\n\t}\n\n\tvar didWarnAboutMaps;\n\tvar didWarnAboutGenerators;\n\tvar didWarnAboutStringRefs;\n\tvar ownerHasKeyUseWarning;\n\tvar ownerHasFunctionTypeWarning;\n\n\tvar warnForMissingKey = function (child, returnFiber) {};\n\n\t{\n\t  didWarnAboutMaps = false;\n\t  didWarnAboutGenerators = false;\n\t  didWarnAboutStringRefs = {};\n\t  /**\n\t   * Warn if there's no key explicitly set on dynamic arrays of children or\n\t   * object keys are not valid. This allows us to keep track of children between\n\t   * updates.\n\t   */\n\n\t  ownerHasKeyUseWarning = {};\n\t  ownerHasFunctionTypeWarning = {};\n\n\t  warnForMissingKey = function (child, returnFiber) {\n\t    if (child === null || typeof child !== 'object') {\n\t      return;\n\t    }\n\n\t    if (!child._store || child._store.validated || child.key != null) {\n\t      return;\n\t    }\n\n\t    if (typeof child._store !== 'object') {\n\t      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\t    }\n\n\t    child._store.validated = true;\n\t    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n\t    if (ownerHasKeyUseWarning[componentName]) {\n\t      return;\n\t    }\n\n\t    ownerHasKeyUseWarning[componentName] = true;\n\n\t    error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n\t  };\n\t}\n\n\tfunction coerceRef(returnFiber, current, element) {\n\t  var mixedRef = element.ref;\n\n\t  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n\t    {\n\t      // TODO: Clean this up once we turn on the string ref warning for\n\t      // everyone, because the strict mode case will no longer be relevant\n\t      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n\t      // because these cannot be automatically converted to an arrow function\n\t      // using a codemod. Therefore, we don't have to warn about string refs again.\n\t      !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n\t        var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n\t        if (!didWarnAboutStringRefs[componentName]) {\n\t          {\n\t            error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n\t          }\n\n\t          didWarnAboutStringRefs[componentName] = true;\n\t        }\n\t      }\n\t    }\n\n\t    if (element._owner) {\n\t      var owner = element._owner;\n\t      var inst;\n\n\t      if (owner) {\n\t        var ownerFiber = owner;\n\n\t        if (ownerFiber.tag !== ClassComponent) {\n\t          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n\t        }\n\n\t        inst = ownerFiber.stateNode;\n\t      }\n\n\t      if (!inst) {\n\t        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + 'bug in React. Please file an issue.');\n\t      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n\t      var resolvedInst = inst;\n\n\t      {\n\t        checkPropStringCoercion(mixedRef, 'ref');\n\t      }\n\n\t      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n\t      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n\t        return current.ref;\n\t      }\n\n\t      var ref = function (value) {\n\t        var refs = resolvedInst.refs;\n\n\t        if (refs === emptyRefsObject) {\n\t          // This is a lazy pooled frozen object, so we need to initialize.\n\t          refs = resolvedInst.refs = {};\n\t        }\n\n\t        if (value === null) {\n\t          delete refs[stringRef];\n\t        } else {\n\t          refs[stringRef] = value;\n\t        }\n\t      };\n\n\t      ref._stringRef = stringRef;\n\t      return ref;\n\t    } else {\n\t      if (typeof mixedRef !== 'string') {\n\t        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n\t      }\n\n\t      if (!element._owner) {\n\t        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n\t      }\n\t    }\n\t  }\n\n\t  return mixedRef;\n\t}\n\n\tfunction throwOnInvalidObjectType(returnFiber, newChild) {\n\t  var childString = Object.prototype.toString.call(newChild);\n\t  throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n\t}\n\n\tfunction warnOnFunctionType(returnFiber) {\n\t  {\n\t    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n\t    if (ownerHasFunctionTypeWarning[componentName]) {\n\t      return;\n\t    }\n\n\t    ownerHasFunctionTypeWarning[componentName] = true;\n\n\t    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n\t  }\n\t}\n\n\tfunction resolveLazy(lazyType) {\n\t  var payload = lazyType._payload;\n\t  var init = lazyType._init;\n\t  return init(payload);\n\t} // This wrapper function exists because I expect to clone the code in each path\n\t// to be able to optimize each path individually by branching early. This needs\n\t// a compiler or we can do it manually. Helpers that don't need this branching\n\t// live outside of this function.\n\n\n\tfunction ChildReconciler(shouldTrackSideEffects) {\n\t  function deleteChild(returnFiber, childToDelete) {\n\t    if (!shouldTrackSideEffects) {\n\t      // Noop.\n\t      return;\n\t    }\n\n\t    var deletions = returnFiber.deletions;\n\n\t    if (deletions === null) {\n\t      returnFiber.deletions = [childToDelete];\n\t      returnFiber.flags |= ChildDeletion;\n\t    } else {\n\t      deletions.push(childToDelete);\n\t    }\n\t  }\n\n\t  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n\t    if (!shouldTrackSideEffects) {\n\t      // Noop.\n\t      return null;\n\t    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n\t    // assuming that after the first child we've already added everything.\n\n\n\t    var childToDelete = currentFirstChild;\n\n\t    while (childToDelete !== null) {\n\t      deleteChild(returnFiber, childToDelete);\n\t      childToDelete = childToDelete.sibling;\n\t    }\n\n\t    return null;\n\t  }\n\n\t  function mapRemainingChildren(returnFiber, currentFirstChild) {\n\t    // Add the remaining children to a temporary map so that we can find them by\n\t    // keys quickly. Implicit (null) keys get added to this set with their index\n\t    // instead.\n\t    var existingChildren = new Map();\n\t    var existingChild = currentFirstChild;\n\n\t    while (existingChild !== null) {\n\t      if (existingChild.key !== null) {\n\t        existingChildren.set(existingChild.key, existingChild);\n\t      } else {\n\t        existingChildren.set(existingChild.index, existingChild);\n\t      }\n\n\t      existingChild = existingChild.sibling;\n\t    }\n\n\t    return existingChildren;\n\t  }\n\n\t  function useFiber(fiber, pendingProps) {\n\t    // We currently set sibling to null and index to 0 here because it is easy\n\t    // to forget to do before returning it. E.g. for the single child case.\n\t    var clone = createWorkInProgress(fiber, pendingProps);\n\t    clone.index = 0;\n\t    clone.sibling = null;\n\t    return clone;\n\t  }\n\n\t  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n\t    newFiber.index = newIndex;\n\n\t    if (!shouldTrackSideEffects) {\n\t      // During hydration, the useId algorithm needs to know which fibers are\n\t      // part of a list of children (arrays, iterators).\n\t      newFiber.flags |= Forked;\n\t      return lastPlacedIndex;\n\t    }\n\n\t    var current = newFiber.alternate;\n\n\t    if (current !== null) {\n\t      var oldIndex = current.index;\n\n\t      if (oldIndex < lastPlacedIndex) {\n\t        // This is a move.\n\t        newFiber.flags |= Placement;\n\t        return lastPlacedIndex;\n\t      } else {\n\t        // This item can stay in place.\n\t        return oldIndex;\n\t      }\n\t    } else {\n\t      // This is an insertion.\n\t      newFiber.flags |= Placement;\n\t      return lastPlacedIndex;\n\t    }\n\t  }\n\n\t  function placeSingleChild(newFiber) {\n\t    // This is simpler for the single child case. We only need to do a\n\t    // placement for inserting new children.\n\t    if (shouldTrackSideEffects && newFiber.alternate === null) {\n\t      newFiber.flags |= Placement;\n\t    }\n\n\t    return newFiber;\n\t  }\n\n\t  function updateTextNode(returnFiber, current, textContent, lanes) {\n\t    if (current === null || current.tag !== HostText) {\n\t      // Insert\n\t      var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n\t      created.return = returnFiber;\n\t      return created;\n\t    } else {\n\t      // Update\n\t      var existing = useFiber(current, textContent);\n\t      existing.return = returnFiber;\n\t      return existing;\n\t    }\n\t  }\n\n\t  function updateElement(returnFiber, current, element, lanes) {\n\t    var elementType = element.type;\n\n\t    if (elementType === REACT_FRAGMENT_TYPE) {\n\t      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n\t    }\n\n\t    if (current !== null) {\n\t      if (current.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n\t       isCompatibleFamilyForHotReloading(current, element) ) || // Lazy types should reconcile their resolved type.\n\t      // We need to do this after the Hot Reloading check above,\n\t      // because hot reloading has different semantics than prod because\n\t      // it doesn't resuspend. So we can't let the call below suspend.\n\t      typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n\t        // Move based on index\n\t        var existing = useFiber(current, element.props);\n\t        existing.ref = coerceRef(returnFiber, current, element);\n\t        existing.return = returnFiber;\n\n\t        {\n\t          existing._debugSource = element._source;\n\t          existing._debugOwner = element._owner;\n\t        }\n\n\t        return existing;\n\t      }\n\t    } // Insert\n\n\n\t    var created = createFiberFromElement(element, returnFiber.mode, lanes);\n\t    created.ref = coerceRef(returnFiber, current, element);\n\t    created.return = returnFiber;\n\t    return created;\n\t  }\n\n\t  function updatePortal(returnFiber, current, portal, lanes) {\n\t    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n\t      // Insert\n\t      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n\t      created.return = returnFiber;\n\t      return created;\n\t    } else {\n\t      // Update\n\t      var existing = useFiber(current, portal.children || []);\n\t      existing.return = returnFiber;\n\t      return existing;\n\t    }\n\t  }\n\n\t  function updateFragment(returnFiber, current, fragment, lanes, key) {\n\t    if (current === null || current.tag !== Fragment) {\n\t      // Insert\n\t      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n\t      created.return = returnFiber;\n\t      return created;\n\t    } else {\n\t      // Update\n\t      var existing = useFiber(current, fragment);\n\t      existing.return = returnFiber;\n\t      return existing;\n\t    }\n\t  }\n\n\t  function createChild(returnFiber, newChild, lanes) {\n\t    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n\t      // Text nodes don't have keys. If the previous node is implicitly keyed\n\t      // we can continue to replace it without aborting even if it is not a text\n\t      // node.\n\t      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n\t      created.return = returnFiber;\n\t      return created;\n\t    }\n\n\t    if (typeof newChild === 'object' && newChild !== null) {\n\t      switch (newChild.$$typeof) {\n\t        case REACT_ELEMENT_TYPE:\n\t          {\n\t            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n\n\t            _created.ref = coerceRef(returnFiber, null, newChild);\n\t            _created.return = returnFiber;\n\t            return _created;\n\t          }\n\n\t        case REACT_PORTAL_TYPE:\n\t          {\n\t            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n\n\t            _created2.return = returnFiber;\n\t            return _created2;\n\t          }\n\n\t        case REACT_LAZY_TYPE:\n\t          {\n\t            var payload = newChild._payload;\n\t            var init = newChild._init;\n\t            return createChild(returnFiber, init(payload), lanes);\n\t          }\n\t      }\n\n\t      if (isArray(newChild) || getIteratorFn(newChild)) {\n\t        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n\n\t        _created3.return = returnFiber;\n\t        return _created3;\n\t      }\n\n\t      throwOnInvalidObjectType(returnFiber, newChild);\n\t    }\n\n\t    {\n\t      if (typeof newChild === 'function') {\n\t        warnOnFunctionType(returnFiber);\n\t      }\n\t    }\n\n\t    return null;\n\t  }\n\n\t  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n\t    // Update the fiber if the keys match, otherwise return null.\n\t    var key = oldFiber !== null ? oldFiber.key : null;\n\n\t    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n\t      // Text nodes don't have keys. If the previous node is implicitly keyed\n\t      // we can continue to replace it without aborting even if it is not a text\n\t      // node.\n\t      if (key !== null) {\n\t        return null;\n\t      }\n\n\t      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n\t    }\n\n\t    if (typeof newChild === 'object' && newChild !== null) {\n\t      switch (newChild.$$typeof) {\n\t        case REACT_ELEMENT_TYPE:\n\t          {\n\t            if (newChild.key === key) {\n\t              return updateElement(returnFiber, oldFiber, newChild, lanes);\n\t            } else {\n\t              return null;\n\t            }\n\t          }\n\n\t        case REACT_PORTAL_TYPE:\n\t          {\n\t            if (newChild.key === key) {\n\t              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n\t            } else {\n\t              return null;\n\t            }\n\t          }\n\n\t        case REACT_LAZY_TYPE:\n\t          {\n\t            var payload = newChild._payload;\n\t            var init = newChild._init;\n\t            return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n\t          }\n\t      }\n\n\t      if (isArray(newChild) || getIteratorFn(newChild)) {\n\t        if (key !== null) {\n\t          return null;\n\t        }\n\n\t        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n\t      }\n\n\t      throwOnInvalidObjectType(returnFiber, newChild);\n\t    }\n\n\t    {\n\t      if (typeof newChild === 'function') {\n\t        warnOnFunctionType(returnFiber);\n\t      }\n\t    }\n\n\t    return null;\n\t  }\n\n\t  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n\t    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n\t      // Text nodes don't have keys, so we neither have to check the old nor\n\t      // new node for the key. If both are text nodes, they match.\n\t      var matchedFiber = existingChildren.get(newIdx) || null;\n\t      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n\t    }\n\n\t    if (typeof newChild === 'object' && newChild !== null) {\n\t      switch (newChild.$$typeof) {\n\t        case REACT_ELEMENT_TYPE:\n\t          {\n\t            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n\t            return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n\t          }\n\n\t        case REACT_PORTAL_TYPE:\n\t          {\n\t            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n\t            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n\t          }\n\n\t        case REACT_LAZY_TYPE:\n\t          var payload = newChild._payload;\n\t          var init = newChild._init;\n\t          return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n\t      }\n\n\t      if (isArray(newChild) || getIteratorFn(newChild)) {\n\t        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n\t        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n\t      }\n\n\t      throwOnInvalidObjectType(returnFiber, newChild);\n\t    }\n\n\t    {\n\t      if (typeof newChild === 'function') {\n\t        warnOnFunctionType(returnFiber);\n\t      }\n\t    }\n\n\t    return null;\n\t  }\n\t  /**\n\t   * Warns if there is a duplicate or missing key\n\t   */\n\n\n\t  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n\t    {\n\t      if (typeof child !== 'object' || child === null) {\n\t        return knownKeys;\n\t      }\n\n\t      switch (child.$$typeof) {\n\t        case REACT_ELEMENT_TYPE:\n\t        case REACT_PORTAL_TYPE:\n\t          warnForMissingKey(child, returnFiber);\n\t          var key = child.key;\n\n\t          if (typeof key !== 'string') {\n\t            break;\n\t          }\n\n\t          if (knownKeys === null) {\n\t            knownKeys = new Set();\n\t            knownKeys.add(key);\n\t            break;\n\t          }\n\n\t          if (!knownKeys.has(key)) {\n\t            knownKeys.add(key);\n\t            break;\n\t          }\n\n\t          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);\n\n\t          break;\n\n\t        case REACT_LAZY_TYPE:\n\t          var payload = child._payload;\n\t          var init = child._init;\n\t          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n\t          break;\n\t      }\n\t    }\n\n\t    return knownKeys;\n\t  }\n\n\t  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n\t    // This algorithm can't optimize by searching from both ends since we\n\t    // don't have backpointers on fibers. I'm trying to see how far we can get\n\t    // with that model. If it ends up not being worth the tradeoffs, we can\n\t    // add it later.\n\t    // Even with a two ended optimization, we'd want to optimize for the case\n\t    // where there are few changes and brute force the comparison instead of\n\t    // going for the Map. It'd like to explore hitting that path first in\n\t    // forward-only mode and only go for the Map once we notice that we need\n\t    // lots of look ahead. This doesn't handle reversal as well as two ended\n\t    // search but that's unusual. Besides, for the two ended optimization to\n\t    // work on Iterables, we'd need to copy the whole set.\n\t    // In this first iteration, we'll just live with hitting the bad case\n\t    // (adding everything to a Map) in for every insert/move.\n\t    // If you change this code, also update reconcileChildrenIterator() which\n\t    // uses the same algorithm.\n\t    {\n\t      // First, validate keys.\n\t      var knownKeys = null;\n\n\t      for (var i = 0; i < newChildren.length; i++) {\n\t        var child = newChildren[i];\n\t        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n\t      }\n\t    }\n\n\t    var resultingFirstChild = null;\n\t    var previousNewFiber = null;\n\t    var oldFiber = currentFirstChild;\n\t    var lastPlacedIndex = 0;\n\t    var newIdx = 0;\n\t    var nextOldFiber = null;\n\n\t    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n\t      if (oldFiber.index > newIdx) {\n\t        nextOldFiber = oldFiber;\n\t        oldFiber = null;\n\t      } else {\n\t        nextOldFiber = oldFiber.sibling;\n\t      }\n\n\t      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n\t      if (newFiber === null) {\n\t        // TODO: This breaks on empty slots like null children. That's\n\t        // unfortunate because it triggers the slow path all the time. We need\n\t        // a better way to communicate whether this was a miss or null,\n\t        // boolean, undefined, etc.\n\t        if (oldFiber === null) {\n\t          oldFiber = nextOldFiber;\n\t        }\n\n\t        break;\n\t      }\n\n\t      if (shouldTrackSideEffects) {\n\t        if (oldFiber && newFiber.alternate === null) {\n\t          // We matched the slot, but we didn't reuse the existing fiber, so we\n\t          // need to delete the existing child.\n\t          deleteChild(returnFiber, oldFiber);\n\t        }\n\t      }\n\n\t      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n\t      if (previousNewFiber === null) {\n\t        // TODO: Move out of the loop. This only happens for the first run.\n\t        resultingFirstChild = newFiber;\n\t      } else {\n\t        // TODO: Defer siblings if we're not at the right index for this slot.\n\t        // I.e. if we had null values before, then we want to defer this\n\t        // for each null value. However, we also don't want to call updateSlot\n\t        // with the previous one.\n\t        previousNewFiber.sibling = newFiber;\n\t      }\n\n\t      previousNewFiber = newFiber;\n\t      oldFiber = nextOldFiber;\n\t    }\n\n\t    if (newIdx === newChildren.length) {\n\t      // We've reached the end of the new children. We can delete the rest.\n\t      deleteRemainingChildren(returnFiber, oldFiber);\n\n\t      if (getIsHydrating()) {\n\t        var numberOfForks = newIdx;\n\t        pushTreeFork(returnFiber, numberOfForks);\n\t      }\n\n\t      return resultingFirstChild;\n\t    }\n\n\t    if (oldFiber === null) {\n\t      // If we don't have any more existing children we can choose a fast path\n\t      // since the rest will all be insertions.\n\t      for (; newIdx < newChildren.length; newIdx++) {\n\t        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n\t        if (_newFiber === null) {\n\t          continue;\n\t        }\n\n\t        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n\t        if (previousNewFiber === null) {\n\t          // TODO: Move out of the loop. This only happens for the first run.\n\t          resultingFirstChild = _newFiber;\n\t        } else {\n\t          previousNewFiber.sibling = _newFiber;\n\t        }\n\n\t        previousNewFiber = _newFiber;\n\t      }\n\n\t      if (getIsHydrating()) {\n\t        var _numberOfForks = newIdx;\n\t        pushTreeFork(returnFiber, _numberOfForks);\n\t      }\n\n\t      return resultingFirstChild;\n\t    } // Add all children to a key map for quick lookups.\n\n\n\t    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n\t    for (; newIdx < newChildren.length; newIdx++) {\n\t      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n\t      if (_newFiber2 !== null) {\n\t        if (shouldTrackSideEffects) {\n\t          if (_newFiber2.alternate !== null) {\n\t            // The new fiber is a work in progress, but if there exists a\n\t            // current, that means that we reused the fiber. We need to delete\n\t            // it from the child list so that we don't add it to the deletion\n\t            // list.\n\t            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n\t          }\n\t        }\n\n\t        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n\t        if (previousNewFiber === null) {\n\t          resultingFirstChild = _newFiber2;\n\t        } else {\n\t          previousNewFiber.sibling = _newFiber2;\n\t        }\n\n\t        previousNewFiber = _newFiber2;\n\t      }\n\t    }\n\n\t    if (shouldTrackSideEffects) {\n\t      // Any existing children that weren't consumed above were deleted. We need\n\t      // to add them to the deletion list.\n\t      existingChildren.forEach(function (child) {\n\t        return deleteChild(returnFiber, child);\n\t      });\n\t    }\n\n\t    if (getIsHydrating()) {\n\t      var _numberOfForks2 = newIdx;\n\t      pushTreeFork(returnFiber, _numberOfForks2);\n\t    }\n\n\t    return resultingFirstChild;\n\t  }\n\n\t  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n\t    // This is the same implementation as reconcileChildrenArray(),\n\t    // but using the iterator instead.\n\t    var iteratorFn = getIteratorFn(newChildrenIterable);\n\n\t    if (typeof iteratorFn !== 'function') {\n\t      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n\t    }\n\n\t    {\n\t      // We don't support rendering Generators because it's a mutation.\n\t      // See https://github.com/facebook/react/issues/12995\n\t      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n\t      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n\t        if (!didWarnAboutGenerators) {\n\t          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n\t        }\n\n\t        didWarnAboutGenerators = true;\n\t      } // Warn about using Maps as children\n\n\n\t      if (newChildrenIterable.entries === iteratorFn) {\n\t        if (!didWarnAboutMaps) {\n\t          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n\t        }\n\n\t        didWarnAboutMaps = true;\n\t      } // First, validate keys.\n\t      // We'll get a different iterator later for the main pass.\n\n\n\t      var _newChildren = iteratorFn.call(newChildrenIterable);\n\n\t      if (_newChildren) {\n\t        var knownKeys = null;\n\n\t        var _step = _newChildren.next();\n\n\t        for (; !_step.done; _step = _newChildren.next()) {\n\t          var child = _step.value;\n\t          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n\t        }\n\t      }\n\t    }\n\n\t    var newChildren = iteratorFn.call(newChildrenIterable);\n\n\t    if (newChildren == null) {\n\t      throw new Error('An iterable object provided no iterator.');\n\t    }\n\n\t    var resultingFirstChild = null;\n\t    var previousNewFiber = null;\n\t    var oldFiber = currentFirstChild;\n\t    var lastPlacedIndex = 0;\n\t    var newIdx = 0;\n\t    var nextOldFiber = null;\n\t    var step = newChildren.next();\n\n\t    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n\t      if (oldFiber.index > newIdx) {\n\t        nextOldFiber = oldFiber;\n\t        oldFiber = null;\n\t      } else {\n\t        nextOldFiber = oldFiber.sibling;\n\t      }\n\n\t      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n\t      if (newFiber === null) {\n\t        // TODO: This breaks on empty slots like null children. That's\n\t        // unfortunate because it triggers the slow path all the time. We need\n\t        // a better way to communicate whether this was a miss or null,\n\t        // boolean, undefined, etc.\n\t        if (oldFiber === null) {\n\t          oldFiber = nextOldFiber;\n\t        }\n\n\t        break;\n\t      }\n\n\t      if (shouldTrackSideEffects) {\n\t        if (oldFiber && newFiber.alternate === null) {\n\t          // We matched the slot, but we didn't reuse the existing fiber, so we\n\t          // need to delete the existing child.\n\t          deleteChild(returnFiber, oldFiber);\n\t        }\n\t      }\n\n\t      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n\t      if (previousNewFiber === null) {\n\t        // TODO: Move out of the loop. This only happens for the first run.\n\t        resultingFirstChild = newFiber;\n\t      } else {\n\t        // TODO: Defer siblings if we're not at the right index for this slot.\n\t        // I.e. if we had null values before, then we want to defer this\n\t        // for each null value. However, we also don't want to call updateSlot\n\t        // with the previous one.\n\t        previousNewFiber.sibling = newFiber;\n\t      }\n\n\t      previousNewFiber = newFiber;\n\t      oldFiber = nextOldFiber;\n\t    }\n\n\t    if (step.done) {\n\t      // We've reached the end of the new children. We can delete the rest.\n\t      deleteRemainingChildren(returnFiber, oldFiber);\n\n\t      if (getIsHydrating()) {\n\t        var numberOfForks = newIdx;\n\t        pushTreeFork(returnFiber, numberOfForks);\n\t      }\n\n\t      return resultingFirstChild;\n\t    }\n\n\t    if (oldFiber === null) {\n\t      // If we don't have any more existing children we can choose a fast path\n\t      // since the rest will all be insertions.\n\t      for (; !step.done; newIdx++, step = newChildren.next()) {\n\t        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n\n\t        if (_newFiber3 === null) {\n\t          continue;\n\t        }\n\n\t        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n\t        if (previousNewFiber === null) {\n\t          // TODO: Move out of the loop. This only happens for the first run.\n\t          resultingFirstChild = _newFiber3;\n\t        } else {\n\t          previousNewFiber.sibling = _newFiber3;\n\t        }\n\n\t        previousNewFiber = _newFiber3;\n\t      }\n\n\t      if (getIsHydrating()) {\n\t        var _numberOfForks3 = newIdx;\n\t        pushTreeFork(returnFiber, _numberOfForks3);\n\t      }\n\n\t      return resultingFirstChild;\n\t    } // Add all children to a key map for quick lookups.\n\n\n\t    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n\t    for (; !step.done; newIdx++, step = newChildren.next()) {\n\t      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n\t      if (_newFiber4 !== null) {\n\t        if (shouldTrackSideEffects) {\n\t          if (_newFiber4.alternate !== null) {\n\t            // The new fiber is a work in progress, but if there exists a\n\t            // current, that means that we reused the fiber. We need to delete\n\t            // it from the child list so that we don't add it to the deletion\n\t            // list.\n\t            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n\t          }\n\t        }\n\n\t        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n\t        if (previousNewFiber === null) {\n\t          resultingFirstChild = _newFiber4;\n\t        } else {\n\t          previousNewFiber.sibling = _newFiber4;\n\t        }\n\n\t        previousNewFiber = _newFiber4;\n\t      }\n\t    }\n\n\t    if (shouldTrackSideEffects) {\n\t      // Any existing children that weren't consumed above were deleted. We need\n\t      // to add them to the deletion list.\n\t      existingChildren.forEach(function (child) {\n\t        return deleteChild(returnFiber, child);\n\t      });\n\t    }\n\n\t    if (getIsHydrating()) {\n\t      var _numberOfForks4 = newIdx;\n\t      pushTreeFork(returnFiber, _numberOfForks4);\n\t    }\n\n\t    return resultingFirstChild;\n\t  }\n\n\t  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n\t    // There's no need to check for keys on text nodes since we don't have a\n\t    // way to define them.\n\t    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n\t      // We already have an existing node so let's just update it and delete\n\t      // the rest.\n\t      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n\t      var existing = useFiber(currentFirstChild, textContent);\n\t      existing.return = returnFiber;\n\t      return existing;\n\t    } // The existing first child is not a text node so we need to create one\n\t    // and delete the existing ones.\n\n\n\t    deleteRemainingChildren(returnFiber, currentFirstChild);\n\t    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n\t    created.return = returnFiber;\n\t    return created;\n\t  }\n\n\t  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n\t    var key = element.key;\n\t    var child = currentFirstChild;\n\n\t    while (child !== null) {\n\t      // TODO: If key === null and child.key === null, then this only applies to\n\t      // the first item in the list.\n\t      if (child.key === key) {\n\t        var elementType = element.type;\n\n\t        if (elementType === REACT_FRAGMENT_TYPE) {\n\t          if (child.tag === Fragment) {\n\t            deleteRemainingChildren(returnFiber, child.sibling);\n\t            var existing = useFiber(child, element.props.children);\n\t            existing.return = returnFiber;\n\n\t            {\n\t              existing._debugSource = element._source;\n\t              existing._debugOwner = element._owner;\n\t            }\n\n\t            return existing;\n\t          }\n\t        } else {\n\t          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n\t           isCompatibleFamilyForHotReloading(child, element) ) || // Lazy types should reconcile their resolved type.\n\t          // We need to do this after the Hot Reloading check above,\n\t          // because hot reloading has different semantics than prod because\n\t          // it doesn't resuspend. So we can't let the call below suspend.\n\t          typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n\t            deleteRemainingChildren(returnFiber, child.sibling);\n\n\t            var _existing = useFiber(child, element.props);\n\n\t            _existing.ref = coerceRef(returnFiber, child, element);\n\t            _existing.return = returnFiber;\n\n\t            {\n\t              _existing._debugSource = element._source;\n\t              _existing._debugOwner = element._owner;\n\t            }\n\n\t            return _existing;\n\t          }\n\t        } // Didn't match.\n\n\n\t        deleteRemainingChildren(returnFiber, child);\n\t        break;\n\t      } else {\n\t        deleteChild(returnFiber, child);\n\t      }\n\n\t      child = child.sibling;\n\t    }\n\n\t    if (element.type === REACT_FRAGMENT_TYPE) {\n\t      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n\t      created.return = returnFiber;\n\t      return created;\n\t    } else {\n\t      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n\n\t      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n\t      _created4.return = returnFiber;\n\t      return _created4;\n\t    }\n\t  }\n\n\t  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n\t    var key = portal.key;\n\t    var child = currentFirstChild;\n\n\t    while (child !== null) {\n\t      // TODO: If key === null and child.key === null, then this only applies to\n\t      // the first item in the list.\n\t      if (child.key === key) {\n\t        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n\t          deleteRemainingChildren(returnFiber, child.sibling);\n\t          var existing = useFiber(child, portal.children || []);\n\t          existing.return = returnFiber;\n\t          return existing;\n\t        } else {\n\t          deleteRemainingChildren(returnFiber, child);\n\t          break;\n\t        }\n\t      } else {\n\t        deleteChild(returnFiber, child);\n\t      }\n\n\t      child = child.sibling;\n\t    }\n\n\t    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n\t    created.return = returnFiber;\n\t    return created;\n\t  } // This API will tag the children with the side-effect of the reconciliation\n\t  // itself. They will be added to the side-effect list as we pass through the\n\t  // children and the parent.\n\n\n\t  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n\t    // This function is not recursive.\n\t    // If the top level item is an array, we treat it as a set of children,\n\t    // not as a fragment. Nested arrays on the other hand will be treated as\n\t    // fragment nodes. Recursion happens at the normal flow.\n\t    // Handle top level unkeyed fragments as if they were arrays.\n\t    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n\t    // We treat the ambiguous cases above the same.\n\t    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n\t    if (isUnkeyedTopLevelFragment) {\n\t      newChild = newChild.props.children;\n\t    } // Handle object types\n\n\n\t    if (typeof newChild === 'object' && newChild !== null) {\n\t      switch (newChild.$$typeof) {\n\t        case REACT_ELEMENT_TYPE:\n\t          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n\t        case REACT_PORTAL_TYPE:\n\t          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n\t        case REACT_LAZY_TYPE:\n\t          var payload = newChild._payload;\n\t          var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n\t          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n\t      }\n\n\t      if (isArray(newChild)) {\n\t        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n\t      }\n\n\t      if (getIteratorFn(newChild)) {\n\t        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n\t      }\n\n\t      throwOnInvalidObjectType(returnFiber, newChild);\n\t    }\n\n\t    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n\t      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n\t    }\n\n\t    {\n\t      if (typeof newChild === 'function') {\n\t        warnOnFunctionType(returnFiber);\n\t      }\n\t    } // Remaining cases are all treated as empty.\n\n\n\t    return deleteRemainingChildren(returnFiber, currentFirstChild);\n\t  }\n\n\t  return reconcileChildFibers;\n\t}\n\n\tvar reconcileChildFibers = ChildReconciler(true);\n\tvar mountChildFibers = ChildReconciler(false);\n\tfunction cloneChildFibers(current, workInProgress) {\n\t  if (current !== null && workInProgress.child !== current.child) {\n\t    throw new Error('Resuming work not yet implemented.');\n\t  }\n\n\t  if (workInProgress.child === null) {\n\t    return;\n\t  }\n\n\t  var currentChild = workInProgress.child;\n\t  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n\t  workInProgress.child = newChild;\n\t  newChild.return = workInProgress;\n\n\t  while (currentChild.sibling !== null) {\n\t    currentChild = currentChild.sibling;\n\t    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n\t    newChild.return = workInProgress;\n\t  }\n\n\t  newChild.sibling = null;\n\t} // Reset a workInProgress child set to prepare it for a second pass.\n\n\tfunction resetChildFibers(workInProgress, lanes) {\n\t  var child = workInProgress.child;\n\n\t  while (child !== null) {\n\t    resetWorkInProgress(child, lanes);\n\t    child = child.sibling;\n\t  }\n\t}\n\n\tvar NO_CONTEXT = {};\n\tvar contextStackCursor$1 = createCursor(NO_CONTEXT);\n\tvar contextFiberStackCursor = createCursor(NO_CONTEXT);\n\tvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n\tfunction requiredContext(c) {\n\t  if (c === NO_CONTEXT) {\n\t    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n\t  }\n\n\t  return c;\n\t}\n\n\tfunction getRootHostContainer() {\n\t  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n\t  return rootInstance;\n\t}\n\n\tfunction pushHostContainer(fiber, nextRootInstance) {\n\t  // Push current root instance onto the stack;\n\t  // This allows us to reset root when portals are popped.\n\t  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n\t  // This enables us to pop only Fibers that provide unique contexts.\n\n\t  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n\t  // However, we can't just call getRootHostContext() and push it because\n\t  // we'd have a different number of entries on the stack depending on\n\t  // whether getRootHostContext() throws somewhere in renderer code or not.\n\t  // So we push an empty value first. This lets us safely unwind on errors.\n\n\t  push(contextStackCursor$1, NO_CONTEXT, fiber);\n\t  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n\t  pop(contextStackCursor$1, fiber);\n\t  push(contextStackCursor$1, nextRootContext, fiber);\n\t}\n\n\tfunction popHostContainer(fiber) {\n\t  pop(contextStackCursor$1, fiber);\n\t  pop(contextFiberStackCursor, fiber);\n\t  pop(rootInstanceStackCursor, fiber);\n\t}\n\n\tfunction getHostContext() {\n\t  var context = requiredContext(contextStackCursor$1.current);\n\t  return context;\n\t}\n\n\tfunction pushHostContext(fiber) {\n\t  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n\t  var context = requiredContext(contextStackCursor$1.current);\n\t  var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n\t  if (context === nextContext) {\n\t    return;\n\t  } // Track the context and the Fiber that provided it.\n\t  // This enables us to pop only Fibers that provide unique contexts.\n\n\n\t  push(contextFiberStackCursor, fiber, fiber);\n\t  push(contextStackCursor$1, nextContext, fiber);\n\t}\n\n\tfunction popHostContext(fiber) {\n\t  // Do not pop unless this Fiber provided the current context.\n\t  // pushHostContext() only pushes Fibers that provide unique contexts.\n\t  if (contextFiberStackCursor.current !== fiber) {\n\t    return;\n\t  }\n\n\t  pop(contextStackCursor$1, fiber);\n\t  pop(contextFiberStackCursor, fiber);\n\t}\n\n\tvar DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n\t// inherited deeply down the subtree. The upper bits only affect\n\t// this immediate suspense boundary and gets reset each new\n\t// boundary or suspense list.\n\n\tvar SubtreeSuspenseContextMask = 1; // Subtree Flags:\n\t// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n\t// boundaries is not currently showing visible main content.\n\t// Either because it is already showing a fallback or is not mounted at all.\n\t// We can use this to determine if it is desirable to trigger a fallback at\n\t// the parent. If not, then we might need to trigger undesirable boundaries\n\t// and/or suspend the commit to avoid hiding the parent content.\n\n\tvar InvisibleParentSuspenseContext = 1; // Shallow Flags:\n\t// ForceSuspenseFallback can be used by SuspenseList to force newly added\n\t// items into their fallback state during one of the render passes.\n\n\tvar ForceSuspenseFallback = 2;\n\tvar suspenseStackCursor = createCursor(DefaultSuspenseContext);\n\tfunction hasSuspenseContext(parentContext, flag) {\n\t  return (parentContext & flag) !== 0;\n\t}\n\tfunction setDefaultShallowSuspenseContext(parentContext) {\n\t  return parentContext & SubtreeSuspenseContextMask;\n\t}\n\tfunction setShallowSuspenseContext(parentContext, shallowContext) {\n\t  return parentContext & SubtreeSuspenseContextMask | shallowContext;\n\t}\n\tfunction addSubtreeSuspenseContext(parentContext, subtreeContext) {\n\t  return parentContext | subtreeContext;\n\t}\n\tfunction pushSuspenseContext(fiber, newContext) {\n\t  push(suspenseStackCursor, newContext, fiber);\n\t}\n\tfunction popSuspenseContext(fiber) {\n\t  pop(suspenseStackCursor, fiber);\n\t}\n\n\tfunction shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n\t  // If it was the primary children that just suspended, capture and render the\n\t  // fallback. Otherwise, don't capture and bubble to the next boundary.\n\t  var nextState = workInProgress.memoizedState;\n\n\t  if (nextState !== null) {\n\t    if (nextState.dehydrated !== null) {\n\t      // A dehydrated boundary always captures.\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  workInProgress.memoizedProps; // Regular boundaries always capture.\n\n\t  {\n\t    return true;\n\t  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n\t}\n\tfunction findFirstSuspended(row) {\n\t  var node = row;\n\n\t  while (node !== null) {\n\t    if (node.tag === SuspenseComponent) {\n\t      var state = node.memoizedState;\n\n\t      if (state !== null) {\n\t        var dehydrated = state.dehydrated;\n\n\t        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n\t          return node;\n\t        }\n\t      }\n\t    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n\t    // keep track of whether it suspended or not.\n\t    node.memoizedProps.revealOrder !== undefined) {\n\t      var didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n\t      if (didSuspend) {\n\t        return node;\n\t      }\n\t    } else if (node.child !== null) {\n\t      node.child.return = node;\n\t      node = node.child;\n\t      continue;\n\t    }\n\n\t    if (node === row) {\n\t      return null;\n\t    }\n\n\t    while (node.sibling === null) {\n\t      if (node.return === null || node.return === row) {\n\t        return null;\n\t      }\n\n\t      node = node.return;\n\t    }\n\n\t    node.sibling.return = node.return;\n\t    node = node.sibling;\n\t  }\n\n\t  return null;\n\t}\n\n\tvar NoFlags$1 =\n\t/*   */\n\t0; // Represents whether effect should fire.\n\n\tvar HasEffect =\n\t/* */\n\t1; // Represents the phase in which the effect (not the clean-up) fires.\n\n\tvar Insertion =\n\t/*  */\n\t2;\n\tvar Layout =\n\t/*    */\n\t4;\n\tvar Passive$1 =\n\t/*   */\n\t8;\n\n\t// and should be reset before starting a new render.\n\t// This tracks which mutable sources need to be reset after a render.\n\n\tvar workInProgressSources = [];\n\tfunction resetWorkInProgressVersions() {\n\t  for (var i = 0; i < workInProgressSources.length; i++) {\n\t    var mutableSource = workInProgressSources[i];\n\n\t    if (isPrimaryRenderer) {\n\t      mutableSource._workInProgressVersionPrimary = null;\n\t    } else {\n\t      mutableSource._workInProgressVersionSecondary = null;\n\t    }\n\t  }\n\n\t  workInProgressSources.length = 0;\n\t}\n\t// This ensures that the version used for server rendering matches the one\n\t// that is eventually read during hydration.\n\t// If they don't match there's a potential tear and a full deopt render is required.\n\n\tfunction registerMutableSourceForHydration(root, mutableSource) {\n\t  var getVersion = mutableSource._getVersion;\n\t  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n\t  // Retaining it forever may interfere with GC.\n\n\t  if (root.mutableSourceEagerHydrationData == null) {\n\t    root.mutableSourceEagerHydrationData = [mutableSource, version];\n\t  } else {\n\t    root.mutableSourceEagerHydrationData.push(mutableSource, version);\n\t  }\n\t}\n\n\tvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,\n\t    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n\tvar didWarnAboutMismatchedHooksForComponent;\n\tvar didWarnUncachedGetSnapshot;\n\n\t{\n\t  didWarnAboutMismatchedHooksForComponent = new Set();\n\t}\n\n\t// These are set right before calling the component.\n\tvar renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n\t// the work-in-progress hook.\n\n\tvar currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n\t// current hook list is the list that belongs to the current fiber. The\n\t// work-in-progress hook list is a new list that will be added to the\n\t// work-in-progress fiber.\n\n\tvar currentHook = null;\n\tvar workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n\t// does not get reset if we do another render pass; only when we're completely\n\t// finished evaluating this component. This is an optimization so we know\n\t// whether we need to clear render phase updates after a throw.\n\n\tvar didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n\t// gets reset after each attempt.\n\t// TODO: Maybe there's some way to consolidate this with\n\t// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\n\tvar didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n\n\tvar localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n\t// hydration). This counter is global, so client ids are not stable across\n\t// render attempts.\n\n\tvar globalClientIdCounter = 0;\n\tvar RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\n\tvar currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n\t// The list stores the order of hooks used during the initial render (mount).\n\t// Subsequent renders (updates) reference this list.\n\n\tvar hookTypesDev = null;\n\tvar hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n\t// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n\t// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\n\tvar ignorePreviousDependencies = false;\n\n\tfunction mountHookTypesDev() {\n\t  {\n\t    var hookName = currentHookNameInDev;\n\n\t    if (hookTypesDev === null) {\n\t      hookTypesDev = [hookName];\n\t    } else {\n\t      hookTypesDev.push(hookName);\n\t    }\n\t  }\n\t}\n\n\tfunction updateHookTypesDev() {\n\t  {\n\t    var hookName = currentHookNameInDev;\n\n\t    if (hookTypesDev !== null) {\n\t      hookTypesUpdateIndexDev++;\n\n\t      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n\t        warnOnHookMismatchInDev(hookName);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction checkDepsAreArrayDev(deps) {\n\t  {\n\t    if (deps !== undefined && deps !== null && !isArray(deps)) {\n\t      // Verify deps, but only on mount to avoid extra checks.\n\t      // It's unlikely their type would change as usually you define them inline.\n\t      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n\t    }\n\t  }\n\t}\n\n\tfunction warnOnHookMismatchInDev(currentHookName) {\n\t  {\n\t    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n\n\t    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n\t      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n\t      if (hookTypesDev !== null) {\n\t        var table = '';\n\t        var secondColumnStart = 30;\n\n\t        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\n\t          var oldHookName = hookTypesDev[i];\n\t          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n\t          var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n\t          // lol @ IE not supporting String#repeat\n\n\t          while (row.length < secondColumnStart) {\n\t            row += ' ';\n\t          }\n\n\t          row += newHookName + '\\n';\n\t          table += row;\n\t        }\n\n\t        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction throwInvalidHookError() {\n\t  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n\t}\n\n\tfunction areHookInputsEqual(nextDeps, prevDeps) {\n\t  {\n\t    if (ignorePreviousDependencies) {\n\t      // Only true when this component is being hot reloaded.\n\t      return false;\n\t    }\n\t  }\n\n\t  if (prevDeps === null) {\n\t    {\n\t      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n\t    }\n\n\t    return false;\n\t  }\n\n\t  {\n\t    // Don't bother comparing lengths in prod because these arrays should be\n\t    // passed inline.\n\t    if (nextDeps.length !== prevDeps.length) {\n\t      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n\t    }\n\t  }\n\n\t  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n\t    if (objectIs(nextDeps[i], prevDeps[i])) {\n\t      continue;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n\t  renderLanes = nextRenderLanes;\n\t  currentlyRenderingFiber$1 = workInProgress;\n\n\t  {\n\t    hookTypesDev = current !== null ? current._debugHookTypes : null;\n\t    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n\t    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n\t  }\n\n\t  workInProgress.memoizedState = null;\n\t  workInProgress.updateQueue = null;\n\t  workInProgress.lanes = NoLanes; // The following should have already been reset\n\t  // currentHook = null;\n\t  // workInProgressHook = null;\n\t  // didScheduleRenderPhaseUpdate = false;\n\t  // localIdCounter = 0;\n\t  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n\t  // Currently we will identify the update render as a mount because memoizedState === null.\n\t  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\t  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n\t  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n\t  // so memoizedState would be null during updates and mounts.\n\n\t  {\n\t    if (current !== null && current.memoizedState !== null) {\n\t      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n\t    } else if (hookTypesDev !== null) {\n\t      // This dispatcher handles an edge case where a component is updating,\n\t      // but no stateful hooks have been used.\n\t      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n\t      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n\t      // This dispatcher does that.\n\t      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n\t    } else {\n\t      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n\t    }\n\t  }\n\n\t  var children = Component(props, secondArg); // Check if there was a render phase update\n\n\t  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n\t    // Keep rendering in a loop for as long as render phase updates continue to\n\t    // be scheduled. Use a counter to prevent infinite loops.\n\t    var numberOfReRenders = 0;\n\n\t    do {\n\t      didScheduleRenderPhaseUpdateDuringThisPass = false;\n\t      localIdCounter = 0;\n\n\t      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n\t        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n\t      }\n\n\t      numberOfReRenders += 1;\n\n\t      {\n\t        // Even when hot reloading, allow dependencies to stabilize\n\t        // after first render to prevent infinite render phase updates.\n\t        ignorePreviousDependencies = false;\n\t      } // Start over from the beginning of the list\n\n\n\t      currentHook = null;\n\t      workInProgressHook = null;\n\t      workInProgress.updateQueue = null;\n\n\t      {\n\t        // Also validate hook order for cascading updates.\n\t        hookTypesUpdateIndexDev = -1;\n\t      }\n\n\t      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;\n\t      children = Component(props, secondArg);\n\t    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n\t  } // We can assume the previous dispatcher is always this one, since we set it\n\t  // at the beginning of the render phase and there's no re-entrance.\n\n\n\t  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n\t  {\n\t    workInProgress._debugHookTypes = hookTypesDev;\n\t  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n\t  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n\t  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n\t  renderLanes = NoLanes;\n\t  currentlyRenderingFiber$1 = null;\n\t  currentHook = null;\n\t  workInProgressHook = null;\n\n\t  {\n\t    currentHookNameInDev = null;\n\t    hookTypesDev = null;\n\t    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n\t    // render. If this fires, it suggests that we incorrectly reset the static\n\t    // flags in some other part of the codebase. This has happened before, for\n\t    // example, in the SuspenseList implementation.\n\n\t    if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n\t    // and creates false positives. To make this work in legacy mode, we'd\n\t    // need to mark fibers that commit in an incomplete state, somehow. For\n\t    // now I'll disable the warning that most of the bugs that would trigger\n\t    // it are either exclusive to concurrent mode or exist in both.\n\t    (current.mode & ConcurrentMode) !== NoMode) {\n\t      error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n\t    }\n\t  }\n\n\t  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n\t  // localIdCounter = 0;\n\n\t  if (didRenderTooFewHooks) {\n\t    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n\t  }\n\n\t  return children;\n\t}\n\tfunction checkDidRenderIdHook() {\n\t  // This should be called immediately after every renderWithHooks call.\n\t  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n\t  // separate function to avoid using an array tuple.\n\t  var didRenderIdHook = localIdCounter !== 0;\n\t  localIdCounter = 0;\n\t  return didRenderIdHook;\n\t}\n\tfunction bailoutHooks(current, workInProgress, lanes) {\n\t  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n\t  // complete phase (bubbleProperties).\n\n\t  if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n\t    workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n\t  } else {\n\t    workInProgress.flags &= ~(Passive | Update);\n\t  }\n\n\t  current.lanes = removeLanes(current.lanes, lanes);\n\t}\n\tfunction resetHooksAfterThrow() {\n\t  // We can assume the previous dispatcher is always this one, since we set it\n\t  // at the beginning of the render phase and there's no re-entrance.\n\t  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n\t  if (didScheduleRenderPhaseUpdate) {\n\t    // There were render phase updates. These are only valid for this render\n\t    // phase, which we are now aborting. Remove the updates from the queues so\n\t    // they do not persist to the next render. Do not remove updates from hooks\n\t    // that weren't processed.\n\t    //\n\t    // Only reset the updates from the queue if it has a clone. If it does\n\t    // not have a clone, that means it wasn't processed, and the updates were\n\t    // scheduled before we entered the render phase.\n\t    var hook = currentlyRenderingFiber$1.memoizedState;\n\n\t    while (hook !== null) {\n\t      var queue = hook.queue;\n\n\t      if (queue !== null) {\n\t        queue.pending = null;\n\t      }\n\n\t      hook = hook.next;\n\t    }\n\n\t    didScheduleRenderPhaseUpdate = false;\n\t  }\n\n\t  renderLanes = NoLanes;\n\t  currentlyRenderingFiber$1 = null;\n\t  currentHook = null;\n\t  workInProgressHook = null;\n\n\t  {\n\t    hookTypesDev = null;\n\t    hookTypesUpdateIndexDev = -1;\n\t    currentHookNameInDev = null;\n\t    isUpdatingOpaqueValueInRenderPhase = false;\n\t  }\n\n\t  didScheduleRenderPhaseUpdateDuringThisPass = false;\n\t  localIdCounter = 0;\n\t}\n\n\tfunction mountWorkInProgressHook() {\n\t  var hook = {\n\t    memoizedState: null,\n\t    baseState: null,\n\t    baseQueue: null,\n\t    queue: null,\n\t    next: null\n\t  };\n\n\t  if (workInProgressHook === null) {\n\t    // This is the first hook in the list\n\t    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n\t  } else {\n\t    // Append to the end of the list\n\t    workInProgressHook = workInProgressHook.next = hook;\n\t  }\n\n\t  return workInProgressHook;\n\t}\n\n\tfunction updateWorkInProgressHook() {\n\t  // This function is used both for updates and for re-renders triggered by a\n\t  // render phase update. It assumes there is either a current hook we can\n\t  // clone, or a work-in-progress hook from a previous render pass that we can\n\t  // use as a base. When we reach the end of the base list, we must switch to\n\t  // the dispatcher used for mounts.\n\t  var nextCurrentHook;\n\n\t  if (currentHook === null) {\n\t    var current = currentlyRenderingFiber$1.alternate;\n\n\t    if (current !== null) {\n\t      nextCurrentHook = current.memoizedState;\n\t    } else {\n\t      nextCurrentHook = null;\n\t    }\n\t  } else {\n\t    nextCurrentHook = currentHook.next;\n\t  }\n\n\t  var nextWorkInProgressHook;\n\n\t  if (workInProgressHook === null) {\n\t    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n\t  } else {\n\t    nextWorkInProgressHook = workInProgressHook.next;\n\t  }\n\n\t  if (nextWorkInProgressHook !== null) {\n\t    // There's already a work-in-progress. Reuse it.\n\t    workInProgressHook = nextWorkInProgressHook;\n\t    nextWorkInProgressHook = workInProgressHook.next;\n\t    currentHook = nextCurrentHook;\n\t  } else {\n\t    // Clone from the current hook.\n\t    if (nextCurrentHook === null) {\n\t      throw new Error('Rendered more hooks than during the previous render.');\n\t    }\n\n\t    currentHook = nextCurrentHook;\n\t    var newHook = {\n\t      memoizedState: currentHook.memoizedState,\n\t      baseState: currentHook.baseState,\n\t      baseQueue: currentHook.baseQueue,\n\t      queue: currentHook.queue,\n\t      next: null\n\t    };\n\n\t    if (workInProgressHook === null) {\n\t      // This is the first hook in the list.\n\t      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n\t    } else {\n\t      // Append to the end of the list.\n\t      workInProgressHook = workInProgressHook.next = newHook;\n\t    }\n\t  }\n\n\t  return workInProgressHook;\n\t}\n\n\tfunction createFunctionComponentUpdateQueue() {\n\t  return {\n\t    lastEffect: null,\n\t    stores: null\n\t  };\n\t}\n\n\tfunction basicStateReducer(state, action) {\n\t  // $FlowFixMe: Flow doesn't like mixed types\n\t  return typeof action === 'function' ? action(state) : action;\n\t}\n\n\tfunction mountReducer(reducer, initialArg, init) {\n\t  var hook = mountWorkInProgressHook();\n\t  var initialState;\n\n\t  if (init !== undefined) {\n\t    initialState = init(initialArg);\n\t  } else {\n\t    initialState = initialArg;\n\t  }\n\n\t  hook.memoizedState = hook.baseState = initialState;\n\t  var queue = {\n\t    pending: null,\n\t    interleaved: null,\n\t    lanes: NoLanes,\n\t    dispatch: null,\n\t    lastRenderedReducer: reducer,\n\t    lastRenderedState: initialState\n\t  };\n\t  hook.queue = queue;\n\t  var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n\t  return [hook.memoizedState, dispatch];\n\t}\n\n\tfunction updateReducer(reducer, initialArg, init) {\n\t  var hook = updateWorkInProgressHook();\n\t  var queue = hook.queue;\n\n\t  if (queue === null) {\n\t    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n\t  }\n\n\t  queue.lastRenderedReducer = reducer;\n\t  var current = currentHook; // The last rebase update that is NOT part of the base state.\n\n\t  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n\t  var pendingQueue = queue.pending;\n\n\t  if (pendingQueue !== null) {\n\t    // We have new updates that haven't been processed yet.\n\t    // We'll add them to the base queue.\n\t    if (baseQueue !== null) {\n\t      // Merge the pending queue and the base queue.\n\t      var baseFirst = baseQueue.next;\n\t      var pendingFirst = pendingQueue.next;\n\t      baseQueue.next = pendingFirst;\n\t      pendingQueue.next = baseFirst;\n\t    }\n\n\t    {\n\t      if (current.baseQueue !== baseQueue) {\n\t        // Internal invariant that should never happen, but feasibly could in\n\t        // the future if we implement resuming, or some form of that.\n\t        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n\t      }\n\t    }\n\n\t    current.baseQueue = baseQueue = pendingQueue;\n\t    queue.pending = null;\n\t  }\n\n\t  if (baseQueue !== null) {\n\t    // We have a queue to process.\n\t    var first = baseQueue.next;\n\t    var newState = current.baseState;\n\t    var newBaseState = null;\n\t    var newBaseQueueFirst = null;\n\t    var newBaseQueueLast = null;\n\t    var update = first;\n\n\t    do {\n\t      var updateLane = update.lane;\n\n\t      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n\t        // Priority is insufficient. Skip this update. If this is the first\n\t        // skipped update, the previous update/state is the new base\n\t        // update/state.\n\t        var clone = {\n\t          lane: updateLane,\n\t          action: update.action,\n\t          hasEagerState: update.hasEagerState,\n\t          eagerState: update.eagerState,\n\t          next: null\n\t        };\n\n\t        if (newBaseQueueLast === null) {\n\t          newBaseQueueFirst = newBaseQueueLast = clone;\n\t          newBaseState = newState;\n\t        } else {\n\t          newBaseQueueLast = newBaseQueueLast.next = clone;\n\t        } // Update the remaining priority in the queue.\n\t        // TODO: Don't need to accumulate this. Instead, we can remove\n\t        // renderLanes from the original lanes.\n\n\n\t        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n\t        markSkippedUpdateLanes(updateLane);\n\t      } else {\n\t        // This update does have sufficient priority.\n\t        if (newBaseQueueLast !== null) {\n\t          var _clone = {\n\t            // This update is going to be committed so we never want uncommit\n\t            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n\t            // this will never be skipped by the check above.\n\t            lane: NoLane,\n\t            action: update.action,\n\t            hasEagerState: update.hasEagerState,\n\t            eagerState: update.eagerState,\n\t            next: null\n\t          };\n\t          newBaseQueueLast = newBaseQueueLast.next = _clone;\n\t        } // Process this update.\n\n\n\t        if (update.hasEagerState) {\n\t          // If this update is a state update (not a reducer) and was processed eagerly,\n\t          // we can use the eagerly computed state\n\t          newState = update.eagerState;\n\t        } else {\n\t          var action = update.action;\n\t          newState = reducer(newState, action);\n\t        }\n\t      }\n\n\t      update = update.next;\n\t    } while (update !== null && update !== first);\n\n\t    if (newBaseQueueLast === null) {\n\t      newBaseState = newState;\n\t    } else {\n\t      newBaseQueueLast.next = newBaseQueueFirst;\n\t    } // Mark that the fiber performed work, but only if the new state is\n\t    // different from the current state.\n\n\n\t    if (!objectIs(newState, hook.memoizedState)) {\n\t      markWorkInProgressReceivedUpdate();\n\t    }\n\n\t    hook.memoizedState = newState;\n\t    hook.baseState = newBaseState;\n\t    hook.baseQueue = newBaseQueueLast;\n\t    queue.lastRenderedState = newState;\n\t  } // Interleaved updates are stored on a separate queue. We aren't going to\n\t  // process them during this render, but we do need to track which lanes\n\t  // are remaining.\n\n\n\t  var lastInterleaved = queue.interleaved;\n\n\t  if (lastInterleaved !== null) {\n\t    var interleaved = lastInterleaved;\n\n\t    do {\n\t      var interleavedLane = interleaved.lane;\n\t      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n\t      markSkippedUpdateLanes(interleavedLane);\n\t      interleaved = interleaved.next;\n\t    } while (interleaved !== lastInterleaved);\n\t  } else if (baseQueue === null) {\n\t    // `queue.lanes` is used for entangling transitions. We can set it back to\n\t    // zero once the queue is empty.\n\t    queue.lanes = NoLanes;\n\t  }\n\n\t  var dispatch = queue.dispatch;\n\t  return [hook.memoizedState, dispatch];\n\t}\n\n\tfunction rerenderReducer(reducer, initialArg, init) {\n\t  var hook = updateWorkInProgressHook();\n\t  var queue = hook.queue;\n\n\t  if (queue === null) {\n\t    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n\t  }\n\n\t  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n\t  // work-in-progress hook.\n\n\t  var dispatch = queue.dispatch;\n\t  var lastRenderPhaseUpdate = queue.pending;\n\t  var newState = hook.memoizedState;\n\n\t  if (lastRenderPhaseUpdate !== null) {\n\t    // The queue doesn't persist past this render pass.\n\t    queue.pending = null;\n\t    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n\t    var update = firstRenderPhaseUpdate;\n\n\t    do {\n\t      // Process this render phase update. We don't have to check the\n\t      // priority because it will always be the same as the current\n\t      // render's.\n\t      var action = update.action;\n\t      newState = reducer(newState, action);\n\t      update = update.next;\n\t    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n\t    // different from the current state.\n\n\n\t    if (!objectIs(newState, hook.memoizedState)) {\n\t      markWorkInProgressReceivedUpdate();\n\t    }\n\n\t    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n\t    // the base state unless the queue is empty.\n\t    // TODO: Not sure if this is the desired semantics, but it's what we\n\t    // do for gDSFP. I can't remember why.\n\n\t    if (hook.baseQueue === null) {\n\t      hook.baseState = newState;\n\t    }\n\n\t    queue.lastRenderedState = newState;\n\t  }\n\n\t  return [newState, dispatch];\n\t}\n\n\tfunction mountMutableSource(source, getSnapshot, subscribe) {\n\t  {\n\t    return undefined;\n\t  }\n\t}\n\n\tfunction updateMutableSource(source, getSnapshot, subscribe) {\n\t  {\n\t    return undefined;\n\t  }\n\t}\n\n\tfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n\t  var fiber = currentlyRenderingFiber$1;\n\t  var hook = mountWorkInProgressHook();\n\t  var nextSnapshot;\n\t  var isHydrating = getIsHydrating();\n\n\t  if (isHydrating) {\n\t    if (getServerSnapshot === undefined) {\n\t      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n\t    }\n\n\t    nextSnapshot = getServerSnapshot();\n\n\t    {\n\t      if (!didWarnUncachedGetSnapshot) {\n\t        if (nextSnapshot !== getServerSnapshot()) {\n\t          error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n\n\t          didWarnUncachedGetSnapshot = true;\n\t        }\n\t      }\n\t    }\n\t  } else {\n\t    nextSnapshot = getSnapshot();\n\n\t    {\n\t      if (!didWarnUncachedGetSnapshot) {\n\t        var cachedSnapshot = getSnapshot();\n\n\t        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n\t          error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n\t          didWarnUncachedGetSnapshot = true;\n\t        }\n\t      }\n\t    } // Unless we're rendering a blocking lane, schedule a consistency check.\n\t    // Right before committing, we will walk the tree and check if any of the\n\t    // stores were mutated.\n\t    //\n\t    // We won't do this if we're hydrating server-rendered content, because if\n\t    // the content is stale, it's already visible anyway. Instead we'll patch\n\t    // it up in a passive effect.\n\n\n\t    var root = getWorkInProgressRoot();\n\n\t    if (root === null) {\n\t      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n\t    }\n\n\t    if (!includesBlockingLane(root, renderLanes)) {\n\t      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n\t    }\n\t  } // Read the current snapshot from the store on every render. This breaks the\n\t  // normal rules of React, and only works because store updates are\n\t  // always synchronous.\n\n\n\t  hook.memoizedState = nextSnapshot;\n\t  var inst = {\n\t    value: nextSnapshot,\n\t    getSnapshot: getSnapshot\n\t  };\n\t  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n\t  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n\t  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n\t  // clean-up function, and we track the deps correctly, we can call pushEffect\n\t  // directly, without storing any additional state. For the same reason, we\n\t  // don't need to set a static flag, either.\n\t  // TODO: We can move this to the passive phase once we add a pre-commit\n\t  // consistency check. See the next comment.\n\n\t  fiber.flags |= Passive;\n\t  pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n\t  return nextSnapshot;\n\t}\n\n\tfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n\t  var fiber = currentlyRenderingFiber$1;\n\t  var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n\t  // normal rules of React, and only works because store updates are\n\t  // always synchronous.\n\n\t  var nextSnapshot = getSnapshot();\n\n\t  {\n\t    if (!didWarnUncachedGetSnapshot) {\n\t      var cachedSnapshot = getSnapshot();\n\n\t      if (!objectIs(nextSnapshot, cachedSnapshot)) {\n\t        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n\t        didWarnUncachedGetSnapshot = true;\n\t      }\n\t    }\n\t  }\n\n\t  var prevSnapshot = hook.memoizedState;\n\t  var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n\n\t  if (snapshotChanged) {\n\t    hook.memoizedState = nextSnapshot;\n\t    markWorkInProgressReceivedUpdate();\n\t  }\n\n\t  var inst = hook.queue;\n\t  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n\t  // commit phase if there was an interleaved mutation. In concurrent mode\n\t  // this can happen all the time, but even in synchronous mode, an earlier\n\t  // effect may have mutated the store.\n\n\t  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n\t  // checking whether we scheduled a subscription effect above.\n\t  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n\t    fiber.flags |= Passive;\n\t    pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n\t    // Right before committing, we will walk the tree and check if any of the\n\t    // stores were mutated.\n\n\t    var root = getWorkInProgressRoot();\n\n\t    if (root === null) {\n\t      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n\t    }\n\n\t    if (!includesBlockingLane(root, renderLanes)) {\n\t      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n\t    }\n\t  }\n\n\t  return nextSnapshot;\n\t}\n\n\tfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n\t  fiber.flags |= StoreConsistency;\n\t  var check = {\n\t    getSnapshot: getSnapshot,\n\t    value: renderedSnapshot\n\t  };\n\t  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n\t  if (componentUpdateQueue === null) {\n\t    componentUpdateQueue = createFunctionComponentUpdateQueue();\n\t    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n\t    componentUpdateQueue.stores = [check];\n\t  } else {\n\t    var stores = componentUpdateQueue.stores;\n\n\t    if (stores === null) {\n\t      componentUpdateQueue.stores = [check];\n\t    } else {\n\t      stores.push(check);\n\t    }\n\t  }\n\t}\n\n\tfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n\t  // These are updated in the passive phase\n\t  inst.value = nextSnapshot;\n\t  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n\t  // have been in an event that fired before the passive effects, or it could\n\t  // have been in a layout effect. In that case, we would have used the old\n\t  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n\t  if (checkIfSnapshotChanged(inst)) {\n\t    // Force a re-render.\n\t    forceStoreRerender(fiber);\n\t  }\n\t}\n\n\tfunction subscribeToStore(fiber, inst, subscribe) {\n\t  var handleStoreChange = function () {\n\t    // The store changed. Check if the snapshot changed since the last time we\n\t    // read from the store.\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceStoreRerender(fiber);\n\t    }\n\t  }; // Subscribe to the store and return a clean-up function.\n\n\n\t  return subscribe(handleStoreChange);\n\t}\n\n\tfunction checkIfSnapshotChanged(inst) {\n\t  var latestGetSnapshot = inst.getSnapshot;\n\t  var prevValue = inst.value;\n\n\t  try {\n\t    var nextValue = latestGetSnapshot();\n\t    return !objectIs(prevValue, nextValue);\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t}\n\n\tfunction forceStoreRerender(fiber) {\n\t  var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t  if (root !== null) {\n\t    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t  }\n\t}\n\n\tfunction mountState(initialState) {\n\t  var hook = mountWorkInProgressHook();\n\n\t  if (typeof initialState === 'function') {\n\t    // $FlowFixMe: Flow doesn't like mixed types\n\t    initialState = initialState();\n\t  }\n\n\t  hook.memoizedState = hook.baseState = initialState;\n\t  var queue = {\n\t    pending: null,\n\t    interleaved: null,\n\t    lanes: NoLanes,\n\t    dispatch: null,\n\t    lastRenderedReducer: basicStateReducer,\n\t    lastRenderedState: initialState\n\t  };\n\t  hook.queue = queue;\n\t  var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n\t  return [hook.memoizedState, dispatch];\n\t}\n\n\tfunction updateState(initialState) {\n\t  return updateReducer(basicStateReducer);\n\t}\n\n\tfunction rerenderState(initialState) {\n\t  return rerenderReducer(basicStateReducer);\n\t}\n\n\tfunction pushEffect(tag, create, destroy, deps) {\n\t  var effect = {\n\t    tag: tag,\n\t    create: create,\n\t    destroy: destroy,\n\t    deps: deps,\n\t    // Circular\n\t    next: null\n\t  };\n\t  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n\t  if (componentUpdateQueue === null) {\n\t    componentUpdateQueue = createFunctionComponentUpdateQueue();\n\t    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n\t    componentUpdateQueue.lastEffect = effect.next = effect;\n\t  } else {\n\t    var lastEffect = componentUpdateQueue.lastEffect;\n\n\t    if (lastEffect === null) {\n\t      componentUpdateQueue.lastEffect = effect.next = effect;\n\t    } else {\n\t      var firstEffect = lastEffect.next;\n\t      lastEffect.next = effect;\n\t      effect.next = firstEffect;\n\t      componentUpdateQueue.lastEffect = effect;\n\t    }\n\t  }\n\n\t  return effect;\n\t}\n\n\tfunction mountRef(initialValue) {\n\t  var hook = mountWorkInProgressHook();\n\n\t  {\n\t    var _ref2 = {\n\t      current: initialValue\n\t    };\n\t    hook.memoizedState = _ref2;\n\t    return _ref2;\n\t  }\n\t}\n\n\tfunction updateRef(initialValue) {\n\t  var hook = updateWorkInProgressHook();\n\t  return hook.memoizedState;\n\t}\n\n\tfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n\t  var hook = mountWorkInProgressHook();\n\t  var nextDeps = deps === undefined ? null : deps;\n\t  currentlyRenderingFiber$1.flags |= fiberFlags;\n\t  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n\t}\n\n\tfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n\t  var hook = updateWorkInProgressHook();\n\t  var nextDeps = deps === undefined ? null : deps;\n\t  var destroy = undefined;\n\n\t  if (currentHook !== null) {\n\t    var prevEffect = currentHook.memoizedState;\n\t    destroy = prevEffect.destroy;\n\n\t    if (nextDeps !== null) {\n\t      var prevDeps = prevEffect.deps;\n\n\t      if (areHookInputsEqual(nextDeps, prevDeps)) {\n\t        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n\t        return;\n\t      }\n\t    }\n\t  }\n\n\t  currentlyRenderingFiber$1.flags |= fiberFlags;\n\t  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n\t}\n\n\tfunction mountEffect(create, deps) {\n\t  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n\t    return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n\t  } else {\n\t    return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n\t  }\n\t}\n\n\tfunction updateEffect(create, deps) {\n\t  return updateEffectImpl(Passive, Passive$1, create, deps);\n\t}\n\n\tfunction mountInsertionEffect(create, deps) {\n\t  return mountEffectImpl(Update, Insertion, create, deps);\n\t}\n\n\tfunction updateInsertionEffect(create, deps) {\n\t  return updateEffectImpl(Update, Insertion, create, deps);\n\t}\n\n\tfunction mountLayoutEffect(create, deps) {\n\t  var fiberFlags = Update;\n\n\t  {\n\t    fiberFlags |= LayoutStatic;\n\t  }\n\n\t  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n\t    fiberFlags |= MountLayoutDev;\n\t  }\n\n\t  return mountEffectImpl(fiberFlags, Layout, create, deps);\n\t}\n\n\tfunction updateLayoutEffect(create, deps) {\n\t  return updateEffectImpl(Update, Layout, create, deps);\n\t}\n\n\tfunction imperativeHandleEffect(create, ref) {\n\t  if (typeof ref === 'function') {\n\t    var refCallback = ref;\n\n\t    var _inst = create();\n\n\t    refCallback(_inst);\n\t    return function () {\n\t      refCallback(null);\n\t    };\n\t  } else if (ref !== null && ref !== undefined) {\n\t    var refObject = ref;\n\n\t    {\n\t      if (!refObject.hasOwnProperty('current')) {\n\t        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n\t      }\n\t    }\n\n\t    var _inst2 = create();\n\n\t    refObject.current = _inst2;\n\t    return function () {\n\t      refObject.current = null;\n\t    };\n\t  }\n\t}\n\n\tfunction mountImperativeHandle(ref, create, deps) {\n\t  {\n\t    if (typeof create !== 'function') {\n\t      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n\t    }\n\t  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n\t  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\t  var fiberFlags = Update;\n\n\t  {\n\t    fiberFlags |= LayoutStatic;\n\t  }\n\n\t  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n\t    fiberFlags |= MountLayoutDev;\n\t  }\n\n\t  return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n\t}\n\n\tfunction updateImperativeHandle(ref, create, deps) {\n\t  {\n\t    if (typeof create !== 'function') {\n\t      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n\t    }\n\t  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n\t  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\t  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n\t}\n\n\tfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n\t  // The react-debug-hooks package injects its own implementation\n\t  // so that e.g. DevTools can display custom hook values.\n\t}\n\n\tvar updateDebugValue = mountDebugValue;\n\n\tfunction mountCallback(callback, deps) {\n\t  var hook = mountWorkInProgressHook();\n\t  var nextDeps = deps === undefined ? null : deps;\n\t  hook.memoizedState = [callback, nextDeps];\n\t  return callback;\n\t}\n\n\tfunction updateCallback(callback, deps) {\n\t  var hook = updateWorkInProgressHook();\n\t  var nextDeps = deps === undefined ? null : deps;\n\t  var prevState = hook.memoizedState;\n\n\t  if (prevState !== null) {\n\t    if (nextDeps !== null) {\n\t      var prevDeps = prevState[1];\n\n\t      if (areHookInputsEqual(nextDeps, prevDeps)) {\n\t        return prevState[0];\n\t      }\n\t    }\n\t  }\n\n\t  hook.memoizedState = [callback, nextDeps];\n\t  return callback;\n\t}\n\n\tfunction mountMemo(nextCreate, deps) {\n\t  var hook = mountWorkInProgressHook();\n\t  var nextDeps = deps === undefined ? null : deps;\n\t  var nextValue = nextCreate();\n\t  hook.memoizedState = [nextValue, nextDeps];\n\t  return nextValue;\n\t}\n\n\tfunction updateMemo(nextCreate, deps) {\n\t  var hook = updateWorkInProgressHook();\n\t  var nextDeps = deps === undefined ? null : deps;\n\t  var prevState = hook.memoizedState;\n\n\t  if (prevState !== null) {\n\t    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n\t    if (nextDeps !== null) {\n\t      var prevDeps = prevState[1];\n\n\t      if (areHookInputsEqual(nextDeps, prevDeps)) {\n\t        return prevState[0];\n\t      }\n\t    }\n\t  }\n\n\t  var nextValue = nextCreate();\n\t  hook.memoizedState = [nextValue, nextDeps];\n\t  return nextValue;\n\t}\n\n\tfunction mountDeferredValue(value) {\n\t  var hook = mountWorkInProgressHook();\n\t  hook.memoizedState = value;\n\t  return value;\n\t}\n\n\tfunction updateDeferredValue(value) {\n\t  var hook = updateWorkInProgressHook();\n\t  var resolvedCurrentHook = currentHook;\n\t  var prevValue = resolvedCurrentHook.memoizedState;\n\t  return updateDeferredValueImpl(hook, prevValue, value);\n\t}\n\n\tfunction rerenderDeferredValue(value) {\n\t  var hook = updateWorkInProgressHook();\n\n\t  if (currentHook === null) {\n\t    // This is a rerender during a mount.\n\t    hook.memoizedState = value;\n\t    return value;\n\t  } else {\n\t    // This is a rerender during an update.\n\t    var prevValue = currentHook.memoizedState;\n\t    return updateDeferredValueImpl(hook, prevValue, value);\n\t  }\n\t}\n\n\tfunction updateDeferredValueImpl(hook, prevValue, value) {\n\t  var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n\n\t  if (shouldDeferValue) {\n\t    // This is an urgent update. If the value has changed, keep using the\n\t    // previous value and spawn a deferred render to update it later.\n\t    if (!objectIs(value, prevValue)) {\n\t      // Schedule a deferred render\n\t      var deferredLane = claimNextTransitionLane();\n\t      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n\t      markSkippedUpdateLanes(deferredLane); // Set this to true to indicate that the rendered value is inconsistent\n\t      // from the latest value. The name \"baseState\" doesn't really match how we\n\t      // use it because we're reusing a state hook field instead of creating a\n\t      // new one.\n\n\t      hook.baseState = true;\n\t    } // Reuse the previous value\n\n\n\t    return prevValue;\n\t  } else {\n\t    // This is not an urgent update, so we can use the latest value regardless\n\t    // of what it is. No need to defer it.\n\t    // However, if we're currently inside a spawned render, then we need to mark\n\t    // this as an update to prevent the fiber from bailing out.\n\t    //\n\t    // `baseState` is true when the current value is different from the rendered\n\t    // value. The name doesn't really match how we use it because we're reusing\n\t    // a state hook field instead of creating a new one.\n\t    if (hook.baseState) {\n\t      // Flip this back to false.\n\t      hook.baseState = false;\n\t      markWorkInProgressReceivedUpdate();\n\t    }\n\n\t    hook.memoizedState = value;\n\t    return value;\n\t  }\n\t}\n\n\tfunction startTransition(setPending, callback, options) {\n\t  var previousPriority = getCurrentUpdatePriority();\n\t  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n\t  setPending(true);\n\t  var prevTransition = ReactCurrentBatchConfig$1.transition;\n\t  ReactCurrentBatchConfig$1.transition = {};\n\t  var currentTransition = ReactCurrentBatchConfig$1.transition;\n\n\t  {\n\t    ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n\t  }\n\n\t  try {\n\t    setPending(false);\n\t    callback();\n\t  } finally {\n\t    setCurrentUpdatePriority(previousPriority);\n\t    ReactCurrentBatchConfig$1.transition = prevTransition;\n\n\t    {\n\t      if (prevTransition === null && currentTransition._updatedFibers) {\n\t        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n\t        if (updatedFibersCount > 10) {\n\t          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n\t        }\n\n\t        currentTransition._updatedFibers.clear();\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction mountTransition() {\n\t  var _mountState = mountState(false),\n\t      isPending = _mountState[0],\n\t      setPending = _mountState[1]; // The `start` method never changes.\n\n\n\t  var start = startTransition.bind(null, setPending);\n\t  var hook = mountWorkInProgressHook();\n\t  hook.memoizedState = start;\n\t  return [isPending, start];\n\t}\n\n\tfunction updateTransition() {\n\t  var _updateState = updateState(),\n\t      isPending = _updateState[0];\n\n\t  var hook = updateWorkInProgressHook();\n\t  var start = hook.memoizedState;\n\t  return [isPending, start];\n\t}\n\n\tfunction rerenderTransition() {\n\t  var _rerenderState = rerenderState(),\n\t      isPending = _rerenderState[0];\n\n\t  var hook = updateWorkInProgressHook();\n\t  var start = hook.memoizedState;\n\t  return [isPending, start];\n\t}\n\n\tvar isUpdatingOpaqueValueInRenderPhase = false;\n\tfunction getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n\t  {\n\t    return isUpdatingOpaqueValueInRenderPhase;\n\t  }\n\t}\n\n\tfunction mountId() {\n\t  var hook = mountWorkInProgressHook();\n\t  var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n\t  // should do this in Fiber, too? Deferring this decision for now because\n\t  // there's no other place to store the prefix except for an internal field on\n\t  // the public createRoot object, which the fiber tree does not currently have\n\t  // a reference to.\n\n\t  var identifierPrefix = root.identifierPrefix;\n\t  var id;\n\n\t  if (getIsHydrating()) {\n\t    var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n\t    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n\t    // that represents the position of this useId hook among all the useId\n\t    // hooks for this fiber.\n\n\t    var localId = localIdCounter++;\n\n\t    if (localId > 0) {\n\t      id += 'H' + localId.toString(32);\n\t    }\n\n\t    id += ':';\n\t  } else {\n\t    // Use a lowercase r prefix for client-generated ids.\n\t    var globalClientId = globalClientIdCounter++;\n\t    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n\t  }\n\n\t  hook.memoizedState = id;\n\t  return id;\n\t}\n\n\tfunction updateId() {\n\t  var hook = updateWorkInProgressHook();\n\t  var id = hook.memoizedState;\n\t  return id;\n\t}\n\n\tfunction dispatchReducerAction(fiber, queue, action) {\n\t  {\n\t    if (typeof arguments[3] === 'function') {\n\t      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n\t    }\n\t  }\n\n\t  var lane = requestUpdateLane(fiber);\n\t  var update = {\n\t    lane: lane,\n\t    action: action,\n\t    hasEagerState: false,\n\t    eagerState: null,\n\t    next: null\n\t  };\n\n\t  if (isRenderPhaseUpdate(fiber)) {\n\t    enqueueRenderPhaseUpdate(queue, update);\n\t  } else {\n\t    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n\t    if (root !== null) {\n\t      var eventTime = requestEventTime();\n\t      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t      entangleTransitionUpdate(root, queue, lane);\n\t    }\n\t  }\n\n\t  markUpdateInDevTools(fiber, lane);\n\t}\n\n\tfunction dispatchSetState(fiber, queue, action) {\n\t  {\n\t    if (typeof arguments[3] === 'function') {\n\t      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n\t    }\n\t  }\n\n\t  var lane = requestUpdateLane(fiber);\n\t  var update = {\n\t    lane: lane,\n\t    action: action,\n\t    hasEagerState: false,\n\t    eagerState: null,\n\t    next: null\n\t  };\n\n\t  if (isRenderPhaseUpdate(fiber)) {\n\t    enqueueRenderPhaseUpdate(queue, update);\n\t  } else {\n\t    var alternate = fiber.alternate;\n\n\t    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n\t      // The queue is currently empty, which means we can eagerly compute the\n\t      // next state before entering the render phase. If the new state is the\n\t      // same as the current state, we may be able to bail out entirely.\n\t      var lastRenderedReducer = queue.lastRenderedReducer;\n\n\t      if (lastRenderedReducer !== null) {\n\t        var prevDispatcher;\n\n\t        {\n\t          prevDispatcher = ReactCurrentDispatcher$1.current;\n\t          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\t        }\n\n\t        try {\n\t          var currentState = queue.lastRenderedState;\n\t          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n\t          // it, on the update object. If the reducer hasn't changed by the\n\t          // time we enter the render phase, then the eager state can be used\n\t          // without calling the reducer again.\n\n\t          update.hasEagerState = true;\n\t          update.eagerState = eagerState;\n\n\t          if (objectIs(eagerState, currentState)) {\n\t            // Fast path. We can bail out without scheduling React to re-render.\n\t            // It's still possible that we'll need to rebase this update later,\n\t            // if the component re-renders for a different reason and by that\n\t            // time the reducer has changed.\n\t            // TODO: Do we still need to entangle transitions in this case?\n\t            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);\n\t            return;\n\t          }\n\t        } catch (error) {// Suppress the error. It will throw again in the render phase.\n\t        } finally {\n\t          {\n\t            ReactCurrentDispatcher$1.current = prevDispatcher;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n\t    if (root !== null) {\n\t      var eventTime = requestEventTime();\n\t      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t      entangleTransitionUpdate(root, queue, lane);\n\t    }\n\t  }\n\n\t  markUpdateInDevTools(fiber, lane);\n\t}\n\n\tfunction isRenderPhaseUpdate(fiber) {\n\t  var alternate = fiber.alternate;\n\t  return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n\t}\n\n\tfunction enqueueRenderPhaseUpdate(queue, update) {\n\t  // This is a render phase update. Stash it in a lazily-created map of\n\t  // queue -> linked list of updates. After this render pass, we'll restart\n\t  // and apply the stashed updates on top of the work-in-progress hook.\n\t  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n\t  var pending = queue.pending;\n\n\t  if (pending === null) {\n\t    // This is the first update. Create a circular list.\n\t    update.next = update;\n\t  } else {\n\t    update.next = pending.next;\n\t    pending.next = update;\n\t  }\n\n\t  queue.pending = update;\n\t} // TODO: Move to ReactFiberConcurrentUpdates?\n\n\n\tfunction entangleTransitionUpdate(root, queue, lane) {\n\t  if (isTransitionLane(lane)) {\n\t    var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n\t    // must have finished. We can remove them from the shared queue, which\n\t    // represents a superset of the actually pending lanes. In some cases we\n\t    // may entangle more than we need to, but that's OK. In fact it's worse if\n\t    // we *don't* entangle when we should.\n\n\t    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n\t    var newQueueLanes = mergeLanes(queueLanes, lane);\n\t    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n\t    // the lane finished since the last time we entangled it. So we need to\n\t    // entangle it again, just to be sure.\n\n\t    markRootEntangled(root, newQueueLanes);\n\t  }\n\t}\n\n\tfunction markUpdateInDevTools(fiber, lane, action) {\n\n\t  {\n\t    markStateUpdateScheduled(fiber, lane);\n\t  }\n\t}\n\n\tvar ContextOnlyDispatcher = {\n\t  readContext: readContext,\n\t  useCallback: throwInvalidHookError,\n\t  useContext: throwInvalidHookError,\n\t  useEffect: throwInvalidHookError,\n\t  useImperativeHandle: throwInvalidHookError,\n\t  useInsertionEffect: throwInvalidHookError,\n\t  useLayoutEffect: throwInvalidHookError,\n\t  useMemo: throwInvalidHookError,\n\t  useReducer: throwInvalidHookError,\n\t  useRef: throwInvalidHookError,\n\t  useState: throwInvalidHookError,\n\t  useDebugValue: throwInvalidHookError,\n\t  useDeferredValue: throwInvalidHookError,\n\t  useTransition: throwInvalidHookError,\n\t  useMutableSource: throwInvalidHookError,\n\t  useSyncExternalStore: throwInvalidHookError,\n\t  useId: throwInvalidHookError,\n\t  unstable_isNewReconciler: enableNewReconciler\n\t};\n\n\tvar HooksDispatcherOnMountInDEV = null;\n\tvar HooksDispatcherOnMountWithHookTypesInDEV = null;\n\tvar HooksDispatcherOnUpdateInDEV = null;\n\tvar HooksDispatcherOnRerenderInDEV = null;\n\tvar InvalidNestedHooksDispatcherOnMountInDEV = null;\n\tvar InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n\tvar InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\n\t{\n\t  var warnInvalidContextAccess = function () {\n\t    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n\t  };\n\n\t  var warnInvalidHookAccess = function () {\n\t    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n\t  };\n\n\t  HooksDispatcherOnMountInDEV = {\n\t    readContext: function (context) {\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      mountHookTypesDev();\n\t      checkDepsAreArrayDev(deps);\n\t      return mountCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      mountHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      mountHookTypesDev();\n\t      checkDepsAreArrayDev(deps);\n\t      return mountEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      mountHookTypesDev();\n\t      checkDepsAreArrayDev(deps);\n\t      return mountImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      mountHookTypesDev();\n\t      checkDepsAreArrayDev(deps);\n\t      return mountInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      mountHookTypesDev();\n\t      checkDepsAreArrayDev(deps);\n\t      return mountLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      mountHookTypesDev();\n\t      checkDepsAreArrayDev(deps);\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      mountHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      mountHookTypesDev();\n\t      return mountRef(initialValue);\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      mountHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      mountHookTypesDev();\n\t      return mountDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      mountHookTypesDev();\n\t      return mountDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      mountHookTypesDev();\n\t      return mountTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      mountHookTypesDev();\n\t      return mountMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      mountHookTypesDev();\n\t      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      mountHookTypesDev();\n\t      return mountId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\n\t  HooksDispatcherOnMountWithHookTypesInDEV = {\n\t    readContext: function (context) {\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      updateHookTypesDev();\n\t      return mountCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      updateHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      updateHookTypesDev();\n\t      return mountEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      updateHookTypesDev();\n\t      return mountImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      updateHookTypesDev();\n\t      return mountInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      updateHookTypesDev();\n\t      return mountLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      updateHookTypesDev();\n\t      return mountRef(initialValue);\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      updateHookTypesDev();\n\t      return mountDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      updateHookTypesDev();\n\t      return mountDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      updateHookTypesDev();\n\t      return mountTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      updateHookTypesDev();\n\t      return mountMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      updateHookTypesDev();\n\t      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      updateHookTypesDev();\n\t      return mountId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\n\t  HooksDispatcherOnUpdateInDEV = {\n\t    readContext: function (context) {\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      updateHookTypesDev();\n\t      return updateCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      updateHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      updateHookTypesDev();\n\t      return updateEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      updateHookTypesDev();\n\t      return updateImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      updateHookTypesDev();\n\t      return updateInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      updateHookTypesDev();\n\t      return updateLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      updateHookTypesDev();\n\t      return updateRef();\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      updateHookTypesDev();\n\t      return updateDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      updateHookTypesDev();\n\t      return updateDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      updateHookTypesDev();\n\t      return updateTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      updateHookTypesDev();\n\t      return updateMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      updateHookTypesDev();\n\t      return updateSyncExternalStore(subscribe, getSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      updateHookTypesDev();\n\t      return updateId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\n\t  HooksDispatcherOnRerenderInDEV = {\n\t    readContext: function (context) {\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      updateHookTypesDev();\n\t      return updateCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      updateHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      updateHookTypesDev();\n\t      return updateEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      updateHookTypesDev();\n\t      return updateImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      updateHookTypesDev();\n\t      return updateInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      updateHookTypesDev();\n\t      return updateLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n\t      try {\n\t        return updateMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n\t      try {\n\t        return rerenderReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      updateHookTypesDev();\n\t      return updateRef();\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n\t      try {\n\t        return rerenderState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      updateHookTypesDev();\n\t      return updateDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      updateHookTypesDev();\n\t      return rerenderDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      updateHookTypesDev();\n\t      return rerenderTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      updateHookTypesDev();\n\t      return updateMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      updateHookTypesDev();\n\t      return updateSyncExternalStore(subscribe, getSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      updateHookTypesDev();\n\t      return updateId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\n\t  InvalidNestedHooksDispatcherOnMountInDEV = {\n\t    readContext: function (context) {\n\t      warnInvalidContextAccess();\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountRef(initialValue);\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n\t      try {\n\t        return mountState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      warnInvalidHookAccess();\n\t      mountHookTypesDev();\n\t      return mountId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\n\t  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n\t    readContext: function (context) {\n\t      warnInvalidContextAccess();\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateRef();\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateSyncExternalStore(subscribe, getSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\n\t  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n\t    readContext: function (context) {\n\t      warnInvalidContextAccess();\n\t      return readContext(context);\n\t    },\n\t    useCallback: function (callback, deps) {\n\t      currentHookNameInDev = 'useCallback';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateCallback(callback, deps);\n\t    },\n\t    useContext: function (context) {\n\t      currentHookNameInDev = 'useContext';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return readContext(context);\n\t    },\n\t    useEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useEffect';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateEffect(create, deps);\n\t    },\n\t    useImperativeHandle: function (ref, create, deps) {\n\t      currentHookNameInDev = 'useImperativeHandle';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateImperativeHandle(ref, create, deps);\n\t    },\n\t    useInsertionEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useInsertionEffect';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateInsertionEffect(create, deps);\n\t    },\n\t    useLayoutEffect: function (create, deps) {\n\t      currentHookNameInDev = 'useLayoutEffect';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateLayoutEffect(create, deps);\n\t    },\n\t    useMemo: function (create, deps) {\n\t      currentHookNameInDev = 'useMemo';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return updateMemo(create, deps);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useReducer: function (reducer, initialArg, init) {\n\t      currentHookNameInDev = 'useReducer';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return rerenderReducer(reducer, initialArg, init);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useRef: function (initialValue) {\n\t      currentHookNameInDev = 'useRef';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateRef();\n\t    },\n\t    useState: function (initialState) {\n\t      currentHookNameInDev = 'useState';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      var prevDispatcher = ReactCurrentDispatcher$1.current;\n\t      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n\t      try {\n\t        return rerenderState(initialState);\n\t      } finally {\n\t        ReactCurrentDispatcher$1.current = prevDispatcher;\n\t      }\n\t    },\n\t    useDebugValue: function (value, formatterFn) {\n\t      currentHookNameInDev = 'useDebugValue';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateDebugValue();\n\t    },\n\t    useDeferredValue: function (value) {\n\t      currentHookNameInDev = 'useDeferredValue';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return rerenderDeferredValue(value);\n\t    },\n\t    useTransition: function () {\n\t      currentHookNameInDev = 'useTransition';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return rerenderTransition();\n\t    },\n\t    useMutableSource: function (source, getSnapshot, subscribe) {\n\t      currentHookNameInDev = 'useMutableSource';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateMutableSource();\n\t    },\n\t    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n\t      currentHookNameInDev = 'useSyncExternalStore';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateSyncExternalStore(subscribe, getSnapshot);\n\t    },\n\t    useId: function () {\n\t      currentHookNameInDev = 'useId';\n\t      warnInvalidHookAccess();\n\t      updateHookTypesDev();\n\t      return updateId();\n\t    },\n\t    unstable_isNewReconciler: enableNewReconciler\n\t  };\n\t}\n\n\tvar now$1 = Scheduler.unstable_now;\n\tvar commitTime = 0;\n\tvar layoutEffectStartTime = -1;\n\tvar profilerStartTime = -1;\n\tvar passiveEffectStartTime = -1;\n\t/**\n\t * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n\t *\n\t * The overall sequence is:\n\t *   1. render\n\t *   2. commit (and call `onRender`, `onCommit`)\n\t *   3. check for nested updates\n\t *   4. flush passive effects (and call `onPostCommit`)\n\t *\n\t * Nested updates are identified in step 3 above,\n\t * but step 4 still applies to the work that was just committed.\n\t * We use two flags to track nested updates then:\n\t * one tracks whether the upcoming update is a nested update,\n\t * and the other tracks whether the current update was a nested update.\n\t * The first value gets synced to the second at the start of the render phase.\n\t */\n\n\tvar currentUpdateIsNested = false;\n\tvar nestedUpdateScheduled = false;\n\n\tfunction isCurrentUpdateNested() {\n\t  return currentUpdateIsNested;\n\t}\n\n\tfunction markNestedUpdateScheduled() {\n\t  {\n\t    nestedUpdateScheduled = true;\n\t  }\n\t}\n\n\tfunction resetNestedUpdateFlag() {\n\t  {\n\t    currentUpdateIsNested = false;\n\t    nestedUpdateScheduled = false;\n\t  }\n\t}\n\n\tfunction syncNestedUpdateFlag() {\n\t  {\n\t    currentUpdateIsNested = nestedUpdateScheduled;\n\t    nestedUpdateScheduled = false;\n\t  }\n\t}\n\n\tfunction getCommitTime() {\n\t  return commitTime;\n\t}\n\n\tfunction recordCommitTime() {\n\n\t  commitTime = now$1();\n\t}\n\n\tfunction startProfilerTimer(fiber) {\n\n\t  profilerStartTime = now$1();\n\n\t  if (fiber.actualStartTime < 0) {\n\t    fiber.actualStartTime = now$1();\n\t  }\n\t}\n\n\tfunction stopProfilerTimerIfRunning(fiber) {\n\n\t  profilerStartTime = -1;\n\t}\n\n\tfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n\n\t  if (profilerStartTime >= 0) {\n\t    var elapsedTime = now$1() - profilerStartTime;\n\t    fiber.actualDuration += elapsedTime;\n\n\t    if (overrideBaseTime) {\n\t      fiber.selfBaseDuration = elapsedTime;\n\t    }\n\n\t    profilerStartTime = -1;\n\t  }\n\t}\n\n\tfunction recordLayoutEffectDuration(fiber) {\n\n\t  if (layoutEffectStartTime >= 0) {\n\t    var elapsedTime = now$1() - layoutEffectStartTime;\n\t    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n\t    // Or the root (for the DevTools Profiler to read)\n\n\t    var parentFiber = fiber.return;\n\n\t    while (parentFiber !== null) {\n\t      switch (parentFiber.tag) {\n\t        case HostRoot:\n\t          var root = parentFiber.stateNode;\n\t          root.effectDuration += elapsedTime;\n\t          return;\n\n\t        case Profiler:\n\t          var parentStateNode = parentFiber.stateNode;\n\t          parentStateNode.effectDuration += elapsedTime;\n\t          return;\n\t      }\n\n\t      parentFiber = parentFiber.return;\n\t    }\n\t  }\n\t}\n\n\tfunction recordPassiveEffectDuration(fiber) {\n\n\t  if (passiveEffectStartTime >= 0) {\n\t    var elapsedTime = now$1() - passiveEffectStartTime;\n\t    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n\t    // Or the root (for the DevTools Profiler to read)\n\n\t    var parentFiber = fiber.return;\n\n\t    while (parentFiber !== null) {\n\t      switch (parentFiber.tag) {\n\t        case HostRoot:\n\t          var root = parentFiber.stateNode;\n\n\t          if (root !== null) {\n\t            root.passiveEffectDuration += elapsedTime;\n\t          }\n\n\t          return;\n\n\t        case Profiler:\n\t          var parentStateNode = parentFiber.stateNode;\n\n\t          if (parentStateNode !== null) {\n\t            // Detached fibers have their state node cleared out.\n\t            // In this case, the return pointer is also cleared out,\n\t            // so we won't be able to report the time spent in this Profiler's subtree.\n\t            parentStateNode.passiveEffectDuration += elapsedTime;\n\t          }\n\n\t          return;\n\t      }\n\n\t      parentFiber = parentFiber.return;\n\t    }\n\t  }\n\t}\n\n\tfunction startLayoutEffectTimer() {\n\n\t  layoutEffectStartTime = now$1();\n\t}\n\n\tfunction startPassiveEffectTimer() {\n\n\t  passiveEffectStartTime = now$1();\n\t}\n\n\tfunction transferActualDuration(fiber) {\n\t  // Transfer time spent rendering these children so we don't lose it\n\t  // after we rerender. This is used as a helper in special cases\n\t  // where we should count the work of multiple passes.\n\t  var child = fiber.child;\n\n\t  while (child) {\n\t    fiber.actualDuration += child.actualDuration;\n\t    child = child.sibling;\n\t  }\n\t}\n\n\tfunction createCapturedValueAtFiber(value, source) {\n\t  // If the value is an error, call this function immediately after it is thrown\n\t  // so the stack is accurate.\n\t  return {\n\t    value: value,\n\t    source: source,\n\t    stack: getStackByFiberInDevAndProd(source),\n\t    digest: null\n\t  };\n\t}\n\tfunction createCapturedValue(value, digest, stack) {\n\t  return {\n\t    value: value,\n\t    source: null,\n\t    stack: stack != null ? stack : null,\n\t    digest: digest != null ? digest : null\n\t  };\n\t}\n\n\t// This module is forked in different environments.\n\t// By default, return `true` to log errors to the console.\n\t// Forks can return `false` if this isn't desirable.\n\tfunction showErrorDialog(boundary, errorInfo) {\n\t  return true;\n\t}\n\n\tfunction logCapturedError(boundary, errorInfo) {\n\t  try {\n\t    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n\t    // This enables renderers like ReactNative to better manage redbox behavior.\n\n\t    if (logError === false) {\n\t      return;\n\t    }\n\n\t    var error = errorInfo.value;\n\n\t    if (true) {\n\t      var source = errorInfo.source;\n\t      var stack = errorInfo.stack;\n\t      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling\n\t      // `preventDefault()` in window `error` handler.\n\t      // We record this information as an expando on the error.\n\n\t      if (error != null && error._suppressLogging) {\n\t        if (boundary.tag === ClassComponent) {\n\t          // The error is recoverable and was silenced.\n\t          // Ignore it and don't print the stack addendum.\n\t          // This is handy for testing error boundaries without noise.\n\t          return;\n\t        } // The error is fatal. Since the silencing might have\n\t        // been accidental, we'll surface it anyway.\n\t        // However, the browser would have silenced the original error\n\t        // so we'll print it first, and then print the stack addendum.\n\n\n\t        console['error'](error); // Don't transform to our wrapper\n\t        // For a more detailed description of this block, see:\n\t        // https://github.com/facebook/react/pull/13384\n\t      }\n\n\t      var componentName = source ? getComponentNameFromFiber(source) : null;\n\t      var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : 'The above error occurred in one of your React components:';\n\t      var errorBoundaryMessage;\n\n\t      if (boundary.tag === HostRoot) {\n\t        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';\n\t      } else {\n\t        var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous';\n\t        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n\t      }\n\n\t      var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n\t      // We don't include the original error message and JS stack because the browser\n\t      // has already printed it. Even if the application swallows the error, it is still\n\t      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n\t      console['error'](combinedMessage); // Don't transform to our wrapper\n\t    }\n\t  } catch (e) {\n\t    // This method must not throw, or React internal state will get messed up.\n\t    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n\t    // we want to report this error outside of the normal stack as a last resort.\n\t    // https://github.com/facebook/react/issues/13188\n\t    setTimeout(function () {\n\t      throw e;\n\t    });\n\t  }\n\t}\n\n\tvar PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n\n\tfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n\t  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n\t  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n\t  // being called \"element\".\n\n\t  update.payload = {\n\t    element: null\n\t  };\n\t  var error = errorInfo.value;\n\n\t  update.callback = function () {\n\t    onUncaughtError(error);\n\t    logCapturedError(fiber, errorInfo);\n\t  };\n\n\t  return update;\n\t}\n\n\tfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n\t  var update = createUpdate(NoTimestamp, lane);\n\t  update.tag = CaptureUpdate;\n\t  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n\t  if (typeof getDerivedStateFromError === 'function') {\n\t    var error$1 = errorInfo.value;\n\n\t    update.payload = function () {\n\t      return getDerivedStateFromError(error$1);\n\t    };\n\n\t    update.callback = function () {\n\t      {\n\t        markFailedErrorBoundaryForHotReloading(fiber);\n\t      }\n\n\t      logCapturedError(fiber, errorInfo);\n\t    };\n\t  }\n\n\t  var inst = fiber.stateNode;\n\n\t  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n\t    update.callback = function callback() {\n\t      {\n\t        markFailedErrorBoundaryForHotReloading(fiber);\n\t      }\n\n\t      logCapturedError(fiber, errorInfo);\n\n\t      if (typeof getDerivedStateFromError !== 'function') {\n\t        // To preserve the preexisting retry behavior of error boundaries,\n\t        // we keep track of which ones already failed during this batch.\n\t        // This gets reset before we yield back to the browser.\n\t        // TODO: Warn in strict mode if getDerivedStateFromError is\n\t        // not defined.\n\t        markLegacyErrorBoundaryAsFailed(this);\n\t      }\n\n\t      var error$1 = errorInfo.value;\n\t      var stack = errorInfo.stack;\n\t      this.componentDidCatch(error$1, {\n\t        componentStack: stack !== null ? stack : ''\n\t      });\n\n\t      {\n\t        if (typeof getDerivedStateFromError !== 'function') {\n\t          // If componentDidCatch is the only error boundary method defined,\n\t          // then it needs to call setState to recover from errors.\n\t          // If no state update is scheduled then the boundary will swallow the error.\n\t          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n\t            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n\t          }\n\t        }\n\t      }\n\t    };\n\t  }\n\n\t  return update;\n\t}\n\n\tfunction attachPingListener(root, wakeable, lanes) {\n\t  // Attach a ping listener\n\t  //\n\t  // The data might resolve before we have a chance to commit the fallback. Or,\n\t  // in the case of a refresh, we'll never commit a fallback. So we need to\n\t  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n\t  // try rendering the tree again.\n\t  //\n\t  // Only attach a listener if one does not already exist for the lanes\n\t  // we're currently rendering (which acts like a \"thread ID\" here).\n\t  //\n\t  // We only need to do this in concurrent mode. Legacy Suspense always\n\t  // commits fallbacks synchronously, so there are no pings.\n\t  var pingCache = root.pingCache;\n\t  var threadIDs;\n\n\t  if (pingCache === null) {\n\t    pingCache = root.pingCache = new PossiblyWeakMap$1();\n\t    threadIDs = new Set();\n\t    pingCache.set(wakeable, threadIDs);\n\t  } else {\n\t    threadIDs = pingCache.get(wakeable);\n\n\t    if (threadIDs === undefined) {\n\t      threadIDs = new Set();\n\t      pingCache.set(wakeable, threadIDs);\n\t    }\n\t  }\n\n\t  if (!threadIDs.has(lanes)) {\n\t    // Memoize using the thread ID to prevent redundant listeners.\n\t    threadIDs.add(lanes);\n\t    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n\t    {\n\t      if (isDevToolsPresent) {\n\t        // If we have pending work still, restore the original updaters\n\t        restorePendingUpdaters(root, lanes);\n\t      }\n\t    }\n\n\t    wakeable.then(ping, ping);\n\t  }\n\t}\n\n\tfunction attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n\t  // Retry listener\n\t  //\n\t  // If the fallback does commit, we need to attach a different type of\n\t  // listener. This one schedules an update on the Suspense boundary to turn\n\t  // the fallback state off.\n\t  //\n\t  // Stash the wakeable on the boundary fiber so we can access it in the\n\t  // commit phase.\n\t  //\n\t  // When the wakeable resolves, we'll attempt to render the boundary\n\t  // again (\"retry\").\n\t  var wakeables = suspenseBoundary.updateQueue;\n\n\t  if (wakeables === null) {\n\t    var updateQueue = new Set();\n\t    updateQueue.add(wakeable);\n\t    suspenseBoundary.updateQueue = updateQueue;\n\t  } else {\n\t    wakeables.add(wakeable);\n\t  }\n\t}\n\n\tfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n\t  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n\t  var tag = sourceFiber.tag;\n\n\t  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n\t    var currentSource = sourceFiber.alternate;\n\n\t    if (currentSource) {\n\t      sourceFiber.updateQueue = currentSource.updateQueue;\n\t      sourceFiber.memoizedState = currentSource.memoizedState;\n\t      sourceFiber.lanes = currentSource.lanes;\n\t    } else {\n\t      sourceFiber.updateQueue = null;\n\t      sourceFiber.memoizedState = null;\n\t    }\n\t  }\n\t}\n\n\tfunction getNearestSuspenseBoundaryToCapture(returnFiber) {\n\t  var node = returnFiber;\n\n\t  do {\n\t    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n\t      return node;\n\t    } // This boundary already captured during this render. Continue to the next\n\t    // boundary.\n\n\n\t    node = node.return;\n\t  } while (node !== null);\n\n\t  return null;\n\t}\n\n\tfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n\t  // This marks a Suspense boundary so that when we're unwinding the stack,\n\t  // it captures the suspended \"exception\" and does a second (fallback) pass.\n\t  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n\t    // Legacy Mode Suspense\n\t    //\n\t    // If the boundary is in legacy mode, we should *not*\n\t    // suspend the commit. Pretend as if the suspended component rendered\n\t    // null and keep rendering. When the Suspense boundary completes,\n\t    // we'll do a second pass to render the fallback.\n\t    if (suspenseBoundary === returnFiber) {\n\t      // Special case where we suspended while reconciling the children of\n\t      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n\t      // when a React.lazy component is a direct child of a\n\t      // Suspense boundary.\n\t      //\n\t      // Suspense boundaries are implemented as multiple fibers, but they\n\t      // are a single conceptual unit. The legacy mode behavior where we\n\t      // pretend the suspended fiber committed as `null` won't work,\n\t      // because in this case the \"suspended\" fiber is the inner\n\t      // Offscreen wrapper.\n\t      //\n\t      // Because the contents of the boundary haven't started rendering\n\t      // yet (i.e. nothing in the tree has partially rendered) we can\n\t      // switch to the regular, concurrent mode behavior: mark the\n\t      // boundary with ShouldCapture and enter the unwind phase.\n\t      suspenseBoundary.flags |= ShouldCapture;\n\t    } else {\n\t      suspenseBoundary.flags |= DidCapture;\n\t      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n\t      // But we shouldn't call any lifecycle methods or callbacks. Remove\n\t      // all lifecycle effect tags.\n\n\t      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n\t      if (sourceFiber.tag === ClassComponent) {\n\t        var currentSourceFiber = sourceFiber.alternate;\n\n\t        if (currentSourceFiber === null) {\n\t          // This is a new mount. Change the tag so it's not mistaken for a\n\t          // completed class component. For example, we should not call\n\t          // componentWillUnmount if it is deleted.\n\t          sourceFiber.tag = IncompleteClassComponent;\n\t        } else {\n\t          // When we try rendering again, we should not reuse the current fiber,\n\t          // since it's known to be in an inconsistent state. Use a force update to\n\t          // prevent a bail out.\n\t          var update = createUpdate(NoTimestamp, SyncLane);\n\t          update.tag = ForceUpdate;\n\t          enqueueUpdate(sourceFiber, update, SyncLane);\n\t        }\n\t      } // The source fiber did not complete. Mark it with Sync priority to\n\t      // indicate that it still has pending work.\n\n\n\t      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n\t    }\n\n\t    return suspenseBoundary;\n\t  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n\t  // with the normal suspend path.\n\t  //\n\t  // After this we'll use a set of heuristics to determine whether this\n\t  // render pass will run to completion or restart or \"suspend\" the commit.\n\t  // The actual logic for this is spread out in different places.\n\t  //\n\t  // This first principle is that if we're going to suspend when we complete\n\t  // a root, then we should also restart if we get an update or ping that\n\t  // might unsuspend it, and vice versa. The only reason to suspend is\n\t  // because you think you might want to restart before committing. However,\n\t  // it doesn't make sense to restart only while in the period we're suspended.\n\t  //\n\t  // Restarting too aggressively is also not good because it starves out any\n\t  // intermediate loading state. So we use heuristics to determine when.\n\t  // Suspense Heuristics\n\t  //\n\t  // If nothing threw a Promise or all the same fallbacks are already showing,\n\t  // then don't suspend/restart.\n\t  //\n\t  // If this is an initial render of a new tree of Suspense boundaries and\n\t  // those trigger a fallback, then don't suspend/restart. We want to ensure\n\t  // that we can show the initial loading state as quickly as possible.\n\t  //\n\t  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n\t  // a fallback, then we should always suspend/restart. Transitions apply\n\t  // to this case. If none is defined, JND is used instead.\n\t  //\n\t  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n\t  // another level, but there's still an inner boundary that would show a fallback,\n\t  // then we suspend/restart for 500ms since the last time we showed a fallback\n\t  // anywhere in the tree. This effectively throttles progressive loading into a\n\t  // consistent train of commits. This also gives us an opportunity to restart to\n\t  // get to the completed state slightly earlier.\n\t  //\n\t  // If there's ambiguity due to batching it's resolved in preference of:\n\t  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n\t  //\n\t  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n\t  // ensure that new initial loading states can commit as soon as possible.\n\n\n\t  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n\t  // the begin phase to prevent an early bailout.\n\n\t  suspenseBoundary.lanes = rootRenderLanes;\n\t  return suspenseBoundary;\n\t}\n\n\tfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n\t  // The source fiber did not complete.\n\t  sourceFiber.flags |= Incomplete;\n\n\t  {\n\t    if (isDevToolsPresent) {\n\t      // If we have pending work still, restore the original updaters\n\t      restorePendingUpdaters(root, rootRenderLanes);\n\t    }\n\t  }\n\n\t  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n\t    // This is a wakeable. The component suspended.\n\t    var wakeable = value;\n\t    resetSuspendedComponent(sourceFiber);\n\n\t    {\n\t      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n\t        markDidThrowWhileHydratingDEV();\n\t      }\n\t    }\n\n\n\t    var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n\n\t    if (suspenseBoundary !== null) {\n\t      suspenseBoundary.flags &= ~ForceClientRender;\n\t      markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n\t      // commits fallbacks synchronously, so there are no pings.\n\n\t      if (suspenseBoundary.mode & ConcurrentMode) {\n\t        attachPingListener(root, wakeable, rootRenderLanes);\n\t      }\n\n\t      attachRetryListener(suspenseBoundary, root, wakeable);\n\t      return;\n\t    } else {\n\t      // No boundary was found. Unless this is a sync update, this is OK.\n\t      // We can suspend and wait for more data to arrive.\n\t      if (!includesSyncLane(rootRenderLanes)) {\n\t        // This is not a sync update. Suspend. Since we're not activating a\n\t        // Suspense boundary, this will unwind all the way to the root without\n\t        // performing a second pass to render a fallback. (This is arguably how\n\t        // refresh transitions should work, too, since we're not going to commit\n\t        // the fallbacks anyway.)\n\t        //\n\t        // This case also applies to initial hydration.\n\t        attachPingListener(root, wakeable, rootRenderLanes);\n\t        renderDidSuspendDelayIfPossible();\n\t        return;\n\t      } // This is a sync/discrete update. We treat this case like an error\n\t      // because discrete renders are expected to produce a complete tree\n\t      // synchronously to maintain consistency with external state.\n\n\n\t      var uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.'); // If we're outside a transition, fall through to the regular error path.\n\t      // The error will be caught by the nearest suspense boundary.\n\n\t      value = uncaughtSuspenseError;\n\t    }\n\t  } else {\n\t    // This is a regular error, not a Suspense wakeable.\n\t    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n\t      markDidThrowWhileHydratingDEV();\n\n\t      var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n\t      // discarding the dehydrated content and switching to a client render.\n\t      // Instead of surfacing the error, find the nearest Suspense boundary\n\t      // and render it again without hydration.\n\n\n\t      if (_suspenseBoundary !== null) {\n\t        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n\t          // Set a flag to indicate that we should try rendering the normal\n\t          // children again, not the fallback.\n\t          _suspenseBoundary.flags |= ForceClientRender;\n\t        }\n\n\t        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n\t        // still log it so it can be fixed.\n\n\t        queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n\t        return;\n\t      }\n\t    }\n\t  }\n\n\t  value = createCapturedValueAtFiber(value, sourceFiber);\n\t  renderDidError(value); // We didn't find a boundary that could handle this type of exception. Start\n\t  // over and traverse parent path again, this time treating the exception\n\t  // as an error.\n\n\t  var workInProgress = returnFiber;\n\n\t  do {\n\t    switch (workInProgress.tag) {\n\t      case HostRoot:\n\t        {\n\t          var _errorInfo = value;\n\t          workInProgress.flags |= ShouldCapture;\n\t          var lane = pickArbitraryLane(rootRenderLanes);\n\t          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n\t          var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n\t          enqueueCapturedUpdate(workInProgress, update);\n\t          return;\n\t        }\n\n\t      case ClassComponent:\n\t        // Capture and retry\n\t        var errorInfo = value;\n\t        var ctor = workInProgress.type;\n\t        var instance = workInProgress.stateNode;\n\n\t        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n\t          workInProgress.flags |= ShouldCapture;\n\n\t          var _lane = pickArbitraryLane(rootRenderLanes);\n\n\t          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n\n\t          var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n\n\t          enqueueCapturedUpdate(workInProgress, _update);\n\t          return;\n\t        }\n\n\t        break;\n\t    }\n\n\t    workInProgress = workInProgress.return;\n\t  } while (workInProgress !== null);\n\t}\n\n\tfunction getSuspendedCache() {\n\t  {\n\t    return null;\n\t  } // This function is called when a Suspense boundary suspends. It returns the\n\t}\n\n\tvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n\tvar didReceiveUpdate = false;\n\tvar didWarnAboutBadClass;\n\tvar didWarnAboutModulePatternComponent;\n\tvar didWarnAboutContextTypeOnFunctionComponent;\n\tvar didWarnAboutGetDerivedStateOnFunctionComponent;\n\tvar didWarnAboutFunctionRefs;\n\tvar didWarnAboutReassigningProps;\n\tvar didWarnAboutRevealOrder;\n\tvar didWarnAboutTailOptions;\n\n\t{\n\t  didWarnAboutBadClass = {};\n\t  didWarnAboutModulePatternComponent = {};\n\t  didWarnAboutContextTypeOnFunctionComponent = {};\n\t  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n\t  didWarnAboutFunctionRefs = {};\n\t  didWarnAboutReassigningProps = false;\n\t  didWarnAboutRevealOrder = {};\n\t  didWarnAboutTailOptions = {};\n\t}\n\n\tfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n\t  if (current === null) {\n\t    // If this is a fresh new component that hasn't been rendered yet, we\n\t    // won't update its child set by applying minimal side-effects. Instead,\n\t    // we will add them all to the child before it gets rendered. That means\n\t    // we can optimize this reconciliation pass by not tracking side-effects.\n\t    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n\t  } else {\n\t    // If the current child is the same as the work in progress, it means that\n\t    // we haven't yet started any work on these children. Therefore, we use\n\t    // the clone algorithm to create a copy of all the current children.\n\t    // If we had any progressed work already, that is invalid at this point so\n\t    // let's throw it out.\n\t    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n\t  }\n\t}\n\n\tfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n\t  // This function is fork of reconcileChildren. It's used in cases where we\n\t  // want to reconcile without matching against the existing set. This has the\n\t  // effect of all current children being unmounted; even if the type and key\n\t  // are the same, the old child is unmounted and a new child is created.\n\t  //\n\t  // To do this, we're going to go through the reconcile algorithm twice. In\n\t  // the first pass, we schedule a deletion for all the current children by\n\t  // passing null.\n\t  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n\t  // pass null in place of where we usually pass the current child set. This has\n\t  // the effect of remounting all children regardless of whether their\n\t  // identities match.\n\n\t  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n\t}\n\n\tfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n\t  // TODO: current can be non-null here even if the component\n\t  // hasn't yet mounted. This happens after the first render suspends.\n\t  // We'll need to figure out if this is fine or can cause issues.\n\t  {\n\t    if (workInProgress.type !== workInProgress.elementType) {\n\t      // Lazy component props can't be validated in createElement\n\t      // because they're only guaranteed to be resolved here.\n\t      var innerPropTypes = Component.propTypes;\n\n\t      if (innerPropTypes) {\n\t        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n\t        'prop', getComponentNameFromType(Component));\n\t      }\n\t    }\n\t  }\n\n\t  var render = Component.render;\n\t  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n\t  var nextChildren;\n\t  var hasId;\n\t  prepareToReadContext(workInProgress, renderLanes);\n\n\t  {\n\t    markComponentRenderStarted(workInProgress);\n\t  }\n\n\t  {\n\t    ReactCurrentOwner$1.current = workInProgress;\n\t    setIsRendering(true);\n\t    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n\t    hasId = checkDidRenderIdHook();\n\n\t    if ( workInProgress.mode & StrictLegacyMode) {\n\t      setIsStrictModeForDevtools(true);\n\n\t      try {\n\t        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n\t        hasId = checkDidRenderIdHook();\n\t      } finally {\n\t        setIsStrictModeForDevtools(false);\n\t      }\n\t    }\n\n\t    setIsRendering(false);\n\t  }\n\n\t  {\n\t    markComponentRenderStopped();\n\t  }\n\n\t  if (current !== null && !didReceiveUpdate) {\n\t    bailoutHooks(current, workInProgress, renderLanes);\n\t    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t  }\n\n\t  if (getIsHydrating() && hasId) {\n\t    pushMaterializedTreeId(workInProgress);\n\t  } // React DevTools reads this flag.\n\n\n\t  workInProgress.flags |= PerformedWork;\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n\t  if (current === null) {\n\t    var type = Component.type;\n\n\t    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n\t    Component.defaultProps === undefined) {\n\t      var resolvedType = type;\n\n\t      {\n\t        resolvedType = resolveFunctionForHotReloading(type);\n\t      } // If this is a plain function component without default props,\n\t      // and with only the default shallow comparison, we upgrade it\n\t      // to a SimpleMemoComponent to allow fast path updates.\n\n\n\t      workInProgress.tag = SimpleMemoComponent;\n\t      workInProgress.type = resolvedType;\n\n\t      {\n\t        validateFunctionComponentInDev(workInProgress, type);\n\t      }\n\n\t      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n\t    }\n\n\t    {\n\t      var innerPropTypes = type.propTypes;\n\n\t      if (innerPropTypes) {\n\t        // Inner memo component props aren't currently validated in createElement.\n\t        // We could move it there, but we'd still need this for lazy code path.\n\t        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n\t        'prop', getComponentNameFromType(type));\n\t      }\n\t    }\n\n\t    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n\t    child.ref = workInProgress.ref;\n\t    child.return = workInProgress;\n\t    workInProgress.child = child;\n\t    return child;\n\t  }\n\n\t  {\n\t    var _type = Component.type;\n\t    var _innerPropTypes = _type.propTypes;\n\n\t    if (_innerPropTypes) {\n\t      // Inner memo component props aren't currently validated in createElement.\n\t      // We could move it there, but we'd still need this for lazy code path.\n\t      checkPropTypes(_innerPropTypes, nextProps, // Resolved props\n\t      'prop', getComponentNameFromType(_type));\n\t    }\n\t  }\n\n\t  var currentChild = current.child; // This is always exactly one child\n\n\t  var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n\t  if (!hasScheduledUpdateOrContext) {\n\t    // This will be the props with resolved defaultProps,\n\t    // unlike current.memoizedProps which will be the unresolved ones.\n\t    var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n\t    var compare = Component.compare;\n\t    compare = compare !== null ? compare : shallowEqual;\n\n\t    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n\t      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t    }\n\t  } // React DevTools reads this flag.\n\n\n\t  workInProgress.flags |= PerformedWork;\n\t  var newChild = createWorkInProgress(currentChild, nextProps);\n\t  newChild.ref = workInProgress.ref;\n\t  newChild.return = workInProgress;\n\t  workInProgress.child = newChild;\n\t  return newChild;\n\t}\n\n\tfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n\t  // TODO: current can be non-null here even if the component\n\t  // hasn't yet mounted. This happens when the inner render suspends.\n\t  // We'll need to figure out if this is fine or can cause issues.\n\t  {\n\t    if (workInProgress.type !== workInProgress.elementType) {\n\t      // Lazy component props can't be validated in createElement\n\t      // because they're only guaranteed to be resolved here.\n\t      var outerMemoType = workInProgress.elementType;\n\n\t      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n\t        // We warn when you define propTypes on lazy()\n\t        // so let's just skip over it to find memo() outer wrapper.\n\t        // Inner props for memo are validated later.\n\t        var lazyComponent = outerMemoType;\n\t        var payload = lazyComponent._payload;\n\t        var init = lazyComponent._init;\n\n\t        try {\n\t          outerMemoType = init(payload);\n\t        } catch (x) {\n\t          outerMemoType = null;\n\t        } // Inner propTypes will be validated in the function component path.\n\n\n\t        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n\t        if (outerPropTypes) {\n\t          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n\t          'prop', getComponentNameFromType(outerMemoType));\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  if (current !== null) {\n\t    var prevProps = current.memoizedProps;\n\n\t    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n\t     workInProgress.type === current.type )) {\n\t      didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n\t      // would during a normal fiber bailout.\n\t      //\n\t      // We don't have strong guarantees that the props object is referentially\n\t      // equal during updates where we can't bail out anyway  like if the props\n\t      // are shallowly equal, but there's a local state or context update in the\n\t      // same batch.\n\t      //\n\t      // However, as a principle, we should aim to make the behavior consistent\n\t      // across different ways of memoizing a component. For example, React.memo\n\t      // has a different internal Fiber layout if you pass a normal function\n\t      // component (SimpleMemoComponent) versus if you pass a different type\n\t      // like forwardRef (MemoComponent). But this is an implementation detail.\n\t      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n\t      // affect whether the props object is reused during a bailout.\n\n\t      workInProgress.pendingProps = nextProps = prevProps;\n\n\t      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n\t        // The pending lanes were cleared at the beginning of beginWork. We're\n\t        // about to bail out, but there might be other lanes that weren't\n\t        // included in the current render. Usually, the priority level of the\n\t        // remaining updates is accumulated during the evaluation of the\n\t        // component (i.e. when processing the update queue). But since since\n\t        // we're bailing out early *without* evaluating the component, we need\n\t        // to account for it here, too. Reset to the value of the current fiber.\n\t        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n\t        // because a MemoComponent fiber does not have hooks or an update queue;\n\t        // rather, it wraps around an inner component, which may or may not\n\t        // contains hooks.\n\t        // TODO: Move the reset at in beginWork out of the common path so that\n\t        // this is no longer necessary.\n\t        workInProgress.lanes = current.lanes;\n\t        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n\t        // This is a special case that only exists for legacy mode.\n\t        // See https://github.com/facebook/react/pull/19216.\n\t        didReceiveUpdate = true;\n\t      }\n\t    }\n\t  }\n\n\t  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n\t}\n\n\tfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n\t  var nextProps = workInProgress.pendingProps;\n\t  var nextChildren = nextProps.children;\n\t  var prevState = current !== null ? current.memoizedState : null;\n\n\t  if (nextProps.mode === 'hidden' || enableLegacyHidden ) {\n\t    // Rendering a hidden tree.\n\t    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n\t      // In legacy sync mode, don't defer the subtree. Render it now.\n\t      // TODO: Consider how Offscreen should work with transitions in the future\n\t      var nextState = {\n\t        baseLanes: NoLanes,\n\t        cachePool: null,\n\t        transitions: null\n\t      };\n\t      workInProgress.memoizedState = nextState;\n\n\t      pushRenderLanes(workInProgress, renderLanes);\n\t    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n\t      var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n\t      // and resume this tree later.\n\n\t      var nextBaseLanes;\n\n\t      if (prevState !== null) {\n\t        var prevBaseLanes = prevState.baseLanes;\n\t        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n\t      } else {\n\t        nextBaseLanes = renderLanes;\n\t      } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n\t      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n\t      var _nextState = {\n\t        baseLanes: nextBaseLanes,\n\t        cachePool: spawnedCachePool,\n\t        transitions: null\n\t      };\n\t      workInProgress.memoizedState = _nextState;\n\t      workInProgress.updateQueue = null;\n\t      // to avoid a push/pop misalignment.\n\n\n\t      pushRenderLanes(workInProgress, nextBaseLanes);\n\n\t      return null;\n\t    } else {\n\t      // This is the second render. The surrounding visible content has already\n\t      // committed. Now we resume rendering the hidden tree.\n\t      // Rendering at offscreen, so we can clear the base lanes.\n\t      var _nextState2 = {\n\t        baseLanes: NoLanes,\n\t        cachePool: null,\n\t        transitions: null\n\t      };\n\t      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n\n\t      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n\n\t      pushRenderLanes(workInProgress, subtreeRenderLanes);\n\t    }\n\t  } else {\n\t    // Rendering a visible tree.\n\t    var _subtreeRenderLanes;\n\n\t    if (prevState !== null) {\n\t      // We're going from hidden -> visible.\n\t      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n\n\t      workInProgress.memoizedState = null;\n\t    } else {\n\t      // We weren't previously hidden, and we still aren't, so there's nothing\n\t      // special to do. Need to push to the stack regardless, though, to avoid\n\t      // a push/pop misalignment.\n\t      _subtreeRenderLanes = renderLanes;\n\t    }\n\n\t    pushRenderLanes(workInProgress, _subtreeRenderLanes);\n\t  }\n\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t} // Note: These happen to have identical begin phases, for now. We shouldn't hold\n\n\tfunction updateFragment(current, workInProgress, renderLanes) {\n\t  var nextChildren = workInProgress.pendingProps;\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction updateMode(current, workInProgress, renderLanes) {\n\t  var nextChildren = workInProgress.pendingProps.children;\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction updateProfiler(current, workInProgress, renderLanes) {\n\t  {\n\t    workInProgress.flags |= Update;\n\n\t    {\n\t      // Reset effect durations for the next eventual effect phase.\n\t      // These are reset during render to allow the DevTools commit hook a chance to read them,\n\t      var stateNode = workInProgress.stateNode;\n\t      stateNode.effectDuration = 0;\n\t      stateNode.passiveEffectDuration = 0;\n\t    }\n\t  }\n\n\t  var nextProps = workInProgress.pendingProps;\n\t  var nextChildren = nextProps.children;\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction markRef(current, workInProgress) {\n\t  var ref = workInProgress.ref;\n\n\t  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n\t    // Schedule a Ref effect\n\t    workInProgress.flags |= Ref;\n\n\t    {\n\t      workInProgress.flags |= RefStatic;\n\t    }\n\t  }\n\t}\n\n\tfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n\t  {\n\t    if (workInProgress.type !== workInProgress.elementType) {\n\t      // Lazy component props can't be validated in createElement\n\t      // because they're only guaranteed to be resolved here.\n\t      var innerPropTypes = Component.propTypes;\n\n\t      if (innerPropTypes) {\n\t        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n\t        'prop', getComponentNameFromType(Component));\n\t      }\n\t    }\n\t  }\n\n\t  var context;\n\n\t  {\n\t    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n\t    context = getMaskedContext(workInProgress, unmaskedContext);\n\t  }\n\n\t  var nextChildren;\n\t  var hasId;\n\t  prepareToReadContext(workInProgress, renderLanes);\n\n\t  {\n\t    markComponentRenderStarted(workInProgress);\n\t  }\n\n\t  {\n\t    ReactCurrentOwner$1.current = workInProgress;\n\t    setIsRendering(true);\n\t    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n\t    hasId = checkDidRenderIdHook();\n\n\t    if ( workInProgress.mode & StrictLegacyMode) {\n\t      setIsStrictModeForDevtools(true);\n\n\t      try {\n\t        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n\t        hasId = checkDidRenderIdHook();\n\t      } finally {\n\t        setIsStrictModeForDevtools(false);\n\t      }\n\t    }\n\n\t    setIsRendering(false);\n\t  }\n\n\t  {\n\t    markComponentRenderStopped();\n\t  }\n\n\t  if (current !== null && !didReceiveUpdate) {\n\t    bailoutHooks(current, workInProgress, renderLanes);\n\t    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t  }\n\n\t  if (getIsHydrating() && hasId) {\n\t    pushMaterializedTreeId(workInProgress);\n\t  } // React DevTools reads this flag.\n\n\n\t  workInProgress.flags |= PerformedWork;\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n\t  {\n\t    // This is used by DevTools to force a boundary to error.\n\t    switch (shouldError(workInProgress)) {\n\t      case false:\n\t        {\n\t          var _instance = workInProgress.stateNode;\n\t          var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n\t          // Is there a better way to do this?\n\n\t          var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n\t          var state = tempInstance.state;\n\n\t          _instance.updater.enqueueSetState(_instance, state, null);\n\n\t          break;\n\t        }\n\n\t      case true:\n\t        {\n\t          workInProgress.flags |= DidCapture;\n\t          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n\t          var error$1 = new Error('Simulated error coming from DevTools');\n\t          var lane = pickArbitraryLane(renderLanes);\n\t          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n\t          var update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error$1, workInProgress), lane);\n\t          enqueueCapturedUpdate(workInProgress, update);\n\t          break;\n\t        }\n\t    }\n\n\t    if (workInProgress.type !== workInProgress.elementType) {\n\t      // Lazy component props can't be validated in createElement\n\t      // because they're only guaranteed to be resolved here.\n\t      var innerPropTypes = Component.propTypes;\n\n\t      if (innerPropTypes) {\n\t        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n\t        'prop', getComponentNameFromType(Component));\n\t      }\n\t    }\n\t  } // Push context providers early to prevent context stack mismatches.\n\t  // During mounting we don't know the child context yet as the instance doesn't exist.\n\t  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n\t  var hasContext;\n\n\t  if (isContextProvider(Component)) {\n\t    hasContext = true;\n\t    pushContextProvider(workInProgress);\n\t  } else {\n\t    hasContext = false;\n\t  }\n\n\t  prepareToReadContext(workInProgress, renderLanes);\n\t  var instance = workInProgress.stateNode;\n\t  var shouldUpdate;\n\n\t  if (instance === null) {\n\t    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); // In the initial pass we might need to construct the instance.\n\n\t    constructClassInstance(workInProgress, Component, nextProps);\n\t    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n\t    shouldUpdate = true;\n\t  } else if (current === null) {\n\t    // In a resume, we'll already have an instance we can reuse.\n\t    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n\t  } else {\n\t    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n\t  }\n\n\t  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n\t  {\n\t    var inst = workInProgress.stateNode;\n\n\t    if (shouldUpdate && inst.props !== nextProps) {\n\t      if (!didWarnAboutReassigningProps) {\n\t        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n\t      }\n\n\t      didWarnAboutReassigningProps = true;\n\t    }\n\t  }\n\n\t  return nextUnitOfWork;\n\t}\n\n\tfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n\t  // Refs should update even if shouldComponentUpdate returns false\n\t  markRef(current, workInProgress);\n\t  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n\t  if (!shouldUpdate && !didCaptureError) {\n\t    // Context providers should defer to sCU for rendering\n\t    if (hasContext) {\n\t      invalidateContextProvider(workInProgress, Component, false);\n\t    }\n\n\t    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t  }\n\n\t  var instance = workInProgress.stateNode; // Rerender\n\n\t  ReactCurrentOwner$1.current = workInProgress;\n\t  var nextChildren;\n\n\t  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n\t    // If we captured an error, but getDerivedStateFromError is not defined,\n\t    // unmount all the children. componentDidCatch will schedule an update to\n\t    // re-render a fallback. This is temporary until we migrate everyone to\n\t    // the new API.\n\t    // TODO: Warn in a future release.\n\t    nextChildren = null;\n\n\t    {\n\t      stopProfilerTimerIfRunning();\n\t    }\n\t  } else {\n\t    {\n\t      markComponentRenderStarted(workInProgress);\n\t    }\n\n\t    {\n\t      setIsRendering(true);\n\t      nextChildren = instance.render();\n\n\t      if ( workInProgress.mode & StrictLegacyMode) {\n\t        setIsStrictModeForDevtools(true);\n\n\t        try {\n\t          instance.render();\n\t        } finally {\n\t          setIsStrictModeForDevtools(false);\n\t        }\n\t      }\n\n\t      setIsRendering(false);\n\t    }\n\n\t    {\n\t      markComponentRenderStopped();\n\t    }\n\t  } // React DevTools reads this flag.\n\n\n\t  workInProgress.flags |= PerformedWork;\n\n\t  if (current !== null && didCaptureError) {\n\t    // If we're recovering from an error, reconcile without reusing any of\n\t    // the existing children. Conceptually, the normal children and the children\n\t    // that are shown on error are two different sets, so we shouldn't reuse\n\t    // normal children even if their identities match.\n\t    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n\t  } else {\n\t    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  } // Memoize state using the values we just used to render.\n\t  // TODO: Restructure so we never read values from the instance.\n\n\n\t  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n\t  if (hasContext) {\n\t    invalidateContextProvider(workInProgress, Component, true);\n\t  }\n\n\t  return workInProgress.child;\n\t}\n\n\tfunction pushHostRootContext(workInProgress) {\n\t  var root = workInProgress.stateNode;\n\n\t  if (root.pendingContext) {\n\t    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n\t  } else if (root.context) {\n\t    // Should always be set\n\t    pushTopLevelContextObject(workInProgress, root.context, false);\n\t  }\n\n\t  pushHostContainer(workInProgress, root.containerInfo);\n\t}\n\n\tfunction updateHostRoot(current, workInProgress, renderLanes) {\n\t  pushHostRootContext(workInProgress);\n\n\t  if (current === null) {\n\t    throw new Error('Should have a current fiber. This is a bug in React.');\n\t  }\n\n\t  var nextProps = workInProgress.pendingProps;\n\t  var prevState = workInProgress.memoizedState;\n\t  var prevChildren = prevState.element;\n\t  cloneUpdateQueue(current, workInProgress);\n\t  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n\t  var nextState = workInProgress.memoizedState;\n\t  workInProgress.stateNode;\n\t  // being called \"element\".\n\n\n\t  var nextChildren = nextState.element;\n\n\t  if (supportsHydration && prevState.isDehydrated) {\n\t    // This is a hydration root whose shell has not yet hydrated. We should\n\t    // attempt to hydrate.\n\t    // Flip isDehydrated to false to indicate that when this render\n\t    // finishes, the root will no longer be dehydrated.\n\t    var overrideState = {\n\t      element: nextChildren,\n\t      isDehydrated: false,\n\t      cache: nextState.cache,\n\t      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n\t      transitions: nextState.transitions\n\t    };\n\t    var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n\t    // have reducer functions so it doesn't need rebasing.\n\n\t    updateQueue.baseState = overrideState;\n\t    workInProgress.memoizedState = overrideState;\n\n\t    if (workInProgress.flags & ForceClientRender) {\n\t      // Something errored during a previous attempt to hydrate the shell, so we\n\t      // forced a client render.\n\t      var recoverableError = createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.'), workInProgress);\n\t      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n\t    } else if (nextChildren !== prevChildren) {\n\t      var _recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n\n\t      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n\t    } else {\n\t      // The outermost shell has not hydrated yet. Start hydrating.\n\t      enterHydrationState(workInProgress);\n\n\t      var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n\t      workInProgress.child = child;\n\t      var node = child;\n\n\t      while (node) {\n\t        // Mark each child as hydrating. This is a fast path to know whether this\n\t        // tree is part of a hydrating tree. This is used to determine if a child\n\t        // node has fully mounted yet, and for scheduling event replaying.\n\t        // Conceptually this is similar to Placement in that a new subtree is\n\t        // inserted into the React tree here. It just happens to not need DOM\n\t        // mutations because it already exists.\n\t        node.flags = node.flags & ~Placement | Hydrating;\n\t        node = node.sibling;\n\t      }\n\t    }\n\t  } else {\n\t    // Root is not dehydrated. Either this is a client-only root, or it\n\t    // already hydrated.\n\t    resetHydrationState();\n\n\t    if (nextChildren === prevChildren) {\n\t      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t    }\n\n\t    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  }\n\n\t  return workInProgress.child;\n\t}\n\n\tfunction mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n\t  // Revert to client rendering.\n\t  resetHydrationState();\n\t  queueHydrationError(recoverableError);\n\t  workInProgress.flags |= ForceClientRender;\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction updateHostComponent(current, workInProgress, renderLanes) {\n\t  pushHostContext(workInProgress);\n\n\t  if (current === null) {\n\t    tryToClaimNextHydratableInstance(workInProgress);\n\t  }\n\n\t  var type = workInProgress.type;\n\t  var nextProps = workInProgress.pendingProps;\n\t  var prevProps = current !== null ? current.memoizedProps : null;\n\t  var nextChildren = nextProps.children;\n\t  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n\t  if (isDirectTextChild) {\n\t    // We special case a direct text child of a host node. This is a common\n\t    // case. We won't handle it as a reified child. We will instead handle\n\t    // this in the host environment that also has access to this prop. That\n\t    // avoids allocating another HostText fiber and traversing it.\n\t    nextChildren = null;\n\t  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n\t    // If we're switching from a direct text child to a normal child, or to\n\t    // empty, we need to schedule the text content to be reset.\n\t    workInProgress.flags |= ContentReset;\n\t  }\n\n\t  markRef(current, workInProgress);\n\t  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction updateHostText(current, workInProgress) {\n\t  if (current === null) {\n\t    tryToClaimNextHydratableInstance(workInProgress);\n\t  } // Nothing to do here. This is terminal. We'll do the completion step\n\t  // immediately after.\n\n\n\t  return null;\n\t}\n\n\tfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n\t  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n\t  var props = workInProgress.pendingProps;\n\t  var lazyComponent = elementType;\n\t  var payload = lazyComponent._payload;\n\t  var init = lazyComponent._init;\n\t  var Component = init(payload); // Store the unwrapped component in the type.\n\n\t  workInProgress.type = Component;\n\t  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n\t  var resolvedProps = resolveDefaultProps(Component, props);\n\t  var child;\n\n\t  switch (resolvedTag) {\n\t    case FunctionComponent:\n\t      {\n\t        {\n\t          validateFunctionComponentInDev(workInProgress, Component);\n\t          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n\t        }\n\n\t        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n\t        return child;\n\t      }\n\n\t    case ClassComponent:\n\t      {\n\t        {\n\t          workInProgress.type = Component = resolveClassForHotReloading(Component);\n\t        }\n\n\t        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n\t        return child;\n\t      }\n\n\t    case ForwardRef:\n\t      {\n\t        {\n\t          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n\t        }\n\n\t        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n\t        return child;\n\t      }\n\n\t    case MemoComponent:\n\t      {\n\t        {\n\t          if (workInProgress.type !== workInProgress.elementType) {\n\t            var outerPropTypes = Component.propTypes;\n\n\t            if (outerPropTypes) {\n\t              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n\t              'prop', getComponentNameFromType(Component));\n\t            }\n\t          }\n\t        }\n\n\t        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n\t        renderLanes);\n\t        return child;\n\t      }\n\t  }\n\n\t  var hint = '';\n\n\t  {\n\t    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n\t      hint = ' Did you wrap a component in React.lazy() more than once?';\n\t    }\n\t  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n\t  // because the fact that it's a separate type of work is an\n\t  // implementation detail.\n\n\n\t  throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n\t}\n\n\tfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n\t  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); // Promote the fiber to a class and try rendering again.\n\n\t  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n\t  // Push context providers early to prevent context stack mismatches.\n\t  // During mounting we don't know the child context yet as the instance doesn't exist.\n\t  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\t  var hasContext;\n\n\t  if (isContextProvider(Component)) {\n\t    hasContext = true;\n\t    pushContextProvider(workInProgress);\n\t  } else {\n\t    hasContext = false;\n\t  }\n\n\t  prepareToReadContext(workInProgress, renderLanes);\n\t  constructClassInstance(workInProgress, Component, nextProps);\n\t  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n\t  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n\t}\n\n\tfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n\t  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n\t  var props = workInProgress.pendingProps;\n\t  var context;\n\n\t  {\n\t    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n\t    context = getMaskedContext(workInProgress, unmaskedContext);\n\t  }\n\n\t  prepareToReadContext(workInProgress, renderLanes);\n\t  var value;\n\t  var hasId;\n\n\t  {\n\t    markComponentRenderStarted(workInProgress);\n\t  }\n\n\t  {\n\t    if (Component.prototype && typeof Component.prototype.render === 'function') {\n\t      var componentName = getComponentNameFromType(Component) || 'Unknown';\n\n\t      if (!didWarnAboutBadClass[componentName]) {\n\t        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n\n\t        didWarnAboutBadClass[componentName] = true;\n\t      }\n\t    }\n\n\t    if (workInProgress.mode & StrictLegacyMode) {\n\t      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n\t    }\n\n\t    setIsRendering(true);\n\t    ReactCurrentOwner$1.current = workInProgress;\n\t    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n\t    hasId = checkDidRenderIdHook();\n\t    setIsRendering(false);\n\t  }\n\n\t  {\n\t    markComponentRenderStopped();\n\t  } // React DevTools reads this flag.\n\n\n\t  workInProgress.flags |= PerformedWork;\n\n\t  {\n\t    // Support for module components is deprecated and is removed behind a flag.\n\t    // Whether or not it would crash later, we want to show a good message in DEV first.\n\t    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n\t      var _componentName = getComponentNameFromType(Component) || 'Unknown';\n\n\t      if (!didWarnAboutModulePatternComponent[_componentName]) {\n\t        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);\n\n\t        didWarnAboutModulePatternComponent[_componentName] = true;\n\t      }\n\t    }\n\t  }\n\n\t  if ( // Run these checks in production only if the flag is off.\n\t  // Eventually we'll delete this branch altogether.\n\t   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n\t    {\n\t      var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n\n\t      if (!didWarnAboutModulePatternComponent[_componentName2]) {\n\t        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);\n\n\t        didWarnAboutModulePatternComponent[_componentName2] = true;\n\t      }\n\t    } // Proceed under the assumption that this is a class instance\n\n\n\t    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n\t    workInProgress.memoizedState = null;\n\t    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n\t    // During mounting we don't know the child context yet as the instance doesn't exist.\n\t    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\t    var hasContext = false;\n\n\t    if (isContextProvider(Component)) {\n\t      hasContext = true;\n\t      pushContextProvider(workInProgress);\n\t    } else {\n\t      hasContext = false;\n\t    }\n\n\t    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n\t    initializeUpdateQueue(workInProgress);\n\t    adoptClassInstance(workInProgress, value);\n\t    mountClassInstance(workInProgress, Component, props, renderLanes);\n\t    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n\t  } else {\n\t    // Proceed under the assumption that this is a function component\n\t    workInProgress.tag = FunctionComponent;\n\n\t    {\n\n\t      if ( workInProgress.mode & StrictLegacyMode) {\n\t        setIsStrictModeForDevtools(true);\n\n\t        try {\n\t          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n\t          hasId = checkDidRenderIdHook();\n\t        } finally {\n\t          setIsStrictModeForDevtools(false);\n\t        }\n\t      }\n\t    }\n\n\t    if (getIsHydrating() && hasId) {\n\t      pushMaterializedTreeId(workInProgress);\n\t    }\n\n\t    reconcileChildren(null, workInProgress, value, renderLanes);\n\n\t    {\n\t      validateFunctionComponentInDev(workInProgress, Component);\n\t    }\n\n\t    return workInProgress.child;\n\t  }\n\t}\n\n\tfunction validateFunctionComponentInDev(workInProgress, Component) {\n\t  {\n\t    if (Component) {\n\t      if (Component.childContextTypes) {\n\t        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n\t      }\n\t    }\n\n\t    if (workInProgress.ref !== null) {\n\t      var info = '';\n\t      var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n\t      if (ownerName) {\n\t        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n\t      }\n\n\t      var warningKey = ownerName || '';\n\t      var debugSource = workInProgress._debugSource;\n\n\t      if (debugSource) {\n\t        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n\t      }\n\n\t      if (!didWarnAboutFunctionRefs[warningKey]) {\n\t        didWarnAboutFunctionRefs[warningKey] = true;\n\n\t        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n\t      }\n\t    }\n\n\t    if (typeof Component.getDerivedStateFromProps === 'function') {\n\t      var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n\n\t      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n\t        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);\n\n\t        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n\t      }\n\t    }\n\n\t    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n\t      var _componentName4 = getComponentNameFromType(Component) || 'Unknown';\n\n\t      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n\t        error('%s: Function components do not support contextType.', _componentName4);\n\n\t        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n\t      }\n\t    }\n\t  }\n\t}\n\n\tvar SUSPENDED_MARKER = {\n\t  dehydrated: null,\n\t  treeContext: null,\n\t  retryLane: NoLane\n\t};\n\n\tfunction mountSuspenseOffscreenState(renderLanes) {\n\t  return {\n\t    baseLanes: renderLanes,\n\t    cachePool: getSuspendedCache(),\n\t    transitions: null\n\t  };\n\t}\n\n\tfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n\t  var cachePool = null;\n\n\t  return {\n\t    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n\t    cachePool: cachePool,\n\t    transitions: prevOffscreenState.transitions\n\t  };\n\t} // TODO: Probably should inline this back\n\n\n\tfunction shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n\t  // If we're already showing a fallback, there are cases where we need to\n\t  // remain on that fallback regardless of whether the content has resolved.\n\t  // For example, SuspenseList coordinates when nested content appears.\n\t  if (current !== null) {\n\t    var suspenseState = current.memoizedState;\n\n\t    if (suspenseState === null) {\n\t      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n\t      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n\t      // Note: This is a factoring smell. Can't remain on a fallback if there's\n\t      // no fallback to remain on.\n\t      return false;\n\t    }\n\t  } // Not currently showing content. Consult the Suspense context.\n\n\n\t  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\t}\n\n\tfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n\t  // TODO: Should not remove render lanes that were pinged during this render\n\t  return removeLanes(current.childLanes, renderLanes);\n\t}\n\n\tfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n\t  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n\t  {\n\t    if (shouldSuspend(workInProgress)) {\n\t      workInProgress.flags |= DidCapture;\n\t    }\n\t  }\n\n\t  var suspenseContext = suspenseStackCursor.current;\n\t  var showFallback = false;\n\t  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n\t  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n\t    // Something in this boundary's subtree already suspended. Switch to\n\t    // rendering the fallback children.\n\t    showFallback = true;\n\t    workInProgress.flags &= ~DidCapture;\n\t  } else {\n\t    // Attempting the main content\n\t    if (current === null || current.memoizedState !== null) {\n\t      // This is a new mount or this boundary is already showing a fallback state.\n\t      // Mark this subtree context as having at least one invisible parent that could\n\t      // handle the fallback state.\n\t      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n\t      {\n\t        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n\t      }\n\t    }\n\t  }\n\n\t  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n\t  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n\t  // boundary's children. This involves some custom reconciliation logic. Two\n\t  // main reasons this is so complicated.\n\t  //\n\t  // First, Legacy Mode has different semantics for backwards compatibility. The\n\t  // primary tree will commit in an inconsistent state, so when we do the\n\t  // second pass to render the fallback, we do some exceedingly, uh, clever\n\t  // hacks to make that not totally break. Like transferring effects and\n\t  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n\t  // because we bailout on the primary tree completely and leave it in its old\n\t  // state, no effects. Same as what we do for Offscreen (except that\n\t  // Offscreen doesn't have the first render pass).\n\t  //\n\t  // Second is hydration. During hydration, the Suspense fiber has a slightly\n\t  // different layout, where the child points to a dehydrated fragment, which\n\t  // contains the DOM rendered by the server.\n\t  //\n\t  // Third, even if you set all that aside, Suspense is like error boundaries in\n\t  // that we first we try to render one tree, and if that fails, we render again\n\t  // and switch to a different tree. Like a try/catch block. So we have to track\n\t  // which branch we're currently rendering. Ideally we would model this using\n\t  // a stack.\n\n\t  if (current === null) {\n\t    // Initial mount\n\t    // Special path for hydration\n\t    // If we're currently hydrating, try to hydrate this boundary.\n\t    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n\t    var suspenseState = workInProgress.memoizedState;\n\n\t    if (suspenseState !== null) {\n\t      var dehydrated = suspenseState.dehydrated;\n\n\t      if (dehydrated !== null) {\n\t        return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n\t      }\n\t    }\n\n\t    var nextPrimaryChildren = nextProps.children;\n\t    var nextFallbackChildren = nextProps.fallback;\n\n\t    if (showFallback) {\n\t      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n\t      var primaryChildFragment = workInProgress.child;\n\t      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n\t      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n\t      return fallbackFragment;\n\t    } else {\n\t      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n\t    }\n\t  } else {\n\t    // This is an update.\n\t    // Special path for hydration\n\t    var prevState = current.memoizedState;\n\n\t    if (prevState !== null) {\n\t      var _dehydrated = prevState.dehydrated;\n\n\t      if (_dehydrated !== null) {\n\t        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, _dehydrated, prevState, renderLanes);\n\t      }\n\t    }\n\n\t    if (showFallback) {\n\t      var _nextFallbackChildren = nextProps.fallback;\n\t      var _nextPrimaryChildren = nextProps.children;\n\t      var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n\t      var _primaryChildFragment2 = workInProgress.child;\n\t      var prevOffscreenState = current.child.memoizedState;\n\t      _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n\n\t      _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n\t      workInProgress.memoizedState = SUSPENDED_MARKER;\n\t      return fallbackChildFragment;\n\t    } else {\n\t      var _nextPrimaryChildren2 = nextProps.children;\n\n\t      var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2, renderLanes);\n\n\t      workInProgress.memoizedState = null;\n\t      return _primaryChildFragment3;\n\t    }\n\t  }\n\t}\n\n\tfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n\t  var mode = workInProgress.mode;\n\t  var primaryChildProps = {\n\t    mode: 'visible',\n\t    children: primaryChildren\n\t  };\n\t  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n\t  primaryChildFragment.return = workInProgress;\n\t  workInProgress.child = primaryChildFragment;\n\t  return primaryChildFragment;\n\t}\n\n\tfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n\t  var mode = workInProgress.mode;\n\t  var progressedPrimaryFragment = workInProgress.child;\n\t  var primaryChildProps = {\n\t    mode: 'hidden',\n\t    children: primaryChildren\n\t  };\n\t  var primaryChildFragment;\n\t  var fallbackChildFragment;\n\n\t  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n\t    // In legacy mode, we commit the primary tree as if it successfully\n\t    // completed, even though it's in an inconsistent state.\n\t    primaryChildFragment = progressedPrimaryFragment;\n\t    primaryChildFragment.childLanes = NoLanes;\n\t    primaryChildFragment.pendingProps = primaryChildProps;\n\n\t    if ( workInProgress.mode & ProfileMode) {\n\t      // Reset the durations from the first pass so they aren't included in the\n\t      // final amounts. This seems counterintuitive, since we're intentionally\n\t      // not measuring part of the render phase, but this makes it match what we\n\t      // do in Concurrent Mode.\n\t      primaryChildFragment.actualDuration = 0;\n\t      primaryChildFragment.actualStartTime = -1;\n\t      primaryChildFragment.selfBaseDuration = 0;\n\t      primaryChildFragment.treeBaseDuration = 0;\n\t    }\n\n\t    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n\t  } else {\n\t    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n\t    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n\t  }\n\n\t  primaryChildFragment.return = workInProgress;\n\t  fallbackChildFragment.return = workInProgress;\n\t  primaryChildFragment.sibling = fallbackChildFragment;\n\t  workInProgress.child = primaryChildFragment;\n\t  return fallbackChildFragment;\n\t}\n\n\tfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n\t  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n\t  // this wrapper function to constrain it.\n\t  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n\t}\n\n\tfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n\t  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n\t  // wrapper function to constrain it.\n\t  return createWorkInProgress(current, offscreenProps);\n\t}\n\n\tfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n\t  var currentPrimaryChildFragment = current.child;\n\t  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n\t  var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n\t    mode: 'visible',\n\t    children: primaryChildren\n\t  });\n\n\t  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n\t    primaryChildFragment.lanes = renderLanes;\n\t  }\n\n\t  primaryChildFragment.return = workInProgress;\n\t  primaryChildFragment.sibling = null;\n\n\t  if (currentFallbackChildFragment !== null) {\n\t    // Delete the fallback child fragment\n\t    var deletions = workInProgress.deletions;\n\n\t    if (deletions === null) {\n\t      workInProgress.deletions = [currentFallbackChildFragment];\n\t      workInProgress.flags |= ChildDeletion;\n\t    } else {\n\t      deletions.push(currentFallbackChildFragment);\n\t    }\n\t  }\n\n\t  workInProgress.child = primaryChildFragment;\n\t  return primaryChildFragment;\n\t}\n\n\tfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n\t  var mode = workInProgress.mode;\n\t  var currentPrimaryChildFragment = current.child;\n\t  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n\t  var primaryChildProps = {\n\t    mode: 'hidden',\n\t    children: primaryChildren\n\t  };\n\t  var primaryChildFragment;\n\n\t  if ( // In legacy mode, we commit the primary tree as if it successfully\n\t  // completed, even though it's in an inconsistent state.\n\t  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n\t  // already cloned. In legacy mode, the only case where this isn't true is\n\t  // when DevTools forces us to display a fallback; we skip the first render\n\t  // pass entirely and go straight to rendering the fallback. (In Concurrent\n\t  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n\t  // only codepath.)\n\t  workInProgress.child !== currentPrimaryChildFragment) {\n\t    var progressedPrimaryFragment = workInProgress.child;\n\t    primaryChildFragment = progressedPrimaryFragment;\n\t    primaryChildFragment.childLanes = NoLanes;\n\t    primaryChildFragment.pendingProps = primaryChildProps;\n\n\t    if ( workInProgress.mode & ProfileMode) {\n\t      // Reset the durations from the first pass so they aren't included in the\n\t      // final amounts. This seems counterintuitive, since we're intentionally\n\t      // not measuring part of the render phase, but this makes it match what we\n\t      // do in Concurrent Mode.\n\t      primaryChildFragment.actualDuration = 0;\n\t      primaryChildFragment.actualStartTime = -1;\n\t      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n\t      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n\t    } // The fallback fiber was added as a deletion during the first pass.\n\t    // However, since we're going to remain on the fallback, we no longer want\n\t    // to delete it.\n\n\n\t    workInProgress.deletions = null;\n\t  } else {\n\t    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n\t    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n\t    // the current tree; see previous branch.)\n\n\t    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n\t  }\n\n\t  var fallbackChildFragment;\n\n\t  if (currentFallbackChildFragment !== null) {\n\t    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n\t  } else {\n\t    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n\t    // mounted but this is a new fiber.\n\n\t    fallbackChildFragment.flags |= Placement;\n\t  }\n\n\t  fallbackChildFragment.return = workInProgress;\n\t  primaryChildFragment.return = workInProgress;\n\t  primaryChildFragment.sibling = fallbackChildFragment;\n\t  workInProgress.child = primaryChildFragment;\n\t  return fallbackChildFragment;\n\t}\n\n\tfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n\t  // Falling back to client rendering. Because this has performance\n\t  // implications, it's considered a recoverable error, even though the user\n\t  // likely won't observe anything wrong with the UI.\n\t  //\n\t  // The error is passed in as an argument to enforce that every caller provide\n\t  // a custom message, or explicitly opt out (currently the only path that opts\n\t  // out is legacy mode; every concurrent path provides an error).\n\t  if (recoverableError !== null) {\n\t    queueHydrationError(recoverableError);\n\t  } // This will add the old fiber to the deletion list\n\n\n\t  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n\t  var nextProps = workInProgress.pendingProps;\n\t  var primaryChildren = nextProps.children;\n\t  var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n\t  // mounted but this is a new fiber.\n\n\t  primaryChildFragment.flags |= Placement;\n\t  workInProgress.memoizedState = null;\n\t  return primaryChildFragment;\n\t}\n\n\tfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n\t  var fiberMode = workInProgress.mode;\n\t  var primaryChildProps = {\n\t    mode: 'visible',\n\t    children: primaryChildren\n\t  };\n\t  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n\t  var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n\t  // boundary) already mounted but this is a new fiber.\n\n\t  fallbackChildFragment.flags |= Placement;\n\t  primaryChildFragment.return = workInProgress;\n\t  fallbackChildFragment.return = workInProgress;\n\t  primaryChildFragment.sibling = fallbackChildFragment;\n\t  workInProgress.child = primaryChildFragment;\n\n\t  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n\t    // We will have dropped the effect list which contains the\n\t    // deletion. We need to reconcile to delete the current child.\n\t    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n\t  }\n\n\t  return fallbackChildFragment;\n\t}\n\n\tfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n\t  // During the first pass, we'll bail out and not drill into the children.\n\t  // Instead, we'll leave the content in place and try to hydrate it later.\n\t  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n\t    {\n\t      error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n\t    }\n\n\t    workInProgress.lanes = laneToLanes(SyncLane);\n\t  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n\t    // This is a client-only boundary. Since we won't get any content from the server\n\t    // for this, we need to schedule that at a higher priority based on when it would\n\t    // have timed out. In theory we could render it in this pass but it would have the\n\t    // wrong priority associated with it and will prevent hydration of parent path.\n\t    // Instead, we'll leave work left on it to render it in a separate commit.\n\t    // TODO This time should be the time at which the server rendered response that is\n\t    // a parent to this boundary was displayed. However, since we currently don't have\n\t    // a protocol to transfer that time, we'll just estimate it by using the current\n\t    // time. This will mean that Suspense timeouts are slightly shifted to later than\n\t    // they should be.\n\t    // Schedule a normal pri update to render this content.\n\t    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n\t  } else {\n\t    // We'll continue hydrating the rest at offscreen priority since we'll already\n\t    // be showing the right content coming from the server, it is no rush.\n\t    workInProgress.lanes = laneToLanes(OffscreenLane);\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {\n\t  if (!didSuspend) {\n\t    // This is the first render pass. Attempt to hydrate.\n\t    // We should never be hydrating at this point because it is the first pass,\n\t    // but after we've already committed once.\n\t    warnIfHydrating();\n\n\t    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n\t      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: When we delete legacy mode, we should make this error argument\n\t      // required  every concurrent mode path that causes hydration to\n\t      // de-opt to client rendering should have an error message.\n\t      null);\n\t    }\n\n\t    if (isSuspenseInstanceFallback(suspenseInstance)) {\n\t      // This boundary is in a permanent fallback state. In this case, we'll never\n\t      // get an update and we'll never be able to hydrate the final content. Let's just try the\n\t      // client side render instead.\n\t      var digest, message, stack;\n\n\t      {\n\t        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n\n\t        digest = _getSuspenseInstanceF.digest;\n\t        message = _getSuspenseInstanceF.message;\n\t        stack = _getSuspenseInstanceF.stack;\n\t      }\n\n\t      var error;\n\n\t      if (message) {\n\t        // eslint-disable-next-line react-internal/prod-error-codes\n\t        error = new Error(message);\n\t      } else {\n\t        error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.');\n\t      }\n\n\t      var capturedValue = createCapturedValue(error, digest, stack);\n\t      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);\n\t    }\n\t    // any context has changed, we need to treat is as if the input might have changed.\n\n\n\t    var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n\t    if (didReceiveUpdate || hasContextChanged) {\n\t      // This boundary has changed since the first render. This means that we are now unable to\n\t      // hydrate it. We might still be able to hydrate it using a higher priority lane.\n\t      var root = getWorkInProgressRoot();\n\n\t      if (root !== null) {\n\t        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n\t        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n\t          // Intentionally mutating since this render will get interrupted. This\n\t          // is one of the very rare times where we mutate the current tree\n\t          // during the render phase.\n\t          suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n\t          var eventTime = NoTimestamp;\n\t          enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n\t          scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime);\n\t        }\n\t      } // If we have scheduled higher pri work above, this will probably just abort the render\n\t      // since we now have higher priority work, but in case it doesn't, we need to prepare to\n\t      // render something, if we time out. Even if that requires us to delete everything and\n\t      // skip hydration.\n\t      // Delay having to do this as long as the suspense timeout allows us.\n\n\n\t      renderDidSuspendDelayIfPossible();\n\n\t      var _capturedValue = createCapturedValue(new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));\n\n\t      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue);\n\t    } else if (isSuspenseInstancePending(suspenseInstance)) {\n\t      // This component is still pending more data from the server, so we can't hydrate its\n\t      // content. We treat it as if this component suspended itself. It might seem as if\n\t      // we could just try to render it client-side instead. However, this will perform a\n\t      // lot of unnecessary work and is unlikely to complete since it often will suspend\n\t      // on missing data anyway. Additionally, the server might be able to render more\n\t      // than we can on the client yet. In that case we'd end up with more fallback states\n\t      // on the client than if we just leave it alone. If the server times out or errors\n\t      // these should update this boundary to the permanent Fallback state instead.\n\t      // Mark it as having captured (i.e. suspended).\n\t      workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n\t      workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n\t      var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n\t      registerSuspenseInstanceRetry(suspenseInstance, retry);\n\t      return null;\n\t    } else {\n\t      // This is the first attempt.\n\t      reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n\t      var primaryChildren = nextProps.children;\n\t      var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n\t      // tree is part of a hydrating tree. This is used to determine if a child\n\t      // node has fully mounted yet, and for scheduling event replaying.\n\t      // Conceptually this is similar to Placement in that a new subtree is\n\t      // inserted into the React tree here. It just happens to not need DOM\n\t      // mutations because it already exists.\n\n\t      primaryChildFragment.flags |= Hydrating;\n\t      return primaryChildFragment;\n\t    }\n\t  } else {\n\t    // This is the second render pass. We already attempted to hydrated, but\n\t    // something either suspended or errored.\n\t    if (workInProgress.flags & ForceClientRender) {\n\t      // Something errored during hydration. Try again without hydrating.\n\t      workInProgress.flags &= ~ForceClientRender;\n\n\t      var _capturedValue2 = createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));\n\n\t      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, _capturedValue2);\n\t    } else if (workInProgress.memoizedState !== null) {\n\t      // Something suspended and we should still be in dehydrated mode.\n\t      // Leave the existing child in place.\n\t      workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n\t      // but the normal suspense pass doesn't.\n\n\t      workInProgress.flags |= DidCapture;\n\t      return null;\n\t    } else {\n\t      // Suspended but we should no longer be in dehydrated mode.\n\t      // Therefore we now have to render the fallback.\n\t      var nextPrimaryChildren = nextProps.children;\n\t      var nextFallbackChildren = nextProps.fallback;\n\t      var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n\t      var _primaryChildFragment4 = workInProgress.child;\n\t      _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n\t      workInProgress.memoizedState = SUSPENDED_MARKER;\n\t      return fallbackChildFragment;\n\t    }\n\t  }\n\t}\n\n\tfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n\t  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n\t  var alternate = fiber.alternate;\n\n\t  if (alternate !== null) {\n\t    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n\t  }\n\n\t  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n\t}\n\n\tfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n\t  // Mark any Suspense boundaries with fallbacks as having work to do.\n\t  // If they were previously forced into fallbacks, they may now be able\n\t  // to unblock.\n\t  var node = firstChild;\n\n\t  while (node !== null) {\n\t    if (node.tag === SuspenseComponent) {\n\t      var state = node.memoizedState;\n\n\t      if (state !== null) {\n\t        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n\t      }\n\t    } else if (node.tag === SuspenseListComponent) {\n\t      // If the tail is hidden there might not be an Suspense boundaries\n\t      // to schedule work on. In this case we have to schedule it on the\n\t      // list itself.\n\t      // We don't have to traverse to the children of the list since\n\t      // the list will propagate the change when it rerenders.\n\t      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n\t    } else if (node.child !== null) {\n\t      node.child.return = node;\n\t      node = node.child;\n\t      continue;\n\t    }\n\n\t    if (node === workInProgress) {\n\t      return;\n\t    }\n\n\t    while (node.sibling === null) {\n\t      if (node.return === null || node.return === workInProgress) {\n\t        return;\n\t      }\n\n\t      node = node.return;\n\t    }\n\n\t    node.sibling.return = node.return;\n\t    node = node.sibling;\n\t  }\n\t}\n\n\tfunction findLastContentRow(firstChild) {\n\t  // This is going to find the last row among these children that is already\n\t  // showing content on the screen, as opposed to being in fallback state or\n\t  // new. If a row has multiple Suspense boundaries, any of them being in the\n\t  // fallback state, counts as the whole row being in a fallback state.\n\t  // Note that the \"rows\" will be workInProgress, but any nested children\n\t  // will still be current since we haven't rendered them yet. The mounted\n\t  // order may not be the same as the new order. We use the new order.\n\t  var row = firstChild;\n\t  var lastContentRow = null;\n\n\t  while (row !== null) {\n\t    var currentRow = row.alternate; // New rows can't be content rows.\n\n\t    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n\t      lastContentRow = row;\n\t    }\n\n\t    row = row.sibling;\n\t  }\n\n\t  return lastContentRow;\n\t}\n\n\tfunction validateRevealOrder(revealOrder) {\n\t  {\n\t    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n\t      didWarnAboutRevealOrder[revealOrder] = true;\n\n\t      if (typeof revealOrder === 'string') {\n\t        switch (revealOrder.toLowerCase()) {\n\t          case 'together':\n\t          case 'forwards':\n\t          case 'backwards':\n\t            {\n\t              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n\n\t              break;\n\t            }\n\n\t          case 'forward':\n\t          case 'backward':\n\t            {\n\t              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n\n\t              break;\n\t            }\n\n\t          default:\n\t            error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n\n\t            break;\n\t        }\n\t      } else {\n\t        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction validateTailOptions(tailMode, revealOrder) {\n\t  {\n\t    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n\t      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n\t        didWarnAboutTailOptions[tailMode] = true;\n\n\t        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n\t      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n\t        didWarnAboutTailOptions[tailMode] = true;\n\n\t        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction validateSuspenseListNestedChild(childSlot, index) {\n\t  {\n\t    var isAnArray = isArray(childSlot);\n\t    var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n\t    if (isAnArray || isIterable) {\n\t      var type = isAnArray ? 'array' : 'iterable';\n\n\t      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction validateSuspenseListChildren(children, revealOrder) {\n\t  {\n\t    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n\t      if (isArray(children)) {\n\t        for (var i = 0; i < children.length; i++) {\n\t          if (!validateSuspenseListNestedChild(children[i], i)) {\n\t            return;\n\t          }\n\t        }\n\t      } else {\n\t        var iteratorFn = getIteratorFn(children);\n\n\t        if (typeof iteratorFn === 'function') {\n\t          var childrenIterator = iteratorFn.call(children);\n\n\t          if (childrenIterator) {\n\t            var step = childrenIterator.next();\n\t            var _i = 0;\n\n\t            for (; !step.done; step = childrenIterator.next()) {\n\t              if (!validateSuspenseListNestedChild(step.value, _i)) {\n\t                return;\n\t              }\n\n\t              _i++;\n\t            }\n\t          }\n\t        } else {\n\t          error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n\t  var renderState = workInProgress.memoizedState;\n\n\t  if (renderState === null) {\n\t    workInProgress.memoizedState = {\n\t      isBackwards: isBackwards,\n\t      rendering: null,\n\t      renderingStartTime: 0,\n\t      last: lastContentRow,\n\t      tail: tail,\n\t      tailMode: tailMode\n\t    };\n\t  } else {\n\t    // We can reuse the existing object from previous renders.\n\t    renderState.isBackwards = isBackwards;\n\t    renderState.rendering = null;\n\t    renderState.renderingStartTime = 0;\n\t    renderState.last = lastContentRow;\n\t    renderState.tail = tail;\n\t    renderState.tailMode = tailMode;\n\t  }\n\t} // This can end up rendering this component multiple passes.\n\t// The first pass splits the children fibers into two sets. A head and tail.\n\t// We first render the head. If anything is in fallback state, we do another\n\t// pass through beginWork to rerender all children (including the tail) with\n\t// the force suspend context. If the first render didn't have anything in\n\t// in fallback state. Then we render each row in the tail one-by-one.\n\t// That happens in the completeWork phase without going back to beginWork.\n\n\n\tfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n\t  var nextProps = workInProgress.pendingProps;\n\t  var revealOrder = nextProps.revealOrder;\n\t  var tailMode = nextProps.tail;\n\t  var newChildren = nextProps.children;\n\t  validateRevealOrder(revealOrder);\n\t  validateTailOptions(tailMode, revealOrder);\n\t  validateSuspenseListChildren(newChildren, revealOrder);\n\t  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n\t  var suspenseContext = suspenseStackCursor.current;\n\t  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n\t  if (shouldForceFallback) {\n\t    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\t    workInProgress.flags |= DidCapture;\n\t  } else {\n\t    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n\t    if (didSuspendBefore) {\n\t      // If we previously forced a fallback, we need to schedule work\n\t      // on any nested boundaries to let them know to try to render\n\t      // again. This is the same as context updating.\n\t      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n\t    }\n\n\t    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n\t  }\n\n\t  pushSuspenseContext(workInProgress, suspenseContext);\n\n\t  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n\t    // In legacy mode, SuspenseList doesn't work so we just\n\t    // use make it a noop by treating it as the default revealOrder.\n\t    workInProgress.memoizedState = null;\n\t  } else {\n\t    switch (revealOrder) {\n\t      case 'forwards':\n\t        {\n\t          var lastContentRow = findLastContentRow(workInProgress.child);\n\t          var tail;\n\n\t          if (lastContentRow === null) {\n\t            // The whole list is part of the tail.\n\t            // TODO: We could fast path by just rendering the tail now.\n\t            tail = workInProgress.child;\n\t            workInProgress.child = null;\n\t          } else {\n\t            // Disconnect the tail rows after the content row.\n\t            // We're going to render them separately later.\n\t            tail = lastContentRow.sibling;\n\t            lastContentRow.sibling = null;\n\t          }\n\n\t          initSuspenseListRenderState(workInProgress, false, // isBackwards\n\t          tail, lastContentRow, tailMode);\n\t          break;\n\t        }\n\n\t      case 'backwards':\n\t        {\n\t          // We're going to find the first row that has existing content.\n\t          // At the same time we're going to reverse the list of everything\n\t          // we pass in the meantime. That's going to be our tail in reverse\n\t          // order.\n\t          var _tail = null;\n\t          var row = workInProgress.child;\n\t          workInProgress.child = null;\n\n\t          while (row !== null) {\n\t            var currentRow = row.alternate; // New rows can't be content rows.\n\n\t            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n\t              // This is the beginning of the main content.\n\t              workInProgress.child = row;\n\t              break;\n\t            }\n\n\t            var nextRow = row.sibling;\n\t            row.sibling = _tail;\n\t            _tail = row;\n\t            row = nextRow;\n\t          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n\t          initSuspenseListRenderState(workInProgress, true, // isBackwards\n\t          _tail, null, // last\n\t          tailMode);\n\t          break;\n\t        }\n\n\t      case 'together':\n\t        {\n\t          initSuspenseListRenderState(workInProgress, false, // isBackwards\n\t          null, // tail\n\t          null, // last\n\t          undefined);\n\t          break;\n\t        }\n\n\t      default:\n\t        {\n\t          // The default reveal order is the same as not having\n\t          // a boundary.\n\t          workInProgress.memoizedState = null;\n\t        }\n\t    }\n\t  }\n\n\t  return workInProgress.child;\n\t}\n\n\tfunction updatePortalComponent(current, workInProgress, renderLanes) {\n\t  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n\t  var nextChildren = workInProgress.pendingProps;\n\n\t  if (current === null) {\n\t    // Portals are special because we don't append the children during mount\n\t    // but at commit. Therefore we need to track insertions which the normal\n\t    // flow doesn't do during mount. This doesn't happen at the root because\n\t    // the root always starts with a \"current\" with a null child.\n\t    // TODO: Consider unifying this with how the root works.\n\t    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n\t  } else {\n\t    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n\t  }\n\n\t  return workInProgress.child;\n\t}\n\n\tvar hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\n\tfunction updateContextProvider(current, workInProgress, renderLanes) {\n\t  var providerType = workInProgress.type;\n\t  var context = providerType._context;\n\t  var newProps = workInProgress.pendingProps;\n\t  var oldProps = workInProgress.memoizedProps;\n\t  var newValue = newProps.value;\n\n\t  {\n\t    if (!('value' in newProps)) {\n\t      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n\t        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n\n\t        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n\t      }\n\t    }\n\n\t    var providerPropTypes = workInProgress.type.propTypes;\n\n\t    if (providerPropTypes) {\n\t      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n\t    }\n\t  }\n\n\t  pushProvider(workInProgress, context, newValue);\n\n\t  {\n\t    if (oldProps !== null) {\n\t      var oldValue = oldProps.value;\n\n\t      if (objectIs(oldValue, newValue)) {\n\t        // No change. Bailout early if children are the same.\n\t        if (oldProps.children === newProps.children && !hasContextChanged()) {\n\t          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t        }\n\t      } else {\n\t        // The context value changed. Search for matching consumers and schedule\n\t        // them to update.\n\t        propagateContextChange(workInProgress, context, renderLanes);\n\t      }\n\t    }\n\t  }\n\n\t  var newChildren = newProps.children;\n\t  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tvar hasWarnedAboutUsingContextAsConsumer = false;\n\n\tfunction updateContextConsumer(current, workInProgress, renderLanes) {\n\t  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n\t  // DEV mode, we create a separate object for Context.Consumer that acts\n\t  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n\t  // so we use the old behaviour (Context.Consumer references Context) to\n\t  // reduce size and overhead. The separate object references context via\n\t  // a property called \"_context\", which also gives us the ability to check\n\t  // in DEV mode if this property exists or not and warn if it does not.\n\n\t  {\n\t    if (context._context === undefined) {\n\t      // This may be because it's a Context (rather than a Consumer).\n\t      // Or it may be because it's older React where they're the same thing.\n\t      // We only want to warn if we're sure it's a new React.\n\t      if (context !== context.Consumer) {\n\t        if (!hasWarnedAboutUsingContextAsConsumer) {\n\t          hasWarnedAboutUsingContextAsConsumer = true;\n\n\t          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n\t        }\n\t      }\n\t    } else {\n\t      context = context._context;\n\t    }\n\t  }\n\n\t  var newProps = workInProgress.pendingProps;\n\t  var render = newProps.children;\n\n\t  {\n\t    if (typeof render !== 'function') {\n\t      error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n\t    }\n\t  }\n\n\t  prepareToReadContext(workInProgress, renderLanes);\n\t  var newValue = readContext(context);\n\n\t  {\n\t    markComponentRenderStarted(workInProgress);\n\t  }\n\n\t  var newChildren;\n\n\t  {\n\t    ReactCurrentOwner$1.current = workInProgress;\n\t    setIsRendering(true);\n\t    newChildren = render(newValue);\n\t    setIsRendering(false);\n\t  }\n\n\t  {\n\t    markComponentRenderStopped();\n\t  } // React DevTools reads this flag.\n\n\n\t  workInProgress.flags |= PerformedWork;\n\t  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n\t  return workInProgress.child;\n\t}\n\n\tfunction markWorkInProgressReceivedUpdate() {\n\t  didReceiveUpdate = true;\n\t}\n\n\tfunction resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {\n\t  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n\t    if (current !== null) {\n\t      // A lazy component only mounts if it suspended inside a non-\n\t      // concurrent tree, in an inconsistent state. We want to treat it like\n\t      // a new mount, even though an empty version of it already committed.\n\t      // Disconnect the alternate pointers.\n\t      current.alternate = null;\n\t      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n\t      workInProgress.flags |= Placement;\n\t    }\n\t  }\n\t}\n\n\tfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n\t  if (current !== null) {\n\t    // Reuse previous dependencies\n\t    workInProgress.dependencies = current.dependencies;\n\t  }\n\n\t  {\n\t    // Don't update \"base\" render times for bailouts.\n\t    stopProfilerTimerIfRunning();\n\t  }\n\n\t  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n\n\t  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n\t    // The children don't have any work either. We can skip them.\n\t    // TODO: Once we add back resuming, we should check if the children are\n\t    // a work-in-progress set. If so, we need to transfer their effects.\n\t    {\n\t      return null;\n\t    }\n\t  } // This fiber doesn't have work, but its subtree does. Clone the child\n\t  // fibers and continue.\n\n\n\t  cloneChildFibers(current, workInProgress);\n\t  return workInProgress.child;\n\t}\n\n\tfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n\t  {\n\t    var returnFiber = oldWorkInProgress.return;\n\n\t    if (returnFiber === null) {\n\t      // eslint-disable-next-line react-internal/prod-error-codes\n\t      throw new Error('Cannot swap the root fiber.');\n\t    } // Disconnect from the old current.\n\t    // It will get deleted.\n\n\n\t    current.alternate = null;\n\t    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n\t    newWorkInProgress.index = oldWorkInProgress.index;\n\t    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n\t    newWorkInProgress.return = oldWorkInProgress.return;\n\t    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n\t    if (oldWorkInProgress === returnFiber.child) {\n\t      returnFiber.child = newWorkInProgress;\n\t    } else {\n\t      var prevSibling = returnFiber.child;\n\n\t      if (prevSibling === null) {\n\t        // eslint-disable-next-line react-internal/prod-error-codes\n\t        throw new Error('Expected parent to have a child.');\n\t      }\n\n\t      while (prevSibling.sibling !== oldWorkInProgress) {\n\t        prevSibling = prevSibling.sibling;\n\n\t        if (prevSibling === null) {\n\t          // eslint-disable-next-line react-internal/prod-error-codes\n\t          throw new Error('Expected to find the previous sibling.');\n\t        }\n\t      }\n\n\t      prevSibling.sibling = newWorkInProgress;\n\t    } // Delete the old fiber and place the new one.\n\t    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n\t    var deletions = returnFiber.deletions;\n\n\t    if (deletions === null) {\n\t      returnFiber.deletions = [current];\n\t      returnFiber.flags |= ChildDeletion;\n\t    } else {\n\t      deletions.push(current);\n\t    }\n\n\t    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n\t    return newWorkInProgress;\n\t  }\n\t}\n\n\tfunction checkScheduledUpdateOrContext(current, renderLanes) {\n\t  // Before performing an early bailout, we must check if there are pending\n\t  // updates or context.\n\t  var updateLanes = current.lanes;\n\n\t  if (includesSomeLane(updateLanes, renderLanes)) {\n\t    return true;\n\t  } // No pending update, but because context is propagated lazily, we need\n\n\t  return false;\n\t}\n\n\tfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n\t  // This fiber does not have any pending work. Bailout without entering\n\t  // the begin phase. There's still some bookkeeping we that needs to be done\n\t  // in this optimized path, mostly pushing stuff onto the stack.\n\t  switch (workInProgress.tag) {\n\t    case HostRoot:\n\t      pushHostRootContext(workInProgress);\n\t      workInProgress.stateNode;\n\n\t      resetHydrationState();\n\t      break;\n\n\t    case HostComponent:\n\t      pushHostContext(workInProgress);\n\t      break;\n\n\t    case ClassComponent:\n\t      {\n\t        var Component = workInProgress.type;\n\n\t        if (isContextProvider(Component)) {\n\t          pushContextProvider(workInProgress);\n\t        }\n\n\t        break;\n\t      }\n\n\t    case HostPortal:\n\t      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n\t      break;\n\n\t    case ContextProvider:\n\t      {\n\t        var newValue = workInProgress.memoizedProps.value;\n\t        var context = workInProgress.type._context;\n\t        pushProvider(workInProgress, context, newValue);\n\t        break;\n\t      }\n\n\t    case Profiler:\n\t      {\n\t        // Profiler should only call onRender when one of its descendants actually rendered.\n\t        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n\t        if (hasChildWork) {\n\t          workInProgress.flags |= Update;\n\t        }\n\n\t        {\n\t          // Reset effect durations for the next eventual effect phase.\n\t          // These are reset during render to allow the DevTools commit hook a chance to read them,\n\t          var stateNode = workInProgress.stateNode;\n\t          stateNode.effectDuration = 0;\n\t          stateNode.passiveEffectDuration = 0;\n\t        }\n\t      }\n\n\t      break;\n\n\t    case SuspenseComponent:\n\t      {\n\t        var state = workInProgress.memoizedState;\n\n\t        if (state !== null) {\n\t          if (state.dehydrated !== null) {\n\t            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n\t            // been unsuspended it has committed as a resolved Suspense component.\n\t            // If it needs to be retried, it should have work scheduled on it.\n\n\t            workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n\t            // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n\t            return null;\n\t          } // If this boundary is currently timed out, we need to decide\n\t          // whether to retry the primary children, or to skip over it and\n\t          // go straight to the fallback. Check the priority of the primary\n\t          // child fragment.\n\n\n\t          var primaryChildFragment = workInProgress.child;\n\t          var primaryChildLanes = primaryChildFragment.childLanes;\n\n\t          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n\t            // The primary children have pending work. Use the normal path\n\t            // to attempt to render the primary children again.\n\t            return updateSuspenseComponent(current, workInProgress, renderLanes);\n\t          } else {\n\t            // The primary child fragment does not have pending work marked\n\t            // on it\n\t            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n\t            // priority. Bailout.\n\n\t            var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n\t            if (child !== null) {\n\t              // The fallback children have pending work. Skip over the\n\t              // primary children and work on the fallback.\n\t              return child.sibling;\n\t            } else {\n\t              // Note: We can return `null` here because we already checked\n\t              // whether there were nested context consumers, via the call to\n\t              // `bailoutOnAlreadyFinishedWork` above.\n\t              return null;\n\t            }\n\t          }\n\t        } else {\n\t          pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n\t        }\n\n\t        break;\n\t      }\n\n\t    case SuspenseListComponent:\n\t      {\n\t        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n\t        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n\t        if (didSuspendBefore) {\n\t          if (_hasChildWork) {\n\t            // If something was in fallback state last time, and we have all the\n\t            // same children then we're still in progressive loading state.\n\t            // Something might get unblocked by state updates or retries in the\n\t            // tree which will affect the tail. So we need to use the normal\n\t            // path to compute the correct tail.\n\t            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n\t          } // If none of the children had any work, that means that none of\n\t          // them got retried so they'll still be blocked in the same way\n\t          // as before. We can fast bail out.\n\n\n\t          workInProgress.flags |= DidCapture;\n\t        } // If nothing suspended before and we're rendering the same children,\n\t        // then the tail doesn't matter. Anything new that suspends will work\n\t        // in the \"together\" mode, so we can continue from the state we had.\n\n\n\t        var renderState = workInProgress.memoizedState;\n\n\t        if (renderState !== null) {\n\t          // Reset to the \"together\" mode in case we've started a different\n\t          // update in the past but didn't complete it.\n\t          renderState.rendering = null;\n\t          renderState.tail = null;\n\t          renderState.lastEffect = null;\n\t        }\n\n\t        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n\t        if (_hasChildWork) {\n\t          break;\n\t        } else {\n\t          // If none of the children had any work, that means that none of\n\t          // them got retried so they'll still be blocked in the same way\n\t          // as before. We can fast bail out.\n\t          return null;\n\t        }\n\t      }\n\n\t    case OffscreenComponent:\n\t    case LegacyHiddenComponent:\n\t      {\n\t        // Need to check if the tree still needs to be deferred. This is\n\t        // almost identical to the logic used in the normal update path,\n\t        // so we'll just enter that. The only difference is we'll bail out\n\t        // at the next level instead of this one, because the child props\n\t        // have not changed. Which is fine.\n\t        // TODO: Probably should refactor `beginWork` to split the bailout\n\t        // path from the normal path. I'm tempted to do a labeled break here\n\t        // but I won't :)\n\t        workInProgress.lanes = NoLanes;\n\t        return updateOffscreenComponent(current, workInProgress, renderLanes);\n\t      }\n\t  }\n\n\t  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\t}\n\n\tfunction beginWork(current, workInProgress, renderLanes) {\n\t  {\n\t    if (workInProgress._debugNeedsRemount && current !== null) {\n\t      // This will restart the begin phase with a new fiber.\n\t      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n\t    }\n\t  }\n\n\t  if (current !== null) {\n\t    var oldProps = current.memoizedProps;\n\t    var newProps = workInProgress.pendingProps;\n\n\t    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n\t     workInProgress.type !== current.type )) {\n\t      // If props or context changed, mark the fiber as having performed work.\n\t      // This may be unset if the props are determined to be equal later (memo).\n\t      didReceiveUpdate = true;\n\t    } else {\n\t      // Neither props nor legacy context changes. Check if there's a pending\n\t      // update or context change.\n\t      var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n\t      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n\t      // may not be work scheduled on `current`, so we check for this flag.\n\t      (workInProgress.flags & DidCapture) === NoFlags) {\n\t        // No pending updates or context. Bail out now.\n\t        didReceiveUpdate = false;\n\t        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n\t      }\n\n\t      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n\t        // This is a special case that only exists for legacy mode.\n\t        // See https://github.com/facebook/react/pull/19216.\n\t        didReceiveUpdate = true;\n\t      } else {\n\t        // An update was scheduled on this fiber, but there are no new props\n\t        // nor legacy context. Set this to false. If an update queue or context\n\t        // consumer produces a changed value, it will set this to true. Otherwise,\n\t        // the component will assume the children have not changed and bail out.\n\t        didReceiveUpdate = false;\n\t      }\n\t    }\n\t  } else {\n\t    didReceiveUpdate = false;\n\n\t    if (getIsHydrating() && isForkedChild(workInProgress)) {\n\t      // Check if this child belongs to a list of muliple children in\n\t      // its parent.\n\t      //\n\t      // In a true multi-threaded implementation, we would render children on\n\t      // parallel threads. This would represent the beginning of a new render\n\t      // thread for this subtree.\n\t      //\n\t      // We only use this for id generation during hydration, which is why the\n\t      // logic is located in this special branch.\n\t      var slotIndex = workInProgress.index;\n\t      var numberOfForks = getForksAtLevel();\n\t      pushTreeId(workInProgress, numberOfForks, slotIndex);\n\t    }\n\t  } // Before entering the begin phase, clear pending update priority.\n\t  // TODO: This assumes that we're about to evaluate the component and process\n\t  // the update queue. However, there's an exception: SimpleMemoComponent\n\t  // sometimes bails out later in the begin phase. This indicates that we should\n\t  // move this assignment out of the common path and into each branch.\n\n\n\t  workInProgress.lanes = NoLanes;\n\n\t  switch (workInProgress.tag) {\n\t    case IndeterminateComponent:\n\t      {\n\t        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n\t      }\n\n\t    case LazyComponent:\n\t      {\n\t        var elementType = workInProgress.elementType;\n\t        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n\t      }\n\n\t    case FunctionComponent:\n\t      {\n\t        var Component = workInProgress.type;\n\t        var unresolvedProps = workInProgress.pendingProps;\n\t        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n\t        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n\t      }\n\n\t    case ClassComponent:\n\t      {\n\t        var _Component = workInProgress.type;\n\t        var _unresolvedProps = workInProgress.pendingProps;\n\n\t        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n\n\t        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n\t      }\n\n\t    case HostRoot:\n\t      return updateHostRoot(current, workInProgress, renderLanes);\n\n\t    case HostComponent:\n\t      return updateHostComponent(current, workInProgress, renderLanes);\n\n\t    case HostText:\n\t      return updateHostText(current, workInProgress);\n\n\t    case SuspenseComponent:\n\t      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n\t    case HostPortal:\n\t      return updatePortalComponent(current, workInProgress, renderLanes);\n\n\t    case ForwardRef:\n\t      {\n\t        var type = workInProgress.type;\n\t        var _unresolvedProps2 = workInProgress.pendingProps;\n\n\t        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n\n\t        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n\t      }\n\n\t    case Fragment:\n\t      return updateFragment(current, workInProgress, renderLanes);\n\n\t    case Mode:\n\t      return updateMode(current, workInProgress, renderLanes);\n\n\t    case Profiler:\n\t      return updateProfiler(current, workInProgress, renderLanes);\n\n\t    case ContextProvider:\n\t      return updateContextProvider(current, workInProgress, renderLanes);\n\n\t    case ContextConsumer:\n\t      return updateContextConsumer(current, workInProgress, renderLanes);\n\n\t    case MemoComponent:\n\t      {\n\t        var _type2 = workInProgress.type;\n\t        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n\t        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n\n\t        {\n\t          if (workInProgress.type !== workInProgress.elementType) {\n\t            var outerPropTypes = _type2.propTypes;\n\n\t            if (outerPropTypes) {\n\t              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only\n\t              'prop', getComponentNameFromType(_type2));\n\t            }\n\t          }\n\t        }\n\n\t        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n\t        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n\t      }\n\n\t    case SimpleMemoComponent:\n\t      {\n\t        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n\t      }\n\n\t    case IncompleteClassComponent:\n\t      {\n\t        var _Component2 = workInProgress.type;\n\t        var _unresolvedProps4 = workInProgress.pendingProps;\n\n\t        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n\n\t        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n\t      }\n\n\t    case SuspenseListComponent:\n\t      {\n\t        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n\t      }\n\n\t    case ScopeComponent:\n\t      {\n\n\t        break;\n\t      }\n\n\t    case OffscreenComponent:\n\t      {\n\t        return updateOffscreenComponent(current, workInProgress, renderLanes);\n\t      }\n\t  }\n\n\t  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n\t}\n\n\tfunction markUpdate(workInProgress) {\n\t  // Tag the fiber with an update effect. This turns a Placement into\n\t  // a PlacementAndUpdate.\n\t  workInProgress.flags |= Update;\n\t}\n\n\tfunction markRef$1(workInProgress) {\n\t  workInProgress.flags |= Ref;\n\n\t  {\n\t    workInProgress.flags |= RefStatic;\n\t  }\n\t}\n\n\tfunction hadNoMutationsEffects(current, completedWork) {\n\t  var didBailout = current !== null && current.child === completedWork.child;\n\n\t  if (didBailout) {\n\t    return true;\n\t  }\n\n\t  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n\t    return false;\n\t  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n\t  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n\t  var child = completedWork.child;\n\n\t  while (child !== null) {\n\t    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n\t      return false;\n\t    }\n\n\t    child = child.sibling;\n\t  }\n\n\t  return true;\n\t}\n\n\tvar appendAllChildren;\n\tvar updateHostContainer;\n\tvar updateHostComponent$1;\n\tvar updateHostText$1;\n\n\tif (supportsMutation) {\n\t  // Mutation mode\n\t  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n\t    // We only have the top Fiber that was created but we need recurse down its\n\t    // children to find all the terminal nodes.\n\t    var node = workInProgress.child;\n\n\t    while (node !== null) {\n\t      if (node.tag === HostComponent || node.tag === HostText) {\n\t        appendInitialChild(parent, node.stateNode);\n\t      } else if (node.tag === HostPortal) ; else if (node.child !== null) {\n\t        node.child.return = node;\n\t        node = node.child;\n\t        continue;\n\t      }\n\n\t      if (node === workInProgress) {\n\t        return;\n\t      }\n\n\t      while (node.sibling === null) {\n\t        if (node.return === null || node.return === workInProgress) {\n\t          return;\n\t        }\n\n\t        node = node.return;\n\t      }\n\n\t      node.sibling.return = node.return;\n\t      node = node.sibling;\n\t    }\n\t  };\n\n\t  updateHostContainer = function (current, workInProgress) {// Noop\n\t  };\n\n\t  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n\t    // If we have an alternate, that means this is an update and we need to\n\t    // schedule a side-effect to do the updates.\n\t    var oldProps = current.memoizedProps;\n\n\t    if (oldProps === newProps) {\n\t      // In mutation mode, this is sufficient for a bailout because\n\t      // we won't touch this node even if children changed.\n\t      return;\n\t    } // If we get updated because one of our children updated, we don't\n\t    // have newProps so we'll have to reuse them.\n\t    // TODO: Split the update API as separate for the props vs. children.\n\t    // Even better would be if children weren't special cased at all tho.\n\n\n\t    var instance = workInProgress.stateNode;\n\t    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n\t    // component is hitting the resume path. Figure out why. Possibly\n\t    // related to `hidden`.\n\n\t    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n\t    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n\t    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n\t    if (updatePayload) {\n\t      markUpdate(workInProgress);\n\t    }\n\t  };\n\n\t  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n\t    // If the text differs, mark it as an update. All the work in done in commitWork.\n\t    if (oldText !== newText) {\n\t      markUpdate(workInProgress);\n\t    }\n\t  };\n\t} else if (supportsPersistence) {\n\t  // Persistent host tree mode\n\t  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n\t    // We only have the top Fiber that was created but we need recurse down its\n\t    // children to find all the terminal nodes.\n\t    var node = workInProgress.child;\n\n\t    while (node !== null) {\n\t      // eslint-disable-next-line no-labels\n\t       if (node.tag === HostComponent) {\n\t        var instance = node.stateNode;\n\n\t        if (needsVisibilityToggle && isHidden) {\n\t          // This child is inside a timed out tree. Hide it.\n\t          var props = node.memoizedProps;\n\t          var type = node.type;\n\t          instance = cloneHiddenInstance(instance, type, props, node);\n\t        }\n\n\t        appendInitialChild(parent, instance);\n\t      } else if (node.tag === HostText) {\n\t        var _instance = node.stateNode;\n\n\t        if (needsVisibilityToggle && isHidden) {\n\t          // This child is inside a timed out tree. Hide it.\n\t          var text = node.memoizedProps;\n\t          _instance = cloneHiddenTextInstance(_instance, text, node);\n\t        }\n\n\t        appendInitialChild(parent, _instance);\n\t      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n\t        // The children in this boundary are hidden. Toggle their visibility\n\t        // before appending.\n\t        var child = node.child;\n\n\t        if (child !== null) {\n\t          child.return = node;\n\t        }\n\n\t        appendAllChildren(parent, node, true, true);\n\t      } else if (node.child !== null) {\n\t        node.child.return = node;\n\t        node = node.child;\n\t        continue;\n\t      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n\t      node = node;\n\n\t      if (node === workInProgress) {\n\t        return;\n\t      }\n\n\t      while (node.sibling === null) {\n\t        if (node.return === null || node.return === workInProgress) {\n\t          return;\n\t        }\n\n\t        node = node.return;\n\t      }\n\n\t      node.sibling.return = node.return;\n\t      node = node.sibling;\n\t    }\n\t  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n\t  var appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n\t    // We only have the top Fiber that was created but we need recurse down its\n\t    // children to find all the terminal nodes.\n\t    var node = workInProgress.child;\n\n\t    while (node !== null) {\n\t      // eslint-disable-next-line no-labels\n\t       if (node.tag === HostComponent) {\n\t        var instance = node.stateNode;\n\n\t        if (needsVisibilityToggle && isHidden) {\n\t          // This child is inside a timed out tree. Hide it.\n\t          var props = node.memoizedProps;\n\t          var type = node.type;\n\t          instance = cloneHiddenInstance(instance, type, props, node);\n\t        }\n\n\t        appendChildToContainerChildSet(containerChildSet, instance);\n\t      } else if (node.tag === HostText) {\n\t        var _instance2 = node.stateNode;\n\n\t        if (needsVisibilityToggle && isHidden) {\n\t          // This child is inside a timed out tree. Hide it.\n\t          var text = node.memoizedProps;\n\t          _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n\t        }\n\n\t        appendChildToContainerChildSet(containerChildSet, _instance2);\n\t      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n\t        // The children in this boundary are hidden. Toggle their visibility\n\t        // before appending.\n\t        var child = node.child;\n\n\t        if (child !== null) {\n\t          child.return = node;\n\t        }\n\n\t        appendAllChildrenToContainer(containerChildSet, node, true, true);\n\t      } else if (node.child !== null) {\n\t        node.child.return = node;\n\t        node = node.child;\n\t        continue;\n\t      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n\t      node = node;\n\n\t      if (node === workInProgress) {\n\t        return;\n\t      }\n\n\t      while (node.sibling === null) {\n\t        if (node.return === null || node.return === workInProgress) {\n\t          return;\n\t        }\n\n\t        node = node.return;\n\t      }\n\n\t      node.sibling.return = node.return;\n\t      node = node.sibling;\n\t    }\n\t  };\n\n\t  updateHostContainer = function (current, workInProgress) {\n\t    var portalOrRoot = workInProgress.stateNode;\n\t    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n\t    if (childrenUnchanged) ; else {\n\t      var container = portalOrRoot.containerInfo;\n\t      var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n\t      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n\t      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n\t      markUpdate(workInProgress);\n\t      finalizeContainerChildren(container, newChildSet);\n\t    }\n\t  };\n\n\t  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n\t    var currentInstance = current.stateNode;\n\t    var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n\t    // This guarantees that we can reuse all of them.\n\n\t    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n\t    if (childrenUnchanged && oldProps === newProps) {\n\t      // No changes, just reuse the existing instance.\n\t      // Note that this might release a previous clone.\n\t      workInProgress.stateNode = currentInstance;\n\t      return;\n\t    }\n\n\t    var recyclableInstance = workInProgress.stateNode;\n\t    var currentHostContext = getHostContext();\n\t    var updatePayload = null;\n\n\t    if (oldProps !== newProps) {\n\t      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\t    }\n\n\t    if (childrenUnchanged && updatePayload === null) {\n\t      // No changes, just reuse the existing instance.\n\t      // Note that this might release a previous clone.\n\t      workInProgress.stateNode = currentInstance;\n\t      return;\n\t    }\n\n\t    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n\t    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n\t      markUpdate(workInProgress);\n\t    }\n\n\t    workInProgress.stateNode = newInstance;\n\n\t    if (childrenUnchanged) {\n\t      // If there are no other effects in this tree, we need to flag this node as having one.\n\t      // Even though we're not going to use it for anything.\n\t      // Otherwise parents won't know that there are new children to propagate upwards.\n\t      markUpdate(workInProgress);\n\t    } else {\n\t      // If children might have changed, we have to add them all to the set.\n\t      appendAllChildren(newInstance, workInProgress, false, false);\n\t    }\n\t  };\n\n\t  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n\t    if (oldText !== newText) {\n\t      // If the text content differs, we'll create a new text instance for it.\n\t      var rootContainerInstance = getRootHostContainer();\n\t      var currentHostContext = getHostContext();\n\t      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n\t      // This lets the parents know that at least one of their children has changed.\n\n\t      markUpdate(workInProgress);\n\t    } else {\n\t      workInProgress.stateNode = current.stateNode;\n\t    }\n\t  };\n\t} else {\n\t  // No host operations\n\t  updateHostContainer = function (current, workInProgress) {// Noop\n\t  };\n\n\t  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n\t  };\n\n\t  updateHostText$1 = function (current, workInProgress, oldText, newText) {// Noop\n\t  };\n\t}\n\n\tfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n\t  if (getIsHydrating()) {\n\t    // If we're hydrating, we should consume as many items as we can\n\t    // so we don't leave any behind.\n\t    return;\n\t  }\n\n\t  switch (renderState.tailMode) {\n\t    case 'hidden':\n\t      {\n\t        // Any insertions at the end of the tail list after this point\n\t        // should be invisible. If there are already mounted boundaries\n\t        // anything before them are not considered for collapsing.\n\t        // Therefore we need to go through the whole tail to find if\n\t        // there are any.\n\t        var tailNode = renderState.tail;\n\t        var lastTailNode = null;\n\n\t        while (tailNode !== null) {\n\t          if (tailNode.alternate !== null) {\n\t            lastTailNode = tailNode;\n\t          }\n\n\t          tailNode = tailNode.sibling;\n\t        } // Next we're simply going to delete all insertions after the\n\t        // last rendered item.\n\n\n\t        if (lastTailNode === null) {\n\t          // All remaining items in the tail are insertions.\n\t          renderState.tail = null;\n\t        } else {\n\t          // Detach the insertion after the last node that was already\n\t          // inserted.\n\t          lastTailNode.sibling = null;\n\t        }\n\n\t        break;\n\t      }\n\n\t    case 'collapsed':\n\t      {\n\t        // Any insertions at the end of the tail list after this point\n\t        // should be invisible. If there are already mounted boundaries\n\t        // anything before them are not considered for collapsing.\n\t        // Therefore we need to go through the whole tail to find if\n\t        // there are any.\n\t        var _tailNode = renderState.tail;\n\t        var _lastTailNode = null;\n\n\t        while (_tailNode !== null) {\n\t          if (_tailNode.alternate !== null) {\n\t            _lastTailNode = _tailNode;\n\t          }\n\n\t          _tailNode = _tailNode.sibling;\n\t        } // Next we're simply going to delete all insertions after the\n\t        // last rendered item.\n\n\n\t        if (_lastTailNode === null) {\n\t          // All remaining items in the tail are insertions.\n\t          if (!hasRenderedATailFallback && renderState.tail !== null) {\n\t            // We suspended during the head. We want to show at least one\n\t            // row at the tail. So we'll keep on and cut off the rest.\n\t            renderState.tail.sibling = null;\n\t          } else {\n\t            renderState.tail = null;\n\t          }\n\t        } else {\n\t          // Detach the insertion after the last node that was already\n\t          // inserted.\n\t          _lastTailNode.sibling = null;\n\t        }\n\n\t        break;\n\t      }\n\t  }\n\t}\n\n\tfunction bubbleProperties(completedWork) {\n\t  var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n\t  var newChildLanes = NoLanes;\n\t  var subtreeFlags = NoFlags;\n\n\t  if (!didBailout) {\n\t    // Bubble up the earliest expiration time.\n\t    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n\t      // In profiling mode, resetChildExpirationTime is also used to reset\n\t      // profiler durations.\n\t      var actualDuration = completedWork.actualDuration;\n\t      var treeBaseDuration = completedWork.selfBaseDuration;\n\t      var child = completedWork.child;\n\n\t      while (child !== null) {\n\t        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n\t        subtreeFlags |= child.subtreeFlags;\n\t        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n\t        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n\t        // When work is done, it should bubble to the parent's actualDuration. If\n\t        // the fiber has not been cloned though, (meaning no work was done), then\n\t        // this value will reflect the amount of time spent working on a previous\n\t        // render. In that case it should not bubble. We determine whether it was\n\t        // cloned by comparing the child pointer.\n\n\t        actualDuration += child.actualDuration;\n\t        treeBaseDuration += child.treeBaseDuration;\n\t        child = child.sibling;\n\t      }\n\n\t      completedWork.actualDuration = actualDuration;\n\t      completedWork.treeBaseDuration = treeBaseDuration;\n\t    } else {\n\t      var _child = completedWork.child;\n\n\t      while (_child !== null) {\n\t        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n\t        subtreeFlags |= _child.subtreeFlags;\n\t        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n\t        // smell because it assumes the commit phase is never concurrent with\n\t        // the render phase. Will address during refactor to alternate model.\n\n\t        _child.return = completedWork;\n\t        _child = _child.sibling;\n\t      }\n\t    }\n\n\t    completedWork.subtreeFlags |= subtreeFlags;\n\t  } else {\n\t    // Bubble up the earliest expiration time.\n\t    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n\t      // In profiling mode, resetChildExpirationTime is also used to reset\n\t      // profiler durations.\n\t      var _treeBaseDuration = completedWork.selfBaseDuration;\n\t      var _child2 = completedWork.child;\n\n\t      while (_child2 !== null) {\n\t        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n\t        // so we should bubble those up even during a bailout. All the other\n\t        // flags have a lifetime only of a single render + commit, so we should\n\t        // ignore them.\n\n\t        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n\t        subtreeFlags |= _child2.flags & StaticMask;\n\t        _treeBaseDuration += _child2.treeBaseDuration;\n\t        _child2 = _child2.sibling;\n\t      }\n\n\t      completedWork.treeBaseDuration = _treeBaseDuration;\n\t    } else {\n\t      var _child3 = completedWork.child;\n\n\t      while (_child3 !== null) {\n\t        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n\t        // so we should bubble those up even during a bailout. All the other\n\t        // flags have a lifetime only of a single render + commit, so we should\n\t        // ignore them.\n\n\t        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n\t        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n\t        // smell because it assumes the commit phase is never concurrent with\n\t        // the render phase. Will address during refactor to alternate model.\n\n\t        _child3.return = completedWork;\n\t        _child3 = _child3.sibling;\n\t      }\n\t    }\n\n\t    completedWork.subtreeFlags |= subtreeFlags;\n\t  }\n\n\t  completedWork.childLanes = newChildLanes;\n\t  return didBailout;\n\t}\n\n\tfunction completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n\t  if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n\t    warnIfUnhydratedTailNodes(workInProgress);\n\t    resetHydrationState();\n\t    workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n\t    return false;\n\t  }\n\n\t  var wasHydrated = popHydrationState(workInProgress);\n\n\t  if (nextState !== null && nextState.dehydrated !== null) {\n\t    // We might be inside a hydration state the first time we're picking up this\n\t    // Suspense boundary, and also after we've reentered it for further hydration.\n\t    if (current === null) {\n\t      if (!wasHydrated) {\n\t        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n\t      }\n\n\t      prepareToHydrateHostSuspenseInstance(workInProgress);\n\t      bubbleProperties(workInProgress);\n\n\t      {\n\t        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n\t          var isTimedOutSuspense = nextState !== null;\n\n\t          if (isTimedOutSuspense) {\n\t            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n\t            var primaryChildFragment = workInProgress.child;\n\n\t            if (primaryChildFragment !== null) {\n\t              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n\t              workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      return false;\n\t    } else {\n\t      // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n\t      // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n\t      resetHydrationState();\n\n\t      if ((workInProgress.flags & DidCapture) === NoFlags) {\n\t        // This boundary did not suspend so it's now hydrated and unsuspended.\n\t        workInProgress.memoizedState = null;\n\t      } // If nothing suspended, we need to schedule an effect to mark this boundary\n\t      // as having hydrated so events know that they're free to be invoked.\n\t      // It's also a signal to replay events and the suspense callback.\n\t      // If something suspended, schedule an effect to attach retry listeners.\n\t      // So we might as well always mark this.\n\n\n\t      workInProgress.flags |= Update;\n\t      bubbleProperties(workInProgress);\n\n\t      {\n\t        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n\t          var _isTimedOutSuspense = nextState !== null;\n\n\t          if (_isTimedOutSuspense) {\n\t            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n\t            var _primaryChildFragment = workInProgress.child;\n\n\t            if (_primaryChildFragment !== null) {\n\t              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n\t              workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      return false;\n\t    }\n\t  } else {\n\t    // Successfully completed this tree. If this was a forced client render,\n\t    // there may have been recoverable errors during first hydration\n\t    // attempt. If so, add them to a queue so we can log them in the\n\t    // commit phase.\n\t    upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n\n\t    return true;\n\t  }\n\t}\n\n\tfunction completeWork(current, workInProgress, renderLanes) {\n\t  var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n\t  // to the current tree provider fiber is just as fast and less error-prone.\n\t  // Ideally we would have a special version of the work loop only\n\t  // for hydration.\n\n\t  popTreeContext(workInProgress);\n\n\t  switch (workInProgress.tag) {\n\t    case IndeterminateComponent:\n\t    case LazyComponent:\n\t    case SimpleMemoComponent:\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case Fragment:\n\t    case Mode:\n\t    case Profiler:\n\t    case ContextConsumer:\n\t    case MemoComponent:\n\t      bubbleProperties(workInProgress);\n\t      return null;\n\n\t    case ClassComponent:\n\t      {\n\t        var Component = workInProgress.type;\n\n\t        if (isContextProvider(Component)) {\n\t          popContext(workInProgress);\n\t        }\n\n\t        bubbleProperties(workInProgress);\n\t        return null;\n\t      }\n\n\t    case HostRoot:\n\t      {\n\t        var fiberRoot = workInProgress.stateNode;\n\t        popHostContainer(workInProgress);\n\t        popTopLevelContextObject(workInProgress);\n\t        resetWorkInProgressVersions();\n\n\t        if (fiberRoot.pendingContext) {\n\t          fiberRoot.context = fiberRoot.pendingContext;\n\t          fiberRoot.pendingContext = null;\n\t        }\n\n\t        if (current === null || current.child === null) {\n\t          // If we hydrated, pop so that we can delete any remaining children\n\t          // that weren't hydrated.\n\t          var wasHydrated = popHydrationState(workInProgress);\n\n\t          if (wasHydrated) {\n\t            // If we hydrated, then we'll need to schedule an update for\n\t            // the commit side-effects on the root.\n\t            markUpdate(workInProgress);\n\t          } else {\n\t            if (current !== null) {\n\t              var prevState = current.memoizedState;\n\n\t              if ( // Check if this is a client root\n\t              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n\t              (workInProgress.flags & ForceClientRender) !== NoFlags) {\n\t                // Schedule an effect to clear this container at the start of the\n\t                // next commit. This handles the case of React rendering into a\n\t                // container with previous children. It's also safe to do for\n\t                // updates too, because current.child would only be null if the\n\t                // previous render was null (so the container would already\n\t                // be empty).\n\t                workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n\t                // recoverable errors during first hydration attempt. If so, add\n\t                // them to a queue so we can log them in the commit phase.\n\n\t                upgradeHydrationErrorsToRecoverable();\n\t              }\n\t            }\n\t          }\n\t        }\n\n\t        updateHostContainer(current, workInProgress);\n\t        bubbleProperties(workInProgress);\n\n\t        return null;\n\t      }\n\n\t    case HostComponent:\n\t      {\n\t        popHostContext(workInProgress);\n\t        var rootContainerInstance = getRootHostContainer();\n\t        var type = workInProgress.type;\n\n\t        if (current !== null && workInProgress.stateNode != null) {\n\t          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\n\n\t          if (current.ref !== workInProgress.ref) {\n\t            markRef$1(workInProgress);\n\t          }\n\t        } else {\n\t          if (!newProps) {\n\t            if (workInProgress.stateNode === null) {\n\t              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n\t            } // This can happen when we abort work.\n\n\n\t            bubbleProperties(workInProgress);\n\t            return null;\n\t          }\n\n\t          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n\t          // \"stack\" as the parent. Then append children as we go in beginWork\n\t          // or completeWork depending on whether we want to add them top->down or\n\t          // bottom->up. Top->down is faster in IE11.\n\n\t          var _wasHydrated = popHydrationState(workInProgress);\n\n\t          if (_wasHydrated) {\n\t            // TODO: Move this and createInstance step into the beginPhase\n\t            // to consolidate.\n\t            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n\t              // If changes to the hydrated node need to be applied at the\n\t              // commit-phase we mark this as such.\n\t              markUpdate(workInProgress);\n\t            }\n\t          } else {\n\t            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n\t            appendAllChildren(instance, workInProgress, false, false);\n\t            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n\t            // (eg DOM renderer supports auto-focus for certain elements).\n\t            // Make sure such renderers get scheduled for later work.\n\n\t            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n\t              markUpdate(workInProgress);\n\t            }\n\t          }\n\n\t          if (workInProgress.ref !== null) {\n\t            // If there is a ref on a host node we need to schedule a callback\n\t            markRef$1(workInProgress);\n\t          }\n\t        }\n\n\t        bubbleProperties(workInProgress);\n\t        return null;\n\t      }\n\n\t    case HostText:\n\t      {\n\t        var newText = newProps;\n\n\t        if (current && workInProgress.stateNode != null) {\n\t          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n\t          // to schedule a side-effect to do the updates.\n\n\t          updateHostText$1(current, workInProgress, oldText, newText);\n\t        } else {\n\t          if (typeof newText !== 'string') {\n\t            if (workInProgress.stateNode === null) {\n\t              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n\t            } // This can happen when we abort work.\n\n\t          }\n\n\t          var _rootContainerInstance = getRootHostContainer();\n\n\t          var _currentHostContext = getHostContext();\n\n\t          var _wasHydrated2 = popHydrationState(workInProgress);\n\n\t          if (_wasHydrated2) {\n\t            if (prepareToHydrateHostTextInstance(workInProgress)) {\n\t              markUpdate(workInProgress);\n\t            }\n\t          } else {\n\t            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n\t          }\n\t        }\n\n\t        bubbleProperties(workInProgress);\n\t        return null;\n\t      }\n\n\t    case SuspenseComponent:\n\t      {\n\t        popSuspenseContext(workInProgress);\n\t        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n\t        // to its own fiber type so that we can add other kinds of hydration\n\t        // boundaries that aren't associated with a Suspense tree. In anticipation\n\t        // of such a refactor, all the hydration logic is contained in\n\t        // this branch.\n\n\t        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n\t          var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n\n\t          if (!fallthroughToNormalSuspensePath) {\n\t            if (workInProgress.flags & ShouldCapture) {\n\t              // Special case. There were remaining unhydrated nodes. We treat\n\t              // this as a mismatch. Revert to client rendering.\n\t              return workInProgress;\n\t            } else {\n\t              // Did not finish hydrating, either because this is the initial\n\t              // render or because something suspended.\n\t              return null;\n\t            }\n\t          } // Continue with the normal Suspense path.\n\n\t        }\n\n\t        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n\t          // Something suspended. Re-render with the fallback children.\n\t          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n\t          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n\t            transferActualDuration(workInProgress);\n\t          } // Don't bubble properties in this case.\n\n\n\t          return workInProgress;\n\t        }\n\n\t        var nextDidTimeout = nextState !== null;\n\t        var prevDidTimeout = current !== null && current.memoizedState !== null;\n\t        // a passive effect, which is when we process the transitions\n\n\n\t        if (nextDidTimeout !== prevDidTimeout) {\n\t          // an effect to toggle the subtree's visibility. When we switch from\n\t          // fallback -> primary, the inner Offscreen fiber schedules this effect\n\t          // as part of its normal complete phase. But when we switch from\n\t          // primary -> fallback, the inner Offscreen fiber does not have a complete\n\t          // phase. So we need to schedule its effect here.\n\t          //\n\t          // We also use this flag to connect/disconnect the effects, but the same\n\t          // logic applies: when re-connecting, the Offscreen fiber's complete\n\t          // phase will handle scheduling the effect. It's only when the fallback\n\t          // is active that we have to do anything special.\n\n\n\t          if (nextDidTimeout) {\n\t            var _offscreenFiber2 = workInProgress.child;\n\t            _offscreenFiber2.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n\t            // in the concurrent tree already suspended during this render.\n\t            // This is a known bug.\n\n\t            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n\t              // TODO: Move this back to throwException because this is too late\n\t              // if this is a large tree which is common for initial loads. We\n\t              // don't know if we should restart a render or not until we get\n\t              // this marker, and this is too late.\n\t              // If this render already had a ping or lower pri updates,\n\t              // and this is the first time we know we're going to suspend we\n\t              // should be able to immediately restart from within throwException.\n\t              var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n\n\t              if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n\t                // If this was in an invisible tree or a new render, then showing\n\t                // this boundary is ok.\n\t                renderDidSuspend();\n\t              } else {\n\t                // Otherwise, we're going to have to hide content so we should\n\t                // suspend for longer if possible.\n\t                renderDidSuspendDelayIfPossible();\n\t              }\n\t            }\n\t          }\n\t        }\n\n\t        var wakeables = workInProgress.updateQueue;\n\n\t        if (wakeables !== null) {\n\t          // Schedule an effect to attach a retry listener to the promise.\n\t          // TODO: Move to passive phase\n\t          workInProgress.flags |= Update;\n\t        }\n\n\t        bubbleProperties(workInProgress);\n\n\t        {\n\t          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n\t            if (nextDidTimeout) {\n\t              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n\t              var primaryChildFragment = workInProgress.child;\n\n\t              if (primaryChildFragment !== null) {\n\t                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n\t                workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n\t              }\n\t            }\n\t          }\n\t        }\n\n\t        return null;\n\t      }\n\n\t    case HostPortal:\n\t      popHostContainer(workInProgress);\n\t      updateHostContainer(current, workInProgress);\n\n\t      if (current === null) {\n\t        preparePortalMount(workInProgress.stateNode.containerInfo);\n\t      }\n\n\t      bubbleProperties(workInProgress);\n\t      return null;\n\n\t    case ContextProvider:\n\t      // Pop provider fiber\n\t      var context = workInProgress.type._context;\n\t      popProvider(context, workInProgress);\n\t      bubbleProperties(workInProgress);\n\t      return null;\n\n\t    case IncompleteClassComponent:\n\t      {\n\t        // Same as class component case. I put it down here so that the tags are\n\t        // sequential to ensure this switch is compiled to a jump table.\n\t        var _Component = workInProgress.type;\n\n\t        if (isContextProvider(_Component)) {\n\t          popContext(workInProgress);\n\t        }\n\n\t        bubbleProperties(workInProgress);\n\t        return null;\n\t      }\n\n\t    case SuspenseListComponent:\n\t      {\n\t        popSuspenseContext(workInProgress);\n\t        var renderState = workInProgress.memoizedState;\n\n\t        if (renderState === null) {\n\t          // We're running in the default, \"independent\" mode.\n\t          // We don't do anything in this mode.\n\t          bubbleProperties(workInProgress);\n\t          return null;\n\t        }\n\n\t        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n\t        var renderedTail = renderState.rendering;\n\n\t        if (renderedTail === null) {\n\t          // We just rendered the head.\n\t          if (!didSuspendAlready) {\n\t            // This is the first pass. We need to figure out if anything is still\n\t            // suspended in the rendered set.\n\t            // If new content unsuspended, but there's still some content that\n\t            // didn't. Then we need to do a second pass that forces everything\n\t            // to keep showing their fallbacks.\n\t            // We might be suspended if something in this render pass suspended, or\n\t            // something in the previous committed pass suspended. Otherwise,\n\t            // there's no chance so we can skip the expensive call to\n\t            // findFirstSuspended.\n\t            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n\t            if (!cannotBeSuspended) {\n\t              var row = workInProgress.child;\n\n\t              while (row !== null) {\n\t                var suspended = findFirstSuspended(row);\n\n\t                if (suspended !== null) {\n\t                  didSuspendAlready = true;\n\t                  workInProgress.flags |= DidCapture;\n\t                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n\t                  // part of the second pass. In that case nothing will subscribe to\n\t                  // its thenables. Instead, we'll transfer its thenables to the\n\t                  // SuspenseList so that it can retry if they resolve.\n\t                  // There might be multiple of these in the list but since we're\n\t                  // going to wait for all of them anyway, it doesn't really matter\n\t                  // which ones gets to ping. In theory we could get clever and keep\n\t                  // track of how many dependencies remain but it gets tricky because\n\t                  // in the meantime, we can add/remove/change items and dependencies.\n\t                  // We might bail out of the loop before finding any but that\n\t                  // doesn't matter since that means that the other boundaries that\n\t                  // we did find already has their listeners attached.\n\n\t                  var newThenables = suspended.updateQueue;\n\n\t                  if (newThenables !== null) {\n\t                    workInProgress.updateQueue = newThenables;\n\t                    workInProgress.flags |= Update;\n\t                  } // Rerender the whole list, but this time, we'll force fallbacks\n\t                  // to stay in place.\n\t                  // Reset the effect flags before doing the second pass since that's now invalid.\n\t                  // Reset the child fibers to their original state.\n\n\n\t                  workInProgress.subtreeFlags = NoFlags;\n\t                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n\t                  // rerender the children.\n\n\t                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n\t                  return workInProgress.child;\n\t                }\n\n\t                row = row.sibling;\n\t              }\n\t            }\n\n\t            if (renderState.tail !== null && now() > getRenderTargetTime()) {\n\t              // We have already passed our CPU deadline but we still have rows\n\t              // left in the tail. We'll just give up further attempts to render\n\t              // the main content and only render fallbacks.\n\t              workInProgress.flags |= DidCapture;\n\t              didSuspendAlready = true;\n\t              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n\t              // to get it started back up to attempt the next item. While in terms\n\t              // of priority this work has the same priority as this current render,\n\t              // it's not part of the same transition once the transition has\n\t              // committed. If it's sync, we still want to yield so that it can be\n\t              // painted. Conceptually, this is really the same as pinging.\n\t              // We can use any RetryLane even if it's the one currently rendering\n\t              // since we're leaving it behind on this node.\n\n\t              workInProgress.lanes = SomeRetryLane;\n\t            }\n\t          } else {\n\t            cutOffTailIfNeeded(renderState, false);\n\t          } // Next we're going to render the tail.\n\n\t        } else {\n\t          // Append the rendered row to the child list.\n\t          if (!didSuspendAlready) {\n\t            var _suspended = findFirstSuspended(renderedTail);\n\n\t            if (_suspended !== null) {\n\t              workInProgress.flags |= DidCapture;\n\t              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n\t              // get lost if this row ends up dropped during a second pass.\n\n\t              var _newThenables = _suspended.updateQueue;\n\n\t              if (_newThenables !== null) {\n\t                workInProgress.updateQueue = _newThenables;\n\t                workInProgress.flags |= Update;\n\t              }\n\n\t              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n\t              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n\t              ) {\n\t                  // We're done.\n\t                  bubbleProperties(workInProgress);\n\t                  return null;\n\t                }\n\t            } else if ( // The time it took to render last row is greater than the remaining\n\t            // time we have to render. So rendering one more row would likely\n\t            // exceed it.\n\t            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n\t              // We have now passed our CPU deadline and we'll just give up further\n\t              // attempts to render the main content and only render fallbacks.\n\t              // The assumption is that this is usually faster.\n\t              workInProgress.flags |= DidCapture;\n\t              didSuspendAlready = true;\n\t              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n\t              // to get it started back up to attempt the next item. While in terms\n\t              // of priority this work has the same priority as this current render,\n\t              // it's not part of the same transition once the transition has\n\t              // committed. If it's sync, we still want to yield so that it can be\n\t              // painted. Conceptually, this is really the same as pinging.\n\t              // We can use any RetryLane even if it's the one currently rendering\n\t              // since we're leaving it behind on this node.\n\n\t              workInProgress.lanes = SomeRetryLane;\n\t            }\n\t          }\n\n\t          if (renderState.isBackwards) {\n\t            // The effect list of the backwards tail will have been added\n\t            // to the end. This breaks the guarantee that life-cycles fire in\n\t            // sibling order but that isn't a strong guarantee promised by React.\n\t            // Especially since these might also just pop in during future commits.\n\t            // Append to the beginning of the list.\n\t            renderedTail.sibling = workInProgress.child;\n\t            workInProgress.child = renderedTail;\n\t          } else {\n\t            var previousSibling = renderState.last;\n\n\t            if (previousSibling !== null) {\n\t              previousSibling.sibling = renderedTail;\n\t            } else {\n\t              workInProgress.child = renderedTail;\n\t            }\n\n\t            renderState.last = renderedTail;\n\t          }\n\t        }\n\n\t        if (renderState.tail !== null) {\n\t          // We still have tail rows to render.\n\t          // Pop a row.\n\t          var next = renderState.tail;\n\t          renderState.rendering = next;\n\t          renderState.tail = next.sibling;\n\t          renderState.renderingStartTime = now();\n\t          next.sibling = null; // Restore the context.\n\t          // TODO: We can probably just avoid popping it instead and only\n\t          // setting it the first time we go from not suspended to suspended.\n\n\t          var suspenseContext = suspenseStackCursor.current;\n\n\t          if (didSuspendAlready) {\n\t            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\t          } else {\n\t            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n\t          }\n\n\t          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n\t          // Don't bubble properties in this case.\n\n\t          return next;\n\t        }\n\n\t        bubbleProperties(workInProgress);\n\t        return null;\n\t      }\n\n\t    case ScopeComponent:\n\t      {\n\n\t        break;\n\t      }\n\n\t    case OffscreenComponent:\n\t    case LegacyHiddenComponent:\n\t      {\n\t        popRenderLanes(workInProgress);\n\t        var _nextState = workInProgress.memoizedState;\n\t        var nextIsHidden = _nextState !== null;\n\n\t        if (current !== null) {\n\t          var _prevState = current.memoizedState;\n\t          var prevIsHidden = _prevState !== null;\n\n\t          if (prevIsHidden !== nextIsHidden && ( // LegacyHidden doesn't do any hiding  it only pre-renders.\n\t          !enableLegacyHidden )) {\n\t            workInProgress.flags |= Visibility;\n\t          }\n\t        }\n\n\t        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n\t          bubbleProperties(workInProgress);\n\t        } else {\n\t          // Don't bubble properties for hidden children unless we're rendering\n\t          // at offscreen priority.\n\t          if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n\t            bubbleProperties(workInProgress);\n\n\t            if (supportsMutation) {\n\t              // Check if there was an insertion or update in the hidden subtree.\n\t              // If so, we need to hide those nodes in the commit phase, so\n\t              // schedule a visibility effect.\n\t              if ( workInProgress.subtreeFlags & (Placement | Update)) {\n\t                workInProgress.flags |= Visibility;\n\t              }\n\t            }\n\t          }\n\t        }\n\t        return null;\n\t      }\n\n\t    case CacheComponent:\n\t      {\n\n\t        return null;\n\t      }\n\n\t    case TracingMarkerComponent:\n\t      {\n\n\t        return null;\n\t      }\n\t  }\n\n\t  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n\t}\n\n\tfunction unwindWork(current, workInProgress, renderLanes) {\n\t  // Note: This intentionally doesn't check if we're hydrating because comparing\n\t  // to the current tree provider fiber is just as fast and less error-prone.\n\t  // Ideally we would have a special version of the work loop only\n\t  // for hydration.\n\t  popTreeContext(workInProgress);\n\n\t  switch (workInProgress.tag) {\n\t    case ClassComponent:\n\t      {\n\t        var Component = workInProgress.type;\n\n\t        if (isContextProvider(Component)) {\n\t          popContext(workInProgress);\n\t        }\n\n\t        var flags = workInProgress.flags;\n\n\t        if (flags & ShouldCapture) {\n\t          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n\n\t          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n\t            transferActualDuration(workInProgress);\n\t          }\n\n\t          return workInProgress;\n\t        }\n\n\t        return null;\n\t      }\n\n\t    case HostRoot:\n\t      {\n\t        workInProgress.stateNode;\n\t        popHostContainer(workInProgress);\n\t        popTopLevelContextObject(workInProgress);\n\t        resetWorkInProgressVersions();\n\t        var _flags = workInProgress.flags;\n\n\t        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n\t          // There was an error during render that wasn't captured by a suspense\n\t          // boundary. Do a second pass on the root to unmount the children.\n\t          workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n\t          return workInProgress;\n\t        } // We unwound to the root without completing it. Exit.\n\n\n\t        return null;\n\t      }\n\n\t    case HostComponent:\n\t      {\n\t        // TODO: popHydrationState\n\t        popHostContext(workInProgress);\n\t        return null;\n\t      }\n\n\t    case SuspenseComponent:\n\t      {\n\t        popSuspenseContext(workInProgress);\n\t        var suspenseState = workInProgress.memoizedState;\n\n\t        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n\t          if (workInProgress.alternate === null) {\n\t            throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n\t          }\n\n\t          resetHydrationState();\n\t        }\n\n\t        var _flags2 = workInProgress.flags;\n\n\t        if (_flags2 & ShouldCapture) {\n\t          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n\t          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n\t            transferActualDuration(workInProgress);\n\t          }\n\n\t          return workInProgress;\n\t        }\n\n\t        return null;\n\t      }\n\n\t    case SuspenseListComponent:\n\t      {\n\t        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n\t        // caught by a nested boundary. If not, it should bubble through.\n\n\t        return null;\n\t      }\n\n\t    case HostPortal:\n\t      popHostContainer(workInProgress);\n\t      return null;\n\n\t    case ContextProvider:\n\t      var context = workInProgress.type._context;\n\t      popProvider(context, workInProgress);\n\t      return null;\n\n\t    case OffscreenComponent:\n\t    case LegacyHiddenComponent:\n\t      popRenderLanes(workInProgress);\n\t      return null;\n\n\t    case CacheComponent:\n\n\t      return null;\n\n\t    default:\n\t      return null;\n\t  }\n\t}\n\n\tfunction unwindInterruptedWork(current, interruptedWork, renderLanes) {\n\t  // Note: This intentionally doesn't check if we're hydrating because comparing\n\t  // to the current tree provider fiber is just as fast and less error-prone.\n\t  // Ideally we would have a special version of the work loop only\n\t  // for hydration.\n\t  popTreeContext(interruptedWork);\n\n\t  switch (interruptedWork.tag) {\n\t    case ClassComponent:\n\t      {\n\t        var childContextTypes = interruptedWork.type.childContextTypes;\n\n\t        if (childContextTypes !== null && childContextTypes !== undefined) {\n\t          popContext(interruptedWork);\n\t        }\n\n\t        break;\n\t      }\n\n\t    case HostRoot:\n\t      {\n\t        interruptedWork.stateNode;\n\t        popHostContainer(interruptedWork);\n\t        popTopLevelContextObject(interruptedWork);\n\t        resetWorkInProgressVersions();\n\t        break;\n\t      }\n\n\t    case HostComponent:\n\t      {\n\t        popHostContext(interruptedWork);\n\t        break;\n\t      }\n\n\t    case HostPortal:\n\t      popHostContainer(interruptedWork);\n\t      break;\n\n\t    case SuspenseComponent:\n\t      popSuspenseContext(interruptedWork);\n\t      break;\n\n\t    case SuspenseListComponent:\n\t      popSuspenseContext(interruptedWork);\n\t      break;\n\n\t    case ContextProvider:\n\t      var context = interruptedWork.type._context;\n\t      popProvider(context, interruptedWork);\n\t      break;\n\n\t    case OffscreenComponent:\n\t    case LegacyHiddenComponent:\n\t      popRenderLanes(interruptedWork);\n\t      break;\n\t  }\n\t}\n\n\tfunction invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n\t  var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n\t  try {\n\t    func.apply(context, funcArgs);\n\t  } catch (error) {\n\t    this.onError(error);\n\t  }\n\t}\n\n\tvar invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n\n\t{\n\t  // In DEV mode, we swap out invokeGuardedCallback for a special version\n\t  // that plays more nicely with the browser's DevTools. The idea is to preserve\n\t  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n\t  // functions in invokeGuardedCallback, and the production version of\n\t  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n\t  // like caught exceptions, and the DevTools won't pause unless the developer\n\t  // takes the extra step of enabling pause on caught exceptions. This is\n\t  // unintuitive, though, because even though React has caught the error, from\n\t  // the developer's perspective, the error is uncaught.\n\t  //\n\t  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n\t  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n\t  // DOM node, and call the user-provided callback from inside an event handler\n\t  // for that fake event. If the callback throws, the error is \"captured\" using\n\t  // a global event handler. But because the error happens in a different\n\t  // event loop context, it does not interrupt the normal program flow.\n\t  // Effectively, this gives us try-catch behavior without actually using\n\t  // try-catch. Neat!\n\t  // Check that the browser supports the APIs we need to implement our special\n\t  // DEV version of invokeGuardedCallback\n\t  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n\t    var fakeNode = document.createElement('react');\n\n\t    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n\t      // If document doesn't exist we know for sure we will crash in this method\n\t      // when we call document.createEvent(). However this can cause confusing\n\t      // errors: https://github.com/facebook/create-react-app/issues/3482\n\t      // So we preemptively throw with a better message instead.\n\t      if (typeof document === 'undefined' || document === null) {\n\t        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');\n\t      }\n\n\t      var evt = document.createEvent('Event');\n\t      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We\n\t      // set this to true at the beginning, then set it to false right after\n\t      // calling the function. If the function errors, `didError` will never be\n\t      // set to false. This strategy works even if the browser is flaky and\n\t      // fails to call our global error handler, because it doesn't rely on\n\t      // the error event at all.\n\n\t      var didError = true; // Keeps track of the value of window.event so that we can reset it\n\t      // during the callback to let user code access window.event in the\n\t      // browsers that support it.\n\n\t      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event\n\t      // dispatching: https://github.com/facebook/react/issues/13688\n\n\t      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');\n\n\t      function restoreAfterDispatch() {\n\t        // We immediately remove the callback from event listeners so that\n\t        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n\t        // nested call would trigger the fake event handlers of any call higher\n\t        // in the stack.\n\t        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the\n\t        // window.event assignment in both IE <= 10 as they throw an error\n\t        // \"Member not found\" in strict mode, and in Firefox which does not\n\t        // support window.event.\n\n\t        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n\t          window.event = windowEvent;\n\t        }\n\t      } // Create an event handler for our fake event. We will synchronously\n\t      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n\t      // call the user-provided callback.\n\n\n\t      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n\t      function callCallback() {\n\t        didCall = true;\n\t        restoreAfterDispatch();\n\t        func.apply(context, funcArgs);\n\t        didError = false;\n\t      } // Create a global error event handler. We use this to capture the value\n\t      // that was thrown. It's possible that this error handler will fire more\n\t      // than once; for example, if non-React code also calls `dispatchEvent`\n\t      // and a handler for that event throws. We should be resilient to most of\n\t      // those cases. Even if our error event handler fires more than once, the\n\t      // last error event is always used. If the callback actually does error,\n\t      // we know that the last error event is the correct one, because it's not\n\t      // possible for anything else to have happened in between our callback\n\t      // erroring and the code that follows the `dispatchEvent` call below. If\n\t      // the callback doesn't error, but the error event was fired, we know to\n\t      // ignore it because `didError` will be false, as described above.\n\n\n\t      var error; // Use this to track whether the error event is ever called.\n\n\t      var didSetError = false;\n\t      var isCrossOriginError = false;\n\n\t      function handleWindowError(event) {\n\t        error = event.error;\n\t        didSetError = true;\n\n\t        if (error === null && event.colno === 0 && event.lineno === 0) {\n\t          isCrossOriginError = true;\n\t        }\n\n\t        if (event.defaultPrevented) {\n\t          // Some other error handler has prevented default.\n\t          // Browsers silence the error report if this happens.\n\t          // We'll remember this to later decide whether to log it or not.\n\t          if (error != null && typeof error === 'object') {\n\t            try {\n\t              error._suppressLogging = true;\n\t            } catch (inner) {// Ignore.\n\t            }\n\t          }\n\t        }\n\t      } // Create a fake event type.\n\n\n\t      var evtType = \"react-\" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n\t      window.addEventListener('error', handleWindowError);\n\t      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n\t      // errors, it will trigger our global error handler.\n\n\t      evt.initEvent(evtType, false, false);\n\t      fakeNode.dispatchEvent(evt);\n\n\t      if (windowEventDescriptor) {\n\t        Object.defineProperty(window, 'event', windowEventDescriptor);\n\t      }\n\n\t      if (didCall && didError) {\n\t        if (!didSetError) {\n\t          // The callback errored, but the error event never fired.\n\t          // eslint-disable-next-line react-internal/prod-error-codes\n\t          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n\t        } else if (isCrossOriginError) {\n\t          // eslint-disable-next-line react-internal/prod-error-codes\n\t          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');\n\t        }\n\n\t        this.onError(error);\n\t      } // Remove our event listeners\n\n\n\t      window.removeEventListener('error', handleWindowError);\n\n\t      if (!didCall) {\n\t        // Something went really wrong, and our event was not dispatched.\n\t        // https://github.com/facebook/react/issues/16734\n\t        // https://github.com/facebook/react/issues/16585\n\t        // Fall back to the production implementation.\n\t        restoreAfterDispatch();\n\t        return invokeGuardedCallbackProd.apply(this, arguments);\n\t      }\n\t    };\n\t  }\n\t}\n\n\tvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\n\tvar hasError = false;\n\tvar caughtError = null; // Used by event system to capture/rethrow the first error.\n\tvar reporter = {\n\t  onError: function (error) {\n\t    hasError = true;\n\t    caughtError = error;\n\t  }\n\t};\n\t/**\n\t * Call a function while guarding against errors that happens within it.\n\t * Returns an error if it throws, otherwise null.\n\t *\n\t * In production, this is implemented using a try-catch. The reason we don't\n\t * use a try-catch directly is so that we can swap out a different\n\t * implementation in DEV mode.\n\t *\n\t * @param {String} name of the guard to use for logging or debugging\n\t * @param {Function} func The function to invoke\n\t * @param {*} context The context to use when calling the function\n\t * @param {...*} args Arguments for function\n\t */\n\n\tfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n\t  hasError = false;\n\t  caughtError = null;\n\t  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n\t}\n\tfunction hasCaughtError() {\n\t  return hasError;\n\t}\n\tfunction clearCaughtError() {\n\t  if (hasError) {\n\t    var error = caughtError;\n\t    hasError = false;\n\t    caughtError = null;\n\t    return error;\n\t  } else {\n\t    throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');\n\t  }\n\t}\n\n\tvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\n\t{\n\t  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n\t} // Used during the commit phase to track the state of the Offscreen component stack.\n\t// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n\t// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\n\n\tvar offscreenSubtreeIsHidden = false;\n\tvar offscreenSubtreeWasHidden = false;\n\tvar PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n\tvar nextEffect = null; // Used for Profiling builds to track updaters.\n\n\tvar inProgressLanes = null;\n\tvar inProgressRoot = null;\n\tfunction reportUncaughtErrorInDEV(error) {\n\t  // Wrapping each small part of the commit phase into a guarded\n\t  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n\t  // But we rely on it to surface errors to DEV tools like overlays\n\t  // (https://github.com/facebook/react/issues/21712).\n\t  // As a compromise, rethrow only caught errors in a guard.\n\t  {\n\t    invokeGuardedCallback(null, function () {\n\t      throw error;\n\t    });\n\t    clearCaughtError();\n\t  }\n\t}\n\n\tvar callComponentWillUnmountWithTimer = function (current, instance) {\n\t  instance.props = current.memoizedProps;\n\t  instance.state = current.memoizedState;\n\n\t  if ( current.mode & ProfileMode) {\n\t    try {\n\t      startLayoutEffectTimer();\n\t      instance.componentWillUnmount();\n\t    } finally {\n\t      recordLayoutEffectDuration(current);\n\t    }\n\t  } else {\n\t    instance.componentWillUnmount();\n\t  }\n\t}; // Capture errors so they don't interrupt mounting.\n\n\n\tfunction safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n\t  try {\n\t    commitHookEffectListMount(Layout, current);\n\t  } catch (error) {\n\t    captureCommitPhaseError(current, nearestMountedAncestor, error);\n\t  }\n\t} // Capture errors so they don't interrupt unmounting.\n\n\n\tfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n\t  try {\n\t    callComponentWillUnmountWithTimer(current, instance);\n\t  } catch (error) {\n\t    captureCommitPhaseError(current, nearestMountedAncestor, error);\n\t  }\n\t} // Capture errors so they don't interrupt mounting.\n\n\n\tfunction safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n\t  try {\n\t    instance.componentDidMount();\n\t  } catch (error) {\n\t    captureCommitPhaseError(current, nearestMountedAncestor, error);\n\t  }\n\t} // Capture errors so they don't interrupt mounting.\n\n\n\tfunction safelyAttachRef(current, nearestMountedAncestor) {\n\t  try {\n\t    commitAttachRef(current);\n\t  } catch (error) {\n\t    captureCommitPhaseError(current, nearestMountedAncestor, error);\n\t  }\n\t}\n\n\tfunction safelyDetachRef(current, nearestMountedAncestor) {\n\t  var ref = current.ref;\n\n\t  if (ref !== null) {\n\t    if (typeof ref === 'function') {\n\t      var retVal;\n\n\t      try {\n\t        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n\t          try {\n\t            startLayoutEffectTimer();\n\t            retVal = ref(null);\n\t          } finally {\n\t            recordLayoutEffectDuration(current);\n\t          }\n\t        } else {\n\t          retVal = ref(null);\n\t        }\n\t      } catch (error) {\n\t        captureCommitPhaseError(current, nearestMountedAncestor, error);\n\t      }\n\n\t      {\n\t        if (typeof retVal === 'function') {\n\t          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n\t        }\n\t      }\n\t    } else {\n\t      ref.current = null;\n\t    }\n\t  }\n\t}\n\n\tfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n\t  try {\n\t    destroy();\n\t  } catch (error) {\n\t    captureCommitPhaseError(current, nearestMountedAncestor, error);\n\t  }\n\t}\n\tvar shouldFireAfterActiveInstanceBlur = false;\n\tfunction commitBeforeMutationEffects(root, firstChild) {\n\t  prepareForCommit(root.containerInfo);\n\t  nextEffect = firstChild;\n\t  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n\t  var shouldFire = shouldFireAfterActiveInstanceBlur;\n\t  shouldFireAfterActiveInstanceBlur = false;\n\t  return shouldFire;\n\t}\n\n\tfunction commitBeforeMutationEffects_begin() {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n\n\t    var child = fiber.child;\n\n\t    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n\t      child.return = fiber;\n\t      nextEffect = child;\n\t    } else {\n\t      commitBeforeMutationEffects_complete();\n\t    }\n\t  }\n\t}\n\n\tfunction commitBeforeMutationEffects_complete() {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    setCurrentFiber(fiber);\n\n\t    try {\n\t      commitBeforeMutationEffectsOnFiber(fiber);\n\t    } catch (error) {\n\t      captureCommitPhaseError(fiber, fiber.return, error);\n\t    }\n\n\t    resetCurrentFiber();\n\t    var sibling = fiber.sibling;\n\n\t    if (sibling !== null) {\n\t      sibling.return = fiber.return;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = fiber.return;\n\t  }\n\t}\n\n\tfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n\t  var current = finishedWork.alternate;\n\t  var flags = finishedWork.flags;\n\n\t  if ((flags & Snapshot) !== NoFlags) {\n\t    setCurrentFiber(finishedWork);\n\n\t    switch (finishedWork.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case SimpleMemoComponent:\n\t        {\n\t          break;\n\t        }\n\n\t      case ClassComponent:\n\t        {\n\t          if (current !== null) {\n\t            var prevProps = current.memoizedProps;\n\t            var prevState = current.memoizedState;\n\t            var instance = finishedWork.stateNode; // We could update instance props and state here,\n\t            // but instead we rely on them being set during last render.\n\t            // TODO: revisit this when we implement resuming.\n\n\t            {\n\t              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n\t                if (instance.props !== finishedWork.memoizedProps) {\n\t                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                }\n\n\t                if (instance.state !== finishedWork.memoizedState) {\n\t                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                }\n\t              }\n\t            }\n\n\t            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n\t            {\n\t              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n\t              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n\t                didWarnSet.add(finishedWork.type);\n\n\t                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n\t              }\n\t            }\n\n\t            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostRoot:\n\t        {\n\t          if (supportsMutation) {\n\t            var root = finishedWork.stateNode;\n\t            clearContainer(root.containerInfo);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostComponent:\n\t      case HostText:\n\t      case HostPortal:\n\t      case IncompleteClassComponent:\n\t        // Nothing to do for these component types\n\t        break;\n\n\t      default:\n\t        {\n\t          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n\t        }\n\t    }\n\n\t    resetCurrentFiber();\n\t  }\n\t}\n\n\tfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n\t  var updateQueue = finishedWork.updateQueue;\n\t  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n\t  if (lastEffect !== null) {\n\t    var firstEffect = lastEffect.next;\n\t    var effect = firstEffect;\n\n\t    do {\n\t      if ((effect.tag & flags) === flags) {\n\t        // Unmount\n\t        var destroy = effect.destroy;\n\t        effect.destroy = undefined;\n\n\t        if (destroy !== undefined) {\n\t          {\n\t            if ((flags & Passive$1) !== NoFlags$1) {\n\t              markComponentPassiveEffectUnmountStarted(finishedWork);\n\t            } else if ((flags & Layout) !== NoFlags$1) {\n\t              markComponentLayoutEffectUnmountStarted(finishedWork);\n\t            }\n\t          }\n\n\t          {\n\t            if ((flags & Insertion) !== NoFlags$1) {\n\t              setIsRunningInsertionEffect(true);\n\t            }\n\t          }\n\n\t          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n\t          {\n\t            if ((flags & Insertion) !== NoFlags$1) {\n\t              setIsRunningInsertionEffect(false);\n\t            }\n\t          }\n\n\t          {\n\t            if ((flags & Passive$1) !== NoFlags$1) {\n\t              markComponentPassiveEffectUnmountStopped();\n\t            } else if ((flags & Layout) !== NoFlags$1) {\n\t              markComponentLayoutEffectUnmountStopped();\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      effect = effect.next;\n\t    } while (effect !== firstEffect);\n\t  }\n\t}\n\n\tfunction commitHookEffectListMount(flags, finishedWork) {\n\t  var updateQueue = finishedWork.updateQueue;\n\t  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n\t  if (lastEffect !== null) {\n\t    var firstEffect = lastEffect.next;\n\t    var effect = firstEffect;\n\n\t    do {\n\t      if ((effect.tag & flags) === flags) {\n\t        {\n\t          if ((flags & Passive$1) !== NoFlags$1) {\n\t            markComponentPassiveEffectMountStarted(finishedWork);\n\t          } else if ((flags & Layout) !== NoFlags$1) {\n\t            markComponentLayoutEffectMountStarted(finishedWork);\n\t          }\n\t        } // Mount\n\n\n\t        var create = effect.create;\n\n\t        {\n\t          if ((flags & Insertion) !== NoFlags$1) {\n\t            setIsRunningInsertionEffect(true);\n\t          }\n\t        }\n\n\t        effect.destroy = create();\n\n\t        {\n\t          if ((flags & Insertion) !== NoFlags$1) {\n\t            setIsRunningInsertionEffect(false);\n\t          }\n\t        }\n\n\t        {\n\t          if ((flags & Passive$1) !== NoFlags$1) {\n\t            markComponentPassiveEffectMountStopped();\n\t          } else if ((flags & Layout) !== NoFlags$1) {\n\t            markComponentLayoutEffectMountStopped();\n\t          }\n\t        }\n\n\t        {\n\t          var destroy = effect.destroy;\n\n\t          if (destroy !== undefined && typeof destroy !== 'function') {\n\t            var hookName = void 0;\n\n\t            if ((effect.tag & Layout) !== NoFlags) {\n\t              hookName = 'useLayoutEffect';\n\t            } else if ((effect.tag & Insertion) !== NoFlags) {\n\t              hookName = 'useInsertionEffect';\n\t            } else {\n\t              hookName = 'useEffect';\n\t            }\n\n\t            var addendum = void 0;\n\n\t            if (destroy === null) {\n\t              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n\t            } else if (typeof destroy.then === 'function') {\n\t              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n\t            } else {\n\t              addendum = ' You returned: ' + destroy;\n\t            }\n\n\t            error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n\t          }\n\t        }\n\t      }\n\n\t      effect = effect.next;\n\t    } while (effect !== firstEffect);\n\t  }\n\t}\n\n\tfunction commitPassiveEffectDurations(finishedRoot, finishedWork) {\n\t  {\n\t    // Only Profilers with work in their subtree will have an Update effect scheduled.\n\t    if ((finishedWork.flags & Update) !== NoFlags) {\n\t      switch (finishedWork.tag) {\n\t        case Profiler:\n\t          {\n\t            var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n\t            var _finishedWork$memoize = finishedWork.memoizedProps,\n\t                id = _finishedWork$memoize.id,\n\t                onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n\t            // It does not get reset until the start of the next commit phase.\n\n\t            var commitTime = getCommitTime();\n\t            var phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n\t            {\n\t              if (isCurrentUpdateNested()) {\n\t                phase = 'nested-update';\n\t              }\n\t            }\n\n\t            if (typeof onPostCommit === 'function') {\n\t              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n\t            } // Bubble times to the next nearest ancestor Profiler.\n\t            // After we process that Profiler, we'll bubble further up.\n\n\n\t            var parentFiber = finishedWork.return;\n\n\t            outer: while (parentFiber !== null) {\n\t              switch (parentFiber.tag) {\n\t                case HostRoot:\n\t                  var root = parentFiber.stateNode;\n\t                  root.passiveEffectDuration += passiveEffectDuration;\n\t                  break outer;\n\n\t                case Profiler:\n\t                  var parentStateNode = parentFiber.stateNode;\n\t                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n\t                  break outer;\n\t              }\n\n\t              parentFiber = parentFiber.return;\n\t            }\n\n\t            break;\n\t          }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n\t  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n\t    switch (finishedWork.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case SimpleMemoComponent:\n\t        {\n\t          if ( !offscreenSubtreeWasHidden) {\n\t            // At this point layout effects have already been destroyed (during mutation phase).\n\t            // This is done to prevent sibling component effects from interfering with each other,\n\t            // e.g. a destroy function in one component should never override a ref set\n\t            // by a create function in another component during the same commit.\n\t            if ( finishedWork.mode & ProfileMode) {\n\t              try {\n\t                startLayoutEffectTimer();\n\t                commitHookEffectListMount(Layout | HasEffect, finishedWork);\n\t              } finally {\n\t                recordLayoutEffectDuration(finishedWork);\n\t              }\n\t            } else {\n\t              commitHookEffectListMount(Layout | HasEffect, finishedWork);\n\t            }\n\t          }\n\n\t          break;\n\t        }\n\n\t      case ClassComponent:\n\t        {\n\t          var instance = finishedWork.stateNode;\n\n\t          if (finishedWork.flags & Update) {\n\t            if (!offscreenSubtreeWasHidden) {\n\t              if (current === null) {\n\t                // We could update instance props and state here,\n\t                // but instead we rely on them being set during last render.\n\t                // TODO: revisit this when we implement resuming.\n\t                {\n\t                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n\t                    if (instance.props !== finishedWork.memoizedProps) {\n\t                      error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                    }\n\n\t                    if (instance.state !== finishedWork.memoizedState) {\n\t                      error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                    }\n\t                  }\n\t                }\n\n\t                if ( finishedWork.mode & ProfileMode) {\n\t                  try {\n\t                    startLayoutEffectTimer();\n\t                    instance.componentDidMount();\n\t                  } finally {\n\t                    recordLayoutEffectDuration(finishedWork);\n\t                  }\n\t                } else {\n\t                  instance.componentDidMount();\n\t                }\n\t              } else {\n\t                var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n\t                var prevState = current.memoizedState; // We could update instance props and state here,\n\t                // but instead we rely on them being set during last render.\n\t                // TODO: revisit this when we implement resuming.\n\n\t                {\n\t                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n\t                    if (instance.props !== finishedWork.memoizedProps) {\n\t                      error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                    }\n\n\t                    if (instance.state !== finishedWork.memoizedState) {\n\t                      error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                    }\n\t                  }\n\t                }\n\n\t                if ( finishedWork.mode & ProfileMode) {\n\t                  try {\n\t                    startLayoutEffectTimer();\n\t                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n\t                  } finally {\n\t                    recordLayoutEffectDuration(finishedWork);\n\t                  }\n\t                } else {\n\t                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n\t                }\n\t              }\n\t            }\n\t          } // TODO: I think this is now always non-null by the time it reaches the\n\t          // commit phase. Consider removing the type check.\n\n\n\t          var updateQueue = finishedWork.updateQueue;\n\n\t          if (updateQueue !== null) {\n\t            {\n\t              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n\t                if (instance.props !== finishedWork.memoizedProps) {\n\t                  error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                }\n\n\t                if (instance.state !== finishedWork.memoizedState) {\n\t                  error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n\t                }\n\t              }\n\t            } // We could update instance props and state here,\n\t            // but instead we rely on them being set during last render.\n\t            // TODO: revisit this when we implement resuming.\n\n\n\t            commitUpdateQueue(finishedWork, updateQueue, instance);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostRoot:\n\t        {\n\t          // TODO: I think this is now always non-null by the time it reaches the\n\t          // commit phase. Consider removing the type check.\n\t          var _updateQueue = finishedWork.updateQueue;\n\n\t          if (_updateQueue !== null) {\n\t            var _instance = null;\n\n\t            if (finishedWork.child !== null) {\n\t              switch (finishedWork.child.tag) {\n\t                case HostComponent:\n\t                  _instance = getPublicInstance(finishedWork.child.stateNode);\n\t                  break;\n\n\t                case ClassComponent:\n\t                  _instance = finishedWork.child.stateNode;\n\t                  break;\n\t              }\n\t            }\n\n\t            commitUpdateQueue(finishedWork, _updateQueue, _instance);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostComponent:\n\t        {\n\t          var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n\t          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n\t          // These effects should only be committed when components are first mounted,\n\t          // aka when there is no current/alternate.\n\n\t          if (current === null && finishedWork.flags & Update) {\n\t            var type = finishedWork.type;\n\t            var props = finishedWork.memoizedProps;\n\t            commitMount(_instance2, type, props, finishedWork);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostText:\n\t        {\n\t          // We have no life-cycles associated with text.\n\t          break;\n\t        }\n\n\t      case HostPortal:\n\t        {\n\t          // We have no life-cycles associated with portals.\n\t          break;\n\t        }\n\n\t      case Profiler:\n\t        {\n\t          {\n\t            var _finishedWork$memoize2 = finishedWork.memoizedProps,\n\t                onCommit = _finishedWork$memoize2.onCommit,\n\t                onRender = _finishedWork$memoize2.onRender;\n\t            var effectDuration = finishedWork.stateNode.effectDuration;\n\t            var commitTime = getCommitTime();\n\t            var phase = current === null ? 'mount' : 'update';\n\n\t            {\n\t              if (isCurrentUpdateNested()) {\n\t                phase = 'nested-update';\n\t              }\n\t            }\n\n\t            if (typeof onRender === 'function') {\n\t              onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n\t            }\n\n\t            {\n\t              if (typeof onCommit === 'function') {\n\t                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n\t              } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n\t              // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n\t              // because the effect is also where times bubble to parent Profilers.\n\n\n\t              enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n\t              // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n\t              var parentFiber = finishedWork.return;\n\n\t              outer: while (parentFiber !== null) {\n\t                switch (parentFiber.tag) {\n\t                  case HostRoot:\n\t                    var root = parentFiber.stateNode;\n\t                    root.effectDuration += effectDuration;\n\t                    break outer;\n\n\t                  case Profiler:\n\t                    var parentStateNode = parentFiber.stateNode;\n\t                    parentStateNode.effectDuration += effectDuration;\n\t                    break outer;\n\t                }\n\n\t                parentFiber = parentFiber.return;\n\t              }\n\t            }\n\t          }\n\n\t          break;\n\t        }\n\n\t      case SuspenseComponent:\n\t        {\n\t          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n\t          break;\n\t        }\n\n\t      case SuspenseListComponent:\n\t      case IncompleteClassComponent:\n\t      case ScopeComponent:\n\t      case OffscreenComponent:\n\t      case LegacyHiddenComponent:\n\t      case TracingMarkerComponent:\n\t        {\n\t          break;\n\t        }\n\n\t      default:\n\t        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n\t    }\n\t  }\n\n\t  if ( !offscreenSubtreeWasHidden) {\n\t    {\n\t      if (finishedWork.flags & Ref) {\n\t        commitAttachRef(finishedWork);\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction reappearLayoutEffectsOnFiber(node) {\n\t  // Turn on layout effects in a tree that previously disappeared.\n\t  // TODO (Offscreen) Check: flags & LayoutStatic\n\t  switch (node.tag) {\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case SimpleMemoComponent:\n\t      {\n\t        if ( node.mode & ProfileMode) {\n\t          try {\n\t            startLayoutEffectTimer();\n\t            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n\t          } finally {\n\t            recordLayoutEffectDuration(node);\n\t          }\n\t        } else {\n\t          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n\t        }\n\n\t        break;\n\t      }\n\n\t    case ClassComponent:\n\t      {\n\t        var instance = node.stateNode;\n\n\t        if (typeof instance.componentDidMount === 'function') {\n\t          safelyCallComponentDidMount(node, node.return, instance);\n\t        }\n\n\t        safelyAttachRef(node, node.return);\n\t        break;\n\t      }\n\n\t    case HostComponent:\n\t      {\n\t        safelyAttachRef(node, node.return);\n\t        break;\n\t      }\n\t  }\n\t}\n\n\tfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n\t  // Only hide or unhide the top-most host nodes.\n\t  var hostSubtreeRoot = null;\n\n\t  if (supportsMutation) {\n\t    // We only have the top Fiber that was inserted but we need to recurse down its\n\t    // children to find all the terminal nodes.\n\t    var node = finishedWork;\n\n\t    while (true) {\n\t      if (node.tag === HostComponent) {\n\t        if (hostSubtreeRoot === null) {\n\t          hostSubtreeRoot = node;\n\n\t          try {\n\t            var instance = node.stateNode;\n\n\t            if (isHidden) {\n\t              hideInstance(instance);\n\t            } else {\n\t              unhideInstance(node.stateNode, node.memoizedProps);\n\t            }\n\t          } catch (error) {\n\t            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t          }\n\t        }\n\t      } else if (node.tag === HostText) {\n\t        if (hostSubtreeRoot === null) {\n\t          try {\n\t            var _instance3 = node.stateNode;\n\n\t            if (isHidden) {\n\t              hideTextInstance(_instance3);\n\t            } else {\n\t              unhideTextInstance(_instance3, node.memoizedProps);\n\t            }\n\t          } catch (error) {\n\t            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t          }\n\t        }\n\t      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {\n\t        node.child.return = node;\n\t        node = node.child;\n\t        continue;\n\t      }\n\n\t      if (node === finishedWork) {\n\t        return;\n\t      }\n\n\t      while (node.sibling === null) {\n\t        if (node.return === null || node.return === finishedWork) {\n\t          return;\n\t        }\n\n\t        if (hostSubtreeRoot === node) {\n\t          hostSubtreeRoot = null;\n\t        }\n\n\t        node = node.return;\n\t      }\n\n\t      if (hostSubtreeRoot === node) {\n\t        hostSubtreeRoot = null;\n\t      }\n\n\t      node.sibling.return = node.return;\n\t      node = node.sibling;\n\t    }\n\t  }\n\t}\n\n\tfunction commitAttachRef(finishedWork) {\n\t  var ref = finishedWork.ref;\n\n\t  if (ref !== null) {\n\t    var instance = finishedWork.stateNode;\n\t    var instanceToUse;\n\n\t    switch (finishedWork.tag) {\n\t      case HostComponent:\n\t        instanceToUse = getPublicInstance(instance);\n\t        break;\n\n\t      default:\n\t        instanceToUse = instance;\n\t    } // Moved outside to ensure DCE works with this flag\n\n\t    if (typeof ref === 'function') {\n\t      var retVal;\n\n\t      if ( finishedWork.mode & ProfileMode) {\n\t        try {\n\t          startLayoutEffectTimer();\n\t          retVal = ref(instanceToUse);\n\t        } finally {\n\t          recordLayoutEffectDuration(finishedWork);\n\t        }\n\t      } else {\n\t        retVal = ref(instanceToUse);\n\t      }\n\n\t      {\n\t        if (typeof retVal === 'function') {\n\t          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));\n\t        }\n\t      }\n\t    } else {\n\t      {\n\t        if (!ref.hasOwnProperty('current')) {\n\t          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n\t        }\n\t      }\n\n\t      ref.current = instanceToUse;\n\t    }\n\t  }\n\t}\n\n\tfunction detachFiberMutation(fiber) {\n\t  // Cut off the return pointer to disconnect it from the tree.\n\t  // This enables us to detect and warn against state updates on an unmounted component.\n\t  // It also prevents events from bubbling from within disconnected components.\n\t  //\n\t  // Ideally, we should also clear the child pointer of the parent alternate to let this\n\t  // get GC:ed but we don't know which for sure which parent is the current\n\t  // one so we'll settle for GC:ing the subtree of this child.\n\t  // This child itself will be GC:ed when the parent updates the next time.\n\t  //\n\t  // Note that we can't clear child or sibling pointers yet.\n\t  // They're needed for passive effects and for findDOMNode.\n\t  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n\t  //\n\t  // Don't reset the alternate yet, either. We need that so we can detach the\n\t  // alternate's fields in the passive phase. Clearing the return pointer is\n\t  // sufficient for findDOMNode semantics.\n\t  var alternate = fiber.alternate;\n\n\t  if (alternate !== null) {\n\t    alternate.return = null;\n\t  }\n\n\t  fiber.return = null;\n\t}\n\n\tfunction detachFiberAfterEffects(fiber) {\n\t  var alternate = fiber.alternate;\n\n\t  if (alternate !== null) {\n\t    fiber.alternate = null;\n\t    detachFiberAfterEffects(alternate);\n\t  } // Note: Defensively using negation instead of < in case\n\t  // `deletedTreeCleanUpLevel` is undefined.\n\n\n\t  {\n\t    // Clear cyclical Fiber fields. This level alone is designed to roughly\n\t    // approximate the planned Fiber refactor. In that world, `setState` will be\n\t    // bound to a special \"instance\" object instead of a Fiber. The Instance\n\t    // object will not have any of these fields. It will only be connected to\n\t    // the fiber tree via a single link at the root. So if this level alone is\n\t    // sufficient to fix memory issues, that bodes well for our plans.\n\t    fiber.child = null;\n\t    fiber.deletions = null;\n\t    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n\t    // tree, which has its own pointers to children, parents, and siblings.\n\t    // The other host nodes also point back to fibers, so we should detach that\n\t    // one, too.\n\n\t    if (fiber.tag === HostComponent) {\n\t      var hostInstance = fiber.stateNode;\n\n\t      if (hostInstance !== null) {\n\t        detachDeletedInstance(hostInstance);\n\t      }\n\t    }\n\n\t    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n\t    // already disconnect the `return` pointer at the root of the deleted\n\t    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n\t    // cyclical  it's only cyclical when combined with `child`, `sibling`, and\n\t    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n\t    {\n\t      fiber._debugOwner = null;\n\t    }\n\n\t    {\n\t      // Theoretically, nothing in here should be necessary, because we already\n\t      // disconnected the fiber from the tree. So even if something leaks this\n\t      // particular fiber, it won't leak anything else\n\t      //\n\t      // The purpose of this branch is to be super aggressive so we can measure\n\t      // if there's any difference in memory impact. If there is, that could\n\t      // indicate a React leak we don't know about.\n\t      fiber.return = null;\n\t      fiber.dependencies = null;\n\t      fiber.memoizedProps = null;\n\t      fiber.memoizedState = null;\n\t      fiber.pendingProps = null;\n\t      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n\t      fiber.updateQueue = null;\n\t    }\n\t  }\n\t}\n\n\tfunction emptyPortalContainer(current) {\n\t  if (!supportsPersistence) {\n\t    return;\n\t  }\n\n\t  var portal = current.stateNode;\n\t  var containerInfo = portal.containerInfo;\n\t  var emptyChildSet = createContainerChildSet(containerInfo);\n\t  replaceContainerChildren(containerInfo, emptyChildSet);\n\t}\n\n\tfunction getHostParentFiber(fiber) {\n\t  var parent = fiber.return;\n\n\t  while (parent !== null) {\n\t    if (isHostParent(parent)) {\n\t      return parent;\n\t    }\n\n\t    parent = parent.return;\n\t  }\n\n\t  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n\t}\n\n\tfunction isHostParent(fiber) {\n\t  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n\t}\n\n\tfunction getHostSibling(fiber) {\n\t  // We're going to search forward into the tree until we find a sibling host\n\t  // node. Unfortunately, if multiple insertions are done in a row we have to\n\t  // search past them. This leads to exponential search for the next sibling.\n\t  // TODO: Find a more efficient way to do this.\n\t  var node = fiber;\n\n\t  siblings: while (true) {\n\t    // If we didn't find anything, let's try the next sibling.\n\t    while (node.sibling === null) {\n\t      if (node.return === null || isHostParent(node.return)) {\n\t        // If we pop out of the root or hit the parent the fiber we are the\n\t        // last sibling.\n\t        return null;\n\t      }\n\n\t      node = node.return;\n\t    }\n\n\t    node.sibling.return = node.return;\n\t    node = node.sibling;\n\n\t    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n\t      // If it is not host node and, we might have a host node inside it.\n\t      // Try to search down until we find one.\n\t      if (node.flags & Placement) {\n\t        // If we don't have a child, try the siblings instead.\n\t        continue siblings;\n\t      } // If we don't have a child, try the siblings instead.\n\t      // We also skip portals because they are not part of this host tree.\n\n\n\t      if (node.child === null || node.tag === HostPortal) {\n\t        continue siblings;\n\t      } else {\n\t        node.child.return = node;\n\t        node = node.child;\n\t      }\n\t    } // Check if this host node is stable or about to be placed.\n\n\n\t    if (!(node.flags & Placement)) {\n\t      // Found it!\n\t      return node.stateNode;\n\t    }\n\t  }\n\t}\n\n\tfunction commitPlacement(finishedWork) {\n\t  if (!supportsMutation) {\n\t    return;\n\t  } // Recursively insert all host nodes into the parent.\n\n\n\t  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n\t  switch (parentFiber.tag) {\n\t    case HostComponent:\n\t      {\n\t        var parent = parentFiber.stateNode;\n\n\t        if (parentFiber.flags & ContentReset) {\n\t          // Reset the text content of the parent before doing any insertions\n\t          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n\t          parentFiber.flags &= ~ContentReset;\n\t        }\n\n\t        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n\t        // children to find all the terminal nodes.\n\n\t        insertOrAppendPlacementNode(finishedWork, before, parent);\n\t        break;\n\t      }\n\n\t    case HostRoot:\n\t    case HostPortal:\n\t      {\n\t        var _parent = parentFiber.stateNode.containerInfo;\n\n\t        var _before = getHostSibling(finishedWork);\n\n\t        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n\t        break;\n\t      }\n\t    // eslint-disable-next-line-no-fallthrough\n\n\t    default:\n\t      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n\t  }\n\t}\n\n\tfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n\t  var tag = node.tag;\n\t  var isHost = tag === HostComponent || tag === HostText;\n\n\t  if (isHost) {\n\t    var stateNode = node.stateNode;\n\n\t    if (before) {\n\t      insertInContainerBefore(parent, stateNode, before);\n\t    } else {\n\t      appendChildToContainer(parent, stateNode);\n\t    }\n\t  } else if (tag === HostPortal) ; else {\n\t    var child = node.child;\n\n\t    if (child !== null) {\n\t      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n\t      var sibling = child.sibling;\n\n\t      while (sibling !== null) {\n\t        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n\t        sibling = sibling.sibling;\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction insertOrAppendPlacementNode(node, before, parent) {\n\t  var tag = node.tag;\n\t  var isHost = tag === HostComponent || tag === HostText;\n\n\t  if (isHost) {\n\t    var stateNode = node.stateNode;\n\n\t    if (before) {\n\t      insertBefore(parent, stateNode, before);\n\t    } else {\n\t      appendChild(parent, stateNode);\n\t    }\n\t  } else if (tag === HostPortal) ; else {\n\t    var child = node.child;\n\n\t    if (child !== null) {\n\t      insertOrAppendPlacementNode(child, before, parent);\n\t      var sibling = child.sibling;\n\n\t      while (sibling !== null) {\n\t        insertOrAppendPlacementNode(sibling, before, parent);\n\t        sibling = sibling.sibling;\n\t      }\n\t    }\n\t  }\n\t} // These are tracked on the stack as we recursively traverse a\n\t// deleted subtree.\n\t// TODO: Update these during the whole mutation phase, not just during\n\t// a deletion.\n\n\n\tvar hostParent = null;\n\tvar hostParentIsContainer = false;\n\n\tfunction commitDeletionEffects(root, returnFiber, deletedFiber) {\n\t  if (supportsMutation) {\n\t    // We only have the top Fiber that was deleted but we need to recurse down its\n\t    // children to find all the terminal nodes.\n\t    // Recursively delete all host nodes from the parent, detach refs, clean\n\t    // up mounted layout effects, and call componentWillUnmount.\n\t    // We only need to remove the topmost host child in each branch. But then we\n\t    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n\t    // could split this into two separate traversals functions, where the second\n\t    // one doesn't include any removeChild logic. This is maybe the same\n\t    // function as \"disappearLayoutEffects\" (or whatever that turns into after\n\t    // the layout phase is refactored to use recursion).\n\t    // Before starting, find the nearest host parent on the stack so we know\n\t    // which instance/container to remove the children from.\n\t    // TODO: Instead of searching up the fiber return path on every deletion, we\n\t    // can track the nearest host component on the JS stack as we traverse the\n\t    // tree during the commit phase. This would make insertions faster, too.\n\t    var parent = returnFiber;\n\n\t    findParent: while (parent !== null) {\n\t      switch (parent.tag) {\n\t        case HostComponent:\n\t          {\n\t            hostParent = parent.stateNode;\n\t            hostParentIsContainer = false;\n\t            break findParent;\n\t          }\n\n\t        case HostRoot:\n\t          {\n\t            hostParent = parent.stateNode.containerInfo;\n\t            hostParentIsContainer = true;\n\t            break findParent;\n\t          }\n\n\t        case HostPortal:\n\t          {\n\t            hostParent = parent.stateNode.containerInfo;\n\t            hostParentIsContainer = true;\n\t            break findParent;\n\t          }\n\t      }\n\n\t      parent = parent.return;\n\t    }\n\n\t    if (hostParent === null) {\n\t      throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n\t    }\n\n\t    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n\t    hostParent = null;\n\t    hostParentIsContainer = false;\n\t  } else {\n\t    // Detach refs and call componentWillUnmount() on the whole subtree.\n\t    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n\t  }\n\n\t  detachFiberMutation(deletedFiber);\n\t}\n\n\tfunction recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n\t  // TODO: Use a static flag to skip trees that don't have unmount effects\n\t  var child = parent.child;\n\n\t  while (child !== null) {\n\t    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n\t    child = child.sibling;\n\t  }\n\t}\n\n\tfunction commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n\t  onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n\t  // into their subtree. There are simpler cases in the inner switch\n\t  // that don't modify the stack.\n\n\t  switch (deletedFiber.tag) {\n\t    case HostComponent:\n\t      {\n\t        if (!offscreenSubtreeWasHidden) {\n\t          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n\t        } // Intentional fallthrough to next branch\n\n\t      }\n\t    // eslint-disable-next-line-no-fallthrough\n\n\t    case HostText:\n\t      {\n\t        // We only need to remove the nearest host child. Set the host parent\n\t        // to `null` on the stack to indicate that nested children don't\n\t        // need to be removed.\n\t        if (supportsMutation) {\n\t          var prevHostParent = hostParent;\n\t          var prevHostParentIsContainer = hostParentIsContainer;\n\t          hostParent = null;\n\t          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t          hostParent = prevHostParent;\n\t          hostParentIsContainer = prevHostParentIsContainer;\n\n\t          if (hostParent !== null) {\n\t            // Now that all the child effects have unmounted, we can remove the\n\t            // node from the tree.\n\t            if (hostParentIsContainer) {\n\t              removeChildFromContainer(hostParent, deletedFiber.stateNode);\n\t            } else {\n\t              removeChild(hostParent, deletedFiber.stateNode);\n\t            }\n\t          }\n\t        } else {\n\t          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        }\n\n\t        return;\n\t      }\n\n\t    case DehydratedFragment:\n\t      {\n\t        // Delete the dehydrated suspense boundary and all of its content.\n\n\n\t        if (supportsMutation) {\n\t          if (hostParent !== null) {\n\t            if (hostParentIsContainer) {\n\t              clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n\t            } else {\n\t              clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n\t            }\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case HostPortal:\n\t      {\n\t        if (supportsMutation) {\n\t          // When we go into a portal, it becomes the parent to remove from.\n\t          var _prevHostParent = hostParent;\n\t          var _prevHostParentIsContainer = hostParentIsContainer;\n\t          hostParent = deletedFiber.stateNode.containerInfo;\n\t          hostParentIsContainer = true;\n\t          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t          hostParent = _prevHostParent;\n\t          hostParentIsContainer = _prevHostParentIsContainer;\n\t        } else {\n\t          emptyPortalContainer(deletedFiber);\n\t          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        }\n\n\t        return;\n\t      }\n\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case MemoComponent:\n\t    case SimpleMemoComponent:\n\t      {\n\t        if (!offscreenSubtreeWasHidden) {\n\t          var updateQueue = deletedFiber.updateQueue;\n\n\t          if (updateQueue !== null) {\n\t            var lastEffect = updateQueue.lastEffect;\n\n\t            if (lastEffect !== null) {\n\t              var firstEffect = lastEffect.next;\n\t              var effect = firstEffect;\n\n\t              do {\n\t                var _effect = effect,\n\t                    destroy = _effect.destroy,\n\t                    tag = _effect.tag;\n\n\t                if (destroy !== undefined) {\n\t                  if ((tag & Insertion) !== NoFlags$1) {\n\t                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n\t                  } else if ((tag & Layout) !== NoFlags$1) {\n\t                    {\n\t                      markComponentLayoutEffectUnmountStarted(deletedFiber);\n\t                    }\n\n\t                    if ( deletedFiber.mode & ProfileMode) {\n\t                      startLayoutEffectTimer();\n\t                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n\t                      recordLayoutEffectDuration(deletedFiber);\n\t                    } else {\n\t                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n\t                    }\n\n\t                    {\n\t                      markComponentLayoutEffectUnmountStopped();\n\t                    }\n\t                  }\n\t                }\n\n\t                effect = effect.next;\n\t              } while (effect !== firstEffect);\n\t            }\n\t          }\n\t        }\n\n\t        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        return;\n\t      }\n\n\t    case ClassComponent:\n\t      {\n\t        if (!offscreenSubtreeWasHidden) {\n\t          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n\t          var instance = deletedFiber.stateNode;\n\n\t          if (typeof instance.componentWillUnmount === 'function') {\n\t            safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n\t          }\n\t        }\n\n\t        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        return;\n\t      }\n\n\t    case ScopeComponent:\n\t      {\n\n\t        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        return;\n\t      }\n\n\t    case OffscreenComponent:\n\t      {\n\t        if ( // TODO: Remove this dead flag\n\t         deletedFiber.mode & ConcurrentMode) {\n\t          // If this offscreen component is hidden, we already unmounted it. Before\n\t          // deleting the children, track that it's already unmounted so that we\n\t          // don't attempt to unmount the effects again.\n\t          // TODO: If the tree is hidden, in most cases we should be able to skip\n\t          // over the nested children entirely. An exception is we haven't yet found\n\t          // the topmost host node to delete, which we already track on the stack.\n\t          // But the other case is portals, which need to be detached no matter how\n\t          // deeply they are nested. We should use a subtree flag to track whether a\n\t          // subtree includes a nested portal.\n\t          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n\t          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n\t          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n\t        } else {\n\t          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        }\n\n\t        break;\n\t      }\n\n\t    default:\n\t      {\n\t        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\t        return;\n\t      }\n\t  }\n\t}\n\n\tfunction commitSuspenseCallback(finishedWork) {\n\t  // TODO: Move this to passive phase\n\t  finishedWork.memoizedState;\n\t}\n\n\tfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n\t  if (!supportsHydration) {\n\t    return;\n\t  }\n\n\t  var newState = finishedWork.memoizedState;\n\n\t  if (newState === null) {\n\t    var current = finishedWork.alternate;\n\n\t    if (current !== null) {\n\t      var prevState = current.memoizedState;\n\n\t      if (prevState !== null) {\n\t        var suspenseInstance = prevState.dehydrated;\n\n\t        if (suspenseInstance !== null) {\n\t          commitHydratedSuspenseInstance(suspenseInstance);\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction attachSuspenseRetryListeners(finishedWork) {\n\t  // If this boundary just timed out, then it will have a set of wakeables.\n\t  // For each wakeable, attach a listener so that when it resolves, React\n\t  // attempts to re-render the boundary in the primary (pre-timeout) state.\n\t  var wakeables = finishedWork.updateQueue;\n\n\t  if (wakeables !== null) {\n\t    finishedWork.updateQueue = null;\n\t    var retryCache = finishedWork.stateNode;\n\n\t    if (retryCache === null) {\n\t      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n\t    }\n\n\t    wakeables.forEach(function (wakeable) {\n\t      // Memoize using the boundary fiber to prevent redundant listeners.\n\t      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n\t      if (!retryCache.has(wakeable)) {\n\t        retryCache.add(wakeable);\n\n\t        {\n\t          if (isDevToolsPresent) {\n\t            if (inProgressLanes !== null && inProgressRoot !== null) {\n\t              // If we have pending work still, associate the original updaters with it.\n\t              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n\t            } else {\n\t              throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n\t            }\n\t          }\n\t        }\n\n\t        wakeable.then(retry, retry);\n\t      }\n\t    });\n\t  }\n\t} // This function detects when a Suspense boundary goes from visible to hidden.\n\tfunction commitMutationEffects(root, finishedWork, committedLanes) {\n\t  inProgressLanes = committedLanes;\n\t  inProgressRoot = root;\n\t  setCurrentFiber(finishedWork);\n\t  commitMutationEffectsOnFiber(finishedWork, root);\n\t  setCurrentFiber(finishedWork);\n\t  inProgressLanes = null;\n\t  inProgressRoot = null;\n\t}\n\n\tfunction recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n\t  // Deletions effects can be scheduled on any fiber type. They need to happen\n\t  // before the children effects hae fired.\n\t  var deletions = parentFiber.deletions;\n\n\t  if (deletions !== null) {\n\t    for (var i = 0; i < deletions.length; i++) {\n\t      var childToDelete = deletions[i];\n\n\t      try {\n\t        commitDeletionEffects(root, parentFiber, childToDelete);\n\t      } catch (error) {\n\t        captureCommitPhaseError(childToDelete, parentFiber, error);\n\t      }\n\t    }\n\t  }\n\n\t  var prevDebugFiber = getCurrentFiber();\n\n\t  if (parentFiber.subtreeFlags & MutationMask) {\n\t    var child = parentFiber.child;\n\n\t    while (child !== null) {\n\t      setCurrentFiber(child);\n\t      commitMutationEffectsOnFiber(child, root);\n\t      child = child.sibling;\n\t    }\n\t  }\n\n\t  setCurrentFiber(prevDebugFiber);\n\t}\n\n\tfunction commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n\t  var current = finishedWork.alternate;\n\t  var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n\t  // because the fiber tag is more specific. An exception is any flag related\n\t  // to reconcilation, because those can be set on all fiber types.\n\n\t  switch (finishedWork.tag) {\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case MemoComponent:\n\t    case SimpleMemoComponent:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Update) {\n\t          try {\n\t            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n\t            commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n\t          } catch (error) {\n\t            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t          } // Layout effects are destroyed during the mutation phase so that all\n\t          // destroy functions for all fibers are called before any create functions.\n\t          // This prevents sibling component effects from interfering with each other,\n\t          // e.g. a destroy function in one component should never override a ref set\n\t          // by a create function in another component during the same commit.\n\n\n\t          if ( finishedWork.mode & ProfileMode) {\n\t            try {\n\t              startLayoutEffectTimer();\n\t              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n\t            } catch (error) {\n\t              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t            }\n\n\t            recordLayoutEffectDuration(finishedWork);\n\t          } else {\n\t            try {\n\t              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n\t            } catch (error) {\n\t              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t            }\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case ClassComponent:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Ref) {\n\t          if (current !== null) {\n\t            safelyDetachRef(current, current.return);\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case HostComponent:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Ref) {\n\t          if (current !== null) {\n\t            safelyDetachRef(current, current.return);\n\t          }\n\t        }\n\n\t        if (supportsMutation) {\n\t          // TODO: ContentReset gets cleared by the children during the commit\n\t          // phase. This is a refactor hazard because it means we must read\n\t          // flags the flags after `commitReconciliationEffects` has already run;\n\t          // the order matters. We should refactor so that ContentReset does not\n\t          // rely on mutating the flag during commit. Like by setting a flag\n\t          // during the render phase instead.\n\t          if (finishedWork.flags & ContentReset) {\n\t            var instance = finishedWork.stateNode;\n\n\t            try {\n\t              resetTextContent(instance);\n\t            } catch (error) {\n\t              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t            }\n\t          }\n\n\t          if (flags & Update) {\n\t            var _instance4 = finishedWork.stateNode;\n\n\t            if (_instance4 != null) {\n\t              // Commit the work prepared earlier.\n\t              var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n\t              // as the newProps. The updatePayload will contain the real change in\n\t              // this case.\n\n\t              var oldProps = current !== null ? current.memoizedProps : newProps;\n\t              var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n\t              var updatePayload = finishedWork.updateQueue;\n\t              finishedWork.updateQueue = null;\n\n\t              if (updatePayload !== null) {\n\t                try {\n\t                  commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);\n\t                } catch (error) {\n\t                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case HostText:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Update) {\n\t          if (supportsMutation) {\n\t            if (finishedWork.stateNode === null) {\n\t              throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n\t            }\n\n\t            var textInstance = finishedWork.stateNode;\n\t            var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n\t            // as the newProps. The updatePayload will contain the real change in\n\t            // this case.\n\n\t            var oldText = current !== null ? current.memoizedProps : newText;\n\n\t            try {\n\t              commitTextUpdate(textInstance, oldText, newText);\n\t            } catch (error) {\n\t              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t            }\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case HostRoot:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Update) {\n\t          if (supportsMutation && supportsHydration) {\n\t            if (current !== null) {\n\t              var prevRootState = current.memoizedState;\n\n\t              if (prevRootState.isDehydrated) {\n\t                try {\n\t                  commitHydratedContainer(root.containerInfo);\n\t                } catch (error) {\n\t                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t                }\n\t              }\n\t            }\n\t          }\n\n\t          if (supportsPersistence) {\n\t            var containerInfo = root.containerInfo;\n\t            var pendingChildren = root.pendingChildren;\n\n\t            try {\n\t              replaceContainerChildren(containerInfo, pendingChildren);\n\t            } catch (error) {\n\t              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t            }\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case HostPortal:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Update) {\n\t          if (supportsPersistence) {\n\t            var portal = finishedWork.stateNode;\n\t            var _containerInfo = portal.containerInfo;\n\t            var _pendingChildren = portal.pendingChildren;\n\n\t            try {\n\t              replaceContainerChildren(_containerInfo, _pendingChildren);\n\t            } catch (error) {\n\t              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t            }\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case SuspenseComponent:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\t        var offscreenFiber = finishedWork.child;\n\n\t        if (offscreenFiber.flags & Visibility) {\n\t          var offscreenInstance = offscreenFiber.stateNode;\n\t          var newState = offscreenFiber.memoizedState;\n\t          var isHidden = newState !== null; // Track the current state on the Offscreen instance so we can\n\t          // read it during an event\n\n\t          offscreenInstance.isHidden = isHidden;\n\n\t          if (isHidden) {\n\t            var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n\n\t            if (!wasHidden) {\n\t              // TODO: Move to passive phase\n\t              markCommitTimeOfFallback();\n\t            }\n\t          }\n\t        }\n\n\t        if (flags & Update) {\n\t          try {\n\t            commitSuspenseCallback(finishedWork);\n\t          } catch (error) {\n\t            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t          }\n\n\t          attachSuspenseRetryListeners(finishedWork);\n\t        }\n\n\t        return;\n\t      }\n\n\t    case OffscreenComponent:\n\t      {\n\t        var _wasHidden = current !== null && current.memoizedState !== null;\n\n\t        if ( // TODO: Remove this dead flag\n\t         finishedWork.mode & ConcurrentMode) {\n\t          // Before committing the children, track on the stack whether this\n\t          // offscreen subtree was already hidden, so that we don't unmount the\n\t          // effects again.\n\t          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n\t          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;\n\t          recursivelyTraverseMutationEffects(root, finishedWork);\n\t          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n\t        } else {\n\t          recursivelyTraverseMutationEffects(root, finishedWork);\n\t        }\n\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Visibility) {\n\t          var _offscreenInstance = finishedWork.stateNode;\n\t          var _newState = finishedWork.memoizedState;\n\n\t          var _isHidden = _newState !== null;\n\n\t          var offscreenBoundary = finishedWork; // Track the current state on the Offscreen instance so we can\n\t          // read it during an event\n\n\t          _offscreenInstance.isHidden = _isHidden;\n\n\t          {\n\t            if (_isHidden) {\n\t              if (!_wasHidden) {\n\t                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n\t                  nextEffect = offscreenBoundary;\n\t                  var offscreenChild = offscreenBoundary.child;\n\n\t                  while (offscreenChild !== null) {\n\t                    nextEffect = offscreenChild;\n\t                    disappearLayoutEffects_begin(offscreenChild);\n\t                    offscreenChild = offscreenChild.sibling;\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          }\n\n\t          if (supportsMutation) {\n\t            // TODO: This needs to run whenever there's an insertion or update\n\t            // inside a hidden Offscreen tree.\n\t            hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n\t          }\n\t        }\n\n\t        return;\n\t      }\n\n\t    case SuspenseListComponent:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\n\t        if (flags & Update) {\n\t          attachSuspenseRetryListeners(finishedWork);\n\t        }\n\n\t        return;\n\t      }\n\n\t    case ScopeComponent:\n\t      {\n\n\t        return;\n\t      }\n\n\t    default:\n\t      {\n\t        recursivelyTraverseMutationEffects(root, finishedWork);\n\t        commitReconciliationEffects(finishedWork);\n\t        return;\n\t      }\n\t  }\n\t}\n\n\tfunction commitReconciliationEffects(finishedWork) {\n\t  // Placement effects (insertions, reorders) can be scheduled on any fiber\n\t  // type. They needs to happen after the children effects have fired, but\n\t  // before the effects on this fiber have fired.\n\t  var flags = finishedWork.flags;\n\n\t  if (flags & Placement) {\n\t    try {\n\t      commitPlacement(finishedWork);\n\t    } catch (error) {\n\t      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n\t    } // Clear the \"placement\" from effect tag so that we know that this is\n\t    // inserted, before any life-cycles like componentDidMount gets called.\n\t    // TODO: findDOMNode doesn't rely on this any more but isMounted does\n\t    // and isMounted is deprecated anyway so we should be able to kill this.\n\n\n\t    finishedWork.flags &= ~Placement;\n\t  }\n\n\t  if (flags & Hydrating) {\n\t    finishedWork.flags &= ~Hydrating;\n\t  }\n\t}\n\n\tfunction commitLayoutEffects(finishedWork, root, committedLanes) {\n\t  inProgressLanes = committedLanes;\n\t  inProgressRoot = root;\n\t  nextEffect = finishedWork;\n\t  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n\t  inProgressLanes = null;\n\t  inProgressRoot = null;\n\t}\n\n\tfunction commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n\t  // Suspense layout effects semantics don't change for legacy roots.\n\t  var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    var firstChild = fiber.child;\n\n\t    if ( fiber.tag === OffscreenComponent && isModernRoot) {\n\t      // Keep track of the current Offscreen stack's state.\n\t      var isHidden = fiber.memoizedState !== null;\n\t      var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n\t      if (newOffscreenSubtreeIsHidden) {\n\t        // The Offscreen tree is hidden. Skip over its layout effects.\n\t        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n\t        continue;\n\t      } else {\n\t        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n\t        var current = fiber.alternate;\n\t        var wasHidden = current !== null && current.memoizedState !== null;\n\t        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n\t        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n\t        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n\n\t        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n\t        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n\t        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n\t          // This is the root of a reappearing boundary. Turn its layout effects\n\t          // back on.\n\t          nextEffect = fiber;\n\t          reappearLayoutEffects_begin(fiber);\n\t        }\n\n\t        var child = firstChild;\n\n\t        while (child !== null) {\n\t          nextEffect = child;\n\t          commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.\n\t          root, committedLanes);\n\t          child = child.sibling;\n\t        } // Restore Offscreen state and resume in our-progress traversal.\n\n\n\t        nextEffect = fiber;\n\t        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n\t        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n\t        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n\t        continue;\n\t      }\n\t    }\n\n\t    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n\t      firstChild.return = fiber;\n\t      nextEffect = firstChild;\n\t    } else {\n\t      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n\t    }\n\t  }\n\t}\n\n\tfunction commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\n\t    if ((fiber.flags & LayoutMask) !== NoFlags) {\n\t      var current = fiber.alternate;\n\t      setCurrentFiber(fiber);\n\n\t      try {\n\t        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n\t      } catch (error) {\n\t        captureCommitPhaseError(fiber, fiber.return, error);\n\t      }\n\n\t      resetCurrentFiber();\n\t    }\n\n\t    if (fiber === subtreeRoot) {\n\t      nextEffect = null;\n\t      return;\n\t    }\n\n\t    var sibling = fiber.sibling;\n\n\t    if (sibling !== null) {\n\t      sibling.return = fiber.return;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = fiber.return;\n\t  }\n\t}\n\n\tfunction disappearLayoutEffects_begin(subtreeRoot) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n\t    switch (fiber.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case MemoComponent:\n\t      case SimpleMemoComponent:\n\t        {\n\t          if ( fiber.mode & ProfileMode) {\n\t            try {\n\t              startLayoutEffectTimer();\n\t              commitHookEffectListUnmount(Layout, fiber, fiber.return);\n\t            } finally {\n\t              recordLayoutEffectDuration(fiber);\n\t            }\n\t          } else {\n\t            commitHookEffectListUnmount(Layout, fiber, fiber.return);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case ClassComponent:\n\t        {\n\t          // TODO (Offscreen) Check: flags & RefStatic\n\t          safelyDetachRef(fiber, fiber.return);\n\t          var instance = fiber.stateNode;\n\n\t          if (typeof instance.componentWillUnmount === 'function') {\n\t            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case HostComponent:\n\t        {\n\t          safelyDetachRef(fiber, fiber.return);\n\t          break;\n\t        }\n\n\t      case OffscreenComponent:\n\t        {\n\t          // Check if this is a\n\t          var isHidden = fiber.memoizedState !== null;\n\n\t          if (isHidden) {\n\t            // Nested Offscreen tree is already hidden. Don't disappear\n\t            // its effects.\n\t            disappearLayoutEffects_complete(subtreeRoot);\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\t    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n\t    if (firstChild !== null) {\n\t      firstChild.return = fiber;\n\t      nextEffect = firstChild;\n\t    } else {\n\t      disappearLayoutEffects_complete(subtreeRoot);\n\t    }\n\t  }\n\t}\n\n\tfunction disappearLayoutEffects_complete(subtreeRoot) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\n\t    if (fiber === subtreeRoot) {\n\t      nextEffect = null;\n\t      return;\n\t    }\n\n\t    var sibling = fiber.sibling;\n\n\t    if (sibling !== null) {\n\t      sibling.return = fiber.return;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = fiber.return;\n\t  }\n\t}\n\n\tfunction reappearLayoutEffects_begin(subtreeRoot) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    var firstChild = fiber.child;\n\n\t    if (fiber.tag === OffscreenComponent) {\n\t      var isHidden = fiber.memoizedState !== null;\n\n\t      if (isHidden) {\n\t        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n\t        reappearLayoutEffects_complete(subtreeRoot);\n\t        continue;\n\t      }\n\t    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n\t    if (firstChild !== null) {\n\t      // This node may have been reused from a previous render, so we can't\n\t      // assume its return pointer is correct.\n\t      firstChild.return = fiber;\n\t      nextEffect = firstChild;\n\t    } else {\n\t      reappearLayoutEffects_complete(subtreeRoot);\n\t    }\n\t  }\n\t}\n\n\tfunction reappearLayoutEffects_complete(subtreeRoot) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n\n\t    setCurrentFiber(fiber);\n\n\t    try {\n\t      reappearLayoutEffectsOnFiber(fiber);\n\t    } catch (error) {\n\t      captureCommitPhaseError(fiber, fiber.return, error);\n\t    }\n\n\t    resetCurrentFiber();\n\n\t    if (fiber === subtreeRoot) {\n\t      nextEffect = null;\n\t      return;\n\t    }\n\n\t    var sibling = fiber.sibling;\n\n\t    if (sibling !== null) {\n\t      // This node may have been reused from a previous render, so we can't\n\t      // assume its return pointer is correct.\n\t      sibling.return = fiber.return;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = fiber.return;\n\t  }\n\t}\n\n\tfunction commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n\t  nextEffect = finishedWork;\n\t  commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);\n\t}\n\n\tfunction commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    var firstChild = fiber.child;\n\n\t    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n\t      firstChild.return = fiber;\n\t      nextEffect = firstChild;\n\t    } else {\n\t      commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);\n\t    }\n\t  }\n\t}\n\n\tfunction commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\n\t    if ((fiber.flags & Passive) !== NoFlags) {\n\t      setCurrentFiber(fiber);\n\n\t      try {\n\t        commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);\n\t      } catch (error) {\n\t        captureCommitPhaseError(fiber, fiber.return, error);\n\t      }\n\n\t      resetCurrentFiber();\n\t    }\n\n\t    if (fiber === subtreeRoot) {\n\t      nextEffect = null;\n\t      return;\n\t    }\n\n\t    var sibling = fiber.sibling;\n\n\t    if (sibling !== null) {\n\t      sibling.return = fiber.return;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = fiber.return;\n\t  }\n\t}\n\n\tfunction commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n\t  switch (finishedWork.tag) {\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case SimpleMemoComponent:\n\t      {\n\t        if ( finishedWork.mode & ProfileMode) {\n\t          startPassiveEffectTimer();\n\n\t          try {\n\t            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n\t          } finally {\n\t            recordPassiveEffectDuration(finishedWork);\n\t          }\n\t        } else {\n\t          commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n\t        }\n\n\t        break;\n\t      }\n\t  }\n\t}\n\n\tfunction commitPassiveUnmountEffects(firstChild) {\n\t  nextEffect = firstChild;\n\t  commitPassiveUnmountEffects_begin();\n\t}\n\n\tfunction commitPassiveUnmountEffects_begin() {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    var child = fiber.child;\n\n\t    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n\t      var deletions = fiber.deletions;\n\n\t      if (deletions !== null) {\n\t        for (var i = 0; i < deletions.length; i++) {\n\t          var fiberToDelete = deletions[i];\n\t          nextEffect = fiberToDelete;\n\t          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n\t        }\n\n\t        {\n\t          // A fiber was deleted from this parent fiber, but it's still part of\n\t          // the previous (alternate) parent fiber's list of children. Because\n\t          // children are a linked list, an earlier sibling that's still alive\n\t          // will be connected to the deleted fiber via its `alternate`:\n\t          //\n\t          //   live fiber\n\t          //   --alternate--> previous live fiber\n\t          //   --sibling--> deleted fiber\n\t          //\n\t          // We can't disconnect `alternate` on nodes that haven't been deleted\n\t          // yet, but we can disconnect the `sibling` and `child` pointers.\n\t          var previousFiber = fiber.alternate;\n\n\t          if (previousFiber !== null) {\n\t            var detachedChild = previousFiber.child;\n\n\t            if (detachedChild !== null) {\n\t              previousFiber.child = null;\n\n\t              do {\n\t                var detachedSibling = detachedChild.sibling;\n\t                detachedChild.sibling = null;\n\t                detachedChild = detachedSibling;\n\t              } while (detachedChild !== null);\n\t            }\n\t          }\n\t        }\n\n\t        nextEffect = fiber;\n\t      }\n\t    }\n\n\t    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n\t      child.return = fiber;\n\t      nextEffect = child;\n\t    } else {\n\t      commitPassiveUnmountEffects_complete();\n\t    }\n\t  }\n\t}\n\n\tfunction commitPassiveUnmountEffects_complete() {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\n\t    if ((fiber.flags & Passive) !== NoFlags) {\n\t      setCurrentFiber(fiber);\n\t      commitPassiveUnmountOnFiber(fiber);\n\t      resetCurrentFiber();\n\t    }\n\n\t    var sibling = fiber.sibling;\n\n\t    if (sibling !== null) {\n\t      sibling.return = fiber.return;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = fiber.return;\n\t  }\n\t}\n\n\tfunction commitPassiveUnmountOnFiber(finishedWork) {\n\t  switch (finishedWork.tag) {\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case SimpleMemoComponent:\n\t      {\n\t        if ( finishedWork.mode & ProfileMode) {\n\t          startPassiveEffectTimer();\n\t          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n\t          recordPassiveEffectDuration(finishedWork);\n\t        } else {\n\t          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n\t        }\n\n\t        break;\n\t      }\n\t  }\n\t}\n\n\tfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect; // Deletion effects fire in parent -> child order\n\t    // TODO: Check if fiber has a PassiveStatic flag\n\n\t    setCurrentFiber(fiber);\n\t    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n\t    resetCurrentFiber();\n\t    var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n\t    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n\t    if (child !== null) {\n\t      child.return = fiber;\n\t      nextEffect = child;\n\t    } else {\n\t      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n\t    }\n\t  }\n\t}\n\n\tfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n\t  while (nextEffect !== null) {\n\t    var fiber = nextEffect;\n\t    var sibling = fiber.sibling;\n\t    var returnFiber = fiber.return;\n\n\t    {\n\t      // Recursively traverse the entire deleted tree and clean up fiber fields.\n\t      // This is more aggressive than ideal, and the long term goal is to only\n\t      // have to detach the deleted tree at the root.\n\t      detachFiberAfterEffects(fiber);\n\n\t      if (fiber === deletedSubtreeRoot) {\n\t        nextEffect = null;\n\t        return;\n\t      }\n\t    }\n\n\t    if (sibling !== null) {\n\t      sibling.return = returnFiber;\n\t      nextEffect = sibling;\n\t      return;\n\t    }\n\n\t    nextEffect = returnFiber;\n\t  }\n\t}\n\n\tfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n\t  switch (current.tag) {\n\t    case FunctionComponent:\n\t    case ForwardRef:\n\t    case SimpleMemoComponent:\n\t      {\n\t        if ( current.mode & ProfileMode) {\n\t          startPassiveEffectTimer();\n\t          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n\t          recordPassiveEffectDuration(current);\n\t        } else {\n\t          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n\t        }\n\n\t        break;\n\t      }\n\t  }\n\t} // TODO: Reuse reappearLayoutEffects traversal here?\n\n\n\tfunction invokeLayoutEffectMountInDEV(fiber) {\n\t  {\n\t    // We don't need to re-check StrictEffectsMode here.\n\t    // This function is only called if that check has already passed.\n\t    switch (fiber.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case SimpleMemoComponent:\n\t        {\n\t          try {\n\t            commitHookEffectListMount(Layout | HasEffect, fiber);\n\t          } catch (error) {\n\t            captureCommitPhaseError(fiber, fiber.return, error);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case ClassComponent:\n\t        {\n\t          var instance = fiber.stateNode;\n\n\t          try {\n\t            instance.componentDidMount();\n\t          } catch (error) {\n\t            captureCommitPhaseError(fiber, fiber.return, error);\n\t          }\n\n\t          break;\n\t        }\n\t    }\n\t  }\n\t}\n\n\tfunction invokePassiveEffectMountInDEV(fiber) {\n\t  {\n\t    // We don't need to re-check StrictEffectsMode here.\n\t    // This function is only called if that check has already passed.\n\t    switch (fiber.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case SimpleMemoComponent:\n\t        {\n\t          try {\n\t            commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n\t          } catch (error) {\n\t            captureCommitPhaseError(fiber, fiber.return, error);\n\t          }\n\n\t          break;\n\t        }\n\t    }\n\t  }\n\t}\n\n\tfunction invokeLayoutEffectUnmountInDEV(fiber) {\n\t  {\n\t    // We don't need to re-check StrictEffectsMode here.\n\t    // This function is only called if that check has already passed.\n\t    switch (fiber.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case SimpleMemoComponent:\n\t        {\n\t          try {\n\t            commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n\t          } catch (error) {\n\t            captureCommitPhaseError(fiber, fiber.return, error);\n\t          }\n\n\t          break;\n\t        }\n\n\t      case ClassComponent:\n\t        {\n\t          var instance = fiber.stateNode;\n\n\t          if (typeof instance.componentWillUnmount === 'function') {\n\t            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n\t          }\n\n\t          break;\n\t        }\n\t    }\n\t  }\n\t}\n\n\tfunction invokePassiveEffectUnmountInDEV(fiber) {\n\t  {\n\t    // We don't need to re-check StrictEffectsMode here.\n\t    // This function is only called if that check has already passed.\n\t    switch (fiber.tag) {\n\t      case FunctionComponent:\n\t      case ForwardRef:\n\t      case SimpleMemoComponent:\n\t        {\n\t          try {\n\t            commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n\t          } catch (error) {\n\t            captureCommitPhaseError(fiber, fiber.return, error);\n\t          }\n\t        }\n\t    }\n\t  }\n\t}\n\n\tvar COMPONENT_TYPE = 0;\n\tvar HAS_PSEUDO_CLASS_TYPE = 1;\n\tvar ROLE_TYPE = 2;\n\tvar TEST_NAME_TYPE = 3;\n\tvar TEXT_TYPE = 4;\n\n\tif (typeof Symbol === 'function' && Symbol.for) {\n\t  var symbolFor = Symbol.for;\n\t  COMPONENT_TYPE = symbolFor('selector.component');\n\t  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n\t  ROLE_TYPE = symbolFor('selector.role');\n\t  TEST_NAME_TYPE = symbolFor('selector.test_id');\n\t  TEXT_TYPE = symbolFor('selector.text');\n\t}\n\n\tfunction createComponentSelector(component) {\n\t  return {\n\t    $$typeof: COMPONENT_TYPE,\n\t    value: component\n\t  };\n\t}\n\tfunction createHasPseudoClassSelector(selectors) {\n\t  return {\n\t    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n\t    value: selectors\n\t  };\n\t}\n\tfunction createRoleSelector(role) {\n\t  return {\n\t    $$typeof: ROLE_TYPE,\n\t    value: role\n\t  };\n\t}\n\tfunction createTextSelector(text) {\n\t  return {\n\t    $$typeof: TEXT_TYPE,\n\t    value: text\n\t  };\n\t}\n\tfunction createTestNameSelector(id) {\n\t  return {\n\t    $$typeof: TEST_NAME_TYPE,\n\t    value: id\n\t  };\n\t}\n\n\tfunction findFiberRootForHostRoot(hostRoot) {\n\t  var maybeFiber = getInstanceFromNode(hostRoot);\n\n\t  if (maybeFiber != null) {\n\t    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n\t      throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n\t    }\n\n\t    return maybeFiber;\n\t  } else {\n\t    var fiberRoot = findFiberRoot(hostRoot);\n\n\t    if (fiberRoot === null) {\n\t      throw new Error('Could not find React container within specified host subtree.');\n\t    } // The Flow type for FiberRoot is a little funky.\n\t    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n\n\n\t    return fiberRoot.stateNode.current;\n\t  }\n\t}\n\n\tfunction matchSelector(fiber, selector) {\n\t  switch (selector.$$typeof) {\n\t    case COMPONENT_TYPE:\n\t      if (fiber.type === selector.value) {\n\t        return true;\n\t      }\n\n\t      break;\n\n\t    case HAS_PSEUDO_CLASS_TYPE:\n\t      return hasMatchingPaths(fiber, selector.value);\n\n\t    case ROLE_TYPE:\n\t      if (fiber.tag === HostComponent) {\n\t        var node = fiber.stateNode;\n\n\t        if (matchAccessibilityRole(node, selector.value)) {\n\t          return true;\n\t        }\n\t      }\n\n\t      break;\n\n\t    case TEXT_TYPE:\n\t      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n\t        var textContent = getTextContent(fiber);\n\n\t        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n\t          return true;\n\t        }\n\t      }\n\n\t      break;\n\n\t    case TEST_NAME_TYPE:\n\t      if (fiber.tag === HostComponent) {\n\t        var dataTestID = fiber.memoizedProps['data-testname'];\n\n\t        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n\t          return true;\n\t        }\n\t      }\n\n\t      break;\n\n\t    default:\n\t      throw new Error('Invalid selector type specified.');\n\t  }\n\n\t  return false;\n\t}\n\n\tfunction selectorToString(selector) {\n\t  switch (selector.$$typeof) {\n\t    case COMPONENT_TYPE:\n\t      var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n\t      return \"<\" + displayName + \">\";\n\n\t    case HAS_PSEUDO_CLASS_TYPE:\n\t      return \":has(\" + (selectorToString(selector) || '') + \")\";\n\n\t    case ROLE_TYPE:\n\t      return \"[role=\\\"\" + selector.value + \"\\\"]\";\n\n\t    case TEXT_TYPE:\n\t      return \"\\\"\" + selector.value + \"\\\"\";\n\n\t    case TEST_NAME_TYPE:\n\t      return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n\n\t    default:\n\t      throw new Error('Invalid selector type specified.');\n\t  }\n\t}\n\n\tfunction findPaths(root, selectors) {\n\t  var matchingFibers = [];\n\t  var stack = [root, 0];\n\t  var index = 0;\n\n\t  while (index < stack.length) {\n\t    var fiber = stack[index++];\n\t    var selectorIndex = stack[index++];\n\t    var selector = selectors[selectorIndex];\n\n\t    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n\t      continue;\n\t    } else {\n\t      while (selector != null && matchSelector(fiber, selector)) {\n\t        selectorIndex++;\n\t        selector = selectors[selectorIndex];\n\t      }\n\t    }\n\n\t    if (selectorIndex === selectors.length) {\n\t      matchingFibers.push(fiber);\n\t    } else {\n\t      var child = fiber.child;\n\n\t      while (child !== null) {\n\t        stack.push(child, selectorIndex);\n\t        child = child.sibling;\n\t      }\n\t    }\n\t  }\n\n\t  return matchingFibers;\n\t} // Same as findPaths but with eager bailout on first match\n\n\n\tfunction hasMatchingPaths(root, selectors) {\n\t  var stack = [root, 0];\n\t  var index = 0;\n\n\t  while (index < stack.length) {\n\t    var fiber = stack[index++];\n\t    var selectorIndex = stack[index++];\n\t    var selector = selectors[selectorIndex];\n\n\t    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n\t      continue;\n\t    } else {\n\t      while (selector != null && matchSelector(fiber, selector)) {\n\t        selectorIndex++;\n\t        selector = selectors[selectorIndex];\n\t      }\n\t    }\n\n\t    if (selectorIndex === selectors.length) {\n\t      return true;\n\t    } else {\n\t      var child = fiber.child;\n\n\t      while (child !== null) {\n\t        stack.push(child, selectorIndex);\n\t        child = child.sibling;\n\t      }\n\t    }\n\t  }\n\n\t  return false;\n\t}\n\n\tfunction findAllNodes(hostRoot, selectors) {\n\t  if (!supportsTestSelectors) {\n\t    throw new Error('Test selector API is not supported by this renderer.');\n\t  }\n\n\t  var root = findFiberRootForHostRoot(hostRoot);\n\t  var matchingFibers = findPaths(root, selectors);\n\t  var instanceRoots = [];\n\t  var stack = Array.from(matchingFibers);\n\t  var index = 0;\n\n\t  while (index < stack.length) {\n\t    var node = stack[index++];\n\n\t    if (node.tag === HostComponent) {\n\t      if (isHiddenSubtree(node)) {\n\t        continue;\n\t      }\n\n\t      instanceRoots.push(node.stateNode);\n\t    } else {\n\t      var child = node.child;\n\n\t      while (child !== null) {\n\t        stack.push(child);\n\t        child = child.sibling;\n\t      }\n\t    }\n\t  }\n\n\t  return instanceRoots;\n\t}\n\tfunction getFindAllNodesFailureDescription(hostRoot, selectors) {\n\t  if (!supportsTestSelectors) {\n\t    throw new Error('Test selector API is not supported by this renderer.');\n\t  }\n\n\t  var root = findFiberRootForHostRoot(hostRoot);\n\t  var maxSelectorIndex = 0;\n\t  var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n\n\t  var stack = [root, 0];\n\t  var index = 0;\n\n\t  while (index < stack.length) {\n\t    var fiber = stack[index++];\n\t    var selectorIndex = stack[index++];\n\t    var selector = selectors[selectorIndex];\n\n\t    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n\t      continue;\n\t    } else if (matchSelector(fiber, selector)) {\n\t      matchedNames.push(selectorToString(selector));\n\t      selectorIndex++;\n\n\t      if (selectorIndex > maxSelectorIndex) {\n\t        maxSelectorIndex = selectorIndex;\n\t      }\n\t    }\n\n\t    if (selectorIndex < selectors.length) {\n\t      var child = fiber.child;\n\n\t      while (child !== null) {\n\t        stack.push(child, selectorIndex);\n\t        child = child.sibling;\n\t      }\n\t    }\n\t  }\n\n\t  if (maxSelectorIndex < selectors.length) {\n\t    var unmatchedNames = [];\n\n\t    for (var i = maxSelectorIndex; i < selectors.length; i++) {\n\t      unmatchedNames.push(selectorToString(selectors[i]));\n\t    }\n\n\t    return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n\t  }\n\n\t  return null;\n\t}\n\tfunction findBoundingRects(hostRoot, selectors) {\n\t  if (!supportsTestSelectors) {\n\t    throw new Error('Test selector API is not supported by this renderer.');\n\t  }\n\n\t  var instanceRoots = findAllNodes(hostRoot, selectors);\n\t  var boundingRects = [];\n\n\t  for (var i = 0; i < instanceRoots.length; i++) {\n\t    boundingRects.push(getBoundingRect(instanceRoots[i]));\n\t  }\n\n\t  for (var _i = boundingRects.length - 1; _i > 0; _i--) {\n\t    var targetRect = boundingRects[_i];\n\t    var targetLeft = targetRect.x;\n\t    var targetRight = targetLeft + targetRect.width;\n\t    var targetTop = targetRect.y;\n\t    var targetBottom = targetTop + targetRect.height;\n\n\t    for (var j = _i - 1; j >= 0; j--) {\n\t      if (_i !== j) {\n\t        var otherRect = boundingRects[j];\n\t        var otherLeft = otherRect.x;\n\t        var otherRight = otherLeft + otherRect.width;\n\t        var otherTop = otherRect.y;\n\t        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n\t        // but we can handle the most common cases:\n\t        // 1. completely overlapping rects\n\t        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n\t        //\n\t        // Even given the above constraints,\n\t        // we still won't end up with the fewest possible rects without doing multiple passes,\n\t        // but it's good enough for this purpose.\n\n\t        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n\t          // Complete overlapping rects; remove the inner one.\n\t          boundingRects.splice(_i, 1);\n\t          break;\n\t        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n\t          // Adjacent vertical rects; merge them.\n\t          if (otherTop > targetTop) {\n\t            otherRect.height += otherTop - targetTop;\n\t            otherRect.y = targetTop;\n\t          }\n\n\t          if (otherBottom < targetBottom) {\n\t            otherRect.height = targetBottom - otherTop;\n\t          }\n\n\t          boundingRects.splice(_i, 1);\n\t          break;\n\t        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n\t          // Adjacent horizontal rects; merge them.\n\t          if (otherLeft > targetLeft) {\n\t            otherRect.width += otherLeft - targetLeft;\n\t            otherRect.x = targetLeft;\n\t          }\n\n\t          if (otherRight < targetRight) {\n\t            otherRect.width = targetRight - otherLeft;\n\t          }\n\n\t          boundingRects.splice(_i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  return boundingRects;\n\t}\n\tfunction focusWithin(hostRoot, selectors) {\n\t  if (!supportsTestSelectors) {\n\t    throw new Error('Test selector API is not supported by this renderer.');\n\t  }\n\n\t  var root = findFiberRootForHostRoot(hostRoot);\n\t  var matchingFibers = findPaths(root, selectors);\n\t  var stack = Array.from(matchingFibers);\n\t  var index = 0;\n\n\t  while (index < stack.length) {\n\t    var fiber = stack[index++];\n\n\t    if (isHiddenSubtree(fiber)) {\n\t      continue;\n\t    }\n\n\t    if (fiber.tag === HostComponent) {\n\t      var node = fiber.stateNode;\n\n\t      if (setFocusIfFocusable(node)) {\n\t        return true;\n\t      }\n\t    }\n\n\t    var child = fiber.child;\n\n\t    while (child !== null) {\n\t      stack.push(child);\n\t      child = child.sibling;\n\t    }\n\t  }\n\n\t  return false;\n\t}\n\tvar commitHooks = [];\n\tfunction onCommitRoot$1() {\n\t  if (supportsTestSelectors) {\n\t    commitHooks.forEach(function (commitHook) {\n\t      return commitHook();\n\t    });\n\t  }\n\t}\n\tfunction observeVisibleRects(hostRoot, selectors, callback, options) {\n\t  if (!supportsTestSelectors) {\n\t    throw new Error('Test selector API is not supported by this renderer.');\n\t  }\n\n\t  var instanceRoots = findAllNodes(hostRoot, selectors);\n\n\t  var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options),\n\t      disconnect = _setupIntersectionObs.disconnect,\n\t      observe = _setupIntersectionObs.observe,\n\t      unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n\n\n\t  var commitHook = function () {\n\t    var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n\t    instanceRoots.forEach(function (target) {\n\t      if (nextInstanceRoots.indexOf(target) < 0) {\n\t        unobserve(target);\n\t      }\n\t    });\n\t    nextInstanceRoots.forEach(function (target) {\n\t      if (instanceRoots.indexOf(target) < 0) {\n\t        observe(target);\n\t      }\n\t    });\n\t  };\n\n\t  commitHooks.push(commitHook);\n\t  return {\n\t    disconnect: function () {\n\t      // Stop listening for React mutations:\n\t      var index = commitHooks.indexOf(commitHook);\n\n\t      if (index >= 0) {\n\t        commitHooks.splice(index, 1);\n\t      } // Disconnect the host observer:\n\n\n\t      disconnect();\n\t    }\n\t  };\n\t}\n\n\tvar ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n\tfunction isLegacyActEnvironment(fiber) {\n\t  {\n\t    // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n\t    // act environment whenever `jest` is defined, but you can still turn off\n\t    // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n\t    // to false.\n\t    var isReactActEnvironmentGlobal = // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n\t    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n\n\t    var jestIsDefined = typeof jest !== 'undefined';\n\t    return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n\t  }\n\t}\n\tfunction isConcurrentActEnvironment() {\n\t  {\n\t    var isReactActEnvironmentGlobal = // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n\t    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n\n\t    if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n\t      // TODO: Include link to relevant documentation page.\n\t      error('The current testing environment is not configured to support ' + 'act(...)');\n\t    }\n\n\t    return isReactActEnvironmentGlobal;\n\t  }\n\t}\n\n\tvar ceil = Math.ceil;\n\tvar ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,\n\t    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,\n\t    ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,\n\t    ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\n\tvar NoContext =\n\t/*             */\n\t0;\n\tvar BatchedContext =\n\t/*               */\n\t1;\n\tvar RenderContext =\n\t/*                */\n\t2;\n\tvar CommitContext =\n\t/*                */\n\t4;\n\tvar RootInProgress = 0;\n\tvar RootFatalErrored = 1;\n\tvar RootErrored = 2;\n\tvar RootSuspended = 3;\n\tvar RootSuspendedWithDelay = 4;\n\tvar RootCompleted = 5;\n\tvar RootDidNotComplete = 6; // Describes where we are in the React execution stack\n\n\tvar executionContext = NoContext; // The root we're working on\n\n\tvar workInProgressRoot = null; // The fiber we're working on\n\n\tvar workInProgress = null; // The lanes we're rendering\n\n\tvar workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n\t// This is a superset of the lanes we started working on at the root. The only\n\t// case where it's different from `workInProgressRootRenderLanes` is when we\n\t// enter a subtree that is hidden and needs to be unhidden: Suspense and\n\t// Offscreen component.\n\t//\n\t// Most things in the work loop should deal with workInProgressRootRenderLanes.\n\t// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\n\tvar subtreeRenderLanes = NoLanes;\n\tvar subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n\n\tvar workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n\n\tvar workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n\t// includes unprocessed updates, not work in bailed out children.\n\n\tvar workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\n\tvar workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\n\tvar workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n\n\tvar workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n\t// We will log them once the tree commits.\n\n\tvar workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n\t// model where we don't commit new loading states in too quick succession.\n\n\tvar globalMostRecentFallbackTime = 0;\n\tvar FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n\t// more and prefer CPU suspense heuristics instead.\n\n\tvar workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n\t// suspense heuristics and opt out of rendering more content.\n\n\tvar RENDER_TIMEOUT_MS = 500;\n\tvar workInProgressTransitions = null;\n\n\tfunction resetRenderTimer() {\n\t  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n\t}\n\n\tfunction getRenderTargetTime() {\n\t  return workInProgressRootRenderTargetTime;\n\t}\n\tvar hasUncaughtError = false;\n\tvar firstUncaughtError = null;\n\tvar legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n\tvar rootDoesHavePassiveEffects = false;\n\tvar rootWithPendingPassiveEffects = null;\n\tvar pendingPassiveEffectsLanes = NoLanes;\n\tvar pendingPassiveProfilerEffects = [];\n\tvar pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n\n\tvar NESTED_UPDATE_LIMIT = 50;\n\tvar nestedUpdateCount = 0;\n\tvar rootWithNestedUpdates = null;\n\tvar isFlushingPassiveEffects = false;\n\tvar didScheduleUpdateDuringPassiveEffects = false;\n\tvar NESTED_PASSIVE_UPDATE_LIMIT = 50;\n\tvar nestedPassiveUpdateCount = 0;\n\tvar rootWithPassiveNestedUpdates = null; // If two updates are scheduled within the same event, we should treat their\n\t// event times as simultaneous, even if the actual clock time has advanced\n\t// between the first and second call.\n\n\tvar currentEventTime = NoTimestamp;\n\tvar currentEventTransitionLane = NoLanes;\n\tvar isRunningInsertionEffect = false;\n\tfunction getWorkInProgressRoot() {\n\t  return workInProgressRoot;\n\t}\n\tfunction requestEventTime() {\n\t  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n\t    // We're inside React, so it's fine to read the actual time.\n\t    return now();\n\t  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n\t  if (currentEventTime !== NoTimestamp) {\n\t    // Use the same start time for all updates until we enter React again.\n\t    return currentEventTime;\n\t  } // This is the first update since React yielded. Compute a new start time.\n\n\n\t  currentEventTime = now();\n\t  return currentEventTime;\n\t}\n\tfunction requestUpdateLane(fiber) {\n\t  // Special cases\n\t  var mode = fiber.mode;\n\n\t  if ((mode & ConcurrentMode) === NoMode) {\n\t    return SyncLane;\n\t  } else if ( (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n\t    // This is a render phase update. These are not officially supported. The\n\t    // old behavior is to give this the same \"thread\" (lanes) as\n\t    // whatever is currently rendering. So if you call `setState` on a component\n\t    // that happens later in the same render, it will flush. Ideally, we want to\n\t    // remove the special case and treat them as if they came from an\n\t    // interleaved event. Regardless, this pattern is not officially supported.\n\t    // This behavior is only a fallback. The flag only exists until we can roll\n\t    // out the setState warning, since existing code might accidentally rely on\n\t    // the current behavior.\n\t    return pickArbitraryLane(workInProgressRootRenderLanes);\n\t  }\n\n\t  var isTransition = requestCurrentTransition() !== NoTransition;\n\n\t  if (isTransition) {\n\t    if ( ReactCurrentBatchConfig$2.transition !== null) {\n\t      var transition = ReactCurrentBatchConfig$2.transition;\n\n\t      if (!transition._updatedFibers) {\n\t        transition._updatedFibers = new Set();\n\t      }\n\n\t      transition._updatedFibers.add(fiber);\n\t    } // The algorithm for assigning an update to a lane should be stable for all\n\t    // updates at the same priority within the same event. To do this, the\n\t    // inputs to the algorithm must be the same.\n\t    //\n\t    // The trick we use is to cache the first of each of these inputs within an\n\t    // event. Then reset the cached values once we can be sure the event is\n\t    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n\t    if (currentEventTransitionLane === NoLane) {\n\t      // All transitions within the same event are assigned the same lane.\n\t      currentEventTransitionLane = claimNextTransitionLane();\n\t    }\n\n\t    return currentEventTransitionLane;\n\t  } // Updates originating inside certain React methods, like flushSync, have\n\t  // their priority set by tracking it with a context variable.\n\t  //\n\t  // The opaque type returned by the host config is internally a lane, so we can\n\t  // use that directly.\n\t  // TODO: Move this type conversion to the event priority module.\n\n\n\t  var updateLane = getCurrentUpdatePriority();\n\n\t  if (updateLane !== NoLane) {\n\t    return updateLane;\n\t  } // This update originated outside React. Ask the host environment for an\n\t  // appropriate priority, based on the type of event.\n\t  //\n\t  // The opaque type returned by the host config is internally a lane, so we can\n\t  // use that directly.\n\t  // TODO: Move this type conversion to the event priority module.\n\n\n\t  var eventLane = getCurrentEventPriority();\n\t  return eventLane;\n\t}\n\n\tfunction requestRetryLane(fiber) {\n\t  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n\t  // \"retries\"  a special update that attempts to flip a Suspense boundary\n\t  // from its placeholder state to its primary/resolved state.\n\t  // Special cases\n\t  var mode = fiber.mode;\n\n\t  if ((mode & ConcurrentMode) === NoMode) {\n\t    return SyncLane;\n\t  }\n\n\t  return claimNextRetryLane();\n\t}\n\n\tfunction scheduleUpdateOnFiber(root, fiber, lane, eventTime) {\n\t  checkForNestedUpdates();\n\n\t  {\n\t    if (isRunningInsertionEffect) {\n\t      error('useInsertionEffect must not schedule updates.');\n\t    }\n\t  }\n\n\t  {\n\t    if (isFlushingPassiveEffects) {\n\t      didScheduleUpdateDuringPassiveEffects = true;\n\t    }\n\t  } // Mark that the root has a pending update.\n\n\n\t  markRootUpdated(root, lane, eventTime);\n\n\t  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n\t    // This update was dispatched during the render phase. This is a mistake\n\t    // if the update originates from user space (with the exception of local\n\t    // hook updates, which are handled differently and don't reach this\n\t    // function), but there are some internal React features that use this as\n\t    // an implementation detail, like selective hydration.\n\t    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n\t  } else {\n\t    // This is a normal update, scheduled from outside the render phase. For\n\t    // example, during an input event.\n\t    {\n\t      if (isDevToolsPresent) {\n\t        addFiberToLanesMap(root, fiber, lane);\n\t      }\n\t    }\n\n\t    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n\t    if (root === workInProgressRoot) {\n\t      // Received an update to a tree that's in the middle of rendering. Mark\n\t      // that there was an interleaved update work on this root. Unless the\n\t      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n\t      // phase update. In that case, we don't treat render phase updates as if\n\t      // they were interleaved, for backwards compat reasons.\n\t      if ( (executionContext & RenderContext) === NoContext) {\n\t        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n\t      }\n\n\t      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n\t        // The root already suspended with a delay, which means this render\n\t        // definitely won't finish. Since we have a new update, let's mark it as\n\t        // suspended now, right before marking the incoming update. This has the\n\t        // effect of interrupting the current render and switching to the update.\n\t        // TODO: Make sure this doesn't override pings that happen while we've\n\t        // already started rendering.\n\t        markRootSuspended$1(root, workInProgressRootRenderLanes);\n\t      }\n\t    }\n\n\t    ensureRootIsScheduled(root, eventTime);\n\n\t    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n\t    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n\t      // Flush the synchronous work now, unless we're already working or inside\n\t      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n\t      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n\t      // without immediately flushing it. We only do this for user-initiated\n\t      // updates, to preserve historical behavior of legacy mode.\n\t      resetRenderTimer();\n\t      flushSyncCallbacksOnlyInLegacyMode();\n\t    }\n\t  }\n\t}\n\tfunction scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n\t  // This is a special fork of scheduleUpdateOnFiber that is only used to\n\t  // schedule the initial hydration of a root that has just been created. Most\n\t  // of the stuff in scheduleUpdateOnFiber can be skipped.\n\t  //\n\t  // The main reason for this separate path, though, is to distinguish the\n\t  // initial children from subsequent updates. In fully client-rendered roots\n\t  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n\t  // updates, but hydration roots are special because the initial render must\n\t  // match what was rendered on the server.\n\t  var current = root.current;\n\t  current.lanes = lane;\n\t  markRootUpdated(root, lane, eventTime);\n\t  ensureRootIsScheduled(root, eventTime);\n\t}\n\tfunction isUnsafeClassRenderPhaseUpdate(fiber) {\n\t  // Check if this is a render phase update. Only called by class components,\n\t  // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n\t  return (// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n\t    // decided not to enable it.\n\t     (executionContext & RenderContext) !== NoContext\n\t  );\n\t} // Use this function to schedule a task for a root. There's only one task per\n\t// root; if a task was already scheduled, we'll check to make sure the priority\n\t// of the existing task is the same as the priority of the next level that the\n\t// root has work on. This function is called on every update, and right before\n\t// exiting a task.\n\n\tfunction ensureRootIsScheduled(root, currentTime) {\n\t  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n\t  // expired so we know to work on those next.\n\n\t  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n\t  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n\t  if (nextLanes === NoLanes) {\n\t    // Special case: There's nothing to work on.\n\t    if (existingCallbackNode !== null) {\n\t      cancelCallback$1(existingCallbackNode);\n\t    }\n\n\t    root.callbackNode = null;\n\t    root.callbackPriority = NoLane;\n\t    return;\n\t  } // We use the highest priority lane to represent the priority of the callback.\n\n\n\t  var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n\t  var existingCallbackPriority = root.callbackPriority;\n\n\t  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n\t  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n\t  // on the `act` queue.\n\t  !( ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n\t    {\n\t      // If we're going to re-use an existing task, it needs to exist.\n\t      // Assume that discrete update microtasks are non-cancellable and null.\n\t      // TODO: Temporary until we confirm this warning is not fired.\n\t      if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n\t        error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n\t      }\n\t    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n\t    return;\n\t  }\n\n\t  if (existingCallbackNode != null) {\n\t    // Cancel the existing callback. We'll schedule a new one below.\n\t    cancelCallback$1(existingCallbackNode);\n\t  } // Schedule a new callback.\n\n\n\t  var newCallbackNode;\n\n\t  if (newCallbackPriority === SyncLane) {\n\t    // Special case: Sync React callbacks are scheduled on a special\n\t    // internal queue\n\t    if (root.tag === LegacyRoot) {\n\t      if ( ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n\t        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n\t      }\n\n\t      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n\t    } else {\n\t      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n\t    }\n\n\t    if (supportsMicrotasks) {\n\t      // Flush the queue in a microtask.\n\t      if ( ReactCurrentActQueue$1.current !== null) {\n\t        // Inside `act`, use our internal `act` queue so that these get flushed\n\t        // at the end of the current scope even when using the sync version\n\t        // of `act`.\n\t        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n\t      } else {\n\t        scheduleMicrotask(function () {\n\t          // In Safari, appending an iframe forces microtasks to run.\n\t          // https://github.com/facebook/react/issues/22459\n\t          // We don't support running callbacks in the middle of render\n\t          // or commit so we need to check against that.\n\t          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n\t            // Note that this would still prematurely flush the callbacks\n\t            // if this happens outside render or commit phase (e.g. in an event).\n\t            flushSyncCallbacks();\n\t          }\n\t        });\n\t      }\n\t    } else {\n\t      // Flush the queue in an Immediate task.\n\t      scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n\t    }\n\n\t    newCallbackNode = null;\n\t  } else {\n\t    var schedulerPriorityLevel;\n\n\t    switch (lanesToEventPriority(nextLanes)) {\n\t      case DiscreteEventPriority:\n\t        schedulerPriorityLevel = ImmediatePriority;\n\t        break;\n\n\t      case ContinuousEventPriority:\n\t        schedulerPriorityLevel = UserBlockingPriority;\n\t        break;\n\n\t      case DefaultEventPriority:\n\t        schedulerPriorityLevel = NormalPriority;\n\t        break;\n\n\t      case IdleEventPriority:\n\t        schedulerPriorityLevel = IdlePriority;\n\t        break;\n\n\t      default:\n\t        schedulerPriorityLevel = NormalPriority;\n\t        break;\n\t    }\n\n\t    newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n\t  }\n\n\t  root.callbackPriority = newCallbackPriority;\n\t  root.callbackNode = newCallbackNode;\n\t} // This is the entry point for every concurrent task, i.e. anything that\n\t// goes through Scheduler.\n\n\n\tfunction performConcurrentWorkOnRoot(root, didTimeout) {\n\t  {\n\t    resetNestedUpdateFlag();\n\t  } // Since we know we're in a React event, we can clear the current\n\t  // event time. The next update will compute a new event time.\n\n\n\t  currentEventTime = NoTimestamp;\n\t  currentEventTransitionLane = NoLanes;\n\n\t  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n\t    throw new Error('Should not already be working.');\n\t  } // Flush any pending passive effects before deciding which lanes to work on,\n\t  // in case they schedule additional work.\n\n\n\t  var originalCallbackNode = root.callbackNode;\n\t  var didFlushPassiveEffects = flushPassiveEffects();\n\n\t  if (didFlushPassiveEffects) {\n\t    // Something in the passive effect phase may have canceled the current task.\n\t    // Check if the task node for this root was changed.\n\t    if (root.callbackNode !== originalCallbackNode) {\n\t      // The current task was canceled. Exit. We don't need to call\n\t      // `ensureRootIsScheduled` because the check above implies either that\n\t      // there's a new task, or that there's no remaining work on this root.\n\t      return null;\n\t    }\n\t  } // Determine the next lanes to work on, using the fields stored\n\t  // on the root.\n\n\n\t  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n\t  if (lanes === NoLanes) {\n\t    // Defensive coding. This is never expected to happen.\n\t    return null;\n\t  } // We disable time-slicing in some cases: if the work has been CPU-bound\n\t  // for too long (\"expired\" work, to prevent starvation), or we're in\n\t  // sync-updates-by-default mode.\n\t  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n\t  // bug we're still investigating. Once the bug in Scheduler is fixed,\n\t  // we can remove this, since we track expiration ourselves.\n\n\n\t  var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && ( !didTimeout);\n\t  var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n\t  if (exitStatus !== RootInProgress) {\n\t    if (exitStatus === RootErrored) {\n\t      // If something threw an error, try rendering one more time. We'll\n\t      // render synchronously to block concurrent data mutations, and we'll\n\t      // includes all pending updates are included. If it still fails after\n\t      // the second attempt, we'll give up and commit the resulting tree.\n\t      var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n\t      if (errorRetryLanes !== NoLanes) {\n\t        lanes = errorRetryLanes;\n\t        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n\t      }\n\t    }\n\n\t    if (exitStatus === RootFatalErrored) {\n\t      var fatalError = workInProgressRootFatalError;\n\t      prepareFreshStack(root, NoLanes);\n\t      markRootSuspended$1(root, lanes);\n\t      ensureRootIsScheduled(root, now());\n\t      throw fatalError;\n\t    }\n\n\t    if (exitStatus === RootDidNotComplete) {\n\t      // The render unwound without completing the tree. This happens in special\n\t      // cases where need to exit the current render without producing a\n\t      // consistent tree or committing.\n\t      //\n\t      // This should only happen during a concurrent render, not a discrete or\n\t      // synchronous update. We should have already checked for this when we\n\t      // unwound the stack.\n\t      markRootSuspended$1(root, lanes);\n\t    } else {\n\t      // The render completed.\n\t      // Check if this render may have yielded to a concurrent event, and if so,\n\t      // confirm that any newly rendered stores are consistent.\n\t      // TODO: It's possible that even a concurrent render may never have yielded\n\t      // to the main thread, if it was fast enough, or if it expired. We could\n\t      // skip the consistency check in that case, too.\n\t      var renderWasConcurrent = !includesBlockingLane(root, lanes);\n\t      var finishedWork = root.current.alternate;\n\n\t      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n\t        // A store was mutated in an interleaved event. Render again,\n\t        // synchronously, to block further mutations.\n\t        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n\t        if (exitStatus === RootErrored) {\n\t          var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n\t          if (_errorRetryLanes !== NoLanes) {\n\t            lanes = _errorRetryLanes;\n\t            exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n\t            // concurrent events.\n\t          }\n\t        }\n\n\t        if (exitStatus === RootFatalErrored) {\n\t          var _fatalError = workInProgressRootFatalError;\n\t          prepareFreshStack(root, NoLanes);\n\t          markRootSuspended$1(root, lanes);\n\t          ensureRootIsScheduled(root, now());\n\t          throw _fatalError;\n\t        }\n\t      } // We now have a consistent tree. The next step is either to commit it,\n\t      // or, if something suspended, wait to commit it after a timeout.\n\n\n\t      root.finishedWork = finishedWork;\n\t      root.finishedLanes = lanes;\n\t      finishConcurrentRender(root, exitStatus, lanes);\n\t    }\n\t  }\n\n\t  ensureRootIsScheduled(root, now());\n\n\t  if (root.callbackNode === originalCallbackNode) {\n\t    // The task node scheduled for this root is the same one that's\n\t    // currently executed. Need to return a continuation.\n\t    return performConcurrentWorkOnRoot.bind(null, root);\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction recoverFromConcurrentError(root, errorRetryLanes) {\n\t  // If an error occurred during hydration, discard server response and fall\n\t  // back to client side render.\n\t  // Before rendering again, save the errors from the previous attempt.\n\t  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n\n\t  if (isRootDehydrated(root)) {\n\t    // The shell failed to hydrate. Set a flag to force a client rendering\n\t    // during the next attempt. To do this, we call prepareFreshStack now\n\t    // to create the root work-in-progress fiber. This is a bit weird in terms\n\t    // of factoring, because it relies on renderRootSync not calling\n\t    // prepareFreshStack again in the call below, which happens because the\n\t    // root and lanes haven't changed.\n\t    //\n\t    // TODO: I think what we should do is set ForceClientRender inside\n\t    // throwException, like we do for nested Suspense boundaries. The reason\n\t    // it's here instead is so we can switch to the synchronous work loop, too.\n\t    // Something to consider for a future refactor.\n\t    var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n\t    rootWorkInProgress.flags |= ForceClientRender;\n\n\t    {\n\t      errorHydratingContainer(root.containerInfo);\n\t    }\n\t  }\n\n\t  var exitStatus = renderRootSync(root, errorRetryLanes);\n\n\t  if (exitStatus !== RootErrored) {\n\t    // Successfully finished rendering on retry\n\t    // The errors from the failed first attempt have been recovered. Add\n\t    // them to the collection of recoverable errors. We'll log them in the\n\t    // commit phase.\n\t    var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n\t    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n\t    // from the first attempt, to preserve the causal sequence.\n\n\t    if (errorsFromSecondAttempt !== null) {\n\t      queueRecoverableErrors(errorsFromSecondAttempt);\n\t    }\n\t  }\n\n\t  return exitStatus;\n\t}\n\n\tfunction queueRecoverableErrors(errors) {\n\t  if (workInProgressRootRecoverableErrors === null) {\n\t    workInProgressRootRecoverableErrors = errors;\n\t  } else {\n\t    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n\t  }\n\t}\n\n\tfunction finishConcurrentRender(root, exitStatus, lanes) {\n\t  switch (exitStatus) {\n\t    case RootInProgress:\n\t    case RootFatalErrored:\n\t      {\n\t        throw new Error('Root did not complete. This is a bug in React.');\n\t      }\n\t    // Flow knows about invariant, so it complains if I add a break\n\t    // statement, but eslint doesn't know about invariant, so it complains\n\t    // if I do. eslint-disable-next-line no-fallthrough\n\n\t    case RootErrored:\n\t      {\n\t        // We should have already attempted to retry this tree. If we reached\n\t        // this point, it errored again. Commit it.\n\t        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n\t        break;\n\t      }\n\n\t    case RootSuspended:\n\t      {\n\t        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n\t        // should immediately commit it or wait a bit.\n\n\t        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n\t        !shouldForceFlushFallbacksInDEV()) {\n\t          // This render only included retries, no updates. Throttle committing\n\t          // retries so that we don't show too many loading states too quickly.\n\t          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n\t          if (msUntilTimeout > 10) {\n\t            var nextLanes = getNextLanes(root, NoLanes);\n\n\t            if (nextLanes !== NoLanes) {\n\t              // There's additional work on this root.\n\t              break;\n\t            }\n\n\t            var suspendedLanes = root.suspendedLanes;\n\n\t            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n\t              // We should prefer to render the fallback of at the last\n\t              // suspended level. Ping the last suspended level to try\n\t              // rendering it again.\n\t              // FIXME: What if the suspended lanes are Idle? Should not restart.\n\t              requestEventTime();\n\t              markRootPinged(root, suspendedLanes);\n\t              break;\n\t            } // The render is suspended, it hasn't timed out, and there's no\n\t            // lower priority work to do. Instead of committing the fallback\n\t            // immediately, wait for more data to arrive.\n\n\n\t            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n\t            break;\n\t          }\n\t        } // The work expired. Commit immediately.\n\n\n\t        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n\t        break;\n\t      }\n\n\t    case RootSuspendedWithDelay:\n\t      {\n\t        markRootSuspended$1(root, lanes);\n\n\t        if (includesOnlyTransitions(lanes)) {\n\t          // This is a transition, so we should exit without committing a\n\t          // placeholder and without scheduling a timeout. Delay indefinitely\n\t          // until we receive more data.\n\t          break;\n\t        }\n\n\t        if (!shouldForceFlushFallbacksInDEV()) {\n\t          // This is not a transition, but we did trigger an avoided state.\n\t          // Schedule a placeholder to display after a short delay, using the Just\n\t          // Noticeable Difference.\n\t          // TODO: Is the JND optimization worth the added complexity? If this is\n\t          // the only reason we track the event time, then probably not.\n\t          // Consider removing.\n\t          var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n\t          var eventTimeMs = mostRecentEventTime;\n\t          var timeElapsedMs = now() - eventTimeMs;\n\n\t          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n\n\t          if (_msUntilTimeout > 10) {\n\t            // Instead of committing the fallback immediately, wait for more data\n\t            // to arrive.\n\t            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);\n\t            break;\n\t          }\n\t        } // Commit the placeholder.\n\n\n\t        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n\t        break;\n\t      }\n\n\t    case RootCompleted:\n\t      {\n\t        // The work completed. Ready to commit.\n\t        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n\t        break;\n\t      }\n\n\t    default:\n\t      {\n\t        throw new Error('Unknown root exit status.');\n\t      }\n\t  }\n\t}\n\n\tfunction isRenderConsistentWithExternalStores(finishedWork) {\n\t  // Search the rendered tree for external store reads, and check whether the\n\t  // stores were mutated in a concurrent event. Intentionally using an iterative\n\t  // loop instead of recursion so we can exit early.\n\t  var node = finishedWork;\n\n\t  while (true) {\n\t    if (node.flags & StoreConsistency) {\n\t      var updateQueue = node.updateQueue;\n\n\t      if (updateQueue !== null) {\n\t        var checks = updateQueue.stores;\n\n\t        if (checks !== null) {\n\t          for (var i = 0; i < checks.length; i++) {\n\t            var check = checks[i];\n\t            var getSnapshot = check.getSnapshot;\n\t            var renderedValue = check.value;\n\n\t            try {\n\t              if (!objectIs(getSnapshot(), renderedValue)) {\n\t                // Found an inconsistent store.\n\t                return false;\n\t              }\n\t            } catch (error) {\n\t              // If `getSnapshot` throws, return `false`. This will schedule\n\t              // a re-render, and the error will be rethrown during render.\n\t              return false;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    var child = node.child;\n\n\t    if (node.subtreeFlags & StoreConsistency && child !== null) {\n\t      child.return = node;\n\t      node = child;\n\t      continue;\n\t    }\n\n\t    if (node === finishedWork) {\n\t      return true;\n\t    }\n\n\t    while (node.sibling === null) {\n\t      if (node.return === null || node.return === finishedWork) {\n\t        return true;\n\t      }\n\n\t      node = node.return;\n\t    }\n\n\t    node.sibling.return = node.return;\n\t    node = node.sibling;\n\t  } // Flow doesn't know this is unreachable, but eslint does\n\t  // eslint-disable-next-line no-unreachable\n\n\n\t  return true;\n\t}\n\n\tfunction markRootSuspended$1(root, suspendedLanes) {\n\t  // When suspending, we should always exclude lanes that were pinged or (more\n\t  // rarely, since we try to avoid it) updated during the render phase.\n\t  // TODO: Lol maybe there's a better way to factor this besides this\n\t  // obnoxiously named function :)\n\t  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n\t  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n\t  markRootSuspended(root, suspendedLanes);\n\t} // This is the entry point for synchronous tasks that don't go\n\t// through Scheduler\n\n\n\tfunction performSyncWorkOnRoot(root) {\n\t  {\n\t    syncNestedUpdateFlag();\n\t  }\n\n\t  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n\t    throw new Error('Should not already be working.');\n\t  }\n\n\t  flushPassiveEffects();\n\t  var lanes = getNextLanes(root, NoLanes);\n\n\t  if (!includesSomeLane(lanes, SyncLane)) {\n\t    // There's no remaining sync work left.\n\t    ensureRootIsScheduled(root, now());\n\t    return null;\n\t  }\n\n\t  var exitStatus = renderRootSync(root, lanes);\n\n\t  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n\t    // If something threw an error, try rendering one more time. We'll render\n\t    // synchronously to block concurrent data mutations, and we'll includes\n\t    // all pending updates are included. If it still fails after the second\n\t    // attempt, we'll give up and commit the resulting tree.\n\t    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n\t    if (errorRetryLanes !== NoLanes) {\n\t      lanes = errorRetryLanes;\n\t      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n\t    }\n\t  }\n\n\t  if (exitStatus === RootFatalErrored) {\n\t    var fatalError = workInProgressRootFatalError;\n\t    prepareFreshStack(root, NoLanes);\n\t    markRootSuspended$1(root, lanes);\n\t    ensureRootIsScheduled(root, now());\n\t    throw fatalError;\n\t  }\n\n\t  if (exitStatus === RootDidNotComplete) {\n\t    throw new Error('Root did not complete. This is a bug in React.');\n\t  } // We now have a consistent tree. Because this is a sync render, we\n\t  // will commit it even if something suspended.\n\n\n\t  var finishedWork = root.current.alternate;\n\t  root.finishedWork = finishedWork;\n\t  root.finishedLanes = lanes;\n\t  commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); // Before exiting, make sure there's a callback scheduled for the next\n\t  // pending level.\n\n\t  ensureRootIsScheduled(root, now());\n\t  return null;\n\t}\n\n\tfunction flushRoot(root, lanes) {\n\t  if (lanes !== NoLanes) {\n\t    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n\t    ensureRootIsScheduled(root, now());\n\n\t    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n\t      resetRenderTimer();\n\t      flushSyncCallbacks();\n\t    }\n\t  }\n\t}\n\tfunction deferredUpdates(fn) {\n\t  var previousPriority = getCurrentUpdatePriority();\n\t  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n\t  try {\n\t    ReactCurrentBatchConfig$2.transition = null;\n\t    setCurrentUpdatePriority(DefaultEventPriority);\n\t    return fn();\n\t  } finally {\n\t    setCurrentUpdatePriority(previousPriority);\n\t    ReactCurrentBatchConfig$2.transition = prevTransition;\n\t  }\n\t}\n\tfunction batchedUpdates(fn, a) {\n\t  var prevExecutionContext = executionContext;\n\t  executionContext |= BatchedContext;\n\n\t  try {\n\t    return fn(a);\n\t  } finally {\n\t    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n\t    // most batchedUpdates-like method.\n\n\t    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n\t    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n\t      resetRenderTimer();\n\t      flushSyncCallbacksOnlyInLegacyMode();\n\t    }\n\t  }\n\t}\n\tfunction discreteUpdates(fn, a, b, c, d) {\n\t  var previousPriority = getCurrentUpdatePriority();\n\t  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n\t  try {\n\t    ReactCurrentBatchConfig$2.transition = null;\n\t    setCurrentUpdatePriority(DiscreteEventPriority);\n\t    return fn(a, b, c, d);\n\t  } finally {\n\t    setCurrentUpdatePriority(previousPriority);\n\t    ReactCurrentBatchConfig$2.transition = prevTransition;\n\n\t    if (executionContext === NoContext) {\n\t      resetRenderTimer();\n\t    }\n\t  }\n\t} // Overload the definition to the two valid signatures.\n\t// Warning, this opts-out of checking the function body.\n\n\t// eslint-disable-next-line no-redeclare\n\tfunction flushSync(fn) {\n\t  // In legacy mode, we flush pending passive effects at the beginning of the\n\t  // next event, not at the end of the previous one.\n\t  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n\t    flushPassiveEffects();\n\t  }\n\n\t  var prevExecutionContext = executionContext;\n\t  executionContext |= BatchedContext;\n\t  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\t  var previousPriority = getCurrentUpdatePriority();\n\n\t  try {\n\t    ReactCurrentBatchConfig$2.transition = null;\n\t    setCurrentUpdatePriority(DiscreteEventPriority);\n\n\t    if (fn) {\n\t      return fn();\n\t    } else {\n\t      return undefined;\n\t    }\n\t  } finally {\n\t    setCurrentUpdatePriority(previousPriority);\n\t    ReactCurrentBatchConfig$2.transition = prevTransition;\n\t    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n\t    // Note that this will happen even if batchedUpdates is higher up\n\t    // the stack.\n\n\t    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n\t      flushSyncCallbacks();\n\t    }\n\t  }\n\t}\n\tfunction isAlreadyRendering() {\n\t  // Used by the renderer to print a warning if certain APIs are called from\n\t  // the wrong context.\n\t  return  (executionContext & (RenderContext | CommitContext)) !== NoContext;\n\t}\n\tfunction flushControlled(fn) {\n\t  var prevExecutionContext = executionContext;\n\t  executionContext |= BatchedContext;\n\t  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\t  var previousPriority = getCurrentUpdatePriority();\n\n\t  try {\n\t    ReactCurrentBatchConfig$2.transition = null;\n\t    setCurrentUpdatePriority(DiscreteEventPriority);\n\t    fn();\n\t  } finally {\n\t    setCurrentUpdatePriority(previousPriority);\n\t    ReactCurrentBatchConfig$2.transition = prevTransition;\n\t    executionContext = prevExecutionContext;\n\n\t    if (executionContext === NoContext) {\n\t      // Flush the immediate callbacks that were scheduled during this batch\n\t      resetRenderTimer();\n\t      flushSyncCallbacks();\n\t    }\n\t  }\n\t}\n\tfunction pushRenderLanes(fiber, lanes) {\n\t  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n\t  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n\t}\n\tfunction popRenderLanes(fiber) {\n\t  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n\t  pop(subtreeRenderLanesCursor, fiber);\n\t}\n\n\tfunction prepareFreshStack(root, lanes) {\n\t  root.finishedWork = null;\n\t  root.finishedLanes = NoLanes;\n\t  var timeoutHandle = root.timeoutHandle;\n\n\t  if (timeoutHandle !== noTimeout) {\n\t    // The root previous suspended and scheduled a timeout to commit a fallback\n\t    // state. Now that we have additional work, cancel the timeout.\n\t    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n\t    cancelTimeout(timeoutHandle);\n\t  }\n\n\t  if (workInProgress !== null) {\n\t    var interruptedWork = workInProgress.return;\n\n\t    while (interruptedWork !== null) {\n\t      var current = interruptedWork.alternate;\n\t      unwindInterruptedWork(current, interruptedWork);\n\t      interruptedWork = interruptedWork.return;\n\t    }\n\t  }\n\n\t  workInProgressRoot = root;\n\t  var rootWorkInProgress = createWorkInProgress(root.current, null);\n\t  workInProgress = rootWorkInProgress;\n\t  workInProgressRootRenderLanes = subtreeRenderLanes = lanes;\n\t  workInProgressRootExitStatus = RootInProgress;\n\t  workInProgressRootFatalError = null;\n\t  workInProgressRootSkippedLanes = NoLanes;\n\t  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n\t  workInProgressRootPingedLanes = NoLanes;\n\t  workInProgressRootConcurrentErrors = null;\n\t  workInProgressRootRecoverableErrors = null;\n\t  finishQueueingConcurrentUpdates();\n\n\t  {\n\t    ReactStrictModeWarnings.discardPendingWarnings();\n\t  }\n\n\t  return rootWorkInProgress;\n\t}\n\n\tfunction handleError(root, thrownValue) {\n\t  do {\n\t    var erroredWork = workInProgress;\n\n\t    try {\n\t      // Reset module-level state that was set during the render phase.\n\t      resetContextDependencies();\n\t      resetHooksAfterThrow();\n\t      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n\t      // separate issue. Write a regression test using string refs.\n\n\t      ReactCurrentOwner$2.current = null;\n\n\t      if (erroredWork === null || erroredWork.return === null) {\n\t        // Expected to be working on a non-root fiber. This is a fatal error\n\t        // because there's no ancestor that can handle it; the root is\n\t        // supposed to capture all errors that weren't caught by an error\n\t        // boundary.\n\t        workInProgressRootExitStatus = RootFatalErrored;\n\t        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n\t        // sibling, or the parent if there are no siblings. But since the root\n\t        // has no siblings nor a parent, we set it to null. Usually this is\n\t        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n\t        // intentionally not calling those, we need set it here.\n\t        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n\t        workInProgress = null;\n\t        return;\n\t      }\n\n\t      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n\t        // Record the time spent rendering before an error was thrown. This\n\t        // avoids inaccurate Profiler durations in the case of a\n\t        // suspended render.\n\t        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n\t      }\n\n\t      if (enableSchedulingProfiler) {\n\t        markComponentRenderStopped();\n\n\t        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n\t          var wakeable = thrownValue;\n\t          markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n\t        } else {\n\t          markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n\t        }\n\t      }\n\n\t      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n\t      completeUnitOfWork(erroredWork);\n\t    } catch (yetAnotherThrownValue) {\n\t      // Something in the return path also threw.\n\t      thrownValue = yetAnotherThrownValue;\n\n\t      if (workInProgress === erroredWork && erroredWork !== null) {\n\t        // If this boundary has already errored, then we had trouble processing\n\t        // the error. Bubble it to the next boundary.\n\t        erroredWork = erroredWork.return;\n\t        workInProgress = erroredWork;\n\t      } else {\n\t        erroredWork = workInProgress;\n\t      }\n\n\t      continue;\n\t    } // Return to the normal work loop.\n\n\n\t    return;\n\t  } while (true);\n\t}\n\n\tfunction pushDispatcher() {\n\t  var prevDispatcher = ReactCurrentDispatcher$2.current;\n\t  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n\n\t  if (prevDispatcher === null) {\n\t    // The React isomorphic package does not include a default dispatcher.\n\t    // Instead the first renderer will lazily attach one, in order to give\n\t    // nicer error messages.\n\t    return ContextOnlyDispatcher;\n\t  } else {\n\t    return prevDispatcher;\n\t  }\n\t}\n\n\tfunction popDispatcher(prevDispatcher) {\n\t  ReactCurrentDispatcher$2.current = prevDispatcher;\n\t}\n\n\tfunction markCommitTimeOfFallback() {\n\t  globalMostRecentFallbackTime = now();\n\t}\n\tfunction markSkippedUpdateLanes(lane) {\n\t  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n\t}\n\tfunction renderDidSuspend() {\n\t  if (workInProgressRootExitStatus === RootInProgress) {\n\t    workInProgressRootExitStatus = RootSuspended;\n\t  }\n\t}\n\tfunction renderDidSuspendDelayIfPossible() {\n\t  if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n\t    workInProgressRootExitStatus = RootSuspendedWithDelay;\n\t  } // Check if there are updates that we skipped tree that might have unblocked\n\t  // this render.\n\n\n\t  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n\t    // Mark the current render as suspended so that we switch to working on\n\t    // the updates that were skipped. Usually we only suspend at the end of\n\t    // the render phase.\n\t    // TODO: We should probably always mark the root as suspended immediately\n\t    // (inside this function), since by suspending at the end of the render\n\t    // phase introduces a potential mistake where we suspend lanes that were\n\t    // pinged or updated while we were rendering.\n\t    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n\t  }\n\t}\n\tfunction renderDidError(error) {\n\t  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n\t    workInProgressRootExitStatus = RootErrored;\n\t  }\n\n\t  if (workInProgressRootConcurrentErrors === null) {\n\t    workInProgressRootConcurrentErrors = [error];\n\t  } else {\n\t    workInProgressRootConcurrentErrors.push(error);\n\t  }\n\t} // Called during render to determine if anything has suspended.\n\t// Returns false if we're not sure.\n\n\tfunction renderHasNotSuspendedYet() {\n\t  // If something errored or completed, we can't really be sure,\n\t  // so those are false.\n\t  return workInProgressRootExitStatus === RootInProgress;\n\t}\n\n\tfunction renderRootSync(root, lanes) {\n\t  var prevExecutionContext = executionContext;\n\t  executionContext |= RenderContext;\n\t  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n\t  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n\t  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n\t    {\n\t      if (isDevToolsPresent) {\n\t        var memoizedUpdaters = root.memoizedUpdaters;\n\n\t        if (memoizedUpdaters.size > 0) {\n\t          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n\t          memoizedUpdaters.clear();\n\t        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n\t        // If we bailout on this work, we'll move them back (like above).\n\t        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n\t        // That way we can keep the current update and future updates separate.\n\n\n\t        movePendingFibersToMemoized(root, lanes);\n\t      }\n\t    }\n\n\t    workInProgressTransitions = getTransitionsForLanes();\n\t    prepareFreshStack(root, lanes);\n\t  }\n\n\t  {\n\t    markRenderStarted(lanes);\n\t  }\n\n\t  do {\n\t    try {\n\t      workLoopSync();\n\t      break;\n\t    } catch (thrownValue) {\n\t      handleError(root, thrownValue);\n\t    }\n\t  } while (true);\n\n\t  resetContextDependencies();\n\t  executionContext = prevExecutionContext;\n\t  popDispatcher(prevDispatcher);\n\n\t  if (workInProgress !== null) {\n\t    // This is a sync render, so we should have finished the whole tree.\n\t    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n\t  }\n\n\t  {\n\t    markRenderStopped();\n\t  } // Set this to null to indicate there's no in-progress render.\n\n\n\t  workInProgressRoot = null;\n\t  workInProgressRootRenderLanes = NoLanes;\n\t  return workInProgressRootExitStatus;\n\t} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n\t/** @noinline */\n\n\n\tfunction workLoopSync() {\n\t  // Already timed out, so perform work without checking if we need to yield.\n\t  while (workInProgress !== null) {\n\t    performUnitOfWork(workInProgress);\n\t  }\n\t}\n\n\tfunction renderRootConcurrent(root, lanes) {\n\t  var prevExecutionContext = executionContext;\n\t  executionContext |= RenderContext;\n\t  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n\t  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n\t  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n\t    {\n\t      if (isDevToolsPresent) {\n\t        var memoizedUpdaters = root.memoizedUpdaters;\n\n\t        if (memoizedUpdaters.size > 0) {\n\t          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n\t          memoizedUpdaters.clear();\n\t        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n\t        // If we bailout on this work, we'll move them back (like above).\n\t        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n\t        // That way we can keep the current update and future updates separate.\n\n\n\t        movePendingFibersToMemoized(root, lanes);\n\t      }\n\t    }\n\n\t    workInProgressTransitions = getTransitionsForLanes();\n\t    resetRenderTimer();\n\t    prepareFreshStack(root, lanes);\n\t  }\n\n\t  {\n\t    markRenderStarted(lanes);\n\t  }\n\n\t  do {\n\t    try {\n\t      workLoopConcurrent();\n\t      break;\n\t    } catch (thrownValue) {\n\t      handleError(root, thrownValue);\n\t    }\n\t  } while (true);\n\n\t  resetContextDependencies();\n\t  popDispatcher(prevDispatcher);\n\t  executionContext = prevExecutionContext;\n\n\n\t  if (workInProgress !== null) {\n\t    // Still work remaining.\n\t    {\n\t      markRenderYielded();\n\t    }\n\n\t    return RootInProgress;\n\t  } else {\n\t    // Completed the tree.\n\t    {\n\t      markRenderStopped();\n\t    } // Set this to null to indicate there's no in-progress render.\n\n\n\t    workInProgressRoot = null;\n\t    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n\n\t    return workInProgressRootExitStatus;\n\t  }\n\t}\n\t/** @noinline */\n\n\n\tfunction workLoopConcurrent() {\n\t  // Perform work until Scheduler asks us to yield\n\t  while (workInProgress !== null && !shouldYield()) {\n\t    performUnitOfWork(workInProgress);\n\t  }\n\t}\n\n\tfunction performUnitOfWork(unitOfWork) {\n\t  // The current, flushed, state of this fiber is the alternate. Ideally\n\t  // nothing should rely on this, but relying on it here means that we don't\n\t  // need an additional field on the work in progress.\n\t  var current = unitOfWork.alternate;\n\t  setCurrentFiber(unitOfWork);\n\t  var next;\n\n\t  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {\n\t    startProfilerTimer(unitOfWork);\n\t    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n\t    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n\t  } else {\n\t    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n\t  }\n\n\t  resetCurrentFiber();\n\t  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n\t  if (next === null) {\n\t    // If this doesn't spawn new work, complete the current work.\n\t    completeUnitOfWork(unitOfWork);\n\t  } else {\n\t    workInProgress = next;\n\t  }\n\n\t  ReactCurrentOwner$2.current = null;\n\t}\n\n\tfunction completeUnitOfWork(unitOfWork) {\n\t  // Attempt to complete the current unit of work, then move to the next\n\t  // sibling. If there are no more siblings, return to the parent fiber.\n\t  var completedWork = unitOfWork;\n\n\t  do {\n\t    // The current, flushed, state of this fiber is the alternate. Ideally\n\t    // nothing should rely on this, but relying on it here means that we don't\n\t    // need an additional field on the work in progress.\n\t    var current = completedWork.alternate;\n\t    var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n\t    if ((completedWork.flags & Incomplete) === NoFlags) {\n\t      setCurrentFiber(completedWork);\n\t      var next = void 0;\n\n\t      if ( (completedWork.mode & ProfileMode) === NoMode) {\n\t        next = completeWork(current, completedWork, subtreeRenderLanes);\n\t      } else {\n\t        startProfilerTimer(completedWork);\n\t        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n\n\t        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n\t      }\n\n\t      resetCurrentFiber();\n\n\t      if (next !== null) {\n\t        // Completing this fiber spawned new work. Work on that next.\n\t        workInProgress = next;\n\t        return;\n\t      }\n\t    } else {\n\t      // This fiber did not complete because something threw. Pop values off\n\t      // the stack without entering the complete phase. If this is a boundary,\n\t      // capture values if possible.\n\t      var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n\n\n\t      if (_next !== null) {\n\t        // If completing this work spawned new work, do that next. We'll come\n\t        // back here again.\n\t        // Since we're restarting, remove anything that is not a host effect\n\t        // from the effect tag.\n\t        _next.flags &= HostEffectMask;\n\t        workInProgress = _next;\n\t        return;\n\t      }\n\n\t      if ( (completedWork.mode & ProfileMode) !== NoMode) {\n\t        // Record the render duration for the fiber that errored.\n\t        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n\t        var actualDuration = completedWork.actualDuration;\n\t        var child = completedWork.child;\n\n\t        while (child !== null) {\n\t          actualDuration += child.actualDuration;\n\t          child = child.sibling;\n\t        }\n\n\t        completedWork.actualDuration = actualDuration;\n\t      }\n\n\t      if (returnFiber !== null) {\n\t        // Mark the parent fiber as incomplete and clear its subtree flags.\n\t        returnFiber.flags |= Incomplete;\n\t        returnFiber.subtreeFlags = NoFlags;\n\t        returnFiber.deletions = null;\n\t      } else {\n\t        // We've unwound all the way to the root.\n\t        workInProgressRootExitStatus = RootDidNotComplete;\n\t        workInProgress = null;\n\t        return;\n\t      }\n\t    }\n\n\t    var siblingFiber = completedWork.sibling;\n\n\t    if (siblingFiber !== null) {\n\t      // If there is more work to do in this returnFiber, do that next.\n\t      workInProgress = siblingFiber;\n\t      return;\n\t    } // Otherwise, return to the parent\n\n\n\t    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n\t    workInProgress = completedWork;\n\t  } while (completedWork !== null); // We've reached the root.\n\n\n\t  if (workInProgressRootExitStatus === RootInProgress) {\n\t    workInProgressRootExitStatus = RootCompleted;\n\t  }\n\t}\n\n\tfunction commitRoot(root, recoverableErrors, transitions) {\n\t  // TODO: This no longer makes any sense. We already wrap the mutation and\n\t  // layout phases. Should be able to remove.\n\t  var previousUpdateLanePriority = getCurrentUpdatePriority();\n\t  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n\t  try {\n\t    ReactCurrentBatchConfig$2.transition = null;\n\t    setCurrentUpdatePriority(DiscreteEventPriority);\n\t    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);\n\t  } finally {\n\t    ReactCurrentBatchConfig$2.transition = prevTransition;\n\t    setCurrentUpdatePriority(previousUpdateLanePriority);\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {\n\t  do {\n\t    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n\t    // means `flushPassiveEffects` will sometimes result in additional\n\t    // passive effects. So we need to keep flushing in a loop until there are\n\t    // no more pending effects.\n\t    // TODO: Might be better if `flushPassiveEffects` did not automatically\n\t    // flush synchronous work at the end, to avoid factoring hazards like this.\n\t    flushPassiveEffects();\n\t  } while (rootWithPendingPassiveEffects !== null);\n\n\t  flushRenderPhaseStrictModeWarningsInDEV();\n\n\t  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n\t    throw new Error('Should not already be working.');\n\t  }\n\n\t  var finishedWork = root.finishedWork;\n\t  var lanes = root.finishedLanes;\n\n\t  {\n\t    markCommitStarted(lanes);\n\t  }\n\n\t  if (finishedWork === null) {\n\n\t    {\n\t      markCommitStopped();\n\t    }\n\n\t    return null;\n\t  } else {\n\t    {\n\t      if (lanes === NoLanes) {\n\t        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n\t      }\n\t    }\n\t  }\n\n\t  root.finishedWork = null;\n\t  root.finishedLanes = NoLanes;\n\n\t  if (finishedWork === root.current) {\n\t    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n\t  } // commitRoot never returns a continuation; it always finishes synchronously.\n\t  // So we can clear these now to allow a new callback to be scheduled.\n\n\n\t  root.callbackNode = null;\n\t  root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n\t  // pending time is whatever is left on the root fiber.\n\n\t  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n\t  markRootFinished(root, remainingLanes);\n\n\t  if (root === workInProgressRoot) {\n\t    // We can reset these now that they are finished.\n\t    workInProgressRoot = null;\n\t    workInProgress = null;\n\t    workInProgressRootRenderLanes = NoLanes;\n\t  } // If there are pending passive effects, schedule a callback to process them.\n\t  // Do this as early as possible, so it is queued before anything else that\n\t  // might get scheduled in the commit phase. (See #16714.)\n\t  // TODO: Delete all other places that schedule the passive effect callback\n\t  // They're redundant.\n\n\n\t  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n\t    if (!rootDoesHavePassiveEffects) {\n\t      rootDoesHavePassiveEffects = true;\n\t      // to store it in pendingPassiveTransitions until they get processed\n\t      // We need to pass this through as an argument to commitRoot\n\t      // because workInProgressTransitions might have changed between\n\t      // the previous render and commit if we throttle the commit\n\t      // with setTimeout\n\n\t      pendingPassiveTransitions = transitions;\n\t      scheduleCallback$1(NormalPriority, function () {\n\t        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n\t        // *after* passive effects fire to avoid freeing a cache pool that may\n\t        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n\t        return null;\n\t      });\n\t    }\n\t  } // Check if there are any effects in the whole tree.\n\t  // TODO: This is left over from the effect list implementation, where we had\n\t  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n\t  // only other reason this optimization exists is because it affects profiling.\n\t  // Reconsider whether this is necessary.\n\n\n\t  var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\t  var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n\t  if (subtreeHasEffects || rootHasEffect) {\n\t    var prevTransition = ReactCurrentBatchConfig$2.transition;\n\t    ReactCurrentBatchConfig$2.transition = null;\n\t    var previousPriority = getCurrentUpdatePriority();\n\t    setCurrentUpdatePriority(DiscreteEventPriority);\n\t    var prevExecutionContext = executionContext;\n\t    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n\t    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n\t    // of the effect list for each phase: all mutation effects come before all\n\t    // layout effects, and so on.\n\t    // The first phase a \"before mutation\" phase. We use this phase to read the\n\t    // state of the host tree right before we mutate it. This is where\n\t    // getSnapshotBeforeUpdate is called.\n\n\t    commitBeforeMutationEffects(root, finishedWork);\n\n\t    {\n\t      // Mark the current commit time to be shared by all Profilers in this\n\t      // batch. This enables them to be grouped later.\n\t      recordCommitTime();\n\t    }\n\n\n\t    commitMutationEffects(root, finishedWork, lanes);\n\n\t    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n\t    // the mutation phase, so that the previous tree is still current during\n\t    // componentWillUnmount, but before the layout phase, so that the finished\n\t    // work is current during componentDidMount/Update.\n\n\t    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n\n\t    {\n\t      markLayoutEffectsStarted(lanes);\n\t    }\n\n\t    commitLayoutEffects(finishedWork, root, lanes);\n\n\t    {\n\t      markLayoutEffectsStopped();\n\t    }\n\t    // opportunity to paint.\n\n\n\t    requestPaint();\n\t    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n\t    setCurrentUpdatePriority(previousPriority);\n\t    ReactCurrentBatchConfig$2.transition = prevTransition;\n\t  } else {\n\t    // No effects.\n\t    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n\t    // no effects.\n\t    // TODO: Maybe there's a better way to report this.\n\n\t    {\n\t      recordCommitTime();\n\t    }\n\t  }\n\n\t  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n\t  if (rootDoesHavePassiveEffects) {\n\t    // This commit has passive effects. Stash a reference to them. But don't\n\t    // schedule a callback until after flushing layout work.\n\t    rootDoesHavePassiveEffects = false;\n\t    rootWithPendingPassiveEffects = root;\n\t    pendingPassiveEffectsLanes = lanes;\n\t  } else {\n\n\t    {\n\t      nestedPassiveUpdateCount = 0;\n\t      rootWithPassiveNestedUpdates = null;\n\t    }\n\t  } // Read this again, since an effect might have updated it\n\n\n\t  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n\t  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n\t  // is to detect whether something might have called setState inside\n\t  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n\t  // inside `componentDidCatch` is itself flawed  that's why we recommend\n\t  // `getDerivedStateFromError` instead. However, it could be improved by\n\t  // checking if remainingLanes includes Sync work, instead of whether there's\n\t  // any work remaining at all (which would also include stuff like Suspense\n\t  // retries or transitions). It's been like this for a while, though, so fixing\n\t  // it probably isn't that urgent.\n\n\t  if (remainingLanes === NoLanes) {\n\t    // If there's no remaining work, we can clear the set of already failed\n\t    // error boundaries.\n\t    legacyErrorBoundariesThatAlreadyFailed = null;\n\t  }\n\n\t  {\n\t    if (!rootDidHavePassiveEffects) {\n\t      commitDoubleInvokeEffectsInDEV(root.current, false);\n\t    }\n\t  }\n\n\t  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n\n\t  {\n\t    if (isDevToolsPresent) {\n\t      root.memoizedUpdaters.clear();\n\t    }\n\t  }\n\n\t  {\n\t    onCommitRoot$1();\n\t  } // Always call this before exiting `commitRoot`, to ensure that any\n\t  // additional work on this root is scheduled.\n\n\n\t  ensureRootIsScheduled(root, now());\n\n\t  if (recoverableErrors !== null) {\n\t    // There were errors during this render, but recovered from them without\n\t    // needing to surface it to the UI. We log them here.\n\t    var onRecoverableError = root.onRecoverableError;\n\n\t    for (var i = 0; i < recoverableErrors.length; i++) {\n\t      var recoverableError = recoverableErrors[i];\n\t      var componentStack = recoverableError.stack;\n\t      var digest = recoverableError.digest;\n\t      onRecoverableError(recoverableError.value, {\n\t        componentStack: componentStack,\n\t        digest: digest\n\t      });\n\t    }\n\t  }\n\n\t  if (hasUncaughtError) {\n\t    hasUncaughtError = false;\n\t    var error$1 = firstUncaughtError;\n\t    firstUncaughtError = null;\n\t    throw error$1;\n\t  } // If the passive effects are the result of a discrete render, flush them\n\t  // synchronously at the end of the current task so that the result is\n\t  // immediately observable. Otherwise, we assume that they are not\n\t  // order-dependent and do not need to be observed by external systems, so we\n\t  // can wait until after paint.\n\t  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n\t  // currently schedule the callback in multiple places, will wait until those\n\t  // are consolidated.\n\n\n\t  if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n\t    flushPassiveEffects();\n\t  } // Read this again, since a passive effect might have updated it\n\n\n\t  remainingLanes = root.pendingLanes;\n\n\t  if (includesSomeLane(remainingLanes, SyncLane)) {\n\t    {\n\t      markNestedUpdateScheduled();\n\t    } // Count the number of times the root synchronously re-renders without\n\t    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n\t    if (root === rootWithNestedUpdates) {\n\t      nestedUpdateCount++;\n\t    } else {\n\t      nestedUpdateCount = 0;\n\t      rootWithNestedUpdates = root;\n\t    }\n\t  } else {\n\t    nestedUpdateCount = 0;\n\t  } // If layout work was scheduled, flush it now.\n\n\n\t  flushSyncCallbacks();\n\n\t  {\n\t    markCommitStopped();\n\t  }\n\n\t  return null;\n\t}\n\n\tfunction flushPassiveEffects() {\n\t  // Returns whether passive effects were flushed.\n\t  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n\t  // probably just combine the two functions. I believe they were only separate\n\t  // in the first place because we used to wrap it with\n\t  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n\t  // priority within React itself, so we can mutate the variable directly.\n\t  if (rootWithPendingPassiveEffects !== null) {\n\t    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n\t    var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n\t    var prevTransition = ReactCurrentBatchConfig$2.transition;\n\t    var previousPriority = getCurrentUpdatePriority();\n\n\t    try {\n\t      ReactCurrentBatchConfig$2.transition = null;\n\t      setCurrentUpdatePriority(priority);\n\t      return flushPassiveEffectsImpl();\n\t    } finally {\n\t      setCurrentUpdatePriority(previousPriority);\n\t      ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n\t    }\n\t  }\n\n\t  return false;\n\t}\n\tfunction enqueuePendingPassiveProfilerEffect(fiber) {\n\t  {\n\t    pendingPassiveProfilerEffects.push(fiber);\n\n\t    if (!rootDoesHavePassiveEffects) {\n\t      rootDoesHavePassiveEffects = true;\n\t      scheduleCallback$1(NormalPriority, function () {\n\t        flushPassiveEffects();\n\t        return null;\n\t      });\n\t    }\n\t  }\n\t}\n\n\tfunction flushPassiveEffectsImpl() {\n\t  if (rootWithPendingPassiveEffects === null) {\n\t    return false;\n\t  } // Cache and clear the transitions flag\n\n\n\t  var transitions = pendingPassiveTransitions;\n\t  pendingPassiveTransitions = null;\n\t  var root = rootWithPendingPassiveEffects;\n\t  var lanes = pendingPassiveEffectsLanes;\n\t  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n\t  // Figure out why and fix it. It's not causing any known issues (probably\n\t  // because it's only used for profiling), but it's a refactor hazard.\n\n\t  pendingPassiveEffectsLanes = NoLanes;\n\n\t  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n\t    throw new Error('Cannot flush passive effects while already rendering.');\n\t  }\n\n\t  {\n\t    isFlushingPassiveEffects = true;\n\t    didScheduleUpdateDuringPassiveEffects = false;\n\t  }\n\n\t  {\n\t    markPassiveEffectsStarted(lanes);\n\t  }\n\n\t  var prevExecutionContext = executionContext;\n\t  executionContext |= CommitContext;\n\t  commitPassiveUnmountEffects(root.current);\n\t  commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n\n\t  {\n\t    var profilerEffects = pendingPassiveProfilerEffects;\n\t    pendingPassiveProfilerEffects = [];\n\n\t    for (var i = 0; i < profilerEffects.length; i++) {\n\t      var _fiber = profilerEffects[i];\n\t      commitPassiveEffectDurations(root, _fiber);\n\t    }\n\t  }\n\n\t  {\n\t    markPassiveEffectsStopped();\n\t  }\n\n\t  {\n\t    commitDoubleInvokeEffectsInDEV(root.current, true);\n\t  }\n\n\t  executionContext = prevExecutionContext;\n\t  flushSyncCallbacks();\n\n\t  {\n\t    // If additional passive effects were scheduled, increment a counter. If this\n\t    // exceeds the limit, we'll fire a warning.\n\t    if (didScheduleUpdateDuringPassiveEffects) {\n\t      if (root === rootWithPassiveNestedUpdates) {\n\t        nestedPassiveUpdateCount++;\n\t      } else {\n\t        nestedPassiveUpdateCount = 0;\n\t        rootWithPassiveNestedUpdates = root;\n\t      }\n\t    } else {\n\t      nestedPassiveUpdateCount = 0;\n\t    }\n\n\t    isFlushingPassiveEffects = false;\n\t    didScheduleUpdateDuringPassiveEffects = false;\n\t  } // TODO: Move to commitPassiveMountEffects\n\n\n\t  onPostCommitRoot(root);\n\n\t  {\n\t    var stateNode = root.current.stateNode;\n\t    stateNode.effectDuration = 0;\n\t    stateNode.passiveEffectDuration = 0;\n\t  }\n\n\t  return true;\n\t}\n\n\tfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n\t  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n\t}\n\tfunction markLegacyErrorBoundaryAsFailed(instance) {\n\t  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n\t    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n\t  } else {\n\t    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n\t  }\n\t}\n\n\tfunction prepareToThrowUncaughtError(error) {\n\t  if (!hasUncaughtError) {\n\t    hasUncaughtError = true;\n\t    firstUncaughtError = error;\n\t  }\n\t}\n\n\tvar onUncaughtError = prepareToThrowUncaughtError;\n\n\tfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n\t  var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n\t  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n\t  var root = enqueueUpdate(rootFiber, update, SyncLane);\n\t  var eventTime = requestEventTime();\n\n\t  if (root !== null) {\n\t    markRootUpdated(root, SyncLane, eventTime);\n\t    ensureRootIsScheduled(root, eventTime);\n\t  }\n\t}\n\n\tfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n\t  {\n\t    reportUncaughtErrorInDEV(error$1);\n\t    setIsRunningInsertionEffect(false);\n\t  }\n\n\t  if (sourceFiber.tag === HostRoot) {\n\t    // Error was thrown at the root. There is no parent, so the root\n\t    // itself should capture it.\n\t    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n\t    return;\n\t  }\n\n\t  var fiber = null;\n\n\t  {\n\t    fiber = nearestMountedAncestor;\n\t  }\n\n\t  while (fiber !== null) {\n\t    if (fiber.tag === HostRoot) {\n\t      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n\t      return;\n\t    } else if (fiber.tag === ClassComponent) {\n\t      var ctor = fiber.type;\n\t      var instance = fiber.stateNode;\n\n\t      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n\t        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n\t        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n\t        var root = enqueueUpdate(fiber, update, SyncLane);\n\t        var eventTime = requestEventTime();\n\n\t        if (root !== null) {\n\t          markRootUpdated(root, SyncLane, eventTime);\n\t          ensureRootIsScheduled(root, eventTime);\n\t        }\n\n\t        return;\n\t      }\n\t    }\n\n\t    fiber = fiber.return;\n\t  }\n\n\t  {\n\t    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n\t    // will fire for errors that are thrown by destroy functions inside deleted\n\t    // trees. What it should instead do is propagate the error to the parent of\n\t    // the deleted tree. In the meantime, do not add this warning to the\n\t    // allowlist; this is only for our internal use.\n\t    error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n\t  }\n\t}\n\tfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n\t  var pingCache = root.pingCache;\n\n\t  if (pingCache !== null) {\n\t    // The wakeable resolved, so we no longer need to memoize, because it will\n\t    // never be thrown again.\n\t    pingCache.delete(wakeable);\n\t  }\n\n\t  var eventTime = requestEventTime();\n\t  markRootPinged(root, pingedLanes);\n\t  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n\t  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n\t    // Received a ping at the same priority level at which we're currently\n\t    // rendering. We might want to restart this render. This should mirror\n\t    // the logic of whether or not a root suspends once it completes.\n\t    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n\t    // we should probably never restart.\n\t    // If we're suspended with delay, or if it's a retry, we'll always suspend\n\t    // so we can always restart.\n\t    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n\t      // Restart from the root.\n\t      prepareFreshStack(root, NoLanes);\n\t    } else {\n\t      // Even though we can't restart right now, we might get an\n\t      // opportunity later. So we mark this render as having a ping.\n\t      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n\t    }\n\t  }\n\n\t  ensureRootIsScheduled(root, eventTime);\n\t}\n\n\tfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n\t  // The boundary fiber (a Suspense component or SuspenseList component)\n\t  // previously was rendered in its fallback state. One of the promises that\n\t  // suspended it has resolved, which means at least part of the tree was\n\t  // likely unblocked. Try rendering again, at a new lanes.\n\t  if (retryLane === NoLane) {\n\t    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n\t    // unnecessary entanglement?\n\t    retryLane = requestRetryLane(boundaryFiber);\n\t  } // TODO: Special case idle priority?\n\n\n\t  var eventTime = requestEventTime();\n\t  var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n\n\t  if (root !== null) {\n\t    markRootUpdated(root, retryLane, eventTime);\n\t    ensureRootIsScheduled(root, eventTime);\n\t  }\n\t}\n\n\tfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n\t  var suspenseState = boundaryFiber.memoizedState;\n\t  var retryLane = NoLane;\n\n\t  if (suspenseState !== null) {\n\t    retryLane = suspenseState.retryLane;\n\t  }\n\n\t  retryTimedOutBoundary(boundaryFiber, retryLane);\n\t}\n\tfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n\t  var retryLane = NoLane; // Default\n\n\t  var retryCache;\n\n\t  switch (boundaryFiber.tag) {\n\t    case SuspenseComponent:\n\t      retryCache = boundaryFiber.stateNode;\n\t      var suspenseState = boundaryFiber.memoizedState;\n\n\t      if (suspenseState !== null) {\n\t        retryLane = suspenseState.retryLane;\n\t      }\n\n\t      break;\n\n\t    case SuspenseListComponent:\n\t      retryCache = boundaryFiber.stateNode;\n\t      break;\n\n\t    default:\n\t      throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n\t  }\n\n\t  if (retryCache !== null) {\n\t    // The wakeable resolved, so we no longer need to memoize, because it will\n\t    // never be thrown again.\n\t    retryCache.delete(wakeable);\n\t  }\n\n\t  retryTimedOutBoundary(boundaryFiber, retryLane);\n\t} // Computes the next Just Noticeable Difference (JND) boundary.\n\t// The theory is that a person can't tell the difference between small differences in time.\n\t// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n\t// difference in the experience. However, waiting for longer might mean that we can avoid\n\t// showing an intermediate loading state. The longer we have already waited, the harder it\n\t// is to tell small differences in time. Therefore, the longer we've already waited,\n\t// the longer we can wait additionally. At some point we have to give up though.\n\t// We pick a train model where the next boundary commits at a consistent schedule.\n\t// These particular numbers are vague estimates. We expect to adjust them based on research.\n\n\tfunction jnd(timeElapsed) {\n\t  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n\t}\n\n\tfunction checkForNestedUpdates() {\n\t  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n\t    nestedUpdateCount = 0;\n\t    rootWithNestedUpdates = null;\n\t    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n\t  }\n\n\t  {\n\t    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n\t      nestedPassiveUpdateCount = 0;\n\t      rootWithPassiveNestedUpdates = null;\n\n\t      error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n\t    }\n\t  }\n\t}\n\n\tfunction flushRenderPhaseStrictModeWarningsInDEV() {\n\t  {\n\t    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n\t    {\n\t      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\t    }\n\t  }\n\t}\n\n\tfunction commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n\t  {\n\t    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n\t    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n\t    // Maybe not a big deal since this is DEV only behavior.\n\t    setCurrentFiber(fiber);\n\t    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n\t    if (hasPassiveEffects) {\n\t      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n\t    }\n\n\t    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n\t    if (hasPassiveEffects) {\n\t      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n\t    }\n\n\t    resetCurrentFiber();\n\t  }\n\t}\n\n\tfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n\t  {\n\t    // We don't need to re-check StrictEffectsMode here.\n\t    // This function is only called if that check has already passed.\n\t    var current = firstChild;\n\t    var subtreeRoot = null;\n\n\t    while (current !== null) {\n\t      var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n\t      if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n\t        current = current.child;\n\t      } else {\n\t        if ((current.flags & fiberFlags) !== NoFlags) {\n\t          invokeEffectFn(current);\n\t        }\n\n\t        if (current.sibling !== null) {\n\t          current = current.sibling;\n\t        } else {\n\t          current = subtreeRoot = current.return;\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tvar didWarnStateUpdateForNotYetMountedComponent = null;\n\tfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n\t  {\n\t    if ((executionContext & RenderContext) !== NoContext) {\n\t      // We let the other warning about render phase updates deal with this one.\n\t      return;\n\t    }\n\n\t    if (!(fiber.mode & ConcurrentMode)) {\n\t      return;\n\t    }\n\n\t    var tag = fiber.tag;\n\n\t    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n\t      // Only warn for user-defined components, not internal ones like Suspense.\n\t      return;\n\t    } // We show the whole stack but dedupe on the top component's name because\n\t    // the problematic code almost always lies inside that component.\n\n\n\t    var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n\t    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n\t      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n\t        return;\n\t      }\n\n\t      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n\t    } else {\n\t      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n\t    }\n\n\t    var previousFiber = current;\n\n\t    try {\n\t      setCurrentFiber(fiber);\n\n\t      error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n\t    } finally {\n\t      if (previousFiber) {\n\t        setCurrentFiber(fiber);\n\t      } else {\n\t        resetCurrentFiber();\n\t      }\n\t    }\n\t  }\n\t}\n\tvar beginWork$1;\n\n\t{\n\t  var dummyFiber = null;\n\n\t  beginWork$1 = function (current, unitOfWork, lanes) {\n\t    // If a component throws an error, we replay it again in a synchronously\n\t    // dispatched event, so that the debugger will treat it as an uncaught\n\t    // error See ReactErrorUtils for more information.\n\t    // Before entering the begin phase, copy the work-in-progress onto a dummy\n\t    // fiber. If beginWork throws, we'll use this to reset the state.\n\t    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n\t    try {\n\t      return beginWork(current, unitOfWork, lanes);\n\t    } catch (originalError) {\n\t      if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n\t        // Don't replay promises.\n\t        // Don't replay errors if we are hydrating and have already suspended or handled an error\n\t        throw originalError;\n\t      } // Keep this code in sync with handleError; any changes here must have\n\t      // corresponding changes there.\n\n\n\t      resetContextDependencies();\n\t      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n\t      // same fiber again.\n\t      // Unwind the failed stack frame\n\n\t      unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n\n\t      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n\t      if ( unitOfWork.mode & ProfileMode) {\n\t        // Reset the profiler timer.\n\t        startProfilerTimer(unitOfWork);\n\t      } // Run beginWork again.\n\n\n\t      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n\n\t      if (hasCaughtError()) {\n\t        var replayError = clearCaughtError();\n\n\t        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n\t          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n\t          originalError._suppressLogging = true;\n\t        }\n\t      } // We always throw the original error in case the second render pass is not idempotent.\n\t      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n\t      throw originalError;\n\t    }\n\t  };\n\t}\n\n\tvar didWarnAboutUpdateInRender = false;\n\tvar didWarnAboutUpdateInRenderForAnotherComponent;\n\n\t{\n\t  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n\t}\n\n\tfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n\t  {\n\t    if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n\t      switch (fiber.tag) {\n\t        case FunctionComponent:\n\t        case ForwardRef:\n\t        case SimpleMemoComponent:\n\t          {\n\t            var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n\t            var dedupeKey = renderingComponentName;\n\n\t            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n\t              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n\t              var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n\t              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n\t            }\n\n\t            break;\n\t          }\n\n\t        case ClassComponent:\n\t          {\n\t            if (!didWarnAboutUpdateInRender) {\n\t              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n\n\t              didWarnAboutUpdateInRender = true;\n\t            }\n\n\t            break;\n\t          }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction restorePendingUpdaters(root, lanes) {\n\t  {\n\t    if (isDevToolsPresent) {\n\t      var memoizedUpdaters = root.memoizedUpdaters;\n\t      memoizedUpdaters.forEach(function (schedulingFiber) {\n\t        addFiberToLanesMap(root, schedulingFiber, lanes);\n\t      }); // This function intentionally does not clear memoized updaters.\n\t      // Those may still be relevant to the current commit\n\t      // and a future one (e.g. Suspense).\n\t    }\n\t  }\n\t}\n\tvar fakeActCallbackNode = {};\n\n\tfunction scheduleCallback$1(priorityLevel, callback) {\n\t  {\n\t    // If we're currently inside an `act` scope, bypass Scheduler and push to\n\t    // the `act` queue instead.\n\t    var actQueue = ReactCurrentActQueue$1.current;\n\n\t    if (actQueue !== null) {\n\t      actQueue.push(callback);\n\t      return fakeActCallbackNode;\n\t    } else {\n\t      return scheduleCallback(priorityLevel, callback);\n\t    }\n\t  }\n\t}\n\n\tfunction cancelCallback$1(callbackNode) {\n\t  if ( callbackNode === fakeActCallbackNode) {\n\t    return;\n\t  } // In production, always call Scheduler. This function will be stripped out.\n\n\n\t  return cancelCallback(callbackNode);\n\t}\n\n\tfunction shouldForceFlushFallbacksInDEV() {\n\t  // Never force flush in production. This function should get stripped out.\n\t  return  ReactCurrentActQueue$1.current !== null;\n\t}\n\n\tfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n\t  {\n\t    if (fiber.mode & ConcurrentMode) {\n\t      if (!isConcurrentActEnvironment()) {\n\t        // Not in an act environment. No need to warn.\n\t        return;\n\t      }\n\t    } else {\n\t      // Legacy mode has additional cases where we suppress a warning.\n\t      if (!isLegacyActEnvironment()) {\n\t        // Not in an act environment. No need to warn.\n\t        return;\n\t      }\n\n\t      if (executionContext !== NoContext) {\n\t        // Legacy mode doesn't warn if the update is batched, i.e.\n\t        // batchedUpdates or flushSync.\n\t        return;\n\t      }\n\n\t      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n\t        // For backwards compatibility with pre-hooks code, legacy mode only\n\t        // warns for updates that originate from a hook.\n\t        return;\n\t      }\n\t    }\n\n\t    if (ReactCurrentActQueue$1.current === null) {\n\t      var previousFiber = current;\n\n\t      try {\n\t        setCurrentFiber(fiber);\n\n\t        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n\t      } finally {\n\t        if (previousFiber) {\n\t          setCurrentFiber(fiber);\n\t        } else {\n\t          resetCurrentFiber();\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n\t  {\n\t    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n\t      error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n\t    }\n\t  }\n\t}\n\n\tfunction setIsRunningInsertionEffect(isRunning) {\n\t  {\n\t    isRunningInsertionEffect = isRunning;\n\t  }\n\t}\n\n\t/* eslint-disable react-internal/prod-error-codes */\n\tvar resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\n\tvar failedBoundaries = null;\n\tvar setRefreshHandler = function (handler) {\n\t  {\n\t    resolveFamily = handler;\n\t  }\n\t};\n\tfunction resolveFunctionForHotReloading(type) {\n\t  {\n\t    if (resolveFamily === null) {\n\t      // Hot reloading is disabled.\n\t      return type;\n\t    }\n\n\t    var family = resolveFamily(type);\n\n\t    if (family === undefined) {\n\t      return type;\n\t    } // Use the latest known implementation.\n\n\n\t    return family.current;\n\t  }\n\t}\n\tfunction resolveClassForHotReloading(type) {\n\t  // No implementation differences.\n\t  return resolveFunctionForHotReloading(type);\n\t}\n\tfunction resolveForwardRefForHotReloading(type) {\n\t  {\n\t    if (resolveFamily === null) {\n\t      // Hot reloading is disabled.\n\t      return type;\n\t    }\n\n\t    var family = resolveFamily(type);\n\n\t    if (family === undefined) {\n\t      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n\t      if (type !== null && type !== undefined && typeof type.render === 'function') {\n\t        // ForwardRef is special because its resolved .type is an object,\n\t        // but it's possible that we only have its inner render function in the map.\n\t        // If that inner render function is different, we'll build a new forwardRef type.\n\t        var currentRender = resolveFunctionForHotReloading(type.render);\n\n\t        if (type.render !== currentRender) {\n\t          var syntheticType = {\n\t            $$typeof: REACT_FORWARD_REF_TYPE,\n\t            render: currentRender\n\t          };\n\n\t          if (type.displayName !== undefined) {\n\t            syntheticType.displayName = type.displayName;\n\t          }\n\n\t          return syntheticType;\n\t        }\n\t      }\n\n\t      return type;\n\t    } // Use the latest known implementation.\n\n\n\t    return family.current;\n\t  }\n\t}\n\tfunction isCompatibleFamilyForHotReloading(fiber, element) {\n\t  {\n\t    if (resolveFamily === null) {\n\t      // Hot reloading is disabled.\n\t      return false;\n\t    }\n\n\t    var prevType = fiber.elementType;\n\t    var nextType = element.type; // If we got here, we know types aren't === equal.\n\n\t    var needsCompareFamilies = false;\n\t    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n\n\t    switch (fiber.tag) {\n\t      case ClassComponent:\n\t        {\n\t          if (typeof nextType === 'function') {\n\t            needsCompareFamilies = true;\n\t          }\n\n\t          break;\n\t        }\n\n\t      case FunctionComponent:\n\t        {\n\t          if (typeof nextType === 'function') {\n\t            needsCompareFamilies = true;\n\t          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n\t            // We don't know the inner type yet.\n\t            // We're going to assume that the lazy inner type is stable,\n\t            // and so it is sufficient to avoid reconciling it away.\n\t            // We're not going to unwrap or actually use the new lazy type.\n\t            needsCompareFamilies = true;\n\t          }\n\n\t          break;\n\t        }\n\n\t      case ForwardRef:\n\t        {\n\t          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n\t            needsCompareFamilies = true;\n\t          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n\t            needsCompareFamilies = true;\n\t          }\n\n\t          break;\n\t        }\n\n\t      case MemoComponent:\n\t      case SimpleMemoComponent:\n\t        {\n\t          if ($$typeofNextType === REACT_MEMO_TYPE) {\n\t            // TODO: if it was but can no longer be simple,\n\t            // we shouldn't set this.\n\t            needsCompareFamilies = true;\n\t          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n\t            needsCompareFamilies = true;\n\t          }\n\n\t          break;\n\t        }\n\n\t      default:\n\t        return false;\n\t    } // Check if both types have a family and it's the same one.\n\n\n\t    if (needsCompareFamilies) {\n\t      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n\t      // This means both of them need to be registered to preserve state.\n\t      // If we unwrapped and compared the inner types for wrappers instead,\n\t      // then we would risk falsely saying two separate memo(Foo)\n\t      // calls are equivalent because they wrap the same Foo function.\n\t      var prevFamily = resolveFamily(prevType);\n\n\t      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n\t        return true;\n\t      }\n\t    }\n\n\t    return false;\n\t  }\n\t}\n\tfunction markFailedErrorBoundaryForHotReloading(fiber) {\n\t  {\n\t    if (resolveFamily === null) {\n\t      // Hot reloading is disabled.\n\t      return;\n\t    }\n\n\t    if (typeof WeakSet !== 'function') {\n\t      return;\n\t    }\n\n\t    if (failedBoundaries === null) {\n\t      failedBoundaries = new WeakSet();\n\t    }\n\n\t    failedBoundaries.add(fiber);\n\t  }\n\t}\n\tvar scheduleRefresh = function (root, update) {\n\t  {\n\t    if (resolveFamily === null) {\n\t      // Hot reloading is disabled.\n\t      return;\n\t    }\n\n\t    var staleFamilies = update.staleFamilies,\n\t        updatedFamilies = update.updatedFamilies;\n\t    flushPassiveEffects();\n\t    flushSync(function () {\n\t      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n\t    });\n\t  }\n\t};\n\tvar scheduleRoot = function (root, element) {\n\t  {\n\t    if (root.context !== emptyContextObject) {\n\t      // Super edge case: root has a legacy _renderSubtree context\n\t      // but we don't know the parentComponent so we can't pass it.\n\t      // Just ignore. We'll delete this with _renderSubtree code path later.\n\t      return;\n\t    }\n\n\t    flushPassiveEffects();\n\t    flushSync(function () {\n\t      updateContainer(element, root, null, null);\n\t    });\n\t  }\n\t};\n\n\tfunction scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n\t  {\n\t    var alternate = fiber.alternate,\n\t        child = fiber.child,\n\t        sibling = fiber.sibling,\n\t        tag = fiber.tag,\n\t        type = fiber.type;\n\t    var candidateType = null;\n\n\t    switch (tag) {\n\t      case FunctionComponent:\n\t      case SimpleMemoComponent:\n\t      case ClassComponent:\n\t        candidateType = type;\n\t        break;\n\n\t      case ForwardRef:\n\t        candidateType = type.render;\n\t        break;\n\t    }\n\n\t    if (resolveFamily === null) {\n\t      throw new Error('Expected resolveFamily to be set during hot reload.');\n\t    }\n\n\t    var needsRender = false;\n\t    var needsRemount = false;\n\n\t    if (candidateType !== null) {\n\t      var family = resolveFamily(candidateType);\n\n\t      if (family !== undefined) {\n\t        if (staleFamilies.has(family)) {\n\t          needsRemount = true;\n\t        } else if (updatedFamilies.has(family)) {\n\t          if (tag === ClassComponent) {\n\t            needsRemount = true;\n\t          } else {\n\t            needsRender = true;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    if (failedBoundaries !== null) {\n\t      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n\t        needsRemount = true;\n\t      }\n\t    }\n\n\t    if (needsRemount) {\n\t      fiber._debugNeedsRemount = true;\n\t    }\n\n\t    if (needsRemount || needsRender) {\n\t      var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t      if (_root !== null) {\n\t        scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);\n\t      }\n\t    }\n\n\t    if (child !== null && !needsRemount) {\n\t      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n\t    }\n\n\t    if (sibling !== null) {\n\t      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n\t    }\n\t  }\n\t}\n\n\tvar findHostInstancesForRefresh = function (root, families) {\n\t  {\n\t    var hostInstances = new Set();\n\t    var types = new Set(families.map(function (family) {\n\t      return family.current;\n\t    }));\n\t    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n\t    return hostInstances;\n\t  }\n\t};\n\n\tfunction findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n\t  {\n\t    var child = fiber.child,\n\t        sibling = fiber.sibling,\n\t        tag = fiber.tag,\n\t        type = fiber.type;\n\t    var candidateType = null;\n\n\t    switch (tag) {\n\t      case FunctionComponent:\n\t      case SimpleMemoComponent:\n\t      case ClassComponent:\n\t        candidateType = type;\n\t        break;\n\n\t      case ForwardRef:\n\t        candidateType = type.render;\n\t        break;\n\t    }\n\n\t    var didMatch = false;\n\n\t    if (candidateType !== null) {\n\t      if (types.has(candidateType)) {\n\t        didMatch = true;\n\t      }\n\t    }\n\n\t    if (didMatch) {\n\t      // We have a match. This only drills down to the closest host components.\n\t      // There's no need to search deeper because for the purpose of giving\n\t      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n\t      findHostInstancesForFiberShallowly(fiber, hostInstances);\n\t    } else {\n\t      // If there's no match, maybe there will be one further down in the child tree.\n\t      if (child !== null) {\n\t        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n\t      }\n\t    }\n\n\t    if (sibling !== null) {\n\t      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n\t    }\n\t  }\n\t}\n\n\tfunction findHostInstancesForFiberShallowly(fiber, hostInstances) {\n\t  {\n\t    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n\n\t    if (foundHostInstances) {\n\t      return;\n\t    } // If we didn't find any host children, fallback to closest host parent.\n\n\n\t    var node = fiber;\n\n\t    while (true) {\n\t      switch (node.tag) {\n\t        case HostComponent:\n\t          hostInstances.add(node.stateNode);\n\t          return;\n\n\t        case HostPortal:\n\t          hostInstances.add(node.stateNode.containerInfo);\n\t          return;\n\n\t        case HostRoot:\n\t          hostInstances.add(node.stateNode.containerInfo);\n\t          return;\n\t      }\n\n\t      if (node.return === null) {\n\t        throw new Error('Expected to reach root first.');\n\t      }\n\n\t      node = node.return;\n\t    }\n\t  }\n\t}\n\n\tfunction findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n\t  {\n\t    var node = fiber;\n\t    var foundHostInstances = false;\n\n\t    while (true) {\n\t      if (node.tag === HostComponent) {\n\t        // We got a match.\n\t        foundHostInstances = true;\n\t        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n\t      } else if (node.child !== null) {\n\t        node.child.return = node;\n\t        node = node.child;\n\t        continue;\n\t      }\n\n\t      if (node === fiber) {\n\t        return foundHostInstances;\n\t      }\n\n\t      while (node.sibling === null) {\n\t        if (node.return === null || node.return === fiber) {\n\t          return foundHostInstances;\n\t        }\n\n\t        node = node.return;\n\t      }\n\n\t      node.sibling.return = node.return;\n\t      node = node.sibling;\n\t    }\n\t  }\n\n\t  return false;\n\t}\n\n\tvar hasBadMapPolyfill;\n\n\t{\n\t  hasBadMapPolyfill = false;\n\n\t  try {\n\t    var nonExtensibleObject = Object.preventExtensions({});\n\t    /* eslint-disable no-new */\n\n\t    new Map([[nonExtensibleObject, null]]);\n\t    new Set([nonExtensibleObject]);\n\t    /* eslint-enable no-new */\n\t  } catch (e) {\n\t    // TODO: Consider warning about bad polyfills\n\t    hasBadMapPolyfill = true;\n\t  }\n\t}\n\n\tfunction FiberNode(tag, pendingProps, key, mode) {\n\t  // Instance\n\t  this.tag = tag;\n\t  this.key = key;\n\t  this.elementType = null;\n\t  this.type = null;\n\t  this.stateNode = null; // Fiber\n\n\t  this.return = null;\n\t  this.child = null;\n\t  this.sibling = null;\n\t  this.index = 0;\n\t  this.ref = null;\n\t  this.pendingProps = pendingProps;\n\t  this.memoizedProps = null;\n\t  this.updateQueue = null;\n\t  this.memoizedState = null;\n\t  this.dependencies = null;\n\t  this.mode = mode; // Effects\n\n\t  this.flags = NoFlags;\n\t  this.subtreeFlags = NoFlags;\n\t  this.deletions = null;\n\t  this.lanes = NoLanes;\n\t  this.childLanes = NoLanes;\n\t  this.alternate = null;\n\n\t  {\n\t    // Note: The following is done to avoid a v8 performance cliff.\n\t    //\n\t    // Initializing the fields below to smis and later updating them with\n\t    // double values will cause Fibers to end up having separate shapes.\n\t    // This behavior/bug has something to do with Object.preventExtension().\n\t    // Fortunately this only impacts DEV builds.\n\t    // Unfortunately it makes React unusably slow for some applications.\n\t    // To work around this, initialize the fields below with doubles.\n\t    //\n\t    // Learn more about this here:\n\t    // https://github.com/facebook/react/issues/14365\n\t    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n\t    this.actualDuration = Number.NaN;\n\t    this.actualStartTime = Number.NaN;\n\t    this.selfBaseDuration = Number.NaN;\n\t    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n\t    // This won't trigger the performance cliff mentioned above,\n\t    // and it simplifies other profiler code (including DevTools).\n\n\t    this.actualDuration = 0;\n\t    this.actualStartTime = -1;\n\t    this.selfBaseDuration = 0;\n\t    this.treeBaseDuration = 0;\n\t  }\n\n\t  {\n\t    // This isn't directly used but is handy for debugging internals:\n\t    this._debugSource = null;\n\t    this._debugOwner = null;\n\t    this._debugNeedsRemount = false;\n\t    this._debugHookTypes = null;\n\n\t    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n\t      Object.preventExtensions(this);\n\t    }\n\t  }\n\t} // This is a constructor function, rather than a POJO constructor, still\n\t// please ensure we do the following:\n\t// 1) Nobody should add any instance methods on this. Instance methods can be\n\t//    more difficult to predict when they get optimized and they are almost\n\t//    never inlined properly in static compilers.\n\t// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n\t//    always know when it is a fiber.\n\t// 3) We might want to experiment with using numeric keys since they are easier\n\t//    to optimize in a non-JIT environment.\n\t// 4) We can easily go from a constructor to a createFiber object literal if that\n\t//    is faster.\n\t// 5) It should be easy to port this to a C struct and keep a C implementation\n\t//    compatible.\n\n\n\tvar createFiber = function (tag, pendingProps, key, mode) {\n\t  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n\t  return new FiberNode(tag, pendingProps, key, mode);\n\t};\n\n\tfunction shouldConstruct$1(Component) {\n\t  var prototype = Component.prototype;\n\t  return !!(prototype && prototype.isReactComponent);\n\t}\n\n\tfunction isSimpleFunctionComponent(type) {\n\t  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;\n\t}\n\tfunction resolveLazyComponentTag(Component) {\n\t  if (typeof Component === 'function') {\n\t    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n\t  } else if (Component !== undefined && Component !== null) {\n\t    var $$typeof = Component.$$typeof;\n\n\t    if ($$typeof === REACT_FORWARD_REF_TYPE) {\n\t      return ForwardRef;\n\t    }\n\n\t    if ($$typeof === REACT_MEMO_TYPE) {\n\t      return MemoComponent;\n\t    }\n\t  }\n\n\t  return IndeterminateComponent;\n\t} // This is used to create an alternate fiber to do work on.\n\n\tfunction createWorkInProgress(current, pendingProps) {\n\t  var workInProgress = current.alternate;\n\n\t  if (workInProgress === null) {\n\t    // We use a double buffering pooling technique because we know that we'll\n\t    // only ever need at most two versions of a tree. We pool the \"other\" unused\n\t    // node that we're free to reuse. This is lazily created to avoid allocating\n\t    // extra objects for things that are never updated. It also allow us to\n\t    // reclaim the extra memory if needed.\n\t    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n\t    workInProgress.elementType = current.elementType;\n\t    workInProgress.type = current.type;\n\t    workInProgress.stateNode = current.stateNode;\n\n\t    {\n\t      // DEV-only fields\n\t      workInProgress._debugSource = current._debugSource;\n\t      workInProgress._debugOwner = current._debugOwner;\n\t      workInProgress._debugHookTypes = current._debugHookTypes;\n\t    }\n\n\t    workInProgress.alternate = current;\n\t    current.alternate = workInProgress;\n\t  } else {\n\t    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n\n\t    workInProgress.type = current.type; // We already have an alternate.\n\t    // Reset the effect tag.\n\n\t    workInProgress.flags = NoFlags; // The effects are no longer valid.\n\n\t    workInProgress.subtreeFlags = NoFlags;\n\t    workInProgress.deletions = null;\n\n\t    {\n\t      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n\t      // This prevents time from endlessly accumulating in new commits.\n\t      // This has the downside of resetting values for different priority renders,\n\t      // But works for yielding (the common case) and should support resuming.\n\t      workInProgress.actualDuration = 0;\n\t      workInProgress.actualStartTime = -1;\n\t    }\n\t  } // Reset all effects except static ones.\n\t  // Static effects are not specific to a render.\n\n\n\t  workInProgress.flags = current.flags & StaticMask;\n\t  workInProgress.childLanes = current.childLanes;\n\t  workInProgress.lanes = current.lanes;\n\t  workInProgress.child = current.child;\n\t  workInProgress.memoizedProps = current.memoizedProps;\n\t  workInProgress.memoizedState = current.memoizedState;\n\t  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n\t  // it cannot be shared with the current fiber.\n\n\t  var currentDependencies = current.dependencies;\n\t  workInProgress.dependencies = currentDependencies === null ? null : {\n\t    lanes: currentDependencies.lanes,\n\t    firstContext: currentDependencies.firstContext\n\t  }; // These will be overridden during the parent's reconciliation\n\n\t  workInProgress.sibling = current.sibling;\n\t  workInProgress.index = current.index;\n\t  workInProgress.ref = current.ref;\n\n\t  {\n\t    workInProgress.selfBaseDuration = current.selfBaseDuration;\n\t    workInProgress.treeBaseDuration = current.treeBaseDuration;\n\t  }\n\n\t  {\n\t    workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n\n\t    switch (workInProgress.tag) {\n\t      case IndeterminateComponent:\n\t      case FunctionComponent:\n\t      case SimpleMemoComponent:\n\t        workInProgress.type = resolveFunctionForHotReloading(current.type);\n\t        break;\n\n\t      case ClassComponent:\n\t        workInProgress.type = resolveClassForHotReloading(current.type);\n\t        break;\n\n\t      case ForwardRef:\n\t        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n\t        break;\n\t    }\n\t  }\n\n\t  return workInProgress;\n\t} // Used to reuse a Fiber for a second pass.\n\n\tfunction resetWorkInProgress(workInProgress, renderLanes) {\n\t  // This resets the Fiber to what createFiber or createWorkInProgress would\n\t  // have set the values to before during the first pass. Ideally this wouldn't\n\t  // be necessary but unfortunately many code paths reads from the workInProgress\n\t  // when they should be reading from current and writing to workInProgress.\n\t  // We assume pendingProps, index, key, ref, return are still untouched to\n\t  // avoid doing another reconciliation.\n\t  // Reset the effect flags but keep any Placement tags, since that's something\n\t  // that child fiber is setting, not the reconciliation.\n\t  workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n\n\t  var current = workInProgress.alternate;\n\n\t  if (current === null) {\n\t    // Reset to createFiber's initial values.\n\t    workInProgress.childLanes = NoLanes;\n\t    workInProgress.lanes = renderLanes;\n\t    workInProgress.child = null;\n\t    workInProgress.subtreeFlags = NoFlags;\n\t    workInProgress.memoizedProps = null;\n\t    workInProgress.memoizedState = null;\n\t    workInProgress.updateQueue = null;\n\t    workInProgress.dependencies = null;\n\t    workInProgress.stateNode = null;\n\n\t    {\n\t      // Note: We don't reset the actualTime counts. It's useful to accumulate\n\t      // actual time across multiple render passes.\n\t      workInProgress.selfBaseDuration = 0;\n\t      workInProgress.treeBaseDuration = 0;\n\t    }\n\t  } else {\n\t    // Reset to the cloned values that createWorkInProgress would've.\n\t    workInProgress.childLanes = current.childLanes;\n\t    workInProgress.lanes = current.lanes;\n\t    workInProgress.child = current.child;\n\t    workInProgress.subtreeFlags = NoFlags;\n\t    workInProgress.deletions = null;\n\t    workInProgress.memoizedProps = current.memoizedProps;\n\t    workInProgress.memoizedState = current.memoizedState;\n\t    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n\n\t    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n\t    // it cannot be shared with the current fiber.\n\n\t    var currentDependencies = current.dependencies;\n\t    workInProgress.dependencies = currentDependencies === null ? null : {\n\t      lanes: currentDependencies.lanes,\n\t      firstContext: currentDependencies.firstContext\n\t    };\n\n\t    {\n\t      // Note: We don't reset the actualTime counts. It's useful to accumulate\n\t      // actual time across multiple render passes.\n\t      workInProgress.selfBaseDuration = current.selfBaseDuration;\n\t      workInProgress.treeBaseDuration = current.treeBaseDuration;\n\t    }\n\t  }\n\n\t  return workInProgress;\n\t}\n\tfunction createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n\t  var mode;\n\n\t  if (tag === ConcurrentRoot) {\n\t    mode = ConcurrentMode;\n\n\t    if (isStrictMode === true) {\n\t      mode |= StrictLegacyMode;\n\n\t      {\n\t        mode |= StrictEffectsMode;\n\t      }\n\t    }\n\t  } else {\n\t    mode = NoMode;\n\t  }\n\n\t  if ( isDevToolsPresent) {\n\t    // Always collect profile timings when DevTools are present.\n\t    // This enables DevTools to start capturing timing at any point\n\t    // Without some nodes in the tree having empty base times.\n\t    mode |= ProfileMode;\n\t  }\n\n\t  return createFiber(HostRoot, null, null, mode);\n\t}\n\tfunction createFiberFromTypeAndProps(type, // React$ElementType\n\tkey, pendingProps, owner, mode, lanes) {\n\t  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n\n\t  var resolvedType = type;\n\n\t  if (typeof type === 'function') {\n\t    if (shouldConstruct$1(type)) {\n\t      fiberTag = ClassComponent;\n\n\t      {\n\t        resolvedType = resolveClassForHotReloading(resolvedType);\n\t      }\n\t    } else {\n\t      {\n\t        resolvedType = resolveFunctionForHotReloading(resolvedType);\n\t      }\n\t    }\n\t  } else if (typeof type === 'string') {\n\t    fiberTag = HostComponent;\n\t  } else {\n\t    getTag: switch (type) {\n\t      case REACT_FRAGMENT_TYPE:\n\t        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n\n\t      case REACT_STRICT_MODE_TYPE:\n\t        fiberTag = Mode;\n\t        mode |= StrictLegacyMode;\n\n\t        if ( (mode & ConcurrentMode) !== NoMode) {\n\t          // Strict effects should never run on legacy roots\n\t          mode |= StrictEffectsMode;\n\t        }\n\n\t        break;\n\n\t      case REACT_PROFILER_TYPE:\n\t        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n\n\t      case REACT_SUSPENSE_TYPE:\n\t        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n\n\t      case REACT_SUSPENSE_LIST_TYPE:\n\t        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n\n\t      case REACT_OFFSCREEN_TYPE:\n\t        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n\n\t      case REACT_LEGACY_HIDDEN_TYPE:\n\n\t      // eslint-disable-next-line no-fallthrough\n\n\t      case REACT_SCOPE_TYPE:\n\n\t      // eslint-disable-next-line no-fallthrough\n\n\t      case REACT_CACHE_TYPE:\n\n\t      // eslint-disable-next-line no-fallthrough\n\n\t      case REACT_TRACING_MARKER_TYPE:\n\n\t      // eslint-disable-next-line no-fallthrough\n\n\t      case REACT_DEBUG_TRACING_MODE_TYPE:\n\n\t      // eslint-disable-next-line no-fallthrough\n\n\t      default:\n\t        {\n\t          if (typeof type === 'object' && type !== null) {\n\t            switch (type.$$typeof) {\n\t              case REACT_PROVIDER_TYPE:\n\t                fiberTag = ContextProvider;\n\t                break getTag;\n\n\t              case REACT_CONTEXT_TYPE:\n\t                // This is a consumer\n\t                fiberTag = ContextConsumer;\n\t                break getTag;\n\n\t              case REACT_FORWARD_REF_TYPE:\n\t                fiberTag = ForwardRef;\n\n\t                {\n\t                  resolvedType = resolveForwardRefForHotReloading(resolvedType);\n\t                }\n\n\t                break getTag;\n\n\t              case REACT_MEMO_TYPE:\n\t                fiberTag = MemoComponent;\n\t                break getTag;\n\n\t              case REACT_LAZY_TYPE:\n\t                fiberTag = LazyComponent;\n\t                resolvedType = null;\n\t                break getTag;\n\t            }\n\t          }\n\n\t          var info = '';\n\n\t          {\n\t            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n\t              info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n\t            }\n\n\t            var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n\n\t            if (ownerName) {\n\t              info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n\t            }\n\t          }\n\n\t          throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n\t        }\n\t    }\n\t  }\n\n\t  var fiber = createFiber(fiberTag, pendingProps, key, mode);\n\t  fiber.elementType = type;\n\t  fiber.type = resolvedType;\n\t  fiber.lanes = lanes;\n\n\t  {\n\t    fiber._debugOwner = owner;\n\t  }\n\n\t  return fiber;\n\t}\n\tfunction createFiberFromElement(element, mode, lanes) {\n\t  var owner = null;\n\n\t  {\n\t    owner = element._owner;\n\t  }\n\n\t  var type = element.type;\n\t  var key = element.key;\n\t  var pendingProps = element.props;\n\t  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n\n\t  {\n\t    fiber._debugSource = element._source;\n\t    fiber._debugOwner = element._owner;\n\t  }\n\n\t  return fiber;\n\t}\n\tfunction createFiberFromFragment(elements, mode, lanes, key) {\n\t  var fiber = createFiber(Fragment, elements, key, mode);\n\t  fiber.lanes = lanes;\n\t  return fiber;\n\t}\n\n\tfunction createFiberFromProfiler(pendingProps, mode, lanes, key) {\n\t  {\n\t    if (typeof pendingProps.id !== 'string') {\n\t      error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n\t    }\n\t  }\n\n\t  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n\t  fiber.elementType = REACT_PROFILER_TYPE;\n\t  fiber.lanes = lanes;\n\n\t  {\n\t    fiber.stateNode = {\n\t      effectDuration: 0,\n\t      passiveEffectDuration: 0\n\t    };\n\t  }\n\n\t  return fiber;\n\t}\n\n\tfunction createFiberFromSuspense(pendingProps, mode, lanes, key) {\n\t  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n\t  fiber.elementType = REACT_SUSPENSE_TYPE;\n\t  fiber.lanes = lanes;\n\t  return fiber;\n\t}\n\tfunction createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n\t  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n\t  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n\t  fiber.lanes = lanes;\n\t  return fiber;\n\t}\n\tfunction createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n\t  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n\t  fiber.elementType = REACT_OFFSCREEN_TYPE;\n\t  fiber.lanes = lanes;\n\t  var primaryChildInstance = {\n\t    isHidden: false\n\t  };\n\t  fiber.stateNode = primaryChildInstance;\n\t  return fiber;\n\t}\n\tfunction createFiberFromText(content, mode, lanes) {\n\t  var fiber = createFiber(HostText, content, null, mode);\n\t  fiber.lanes = lanes;\n\t  return fiber;\n\t}\n\tfunction createFiberFromHostInstanceForDeletion() {\n\t  var fiber = createFiber(HostComponent, null, null, NoMode);\n\t  fiber.elementType = 'DELETED';\n\t  return fiber;\n\t}\n\tfunction createFiberFromDehydratedFragment(dehydratedNode) {\n\t  var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n\t  fiber.stateNode = dehydratedNode;\n\t  return fiber;\n\t}\n\tfunction createFiberFromPortal(portal, mode, lanes) {\n\t  var pendingProps = portal.children !== null ? portal.children : [];\n\t  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n\t  fiber.lanes = lanes;\n\t  fiber.stateNode = {\n\t    containerInfo: portal.containerInfo,\n\t    pendingChildren: null,\n\t    // Used by persistent updates\n\t    implementation: portal.implementation\n\t  };\n\t  return fiber;\n\t} // Used for stashing WIP properties to replay failed work in DEV.\n\n\tfunction assignFiberPropertiesInDEV(target, source) {\n\t  if (target === null) {\n\t    // This Fiber's initial properties will always be overwritten.\n\t    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n\t    target = createFiber(IndeterminateComponent, null, null, NoMode);\n\t  } // This is intentionally written as a list of all properties.\n\t  // We tried to use Object.assign() instead but this is called in\n\t  // the hottest path, and Object.assign() was too slow:\n\t  // https://github.com/facebook/react/issues/12502\n\t  // This code is DEV-only so size is not a concern.\n\n\n\t  target.tag = source.tag;\n\t  target.key = source.key;\n\t  target.elementType = source.elementType;\n\t  target.type = source.type;\n\t  target.stateNode = source.stateNode;\n\t  target.return = source.return;\n\t  target.child = source.child;\n\t  target.sibling = source.sibling;\n\t  target.index = source.index;\n\t  target.ref = source.ref;\n\t  target.pendingProps = source.pendingProps;\n\t  target.memoizedProps = source.memoizedProps;\n\t  target.updateQueue = source.updateQueue;\n\t  target.memoizedState = source.memoizedState;\n\t  target.dependencies = source.dependencies;\n\t  target.mode = source.mode;\n\t  target.flags = source.flags;\n\t  target.subtreeFlags = source.subtreeFlags;\n\t  target.deletions = source.deletions;\n\t  target.lanes = source.lanes;\n\t  target.childLanes = source.childLanes;\n\t  target.alternate = source.alternate;\n\n\t  {\n\t    target.actualDuration = source.actualDuration;\n\t    target.actualStartTime = source.actualStartTime;\n\t    target.selfBaseDuration = source.selfBaseDuration;\n\t    target.treeBaseDuration = source.treeBaseDuration;\n\t  }\n\n\t  target._debugSource = source._debugSource;\n\t  target._debugOwner = source._debugOwner;\n\t  target._debugNeedsRemount = source._debugNeedsRemount;\n\t  target._debugHookTypes = source._debugHookTypes;\n\t  return target;\n\t}\n\n\tfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n\t  this.tag = tag;\n\t  this.containerInfo = containerInfo;\n\t  this.pendingChildren = null;\n\t  this.current = null;\n\t  this.pingCache = null;\n\t  this.finishedWork = null;\n\t  this.timeoutHandle = noTimeout;\n\t  this.context = null;\n\t  this.pendingContext = null;\n\t  this.callbackNode = null;\n\t  this.callbackPriority = NoLane;\n\t  this.eventTimes = createLaneMap(NoLanes);\n\t  this.expirationTimes = createLaneMap(NoTimestamp);\n\t  this.pendingLanes = NoLanes;\n\t  this.suspendedLanes = NoLanes;\n\t  this.pingedLanes = NoLanes;\n\t  this.expiredLanes = NoLanes;\n\t  this.mutableReadLanes = NoLanes;\n\t  this.finishedLanes = NoLanes;\n\t  this.entangledLanes = NoLanes;\n\t  this.entanglements = createLaneMap(NoLanes);\n\t  this.identifierPrefix = identifierPrefix;\n\t  this.onRecoverableError = onRecoverableError;\n\n\t  if (supportsHydration) {\n\t    this.mutableSourceEagerHydrationData = null;\n\t  }\n\n\t  {\n\t    this.effectDuration = 0;\n\t    this.passiveEffectDuration = 0;\n\t  }\n\n\t  {\n\t    this.memoizedUpdaters = new Set();\n\t    var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n\t    for (var _i = 0; _i < TotalLanes; _i++) {\n\t      pendingUpdatersLaneMap.push(new Set());\n\t    }\n\t  }\n\n\t  {\n\t    switch (tag) {\n\t      case ConcurrentRoot:\n\t        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n\t        break;\n\n\t      case LegacyRoot:\n\t        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n\t        break;\n\t    }\n\t  }\n\t}\n\n\tfunction createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n\t// host config, but because they are passed in at runtime, we have to thread\n\t// them through the root constructor. Perhaps we should put them all into a\n\t// single type, like a DynamicHostConfig that is defined by the renderer.\n\tidentifierPrefix, onRecoverableError, transitionCallbacks) {\n\t  var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n\t  // stateNode is any.\n\n\n\t  var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n\t  root.current = uninitializedFiber;\n\t  uninitializedFiber.stateNode = root;\n\n\t  {\n\t    var _initialState = {\n\t      element: initialChildren,\n\t      isDehydrated: hydrate,\n\t      cache: null,\n\t      // not enabled yet\n\t      transitions: null,\n\t      pendingSuspenseBoundaries: null\n\t    };\n\t    uninitializedFiber.memoizedState = _initialState;\n\t  }\n\n\t  initializeUpdateQueue(uninitializedFiber);\n\t  return root;\n\t}\n\n\tvar ReactVersion = '18.2.0';\n\n\tfunction createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\n\timplementation) {\n\t  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\t  {\n\t    checkKeyStringCoercion(key);\n\t  }\n\n\t  return {\n\t    // This tag allow us to uniquely identify this as a React Portal\n\t    $$typeof: REACT_PORTAL_TYPE,\n\t    key: key == null ? null : '' + key,\n\t    children: children,\n\t    containerInfo: containerInfo,\n\t    implementation: implementation\n\t  };\n\t}\n\n\tvar didWarnAboutNestedUpdates;\n\tvar didWarnAboutFindNodeInStrictMode;\n\n\t{\n\t  didWarnAboutNestedUpdates = false;\n\t  didWarnAboutFindNodeInStrictMode = {};\n\t}\n\n\tfunction getContextForSubtree(parentComponent) {\n\t  if (!parentComponent) {\n\t    return emptyContextObject;\n\t  }\n\n\t  var fiber = get(parentComponent);\n\t  var parentContext = findCurrentUnmaskedContext(fiber);\n\n\t  if (fiber.tag === ClassComponent) {\n\t    var Component = fiber.type;\n\n\t    if (isContextProvider(Component)) {\n\t      return processChildContext(fiber, Component, parentContext);\n\t    }\n\t  }\n\n\t  return parentContext;\n\t}\n\n\tfunction findHostInstance(component) {\n\t  var fiber = get(component);\n\n\t  if (fiber === undefined) {\n\t    if (typeof component.render === 'function') {\n\t      throw new Error('Unable to find node on an unmounted component.');\n\t    } else {\n\t      var keys = Object.keys(component).join(',');\n\t      throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n\t    }\n\t  }\n\n\t  var hostFiber = findCurrentHostFiber(fiber);\n\n\t  if (hostFiber === null) {\n\t    return null;\n\t  }\n\n\t  return hostFiber.stateNode;\n\t}\n\n\tfunction findHostInstanceWithWarning(component, methodName) {\n\t  {\n\t    var fiber = get(component);\n\n\t    if (fiber === undefined) {\n\t      if (typeof component.render === 'function') {\n\t        throw new Error('Unable to find node on an unmounted component.');\n\t      } else {\n\t        var keys = Object.keys(component).join(',');\n\t        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n\t      }\n\t    }\n\n\t    var hostFiber = findCurrentHostFiber(fiber);\n\n\t    if (hostFiber === null) {\n\t      return null;\n\t    }\n\n\t    if (hostFiber.mode & StrictLegacyMode) {\n\t      var componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n\t      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n\t        didWarnAboutFindNodeInStrictMode[componentName] = true;\n\t        var previousFiber = current;\n\n\t        try {\n\t          setCurrentFiber(hostFiber);\n\n\t          if (fiber.mode & StrictLegacyMode) {\n\t            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n\t          } else {\n\t            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n\t          }\n\t        } finally {\n\t          // Ideally this should reset to previous but this shouldn't be called in\n\t          // render and there's another warning for that anyway.\n\t          if (previousFiber) {\n\t            setCurrentFiber(previousFiber);\n\t          } else {\n\t            resetCurrentFiber();\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    return hostFiber.stateNode;\n\t  }\n\t}\n\n\tfunction createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n\t  var hydrate = false;\n\t  var initialChildren = null;\n\t  return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n\t}\n\tfunction createHydrationContainer(initialChildren, // TODO: Remove `callback` when we delete legacy mode.\n\tcallback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n\t  var hydrate = true;\n\t  var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n\n\t  root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n\t  // a regular update because the initial render must match was was rendered\n\t  // on the server.\n\t  // NOTE: This update intentionally doesn't have a payload. We're only using\n\t  // the update to schedule work on the root fiber (and, for legacy roots, to\n\t  // enqueue the callback if one is provided).\n\n\t  var current = root.current;\n\t  var eventTime = requestEventTime();\n\t  var lane = requestUpdateLane(current);\n\t  var update = createUpdate(eventTime, lane);\n\t  update.callback = callback !== undefined && callback !== null ? callback : null;\n\t  enqueueUpdate(current, update, lane);\n\t  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n\t  return root;\n\t}\n\tfunction updateContainer(element, container, parentComponent, callback) {\n\t  {\n\t    onScheduleRoot(container, element);\n\t  }\n\n\t  var current$1 = container.current;\n\t  var eventTime = requestEventTime();\n\t  var lane = requestUpdateLane(current$1);\n\n\t  {\n\t    markRenderScheduled(lane);\n\t  }\n\n\t  var context = getContextForSubtree(parentComponent);\n\n\t  if (container.context === null) {\n\t    container.context = context;\n\t  } else {\n\t    container.pendingContext = context;\n\t  }\n\n\t  {\n\t    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n\t      didWarnAboutNestedUpdates = true;\n\n\t      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n\t    }\n\t  }\n\n\t  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n\t  // being called \"element\".\n\n\t  update.payload = {\n\t    element: element\n\t  };\n\t  callback = callback === undefined ? null : callback;\n\n\t  if (callback !== null) {\n\t    {\n\t      if (typeof callback !== 'function') {\n\t        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n\t      }\n\t    }\n\n\t    update.callback = callback;\n\t  }\n\n\t  var root = enqueueUpdate(current$1, update, lane);\n\n\t  if (root !== null) {\n\t    scheduleUpdateOnFiber(root, current$1, lane, eventTime);\n\t    entangleTransitions(root, current$1, lane);\n\t  }\n\n\t  return lane;\n\t}\n\tfunction getPublicRootInstance(container) {\n\t  var containerFiber = container.current;\n\n\t  if (!containerFiber.child) {\n\t    return null;\n\t  }\n\n\t  switch (containerFiber.child.tag) {\n\t    case HostComponent:\n\t      return getPublicInstance(containerFiber.child.stateNode);\n\n\t    default:\n\t      return containerFiber.child.stateNode;\n\t  }\n\t}\n\tfunction attemptSynchronousHydration(fiber) {\n\t  switch (fiber.tag) {\n\t    case HostRoot:\n\t      {\n\t        var root = fiber.stateNode;\n\n\t        if (isRootDehydrated(root)) {\n\t          // Flush the first scheduled \"update\".\n\t          var lanes = getHighestPriorityPendingLanes(root);\n\t          flushRoot(root, lanes);\n\t        }\n\n\t        break;\n\t      }\n\n\t    case SuspenseComponent:\n\t      {\n\t        flushSync(function () {\n\t          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t          if (root !== null) {\n\t            var eventTime = requestEventTime();\n\t            scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);\n\t          }\n\t        }); // If we're still blocked after this, we need to increase\n\t        // the priority of any promises resolving within this\n\t        // boundary so that they next attempt also has higher pri.\n\n\t        var retryLane = SyncLane;\n\t        markRetryLaneIfNotHydrated(fiber, retryLane);\n\t        break;\n\t      }\n\t  }\n\t}\n\n\tfunction markRetryLaneImpl(fiber, retryLane) {\n\t  var suspenseState = fiber.memoizedState;\n\n\t  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n\t    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n\t  }\n\t} // Increases the priority of thenables when they resolve within this boundary.\n\n\n\tfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n\t  markRetryLaneImpl(fiber, retryLane);\n\t  var alternate = fiber.alternate;\n\n\t  if (alternate) {\n\t    markRetryLaneImpl(alternate, retryLane);\n\t  }\n\t}\n\n\tfunction attemptDiscreteHydration(fiber) {\n\t  if (fiber.tag !== SuspenseComponent) {\n\t    // We ignore HostRoots here because we can't increase\n\t    // their priority and they should not suspend on I/O,\n\t    // since you have to wrap anything that might suspend in\n\t    // Suspense.\n\t    return;\n\t  }\n\n\t  var lane = SyncLane;\n\t  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n\t  if (root !== null) {\n\t    var eventTime = requestEventTime();\n\t    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t  }\n\n\t  markRetryLaneIfNotHydrated(fiber, lane);\n\t}\n\tfunction attemptContinuousHydration(fiber) {\n\t  if (fiber.tag !== SuspenseComponent) {\n\t    // We ignore HostRoots here because we can't increase\n\t    // their priority and they should not suspend on I/O,\n\t    // since you have to wrap anything that might suspend in\n\t    // Suspense.\n\t    return;\n\t  }\n\n\t  var lane = SelectiveHydrationLane;\n\t  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n\t  if (root !== null) {\n\t    var eventTime = requestEventTime();\n\t    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t  }\n\n\t  markRetryLaneIfNotHydrated(fiber, lane);\n\t}\n\tfunction attemptHydrationAtCurrentPriority(fiber) {\n\t  if (fiber.tag !== SuspenseComponent) {\n\t    // We ignore HostRoots here because we can't increase\n\t    // their priority other than synchronously flush it.\n\t    return;\n\t  }\n\n\t  var lane = requestUpdateLane(fiber);\n\t  var root = enqueueConcurrentRenderForLane(fiber, lane);\n\n\t  if (root !== null) {\n\t    var eventTime = requestEventTime();\n\t    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n\t  }\n\n\t  markRetryLaneIfNotHydrated(fiber, lane);\n\t}\n\tfunction findHostInstanceWithNoPortals(fiber) {\n\t  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n\t  if (hostFiber === null) {\n\t    return null;\n\t  }\n\n\t  return hostFiber.stateNode;\n\t}\n\n\tvar shouldErrorImpl = function (fiber) {\n\t  return null;\n\t};\n\n\tfunction shouldError(fiber) {\n\t  return shouldErrorImpl(fiber);\n\t}\n\n\tvar shouldSuspendImpl = function (fiber) {\n\t  return false;\n\t};\n\n\tfunction shouldSuspend(fiber) {\n\t  return shouldSuspendImpl(fiber);\n\t}\n\tvar overrideHookState = null;\n\tvar overrideHookStateDeletePath = null;\n\tvar overrideHookStateRenamePath = null;\n\tvar overrideProps = null;\n\tvar overridePropsDeletePath = null;\n\tvar overridePropsRenamePath = null;\n\tvar scheduleUpdate = null;\n\tvar setErrorHandler = null;\n\tvar setSuspenseHandler = null;\n\n\t{\n\t  var copyWithDeleteImpl = function (obj, path, index) {\n\t    var key = path[index];\n\t    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n\t    if (index + 1 === path.length) {\n\t      if (isArray(updated)) {\n\t        updated.splice(key, 1);\n\t      } else {\n\t        delete updated[key];\n\t      }\n\n\t      return updated;\n\t    } // $FlowFixMe number or string is fine here\n\n\n\t    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n\t    return updated;\n\t  };\n\n\t  var copyWithDelete = function (obj, path) {\n\t    return copyWithDeleteImpl(obj, path, 0);\n\t  };\n\n\t  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {\n\t    var oldKey = oldPath[index];\n\t    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n\t    if (index + 1 === oldPath.length) {\n\t      var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n\t      updated[newKey] = updated[oldKey];\n\n\t      if (isArray(updated)) {\n\t        updated.splice(oldKey, 1);\n\t      } else {\n\t        delete updated[oldKey];\n\t      }\n\t    } else {\n\t      // $FlowFixMe number or string is fine here\n\t      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n\t      obj[oldKey], oldPath, newPath, index + 1);\n\t    }\n\n\t    return updated;\n\t  };\n\n\t  var copyWithRename = function (obj, oldPath, newPath) {\n\t    if (oldPath.length !== newPath.length) {\n\t      warn('copyWithRename() expects paths of the same length');\n\n\t      return;\n\t    } else {\n\t      for (var i = 0; i < newPath.length - 1; i++) {\n\t        if (oldPath[i] !== newPath[i]) {\n\t          warn('copyWithRename() expects paths to be the same except for the deepest key');\n\n\t          return;\n\t        }\n\t      }\n\t    }\n\n\t    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n\t  };\n\n\t  var copyWithSetImpl = function (obj, path, index, value) {\n\t    if (index >= path.length) {\n\t      return value;\n\t    }\n\n\t    var key = path[index];\n\t    var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n\n\t    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n\t    return updated;\n\t  };\n\n\t  var copyWithSet = function (obj, path, value) {\n\t    return copyWithSetImpl(obj, path, 0, value);\n\t  };\n\n\t  var findHook = function (fiber, id) {\n\t    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n\t    // This may change in the future with e.g. nested hooks.\n\t    var currentHook = fiber.memoizedState;\n\n\t    while (currentHook !== null && id > 0) {\n\t      currentHook = currentHook.next;\n\t      id--;\n\t    }\n\n\t    return currentHook;\n\t  }; // Support DevTools editable values for useState and useReducer.\n\n\n\t  overrideHookState = function (fiber, id, path, value) {\n\t    var hook = findHook(fiber, id);\n\n\t    if (hook !== null) {\n\t      var newState = copyWithSet(hook.memoizedState, path, value);\n\t      hook.memoizedState = newState;\n\t      hook.baseState = newState; // We aren't actually adding an update to the queue,\n\t      // because there is no update we can add for useReducer hooks that won't trigger an error.\n\t      // (There's no appropriate action type for DevTools overrides.)\n\t      // As a result though, React will see the scheduled update as a noop and bailout.\n\t      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n\t      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n\t      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t      if (root !== null) {\n\t        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t      }\n\t    }\n\t  };\n\n\t  overrideHookStateDeletePath = function (fiber, id, path) {\n\t    var hook = findHook(fiber, id);\n\n\t    if (hook !== null) {\n\t      var newState = copyWithDelete(hook.memoizedState, path);\n\t      hook.memoizedState = newState;\n\t      hook.baseState = newState; // We aren't actually adding an update to the queue,\n\t      // because there is no update we can add for useReducer hooks that won't trigger an error.\n\t      // (There's no appropriate action type for DevTools overrides.)\n\t      // As a result though, React will see the scheduled update as a noop and bailout.\n\t      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n\t      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n\t      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t      if (root !== null) {\n\t        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t      }\n\t    }\n\t  };\n\n\t  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {\n\t    var hook = findHook(fiber, id);\n\n\t    if (hook !== null) {\n\t      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n\t      hook.memoizedState = newState;\n\t      hook.baseState = newState; // We aren't actually adding an update to the queue,\n\t      // because there is no update we can add for useReducer hooks that won't trigger an error.\n\t      // (There's no appropriate action type for DevTools overrides.)\n\t      // As a result though, React will see the scheduled update as a noop and bailout.\n\t      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n\t      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n\t      var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t      if (root !== null) {\n\t        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t      }\n\t    }\n\t  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n\t  overrideProps = function (fiber, path, value) {\n\t    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n\t    if (fiber.alternate) {\n\t      fiber.alternate.pendingProps = fiber.pendingProps;\n\t    }\n\n\t    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t    }\n\t  };\n\n\t  overridePropsDeletePath = function (fiber, path) {\n\t    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n\t    if (fiber.alternate) {\n\t      fiber.alternate.pendingProps = fiber.pendingProps;\n\t    }\n\n\t    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t    }\n\t  };\n\n\t  overridePropsRenamePath = function (fiber, oldPath, newPath) {\n\t    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n\t    if (fiber.alternate) {\n\t      fiber.alternate.pendingProps = fiber.pendingProps;\n\t    }\n\n\t    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t    }\n\t  };\n\n\t  scheduleUpdate = function (fiber) {\n\t    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n\t    if (root !== null) {\n\t      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n\t    }\n\t  };\n\n\t  setErrorHandler = function (newShouldErrorImpl) {\n\t    shouldErrorImpl = newShouldErrorImpl;\n\t  };\n\n\t  setSuspenseHandler = function (newShouldSuspendImpl) {\n\t    shouldSuspendImpl = newShouldSuspendImpl;\n\t  };\n\t}\n\n\tfunction findHostInstanceByFiber(fiber) {\n\t  var hostFiber = findCurrentHostFiber(fiber);\n\n\t  if (hostFiber === null) {\n\t    return null;\n\t  }\n\n\t  return hostFiber.stateNode;\n\t}\n\n\tfunction emptyFindFiberByHostInstance(instance) {\n\t  return null;\n\t}\n\n\tfunction getCurrentFiberForDevTools() {\n\t  return current;\n\t}\n\n\tfunction injectIntoDevTools(devToolsConfig) {\n\t  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\t  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n\t  return injectInternals({\n\t    bundleType: devToolsConfig.bundleType,\n\t    version: devToolsConfig.version,\n\t    rendererPackageName: devToolsConfig.rendererPackageName,\n\t    rendererConfig: devToolsConfig.rendererConfig,\n\t    overrideHookState: overrideHookState,\n\t    overrideHookStateDeletePath: overrideHookStateDeletePath,\n\t    overrideHookStateRenamePath: overrideHookStateRenamePath,\n\t    overrideProps: overrideProps,\n\t    overridePropsDeletePath: overridePropsDeletePath,\n\t    overridePropsRenamePath: overridePropsRenamePath,\n\t    setErrorHandler: setErrorHandler,\n\t    setSuspenseHandler: setSuspenseHandler,\n\t    scheduleUpdate: scheduleUpdate,\n\t    currentDispatcherRef: ReactCurrentDispatcher,\n\t    findHostInstanceByFiber: findHostInstanceByFiber,\n\t    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n\t    // React Refresh\n\t    findHostInstancesForRefresh:  findHostInstancesForRefresh ,\n\t    scheduleRefresh:  scheduleRefresh ,\n\t    scheduleRoot:  scheduleRoot ,\n\t    setRefreshHandler:  setRefreshHandler ,\n\t    // Enables DevTools to append owner stacks to error messages in DEV mode.\n\t    getCurrentFiber:  getCurrentFiberForDevTools ,\n\t    // Enables DevTools to detect reconciler version rather than renderer version\n\t    // which may not match for third party renderers.\n\t    reconcilerVersion: ReactVersion\n\t  });\n\t}\n\n\texports.attemptContinuousHydration = attemptContinuousHydration;\n\texports.attemptDiscreteHydration = attemptDiscreteHydration;\n\texports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n\texports.attemptSynchronousHydration = attemptSynchronousHydration;\n\texports.batchedUpdates = batchedUpdates;\n\texports.createComponentSelector = createComponentSelector;\n\texports.createContainer = createContainer;\n\texports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n\texports.createHydrationContainer = createHydrationContainer;\n\texports.createPortal = createPortal;\n\texports.createRoleSelector = createRoleSelector;\n\texports.createTestNameSelector = createTestNameSelector;\n\texports.createTextSelector = createTextSelector;\n\texports.deferredUpdates = deferredUpdates;\n\texports.discreteUpdates = discreteUpdates;\n\texports.findAllNodes = findAllNodes;\n\texports.findBoundingRects = findBoundingRects;\n\texports.findHostInstance = findHostInstance;\n\texports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n\texports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n\texports.flushControlled = flushControlled;\n\texports.flushPassiveEffects = flushPassiveEffects;\n\texports.flushSync = flushSync;\n\texports.focusWithin = focusWithin;\n\texports.getCurrentUpdatePriority = getCurrentUpdatePriority;\n\texports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n\texports.getPublicRootInstance = getPublicRootInstance;\n\texports.injectIntoDevTools = injectIntoDevTools;\n\texports.isAlreadyRendering = isAlreadyRendering;\n\texports.observeVisibleRects = observeVisibleRects;\n\texports.registerMutableSourceForHydration = registerMutableSourceForHydration;\n\texports.runWithPriority = runWithPriority;\n\texports.shouldError = shouldError;\n\texports.shouldSuspend = shouldSuspend;\n\texports.updateContainer = updateContainer;\n\t    return exports;\n\t  };\n\t}\n\treturn reactReconciler_developmentExports;\n}\n\n(function (module) {\n\n\t{\n\t  module.exports = requireReactReconciler_development();\n\t}\n} (reactReconciler));\n\nvar Reconciler = /*@__PURE__*/getDefaultExportFromCjs(reactReconcilerExports);\n\nvar name = \"root\";\nvar workspaces = [\n\t\"packages/*\"\n];\nvar scripts = {\n\tbuild: \"nx run-many --target=build --all --parallel\",\n\t\"build:force\": \"nx run-many --target=build --all --parallel --skip-nx-cache\",\n\t\"build:docs\": \"nx run @pixi/react-docs:deploy\",\n\tclean: \"rimraf packages/*/dist packages/*/build\",\n\tlint: \"eslint .\",\n\tprepare: \"husky install\",\n\tprerelease: \"./scripts/checkReleaseBranch.mjs && npm run lint && npm run test:force && npm run build:force\",\n\trelease: \"lerna publish --no-private\",\n\ttest: \"nx run-many --target=test --all --parallel\",\n\t\"test:force\": \"nx run-many --target=test --all --parallel --skip-nx-cache\",\n\t\"test:types\": \"nx run-many --target=test:types --all --parallel\",\n\t\"test:types:force\": \"nx run-many --target=test:types --all --parallel --skip-nx-cache\"\n};\nvar husky = {\n\thooks: {\n\t\t\"pre-commit\": \"lint-staged\"\n\t}\n};\nvar resolutions = {\n\t\"get-pkg-repo\": \"4.1.1\",\n\t\"hosted-git-info\": \"^2.1.4\"\n};\nvar dependencies = {\n\t\"@babel/runtime\": \"^7.14.8\",\n\t\"@pixi/app\": \"^7.1.1\",\n\t\"@pixi/constants\": \"^7.1.1\",\n\t\"@pixi/core\": \"^7.1.1\",\n\t\"@pixi/display\": \"^7.1.1\",\n\t\"@pixi/extensions\": \"^7.1.1\",\n\t\"@pixi/graphics\": \"^7.1.1\",\n\t\"@pixi/math\": \"^7.1.1\",\n\t\"@pixi/mesh\": \"^7.1.1\",\n\t\"@pixi/mesh-extras\": \"^7.1.1\",\n\t\"@pixi/particle-container\": \"^7.1.1\",\n\t\"@pixi/sprite\": \"^7.1.1\",\n\t\"@pixi/sprite-animated\": \"^7.1.1\",\n\t\"@pixi/sprite-tiling\": \"^7.1.1\",\n\t\"@pixi/text\": \"^7.1.1\",\n\t\"@pixi/text-bitmap\": \"^7.1.1\",\n\t\"@pixi/ticker\": \"^7.1.1\",\n\t\"@react-spring/animated\": \"^9.6.1\",\n\t\"@react-spring/types\": \"^9.6.1\",\n\treact: \"^18.0.0\",\n\t\"react-dom\": \"^18.0.0\",\n\t\"react-reconciler\": \"0.29.0\",\n\t\"react-spring\": \"^9.6.1\"\n};\nvar devDependencies = {\n\t\"@babel/cli\": \"^7.20.7\",\n\t\"@babel/core\": \"^7.20.7\",\n\t\"@babel/eslint-parser\": \"^7.19.1\",\n\t\"@babel/plugin-transform-runtime\": \"^7.19.6\",\n\t\"@babel/preset-env\": \"^7.20.2\",\n\t\"@babel/preset-react\": \"^7.18.6\",\n\t\"@nrwl/nx-cloud\": \"latest\",\n\t\"@pixi/eslint-config\": \"^4.0.1\",\n\t\"@rollup/plugin-alias\": \"^4.0.2\",\n\t\"@rollup/plugin-babel\": \"^6.0.3\",\n\t\"@rollup/plugin-commonjs\": \"^24.0.0\",\n\t\"@rollup/plugin-json\": \"^6.0.0\",\n\t\"@rollup/plugin-node-resolve\": \"^15.0.1\",\n\t\"@rollup/plugin-replace\": \"^5.0.2\",\n\t\"@rollup/plugin-terser\": \"^0.2.1\",\n\t\"@rollup/plugin-typescript\": \"^10.0.1\",\n\t\"@types/jest\": \"^29.2.4\",\n\t\"@types/react\": \"17.0.15\",\n\t\"@types/react-dom\": \"17.0.9\",\n\t\"@types/react-reconciler\": \"0.28.2\",\n\t\"babel-jest\": \"^29.3.1\",\n\t\"babel-plugin-module-resolver\": \"4.1.0\",\n\t\"cross-env\": \"^7.0.3\",\n\teslint: \"^8.29.0\",\n\t\"eslint-plugin-react\": \"^7.31.11\",\n\thusky: \"^8.0.2\",\n\tjest: \"^29.3.1\",\n\t\"jest-environment-jsdom\": \"^29.3.1\",\n\t\"jest-extended\": \"^3.2.0\",\n\t\"jest-watch-typeahead\": \"^2.2.1\",\n\tlerna: \"^6.0.3\",\n\t\"lint-staged\": \"^13.1.0\",\n\tnx: \"15.3.0\",\n\trimraf: \"^3.0.2\",\n\trollup: \"^3.7.0\",\n\t\"rollup-plugin-filesize\": \"^9.1.2\",\n\t\"rollup-plugin-visualizer\": \"^5.9.0\",\n\t\"ts-jest\": \"^29.0.3\",\n\t\"ts-node\": \"^10.9.1\",\n\ttypescript: \"^4.9.4\"\n};\nvar pkg = {\n\tname: name,\n\t\"private\": true,\n\tworkspaces: workspaces,\n\tscripts: scripts,\n\thusky: husky,\n\t\"lint-staged\": {\n\t\"*.{ts,js,mjs}\": [\n\t\t\"eslint --cache --fix\"\n\t]\n},\n\tresolutions: resolutions,\n\tdependencies: dependencies,\n\tdevDependencies: devDependencies\n};\n\nvar performanceNowExports = {};\nvar performanceNow = {\n  get exports(){ return performanceNowExports; },\n  set exports(v){ performanceNowExports = v; },\n};\n\n// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    performanceNow.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    performanceNow.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    performanceNow.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    performanceNow.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(commonjsGlobal);\n\nvar constantsExports = {};\nvar constants = {\n  get exports(){ return constantsExports; },\n  set exports(v){ constantsExports = v; },\n};\n\nvar reactReconcilerConstants_development = {};\n\n/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredReactReconcilerConstants_development;\n\nfunction requireReactReconcilerConstants_development () {\n\tif (hasRequiredReactReconcilerConstants_development) return reactReconcilerConstants_development;\n\thasRequiredReactReconcilerConstants_development = 1;\n\n\t{\n\t  (function() {\n\n\tvar SyncLane =\n\t/*                        */\n\t1;\n\tvar InputContinuousLane =\n\t/*             */\n\t4;\n\tvar DefaultLane =\n\t/*                     */\n\t16;\n\tvar IdleLane =\n\t/*                        */\n\t536870912;\n\n\tvar DiscreteEventPriority = SyncLane;\n\tvar ContinuousEventPriority = InputContinuousLane;\n\tvar DefaultEventPriority = DefaultLane;\n\tvar IdleEventPriority = IdleLane;\n\n\tvar LegacyRoot = 0;\n\tvar ConcurrentRoot = 1;\n\n\treactReconcilerConstants_development.ConcurrentRoot = ConcurrentRoot;\n\treactReconcilerConstants_development.ContinuousEventPriority = ContinuousEventPriority;\n\treactReconcilerConstants_development.DefaultEventPriority = DefaultEventPriority;\n\treactReconcilerConstants_development.DiscreteEventPriority = DiscreteEventPriority;\n\treactReconcilerConstants_development.IdleEventPriority = IdleEventPriority;\n\treactReconcilerConstants_development.LegacyRoot = LegacyRoot;\n\t  })();\n\t}\n\treturn reactReconcilerConstants_development;\n}\n\n(function (module) {\n\n\t{\n\t  module.exports = requireReactReconcilerConstants_development();\n\t}\n} (constants));\n\nvar NO_CONTEXT = {};\nfunction getEventPriority() {\n  var _window, _window$event;\n  if (typeof window === 'undefined') {\n    return constantsExports.DefaultEventPriority;\n  }\n  var name = (_window = window) === null || _window === void 0 ? void 0 : (_window$event = _window.event) === null || _window$event === void 0 ? void 0 : _window$event.type;\n  switch (name) {\n    case 'click':\n    case 'contextmenu':\n    case 'dblclick':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n      return constantsExports.DiscreteEventPriority;\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'pointerenter':\n    case 'pointerleave':\n    case 'wheel':\n      return constantsExports.ContinuousEventPriority;\n    default:\n      return constantsExports.DefaultEventPriority;\n  }\n}\nfunction _appendChild(parent, child) {\n  if (parent.addChild) {\n    parent.addChild(child);\n    if (typeof child.didMount === 'function') {\n      child.didMount(child, parent);\n    }\n  }\n}\nfunction willUnmountRecursive(child, parent) {\n  var _child$willUnmount, _child$config, _child$children;\n  (_child$willUnmount = child.willUnmount) === null || _child$willUnmount === void 0 ? void 0 : _child$willUnmount.call(child, child, parent);\n\n  // ensure willUnmount is called on children, but don't actually destroy them\n  if (((_child$config = child.config) === null || _child$config === void 0 ? void 0 : _child$config.destroyChildren) !== false && (_child$children = child.children) !== null && _child$children !== void 0 && _child$children.length) {\n    _toConsumableArray(child.children).forEach(function (c) {\n      // TODO: should we call willUnmount anyway irrespective of whether destroyChildren is true?\n      willUnmountRecursive(c, child);\n    });\n  }\n}\nfunction _removeChild(parent, child) {\n  var _child$config2;\n  // call willUnmount on child and iteratively on its descendants\n  willUnmountRecursive(child, parent);\n  parent.removeChild(child);\n  var _ref = (_child$config2 = child.config) !== null && _child$config2 !== void 0 ? _child$config2 : {},\n    _ref$destroy = _ref.destroy,\n    destroy = _ref$destroy === void 0 ? true : _ref$destroy,\n    _ref$destroyChildren = _ref.destroyChildren,\n    destroyChildren = _ref$destroyChildren === void 0 ? true : _ref$destroyChildren,\n    _ref$destroyTexture = _ref.destroyTexture,\n    destroyTexture = _ref$destroyTexture === void 0 ? false : _ref$destroyTexture,\n    _ref$destroyBaseTextu = _ref.destroyBaseTexture,\n    destroyBaseTexture = _ref$destroyBaseTextu === void 0 ? false : _ref$destroyBaseTextu;\n  if (destroy) {\n    // defer to PIXI to actually destroy children\n    child.destroy({\n      children: destroyChildren,\n      texture: destroyTexture,\n      baseTexture: destroyBaseTexture\n    });\n  }\n}\nfunction insertBefore(parent, child, beforeChild) {\n  invariant(child !== beforeChild, 'pixi-react: PixiFiber cannot insert node before itself');\n  var childExists = parent.children.indexOf(child) !== -1;\n  if (childExists) {\n    parent.removeChild(child);\n  }\n  var index = parent.getChildIndex(beforeChild);\n  parent.addChildAt(child, index);\n}\n\n// get diff between 2 objects\n// https://github.com/facebook/react/blob/97e2911/packages/react-dom/src/client/ReactDOMFiberComponent.js#L546\nfunction diffProperties(pixiElement, type, lastProps, nextProps) {\n  var updatePayload = null;\n  for (var propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] === null) {\n      continue;\n    }\n    if (propKey === CHILDREN) ; else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n      updatePayload.push(propKey, null);\n    }\n  }\n  for (var _propKey in nextProps) {\n    var nextProp = nextProps[_propKey];\n    var lastProp = lastProps !== null ? lastProps[_propKey] : undefined;\n    if (!nextProps.hasOwnProperty(_propKey) || nextProp === lastProp || nextProp === null && lastProp === null) {\n      continue;\n    }\n    if (_propKey === CHILDREN) ; else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n      updatePayload.push(_propKey, nextProp);\n    }\n  }\n  return updatePayload;\n}\nvar prepareChanged = null;\nvar HostConfig = {\n  getRootHostContext: function getRootHostContext() {\n    return NO_CONTEXT;\n  },\n  getChildHostContext: function getChildHostContext(parentHostContext) {\n    return parentHostContext;\n  },\n  getChildHostContextForEventComponent: function getChildHostContextForEventComponent(parentHostContext) {\n    return parentHostContext;\n  },\n  getPublicInstance: function getPublicInstance(instance) {\n    return instance;\n  },\n  // TODO: Implement a proper version of getCurrentEventPriority\n  getCurrentEventPriority: function getCurrentEventPriority() {\n    return getEventPriority();\n  },\n  prepareForCommit: function prepareForCommit() {\n    // noop\n    return null;\n  },\n  resetAfterCommit: function resetAfterCommit() {\n    // noop\n  },\n  createInstance: createElement,\n  hideInstance: function hideInstance(instance) {\n    instance.visible = false;\n  },\n  unhideInstance: function unhideInstance(instance, props) {\n    var visible = props !== undefined && props !== null && props.hasOwnProperty('visible') ? props.visible : true;\n    instance.visible = visible;\n  },\n  finalizeInitialChildren: function finalizeInitialChildren(wordElement, type, props) {\n    return false;\n  },\n  prepareUpdate: function prepareUpdate(pixiElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    prepareChanged = diffProperties(pixiElement, type, oldProps, newProps);\n    return prepareChanged;\n  },\n  shouldSetTextContent: function shouldSetTextContent(type, props) {\n    return false;\n  },\n  shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {\n    var isAlphaVisible = typeof props.alpha === 'undefined' || props.alpha > 0;\n    var isRenderable = typeof props.renderable === 'undefined' || props.renderable === true;\n    var isVisible = typeof props.visible === 'undefined' || props.visible === true;\n    return !(isAlphaVisible && isRenderable && isVisible);\n  },\n  createTextInstance: function createTextInstance(text, rootContainerInstance, internalInstanceHandler) {\n    invariant(false, \"pixi-react: Error trying to add text node \\\"\".concat(text, \"\\\"\"), 'PixiFiber does not support text nodes as children of a Pixi component. ' + 'To pass a string value to your component, use a property other than children. ' + 'If you wish to display some text, you can use &lt;Text text={string} /&gt; instead.');\n  },\n  unhideTextInstance: function unhideTextInstance(textInstance, text) {\n    // noop\n  },\n  mountEventComponent: function mountEventComponent() {\n    // noop\n  },\n  updateEventComponent: function updateEventComponent() {\n    // noop\n  },\n  handleEventTarget: function handleEventTarget() {\n    // noop\n  },\n  scheduleTimeout: setTimeout,\n  cancelTimeout: clearTimeout,\n  noTimeout: -1,\n  warnsIfNotActing: false,\n  now: performanceNowExports,\n  isPrimaryRenderer: false,\n  supportsMutation: true,\n  supportsPersistence: false,\n  supportsHydration: false,\n  supportsMicrotasks: true,\n  scheduleMicrotask: queueMicrotask,\n  /**\n  * -------------------------------------------\n  * Mutation\n  * -------------------------------------------\n  */\n  appendInitialChild: function appendInitialChild() {\n    var _args$0$__reactpixi, _args$0$__reactpixi$r;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var res = _appendChild.apply(null, args);\n    (_args$0$__reactpixi = args[0].__reactpixi) === null || _args$0$__reactpixi === void 0 ? void 0 : (_args$0$__reactpixi$r = _args$0$__reactpixi.root) === null || _args$0$__reactpixi$r === void 0 ? void 0 : _args$0$__reactpixi$r.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n      detail: 'appendInitialChild'\n    });\n    return res;\n  },\n  appendChild: function appendChild() {\n    var _args$0$__reactpixi2, _args$0$__reactpixi2$;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    var res = _appendChild.apply(null, args);\n    (_args$0$__reactpixi2 = args[0].__reactpixi) === null || _args$0$__reactpixi2 === void 0 ? void 0 : (_args$0$__reactpixi2$ = _args$0$__reactpixi2.root) === null || _args$0$__reactpixi2$ === void 0 ? void 0 : _args$0$__reactpixi2$.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n      detail: 'appendChild'\n    });\n    return res;\n  },\n  appendChildToContainer: function appendChildToContainer() {\n    var _args$0$__reactpixi3, _args$0$__reactpixi3$;\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    var res = _appendChild.apply(null, args);\n    (_args$0$__reactpixi3 = args[0].__reactpixi) === null || _args$0$__reactpixi3 === void 0 ? void 0 : (_args$0$__reactpixi3$ = _args$0$__reactpixi3.root) === null || _args$0$__reactpixi3$ === void 0 ? void 0 : _args$0$__reactpixi3$.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n      detail: 'appendChildToContainer'\n    });\n    return res;\n  },\n  removeChild: function removeChild() {\n    var _args$0$__reactpixi4, _args$0$__reactpixi4$;\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    var res = _removeChild.apply(null, args);\n    (_args$0$__reactpixi4 = args[0].__reactpixi) === null || _args$0$__reactpixi4 === void 0 ? void 0 : (_args$0$__reactpixi4$ = _args$0$__reactpixi4.root) === null || _args$0$__reactpixi4$ === void 0 ? void 0 : _args$0$__reactpixi4$.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n      detail: 'removeChild'\n    });\n    return res;\n  },\n  removeChildFromContainer: function removeChildFromContainer() {\n    var _args$0$__reactpixi5, _args$0$__reactpixi5$;\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    var res = _removeChild.apply(null, args);\n    (_args$0$__reactpixi5 = args[0].__reactpixi) === null || _args$0$__reactpixi5 === void 0 ? void 0 : (_args$0$__reactpixi5$ = _args$0$__reactpixi5.root) === null || _args$0$__reactpixi5$ === void 0 ? void 0 : _args$0$__reactpixi5$.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n      detail: 'removeChildFromContainer'\n    });\n    return res;\n  },\n  insertBefore: insertBefore,\n  insertInContainerBefore: function insertInContainerBefore() {\n    var _args$0$__reactpixi6, _args$0$__reactpixi6$;\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    var res = insertBefore.apply(null, args);\n    (_args$0$__reactpixi6 = args[0].__reactpixi) === null || _args$0$__reactpixi6 === void 0 ? void 0 : (_args$0$__reactpixi6$ = _args$0$__reactpixi6.root) === null || _args$0$__reactpixi6$ === void 0 ? void 0 : _args$0$__reactpixi6$.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n      detail: 'insertInContainerBefore'\n    });\n    return res;\n  },\n  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n    var applyProps = instance && instance.applyProps;\n    if (typeof applyProps !== 'function') {\n      applyProps = applyDefaultProps;\n    }\n    var changed = applyProps(instance, oldProps, newProps);\n    if (changed || prepareChanged) {\n      var _instance$__reactpixi, _instance$__reactpixi2;\n      (_instance$__reactpixi = instance.__reactpixi) === null || _instance$__reactpixi === void 0 ? void 0 : (_instance$__reactpixi2 = _instance$__reactpixi.root) === null || _instance$__reactpixi2 === void 0 ? void 0 : _instance$__reactpixi2.emit(\"__REACT_PIXI_REQUEST_RENDER__\", {\n        detail: 'commitUpdate'\n      });\n    }\n  },\n  commitMount: function commitMount(instance, updatePayload, type, oldProps, newProps) {\n    // noop\n  },\n  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n    // noop\n  },\n  resetTextContent: function resetTextContent(pixiElement) {\n    // noop\n  },\n  clearContainer: function clearContainer(container) {\n    // TODO implement this\n  },\n  getFundamentalComponentInstance: function getFundamentalComponentInstance(fundamentalInstance) {\n    throw new Error('Not yet implemented.');\n  },\n  mountFundamentalComponent: function mountFundamentalComponent(fundamentalInstance) {\n    throw new Error('Not yet implemented.');\n  },\n  shouldUpdateFundamentalComponent: function shouldUpdateFundamentalComponent(fundamentalInstance) {\n    throw new Error('Not yet implemented.');\n  },\n  unmountFundamentalComponent: function unmountFundamentalComponent(fundamentalInstance) {\n    throw new Error('Not yet implemented.');\n  },\n  getInstanceFromNode: function getInstanceFromNode(node) {\n    throw new Error('Not yet implemented.');\n  },\n  isOpaqueHydratingObject: function isOpaqueHydratingObject(value) {\n    throw new Error('Not yet implemented');\n  },\n  makeOpaqueHydratingObject: function makeOpaqueHydratingObject(attemptToReadValue) {\n    throw new Error('Not yet implemented.');\n  },\n  makeClientIdInDEV: function makeClientIdInDEV(warnOnAccessInDEV) {\n    throw new Error('Not yet implemented');\n  },\n  beforeActiveInstanceBlur: function beforeActiveInstanceBlur(internalInstanceHandle) {\n    // noop\n  },\n  afterActiveInstanceBlur: function afterActiveInstanceBlur() {\n    // noop\n  },\n  detachDeletedInstance: function detachDeletedInstance() {\n    // noop\n  },\n  preparePortalMount: function preparePortalMount(portalInstance) {\n    // noop\n  }\n};\nvar hostconfig = HostConfig;\n\nvar PixiFiber = Reconciler(hostconfig);\nvar REACT_DOM_VERSION = pkg.dependencies['react-dom'].replace(/[^0-9.]/g, '');\nvar PACKAGE_NAME = pkg.name;\nPixiFiber.injectIntoDevTools({\n  bundleType: 1 ,\n  version: REACT_DOM_VERSION,\n  rendererPackageName: PACKAGE_NAME,\n  findHostInstanceByFiber: PixiFiber.findHostInstance\n});\n\n// cache both root PixiFiber containers and React roots\nvar roots = new Map();\n\n/**\n * @param {Container} container\n */\nfunction unmountComponent(container) {\n  invariant(_pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container.prototype.isPrototypeOf(container), 'Invalid argument `container`, expected instance of `PIXI.Container`.');\n  if (roots.has(container)) {\n    var _roots$get = roots.get(container),\n      pixiFiberContainer = _roots$get.pixiFiberContainer;\n\n    // unmount component\n    PixiFiber.updateContainer(null, pixiFiberContainer, undefined, function () {\n      roots.delete(container);\n    });\n  }\n}\n\n/**\n * Custom Renderer with react 18 API\n * Use this without React-DOM\n *\n * @param {Container} container\n * @returns {{ render: Function, unmount: Function}}\n */\nfunction createRoot(container) {\n  invariant(_pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container.prototype.isPrototypeOf(container), 'Invalid argument `container`, expected instance of `PIXI.Container`.');\n  var root = roots.get(container);\n  invariant(!root, 'Pixi React: createRoot should only be called once');\n  if (!root) {\n    var pixiFiberContainer = PixiFiber.createContainer(container);\n    var reactRoot = {\n      render: function render(element) {\n        // schedules a top level update\n        PixiFiber.updateContainer(element, pixiFiberContainer, undefined);\n        return PixiFiber.getPublicRootInstance(pixiFiberContainer);\n      },\n      unmount: function unmount() {\n        unmountComponent(container);\n        roots.delete(container);\n      }\n    };\n    root = {\n      pixiFiberContainer: pixiFiberContainer,\n      reactRoot: reactRoot\n    };\n    roots.set(container, root);\n  }\n  return root.reactRoot;\n}\n\n/**\n * Custom Renderer\n * Use this without React-DOM\n *\n * @deprecated use createRoot instead\n *\n * @param {React.ReactNode} element\n * @param {Container} container (i.e. the Stage)\n * @param {Function} callback\n */\nfunction render(element, container, callback) {\n  console.warn('Pixi React Deprecation Warning: render is deprecated, use createRoot instead');\n  if (callback !== undefined) {\n    console.warn('Pixi React Deprecation Warning: render callback no longer exists in React 18');\n  }\n  var reactRoot;\n  if (roots.has(container)) {\n    var _roots$get2 = roots.get(container);\n    reactRoot = _roots$get2.reactRoot;\n  } else {\n    reactRoot = createRoot(container);\n  }\n  return reactRoot.render(element);\n}\n\n/**\n * @deprecated use root.unmount() instead\n * @param {Container} container\n */\nfunction unmountComponentAtNode(container) {\n  unmountComponent(container);\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar Context = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().createContext(null);\nvar AppProvider = Context.Provider;\nvar AppConsumer = Context.Consumer;\nvar withPixiApp = function withPixiApp(BaseComponent) {\n  var wrapper = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().forwardRef(function (props, ref) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().createElement(AppConsumer, null, function (app) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().createElement(BaseComponent, _extends({}, props, {\n        ref: ref,\n        app: app\n      }));\n    });\n  });\n  wrapper.displayName = \"withPIXIApp(\".concat(BaseComponent.displayName || BaseComponent.name, \")\");\n  return wrapper;\n};\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar noop = function noop() {};\n\n/**\n * -------------------------------------------\n * Stage React Component (use this in react-dom)\n *\n * @usage\n *\n * const App = () => (\n *   <Stage\n *     width={500}\n *     height={500}\n *     options={ backgroundColor: 0xff0000 }\n *     onMount={( renderer, canvas ) => {\n *       console.log('PIXI renderer: ', renderer)\n *       console.log('Canvas element: ', canvas)\n *     }}>\n * );\n *\n * -------------------------------------------\n */\n\nvar propTypes = {\n  // dimensions\n  width: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n  // will return renderer\n  onMount: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().func),\n  onUnmount: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().func),\n  // run ticker at start?\n  raf: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n  // render component on component lifecycle changes?\n  renderOnComponentChange: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n  children: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().node),\n  // PIXI options, see https://pixijs.download/dev/docs/PIXI.Application.html\n  options: prop_types__WEBPACK_IMPORTED_MODULE_15___default().shape({\n    autoStart: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    width: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n    height: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n    useContextAlpha: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    backgroundAlpha: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n    autoDensity: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    antialias: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    preserveDrawingBuffer: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    resolution: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n    forceCanvas: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    backgroundColor: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number),\n    clearBeforeRender: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    powerPreference: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string),\n    sharedTicker: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    sharedLoader: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n    // resizeTo needs to be a window or HTMLElement\n    resizeTo: function resizeTo(props, propName) {\n      var el = props[propName];\n      el && invariant(el === window || el instanceof HTMLElement, \"Invalid prop `resizeTo` of type \".concat(_typeof(el), \", expect `window` or an `HTMLElement`.\"));\n    },\n    // view is optional, use if provided\n    view: function view(props, propName, componentName) {\n      var el = props[propName];\n      el && invariant(el instanceof HTMLCanvasElement, \"Invalid prop `view` of type \".concat(_typeof(el), \", supplied to \").concat(componentName, \", expected `<canvas> Element`\"));\n    }\n  })\n};\nvar defaultProps = {\n  width: 800,\n  height: 600,\n  onMount: noop,\n  onUnmount: noop,\n  raf: true,\n  renderOnComponentChange: true\n};\nfunction getCanvasProps(props) {\n  var reserved = [].concat(_toConsumableArray(Object.keys(propTypes)), _toConsumableArray(Object.keys(PROPS_DISPLAY_OBJECT)));\n  return Object.keys(props).filter(function (p) {\n    return !reserved.includes(p);\n  }).reduce(function (all, prop) {\n    return _objectSpread$1(_objectSpread$1({}, all), {}, _defineProperty({}, prop, props[prop]));\n  }, {});\n}\nvar Stage = /*#__PURE__*/function (_React$Component) {\n  _inherits(Stage, _React$Component);\n  var _super = _createSuper(Stage);\n  function Stage() {\n    var _this;\n    _classCallCheck(this, Stage);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"_canvas\", null);\n    _defineProperty(_assertThisInitialized(_this), \"_mediaQuery\", null);\n    _defineProperty(_assertThisInitialized(_this), \"_ticker\", null);\n    _defineProperty(_assertThisInitialized(_this), \"_needsUpdate\", true);\n    _defineProperty(_assertThisInitialized(_this), \"app\", null);\n    _defineProperty(_assertThisInitialized(_this), \"updateSize\", function () {\n      var _this$props = _this.props,\n        width = _this$props.width,\n        height = _this$props.height,\n        options = _this$props.options;\n      if (!(options !== null && options !== void 0 && options.resolution)) {\n        _this.app.renderer.resolution = window.devicePixelRatio;\n        _this.resetInteractionManager();\n      }\n      _this.app.renderer.resize(width, height);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"needsRenderUpdate\", function () {\n      _this._needsUpdate = true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"renderStage\", function () {\n      var _this$props2 = _this.props,\n        renderOnComponentChange = _this$props2.renderOnComponentChange,\n        raf = _this$props2.raf;\n      if (!raf && renderOnComponentChange && _this._needsUpdate) {\n        _this._needsUpdate = false;\n        _this.app.renderer.render(_this.app.stage);\n      }\n    });\n    return _this;\n  }\n  _createClass(Stage, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props3 = this.props,\n        onMount = _this$props3.onMount,\n        width = _this$props3.width,\n        height = _this$props3.height,\n        options = _this$props3.options,\n        raf = _this$props3.raf,\n        renderOnComponentChange = _this$props3.renderOnComponentChange;\n      this.app = new _pixi_app__WEBPACK_IMPORTED_MODULE_13__.Application(_objectSpread$1(_objectSpread$1({\n        width: width,\n        height: height,\n        view: this._canvas\n      }, options), {}, {\n        autoDensity: (options === null || options === void 0 ? void 0 : options.autoDensity) !== false\n      }));\n      {\n        // workaround for React 18 Strict Mode unmount causing canvas\n        // context to be lost\n        this.app.renderer.context.extensions.loseContext = null;\n      }\n      this.app.ticker.autoStart = false;\n      this.app.ticker[raf ? 'start' : 'stop']();\n      this.app.stage.__reactpixi = {\n        root: this.app.stage\n      };\n      this.mountNode = PixiFiber.createContainer(this.app.stage);\n      PixiFiber.updateContainer(this.getChildren(), this.mountNode, this);\n      onMount(this.app);\n\n      // update size on media query resolution change?\n      // only if autoDensity = true\n      if (options !== null && options !== void 0 && options.autoDensity && window.matchMedia && (options === null || options === void 0 ? void 0 : options.resolution) === undefined) {\n        this._mediaQuery = window.matchMedia(\"(-webkit-min-device-pixel-ratio: 1.3), (min-resolution: 120dpi)\");\n        this._mediaQuery.addListener(this.updateSize);\n      }\n\n      // listen for reconciler changes\n      if (renderOnComponentChange && !raf) {\n        this._ticker = new _pixi_ticker__WEBPACK_IMPORTED_MODULE_14__.Ticker();\n        this._ticker.autoStart = true;\n        this._ticker.add(this.renderStage);\n        this.app.stage.on('__REACT_PIXI_REQUEST_RENDER__', this.needsRenderUpdate);\n      }\n      this.updateSize();\n      this.renderStage();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState, prevContext) {\n      var _prevProps$options;\n      var _this$props4 = this.props,\n        width = _this$props4.width,\n        height = _this$props4.height,\n        raf = _this$props4.raf,\n        renderOnComponentChange = _this$props4.renderOnComponentChange,\n        options = _this$props4.options;\n\n      // update resolution\n      if ((options === null || options === void 0 ? void 0 : options.resolution) !== undefined && (prevProps === null || prevProps === void 0 ? void 0 : prevProps.options.resolution) !== (options === null || options === void 0 ? void 0 : options.resolution)) {\n        this.app.renderer.resolution = options.resolution;\n        this.resetInteractionManager();\n      }\n\n      // update size\n      if (prevProps.height !== height || prevProps.width !== width || ((_prevProps$options = prevProps.options) === null || _prevProps$options === void 0 ? void 0 : _prevProps$options.resolution) !== (options === null || options === void 0 ? void 0 : options.resolution)) {\n        this.updateSize();\n      }\n\n      // handle raf change\n      if (prevProps.raf !== raf) {\n        this.app.ticker[raf ? 'start' : 'stop']();\n      }\n\n      // flush fiber\n      PixiFiber.updateContainer(this.getChildren(), this.mountNode, this);\n      if (prevProps.width !== width || prevProps.height !== height || prevProps.raf !== raf || prevProps.renderOnComponentChange !== renderOnComponentChange || prevProps.options !== options) {\n        this._needsUpdate = true;\n        this.renderStage();\n      }\n    }\n  }, {\n    key: \"resetInteractionManager\",\n    value:\n    // provide support for Pixi v6 still\n    function resetInteractionManager() {\n      // `interaction` property is absent in Pixi v7 and in v6 if user has installed Federated Events API plugin.\n      // https://api.pixijs.io/@pixi/events.html\n      // in v7 however, there's a stub object which displays a deprecation warning, so also check the resolution property:\n      var maybeInteraction = this.app.renderer.plugins.interaction;\n      if (maybeInteraction !== null && maybeInteraction !== void 0 && maybeInteraction.resolution) {\n        maybeInteraction.resolution = this.app.renderer.resolution;\n      }\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var children = this.props.children;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().createElement(AppProvider, {\n        value: this.app\n      }, children);\n    }\n  }, {\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(error, errorInfo) {\n      console.error(\"Error occurred in `Stage`.\");\n      console.error(error);\n      console.error(errorInfo);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.onUnmount(this.app);\n      if (this._ticker) {\n        this._ticker.remove(this.renderStage);\n        this._ticker.destroy();\n      }\n      this.app.stage.off('__REACT_PIXI_REQUEST_RENDER__', this.needsRenderUpdate);\n      PixiFiber.updateContainer(null, this.mountNode, this);\n      if (this._mediaQuery) {\n        this._mediaQuery.removeListener(this.updateSize);\n        this._mediaQuery = null;\n      }\n      this.app.destroy();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var options = this.props.options;\n      if (options && options.view) {\n        invariant(options.view instanceof HTMLCanvasElement, 'options.view needs to be a `HTMLCanvasElement`');\n        return null;\n      }\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().createElement(\"canvas\", _extends({}, getCanvasProps(this.props), {\n        ref: function ref(c) {\n          return _this2._canvas = c;\n        }\n      }));\n    }\n  }]);\n  return Stage;\n}((react__WEBPACK_IMPORTED_MODULE_12___default().Component));\nStage.propTypes = propTypes;\nStage.defaultProps = defaultProps;\nvar Stage$1 = Stage;\n\nfunction useApp() {\n  var app = (0,react__WEBPACK_IMPORTED_MODULE_12__.useContext)(Context);\n  invariant(app instanceof _pixi_app__WEBPACK_IMPORTED_MODULE_13__.Application, 'No Context found with `%s`. Make sure to wrap component with `%s`', 'PIXI.Application', 'AppProvider');\n  return app;\n}\n\nfunction useTick(callback) {\n  var enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var app = useApp();\n  invariant(typeof callback === 'function', '`useTick` needs a callback function.');\n  invariant(app instanceof _pixi_app__WEBPACK_IMPORTED_MODULE_13__.Application, 'No Context found with `%s`. Make sure to wrap component with `%s`', 'PIXI.Application', 'AppProvider');\n  var savedRef = (0,react__WEBPACK_IMPORTED_MODULE_12__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_12__.useEffect)(function () {\n    savedRef.current = callback;\n  }, [callback]);\n\n  // eslint-disable-next-line consistent-return\n  (0,react__WEBPACK_IMPORTED_MODULE_12__.useEffect)(function () {\n    if (enabled) {\n      var tick = function tick(delta) {\n        return savedRef.current.apply(app.ticker, [delta, app.ticker]);\n      };\n      app.ticker.add(tick);\n      return function () {\n        if (app.ticker) {\n          app.ticker.remove(tick);\n        }\n      };\n    }\n  }, [enabled]);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\n\nvar _excluded = [\"children\", \"apply\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar withFilters = function withFilters(WrapperComponent, filters) {\n  invariant(_typeof(filters) === 'object', 'Second argument needs to be an indexed object with { prop: Filter }');\n  var keys = Object.keys(filters);\n  var Wrapper = function Wrapper(_ref) {\n    var children = _ref.children,\n      apply = _ref.apply,\n      props = _objectWithoutProperties(_ref, _excluded);\n    // create filters\n    var filterList = (0,react__WEBPACK_IMPORTED_MODULE_12__.useRef)((0,react__WEBPACK_IMPORTED_MODULE_12__.useMemo)(function () {\n      return keys.map(function (prop) {\n        var _props$prop;\n        var constructorArgs = (props === null || props === void 0 ? void 0 : (_props$prop = props[prop]) === null || _props$prop === void 0 ? void 0 : _props$prop.construct) || [];\n        return _construct(filters[prop], _toConsumableArray(constructorArgs));\n      });\n    }, [keys]));\n    var filterObj = (0,react__WEBPACK_IMPORTED_MODULE_12__.useMemo)(function () {\n      return keys.reduce(function (all, c, i) {\n        return _objectSpread(_objectSpread({}, all), {}, _defineProperty({}, c, filterList.current[i]));\n      }, {});\n    }, [keys]);\n\n    // get rest props\n    var restProps = (0,react__WEBPACK_IMPORTED_MODULE_12__.useMemo)(function () {\n      return Object.keys(props).filter(not(hasKey(keys))).reduce(function (all, c) {\n        return _objectSpread(_objectSpread({}, all), {}, _defineProperty({}, c, props[c]));\n      }, {});\n    }, [props, keys]);\n\n    // update filter params\n    keys.forEach(function (k, i) {\n      return Object.assign(filterList.current[i], props[k]);\n    });\n\n    // use apply ?\n    if (apply && isFunction(apply)) {\n      apply.call(WrapperComponent, filterObj);\n    }\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_12___default().createElement(WrapperComponent, _extends({}, restProps, {\n      filters: filterList.current\n    }), children);\n  };\n  Wrapper.displayName = 'FilterWrapper';\n  Wrapper.propTypes = {\n    children: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().node),\n    apply: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().func)\n  };\n  return Wrapper;\n};\n\nvar BitmapText = TYPES.BitmapText;\nvar Container = TYPES.Container;\nvar Graphics = TYPES.Graphics;\nvar NineSlicePlane = TYPES.NineSlicePlane;\nvar ParticleContainer = TYPES.ParticleContainer;\nvar Sprite = TYPES.Sprite;\nvar AnimatedSprite = TYPES.AnimatedSprite;\nvar Text = TYPES.Text;\nvar TilingSprite = TYPES.TilingSprite;\nvar SimpleMesh = TYPES.SimpleMesh;\nvar SimpleRope = TYPES.SimpleRope;\n\n\n//# sourceMappingURL=index.es-dev.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBpeGkvcmVhY3QvZGlzdC9pbmRleC5lcy1kZXYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNtQztBQUNwQjtBQUNXO0FBQ1A7QUFDdUU7QUFDM0M7QUFDbEM7QUFDeUI7QUFDL0I7QUFDeUI7QUFDeEI7QUFDeUI7QUFDOUI7QUFDRjtBQUNIOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxzSEFBc0gscUJBQU0sbUJBQW1CLHFCQUFNOztBQUVySjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFLLHFCQUFxQix1REFBZTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0NBQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUVBQXlFLCtDQUFPO0FBQ2hGLEdBQUc7QUFDSDtBQUNBLGdCQUFnQixvREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBcUM7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5REFBWTtBQUN6QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxvREFBVztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvREFBVTtBQUN2RCx5QkFBeUIsb0RBQVUsMEJBQTBCLG9EQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0QsNkRBQTZELGlFQUFpRSxzQ0FBc0M7QUFDelUsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsK0RBQStELDRDQUE0QyxzS0FBc0ssbUZBQW1GLEtBQUs7QUFDaGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5QkFBeUI7QUFDNUIseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNkJBQTZCO0FBQ2hDLHNCQUFzQix1RUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQU8sK0lBQStJLHNEQUFzRDtBQUMvTztBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQyw0RUFBMkIsZUFBZSxpRUFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EscUJBQXFCLDRDQUFNO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGdEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrRUFBb0I7QUFDaEUsdUJBQXVCLHlEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsNkNBQTZDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDO0FBQ3pVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELCtEQUErRCw0Q0FBNEMsc0tBQXNLLG1GQUFtRixLQUFLOztBQUVoZjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWUsb0JBQW9CO0FBQzlFLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRCxrQkFBa0IsNkJBQTZCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLGtCQUFrQix1QkFBdUI7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBLHNDQUFzQzs7QUFFdEMsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQyxpREFBaUQ7O0FBRWpEO0FBQ0EsdUJBQXVCOztBQUV2Qix5QkFBeUI7QUFDekI7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxxRkFBcUY7O0FBRXJGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDRDQUE0QztBQUM3RCxrQkFBa0IseUNBQXlDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0NBQUs7QUFDcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsYUFBYTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE1BQU0sR0FBRzs7QUFFVCxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQywyQ0FBMkM7O0FBRTNDLGlDQUFpQzs7QUFFakMsOENBQThDO0FBQzlDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDLGlDQUFpQzs7QUFFakMsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQyxtQkFBbUI7O0FBRW5CLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhELDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Ysd0JBQXdCO0FBQ3hCO0FBQ0EsVUFBVTtBQUNWLHdCQUF3QjtBQUN4QjtBQUNBLFVBQVU7QUFDVix5QkFBeUI7QUFDekI7QUFDQSxVQUFVO0FBQ1YseUJBQXlCO0FBQ3pCO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBLFVBQVU7QUFDViw0QkFBNEI7QUFDNUI7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7OztBQUduQjtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCw0REFBNEQ7O0FBRTVELHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLDRIQUE0SDtBQUM1SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTs7QUFFQSxjQUFjLGtCQUFrQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0QsNERBQTREOztBQUU1RCxnRUFBZ0U7O0FBRWhFO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUEsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVKQUF1Sjs7QUFFdkosc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRCxzREFBc0Q7QUFDdEQsNERBQTREO0FBQzVELDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEOztBQUVoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1RkFBdUY7O0FBRXZGLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUJBQXlCOzs7QUFHcEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0wsa0dBQWtHO0FBQ2xHLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0lBQStJOztBQUUvSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLG1FQUFtRSw0Q0FBNEM7QUFDL0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0lBQW9JO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrSEFBK0gseUNBQXlDO0FBQ3hLOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFrRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUCx5RUFBeUU7O0FBRXpFLFlBQVksNkJBQTZCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQLHlFQUF5RTs7QUFFekUsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQ7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUEseURBQXlEOztBQUV6RCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0Isa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsOEJBQThCO0FBQ3ZEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QixzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDJDQUEyQztBQUNsRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwwS0FBMEssMENBQTBDO0FBQ3BOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOzs7QUFHcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTs7QUFFakU7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7O0FBR0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpELCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0Esa1FBQWtRO0FBQ2xROztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnSEFBZ0g7QUFDaEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkVBQTJFOztBQUUzRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOzs7QUFHWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLG9DQUFvQztBQUNwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0EsMEVBQTBFOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOzs7QUFHQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFOztBQUV2RSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1AsMENBQTBDOztBQUUxQztBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQSxLQUFLO0FBQ0wsZ0hBQWdIO0FBQ2hIO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUdBQWlHO0FBQ2pHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBOQUEwTixHQUFHOztBQUU3TjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBLFdBQVc7QUFDWDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0NBQW9DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUEsdUhBQXVIOztBQUV2SCxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLG9DQUFvQztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxvQ0FBb0M7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUEsc0dBQXNHO0FBQ3RHOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7O0FBR2Y7QUFDQTtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0EsYUFBYTs7O0FBR2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esa0VBQWtFO0FBQ2xFOztBQUVBLHVJQUF1STs7QUFFdkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7O0FBRXpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVCx5RUFBeUU7O0FBRXpFO0FBQ0EsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QixZQUFZLEdBQUc7QUFDZixZQUFZLE1BQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG1PQUFtTyxxQ0FBcUMsd0ZBQXdGLDJCQUEyQixxQkFBcUIsUUFBUSxhQUFhO0FBQ3JhLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7O0FBR0Esa0VBQWtFO0FBQ2xFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNElBQTRJO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUssK0JBQStCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7O0FBR3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QixtQ0FBbUM7O0FBRW5DLGdDQUFnQzs7QUFFaEMsNEJBQTRCOztBQUU1Qiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7O0FBRXZELG9EQUFvRDs7QUFFcEQsMENBQTBDO0FBQzFDOztBQUVBLCtDQUErQzs7QUFFL0MsMERBQTBEOztBQUUxRCw4Q0FBOEM7O0FBRTlDLGdEQUFnRDtBQUNoRDs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQSxpREFBaUQ7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsZ0VBQWdFOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7O0FBRTdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7OztBQUdyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7O0FBR3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCxrQ0FBa0M7O0FBRWxDO0FBQ0EsS0FBSyxnQ0FBZ0M7OztBQUdyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyw0Q0FBNEM7QUFDakQ7OztBQUdBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQ7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUEsbURBQW1EOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IOztBQUVwSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtMQUErTCxvREFBb0QsRUFBRTtBQUNyUCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb09BQW9PLG9EQUFvRCxFQUFFO0FBQzFSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxpREFBaUQ7O0FBRWpELHlDQUF5QztBQUN6Qzs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5TEFBeUw7O0FBRXpMLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxHQUFHO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELFFBQVE7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVTtBQUNmO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQsa0JBQWtCLDRCQUE0QjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQixPQUFPLG9CQUFvQixPQUFPLGNBQWMsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQyxrQkFBa0IsdUJBQXVCO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMFNBQTBTLFdBQVcsUUFBUSxNQUFNO0FBQ25VLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBLFlBQVksNEVBQW1DO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksNEVBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDJEQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQWdCO0FBQzdDLHdCQUF3QiwyREFBbUI7QUFDM0MsMEJBQTBCLDJEQUFtQiwyQkFBMkI7QUFDeEU7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsK0RBQStELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7QUFDdFgseUNBQXlDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZO0FBQzFULDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQztBQUN6VSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCwrREFBK0QsNENBQTRDLHNLQUFzSyxtRkFBbUYsS0FBSztBQUNoZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsMkRBQWdCO0FBQ3pCLFVBQVUsMkRBQWdCO0FBQzFCO0FBQ0EsV0FBVyx5REFBYztBQUN6QixhQUFhLHlEQUFjO0FBQzNCO0FBQ0EsT0FBTyx5REFBYztBQUNyQjtBQUNBLDJCQUEyQix5REFBYztBQUN6QyxZQUFZLHlEQUFjO0FBQzFCO0FBQ0EsV0FBVyx3REFBZTtBQUMxQixlQUFlLHlEQUFjO0FBQzdCLFdBQVcsMkRBQWdCO0FBQzNCLFlBQVksMkRBQWdCO0FBQzVCLHFCQUFxQix5REFBYztBQUNuQyxxQkFBcUIsMkRBQWdCO0FBQ3JDLGlCQUFpQix5REFBYztBQUMvQixlQUFlLHlEQUFjO0FBQzdCLDJCQUEyQix5REFBYztBQUN6QyxnQkFBZ0IsMkRBQWdCO0FBQ2hDLGlCQUFpQix5REFBYztBQUMvQixxQkFBcUIsMkRBQWdCO0FBQ3JDLHVCQUF1Qix5REFBYztBQUNyQyxxQkFBcUIsMkRBQWdCO0FBQ3JDLGtCQUFrQix5REFBYztBQUNoQyxrQkFBa0IseURBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2Q0FBNkMsVUFBVSxvQkFBb0I7QUFDM0UsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQSxPQUFPLGNBQWM7QUFDckI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBbUI7QUFDN0M7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFtQixzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLHlEQUFlO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksa0RBQVU7QUFDdEIsMkJBQTJCLG1EQUFXO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQVc7QUFDdEMsaUJBQWlCLDhDQUFNO0FBQ3ZCLEVBQUUsaURBQVM7QUFDWDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFLGlEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw2REFBNkQsaUVBQWlFLHNDQUFzQztBQUN2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSztBQUMxZTtBQUNBLGlHQUFpRyxjQUFjO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBTSxDQUFDLCtDQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxvQkFBb0IsK0NBQU87QUFDM0I7QUFDQSw2Q0FBNkMsVUFBVSxvQkFBb0I7QUFDM0UsT0FBTyxJQUFJO0FBQ1gsS0FBSzs7QUFFTDtBQUNBLG9CQUFvQiwrQ0FBTztBQUMzQjtBQUNBLDZDQUE2QyxVQUFVLG9CQUFvQjtBQUMzRSxPQUFPLElBQUk7QUFDWCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQW1CLDhCQUE4QjtBQUN6RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFjO0FBQzVCLFdBQVcseURBQWM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStXO0FBQy9XIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcGl4aS9yZWFjdC9kaXN0L2luZGV4LmVzLWRldi5qcz9lMWUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IERpc3BsYXlPYmplY3QsIENvbnRhaW5lciBhcyBDb250YWluZXIkMyB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgUG9pbnQsIE9ic2VydmFibGVQb2ludCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgQml0bWFwVGV4dCBhcyBCaXRtYXBUZXh0JDMgfSBmcm9tICdAcGl4aS90ZXh0LWJpdG1hcCc7XG5pbXBvcnQgeyBHcmFwaGljcyBhcyBHcmFwaGljcyQzIH0gZnJvbSAnQHBpeGkvZ3JhcGhpY3MnO1xuaW1wb3J0IHsgTmluZVNsaWNlUGxhbmUgYXMgTmluZVNsaWNlUGxhbmUkMywgU2ltcGxlTWVzaCBhcyBTaW1wbGVNZXNoJDMsIFNpbXBsZVJvcGUgYXMgU2ltcGxlUm9wZSQzIH0gZnJvbSAnQHBpeGkvbWVzaC1leHRyYXMnO1xuaW1wb3J0IHsgUGFydGljbGVDb250YWluZXIgYXMgUGFydGljbGVDb250YWluZXIkMyB9IGZyb20gJ0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBTcHJpdGUgYXMgU3ByaXRlJDMgfSBmcm9tICdAcGl4aS9zcHJpdGUnO1xuaW1wb3J0IHsgQW5pbWF0ZWRTcHJpdGUgYXMgQW5pbWF0ZWRTcHJpdGUkMyB9IGZyb20gJ0BwaXhpL3Nwcml0ZS1hbmltYXRlZCc7XG5pbXBvcnQgeyBUZXh0IGFzIFRleHQkMyB9IGZyb20gJ0BwaXhpL3RleHQnO1xuaW1wb3J0IHsgVGlsaW5nU3ByaXRlIGFzIFRpbGluZ1Nwcml0ZSQzIH0gZnJvbSAnQHBpeGkvc3ByaXRlLXRpbGluZyc7XG5pbXBvcnQgeyBEUkFXX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnQHBpeGkvYXBwJztcbmltcG9ydCB7IFRpY2tlciB9IGZyb20gJ0BwaXhpL3RpY2tlcic7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbi8vIGJvcnJvd2VkIGZyb20gZmJqc1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbYXJnSW5kZXgrK10pO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyBTa2lwIGludmFyaWFudCdzIG93biBzdGFjayBmcmFtZS5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuLyoqXG4gKiBsb2Rhc2ggNC4wLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNiBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmlsKG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOaWwodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmlsKE5hTik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbn1cblxudmFyIGxvZGFzaF9pc25pbCA9IGlzTmlsO1xuXG4vKipcbiAqIFBhcnNlIFBJWEkgcG9pbnQgdmFsdWUgdG8gYXJyYXkgb2YgY29vcmRpbmF0ZXNcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlUG9pbnQodmFsdWUpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGFyciA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGFyciA9IFt2YWx1ZV07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnIgPSBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgIHZhciB4ID0gdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS54KSB8fCAwO1xuICAgIHZhciB5ID0gdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS55KSB8fCAwO1xuICAgIGFyciA9IFt4LCB5XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuICFsb2Rhc2hfaXNuaWwocCkgJiYgIWlzTmFOKHApO1xuICB9KS5tYXAoTnVtYmVyKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuICpcbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBwb2ludHNBcmVFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgaWYgKG9sZFZhbHVlLmxlbmd0aCAhPT0gbmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2xkVmFsdWVbaV0gIT09IG5ld1ZhbHVlW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZSB2YWx1ZSBpcyB0eXBlIG9mIFBvaW50IG9yIE9ic2VydmFibGVQb2ludFxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWxvY2htYW4vcmVhY3QtcGl4aS1maWJlci9ibG9iL2E0ZGJkZGJlZjBmZmJmMGY1NjNjNjRkMzA3NjZlYTI4MjIyYTUxZWEvc3JjL3V0aWxzLmpzI0w0OFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BvaW50VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQb2ludCB8fCB2YWx1ZSBpbnN0YW5jZW9mIE9ic2VydmFibGVQb2ludDtcbn1cblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyc1xuICpcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xudmFyIGV2ZW50SGFuZGxlcnMgPSBbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJywgJ21vdXNldXAnLCAnbW91c2V1cG91dHNpZGUnLCAndGFwJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoZW5kb3V0c2lkZScsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJvdXQnLCAncG9pbnRlcm92ZXInLCAncG9pbnRlcnRhcCcsICdwb2ludGVyZG93bicsICdwb2ludGVydXAnLCAncG9pbnRlcnVwb3V0c2lkZScsICdwb2ludGVybW92ZScsICdyaWdodGNsaWNrJywgJ3JpZ2h0ZG93bicsICdyaWdodHVwJywgJ3JpZ2h0dXBvdXRzaWRlJywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoZW5kb3V0c2lkZScsICd0b3VjaG1vdmUnLCAndG91Y2hzdGFydCddO1xuXG4vKipcbiAqIFNldCB2YWx1ZSBvbiBhIFBJWEkuRGlzcGxheU9iamVjdFxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9JenppbWFjaC9yZWFjdC1waXhpL2Jsb2IvYTI1MTk2MjUxYTEzZWQ5YmIxMTZhODU3NmQ5M2U5ZmNlYWMyYTE0Yy9zcmMvUmVhY3RQSVhJLmpzI0wxMTRcbiAqXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlKGluc3RhbmNlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAoaXNQb2ludFR5cGUoaW5zdGFuY2VbcHJvcF0pICYmIGlzUG9pbnRUeXBlKHZhbHVlKSkge1xuICAgIC8vIGNvcHkgdmFsdWVcbiAgICBpbnN0YW5jZVtwcm9wXS5jb3B5RnJvbSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQb2ludFR5cGUoaW5zdGFuY2VbcHJvcF0pKSB7XG4gICAgLy8gcGFyc2UgdmFsdWUgaWYgYSBub24tUG9pbnQgdHlwZSBpcyBiZWluZyBhc3NpZ25lZCB0byBhIFBvaW50IHR5cGVcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwYXJzZVBvaW50KHZhbHVlKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIGNvb3JkaW5hdGVzICE9PSAndW5kZWZpbmVkJyAmJiBjb29yZGluYXRlcy5sZW5ndGggPiAwICYmIGNvb3JkaW5hdGVzLmxlbmd0aCA8IDMsICdUaGUgcHJvcGVydHkgYCVzYCBpcyBhIGBQSVhJLlBvaW50YCBvciBgUElYSS5PYnNlcnZhYmxlUG9pbnRgIGFuZCBtdXN0IGJlIHNldCB0byBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgb2YgJyArICdlaXRoZXIgMSBvciAyIGNvb3JkaW5hdGVzLCBhIDEgb3IgMiBlbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgY29vcmRpbmF0ZXMsIG9yIGEgUElYSSBQb2ludC9PYnNlcnZhYmxlUG9pbnQuICcgKyAnSWYgb25seSBvbmUgY29vcmRpbmF0ZSBpcyBnaXZlbiB0aGVuIFggYW5kIFkgd2lsbCBiZSBzZXQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBSZWNlaXZlZDogYCVzYCBvZiB0eXBlIGAlc2AuJywgcHJvcCwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBfdHlwZW9mKHZhbHVlKSk7XG4gICAgaW5zdGFuY2VbcHJvcF0uc2V0KGNvb3JkaW5hdGVzLnNoaWZ0KCksIGNvb3JkaW5hdGVzLnNoaWZ0KCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGp1c3QgaGFyZCBhc3NpZ24gdmFsdWVcbiAgICBpbnN0YW5jZVtwcm9wXSA9IHZhbHVlO1xuICB9XG59XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gYXJncy5ldmVyeShmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJztcbiAgfSk7XG59O1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59O1xudmFyIGhhc0tleSA9IGZ1bmN0aW9uIGhhc0tleShjb2xsZWN0aW9uKSB7XG4gIHZhciBjb2xsID0gY29sbGVjdGlvbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbGwpKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbGxlY3Rpb24pKSB7XG4gICAgICBjb2xsID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29sbGVjdGlvbiBuZWVkcyB0byBiZSBhbiBBcnJheSBvciBPYmplY3QnKTtcbiAgICB9XG4gIH1cbiAgdmFyIGluZGV4ID0ge307XG4gIGNvbGwuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaW5kZXhba2V5XSA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0eXBlb2YgaW5kZXhba2V5XSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH07XG59O1xudmFyIG5vdCA9IGZ1bmN0aW9uIG5vdChib29sRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIWJvb2xGbi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgX1BST1BTX1JFU0VSVkVEO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbi8qKlxuICogUmVzZXJ2ZWQgcHJvcHNcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgUFJPUFNfUkVTRVJWRUQgPSAoX1BST1BTX1JFU0VSVkVEID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfUFJPUFNfUkVTRVJWRUQsIENISUxEUkVOLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9QUk9QU19SRVNFUlZFRCwgXCJwYXJlbnRcIiwgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfUFJPUFNfUkVTRVJWRUQsIFwid29ybGRBbHBoYVwiLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9QUk9QU19SRVNFUlZFRCwgXCJ3b3JsZFRyYW5zZm9ybVwiLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9QUk9QU19SRVNFUlZFRCwgXCJ3b3JsZFZpc2libGVcIiwgdHJ1ZSksIF9QUk9QU19SRVNFUlZFRCk7XG5cbi8qKlxuICogRGVmYXVsdCBkaXNwbGF5IG9iamVjdCBwcm9wc1xuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWxvY2htYW4vcmVhY3QtcGl4aS1maWJlci9ibG9iL2E0ZGJkZGJlZjBmZmJmMGY1NjNjNjRkMzA3NjZlYTI4MjIyYTUxZWEvc3JjL3Byb3BzLmpzI0w5XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIFBST1BTX0RJU1BMQVlfT0JKRUNUID0ge1xuICBhbHBoYTogMSxcbiAgYnV0dG9uTW9kZTogZmFsc2UsXG4gIGNhY2hlQXNCaXRtYXA6IGZhbHNlLFxuICBjdXJzb3I6IG51bGwsXG4gIGZpbHRlckFyZWE6IG51bGwsXG4gIGZpbHRlcnM6IG51bGwsXG4gIGhpdEFyZWE6IG51bGwsXG4gIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgbWFzazogbnVsbCxcbiAgcGl2b3Q6IDAsXG4gIHBvc2l0aW9uOiAwLFxuICByZW5kZXJhYmxlOiB0cnVlLFxuICByb3RhdGlvbjogMCxcbiAgc2NhbGU6IDEsXG4gIHNrZXc6IDAsXG4gIHRyYW5zZm9ybTogbnVsbCxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgeDogMCxcbiAgeTogMFxufTtcblxuLyoqXG4gKiBIZWxwZXIgdXRpbCBmb3IgZmV0Y2hpbmcgdGhlIHRleHR1cmUgZnJvbSBwcm9wc1xuICogQ2FuIGJlIGVpdGhlciB0ZXh0dXJlIG9yIGltYWdlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlXG4gKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSByb290XG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEByZXR1cm5zIHtQSVhJLlRleHR1cmV8bnVsbH1cbiAqL1xudmFyIGdldFRleHR1cmVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXRUZXh0dXJlRnJvbVByb3BzKGVsZW1lbnRUeXBlLCByb290KSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBlbWl0Q2hhbmdlID0gZnVuY3Rpb24gZW1pdENoYW5nZSh0ZXh0dXJlKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RleHR1cmUkX19yZWFjdHBpeGksIF90ZXh0dXJlJF9fcmVhY3RwaXhpJDtcbiAgICAgIHRleHR1cmUgPT09IG51bGwgfHwgdGV4dHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90ZXh0dXJlJF9fcmVhY3RwaXhpID0gdGV4dHVyZS5fX3JlYWN0cGl4aSkgPT09IG51bGwgfHwgX3RleHR1cmUkX19yZWFjdHBpeGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGV4dHVyZSRfX3JlYWN0cGl4aSQgPSBfdGV4dHVyZSRfX3JlYWN0cGl4aS5yb290KSA9PT0gbnVsbCB8fCBfdGV4dHVyZSRfX3JlYWN0cGl4aSQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90ZXh0dXJlJF9fcmVhY3RwaXhpJC5lbWl0KFwiX19SRUFDVF9QSVhJX1JFUVVFU1RfUkVOREVSX19cIik7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKGluVHlwZSwgdmFsaWRhdG9yKSB7XG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGluVHlwZSkpIHtcbiAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRvci50eXBlb2ZzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIF90eXBlb2YocHJvcHNbaW5UeXBlXSkgPT09IHQ7XG4gICAgICB9KSB8fCB2YWxpZGF0b3IuaW5zdGFuY2VvZnMuc29tZShmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gcHJvcHNbaW5UeXBlXSBpbnN0YW5jZW9mIGk7XG4gICAgICB9KTtcbiAgICAgIGludmFyaWFudCh2YWxpZCwgXCJcIi5jb25jYXQoZWxlbWVudFR5cGUsIFwiIFwiKS5jb25jYXQoaW5UeXBlLCBcIiBwcm9wIGlzIGludmFsaWRcIikpO1xuICAgICAgcmV0dXJuIHByb3BzW2luVHlwZV07XG4gICAgfVxuICB9O1xuICBpZiAocHJvcHMudGV4dHVyZSkge1xuICAgIGludmFyaWFudChwcm9wcy50ZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSwgXCJcIi5jb25jYXQoZWxlbWVudFR5cGUsIFwiIHRleHR1cmUgbmVlZHMgdG8gYmUgdHlwZW9mIGBUZXh0dXJlYFwiKSk7XG4gICAgcmV0dXJuIHByb3BzLnRleHR1cmU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IGNoZWNrKCdpbWFnZScsIHtcbiAgICB0eXBlb2ZzOiBbJ3N0cmluZyddLFxuICAgIGluc3RhbmNlb2ZzOiBbSFRNTEltYWdlRWxlbWVudF1cbiAgfSkgfHwgY2hlY2soJ3ZpZGVvJywge1xuICAgIHR5cGVvZnM6IFsnc3RyaW5nJ10sXG4gICAgaW5zdGFuY2VvZnM6IFtIVE1MVmlkZW9FbGVtZW50XVxuICB9KSB8fCBjaGVjaygnc291cmNlJywge1xuICAgIHR5cGVvZnM6IFsnc3RyaW5nJywgJ251bWJlciddLFxuICAgIGluc3RhbmNlb2ZzOiBbSFRNTEltYWdlRWxlbWVudCwgSFRNTFZpZGVvRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQsIFRleHR1cmVdXG4gIH0pO1xuICBpbnZhcmlhbnQoISFyZXN1bHQsIFwiXCIuY29uY2F0KGVsZW1lbnRUeXBlLCBcIiBjb3VsZCBub3QgZ2V0IHRleHR1cmUgZnJvbSBwcm9wc1wiKSk7XG4gIHZhciB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tKHJlc3VsdCk7XG4gIHRleHR1cmUuX19yZWFjdHBpeGkgPSB7XG4gICAgcm9vdDogcm9vdFxuICB9O1xuICB0ZXh0dXJlLm9uY2UoJ3VwZGF0ZScsIGVtaXRDaGFuZ2UpO1xuICB0ZXh0dXJlLm9uY2UoJ2xvYWRlZCcsIGVtaXRDaGFuZ2UpO1xuICBpZiAodGV4dHVyZS52YWxpZCkge1xuICAgIGVtaXRDaGFuZ2UodGV4dHVyZSk7XG4gIH1cbiAgcmV0dXJuIHRleHR1cmU7XG59O1xudmFyIGZpbHRlclByb3BzID0gbm90KGhhc0tleShbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5rZXlzKFBST1BTX1JFU0VSVkVEKSksIF90b0NvbnN1bWFibGVBcnJheShldmVudEhhbmRsZXJzKSkpKTtcblxuLyoqXG4gKiBBcHBseSBkZWZhdWx0IHByb3BzIG9uIERpc3BsYXkgT2JqZWN0IGluc3RhbmNlICh3aGljaCBhcmUgYWxsIGNvbXBvbmVudHMpXG4gKlxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdQcm9wc1xuICovXG5mdW5jdGlvbiBhcHBseURlZmF1bHRQcm9wcyhpbnN0YW5jZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIGludmFyaWFudChEaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGluc3RhbmNlKSwgJ2luc3RhbmNlIG5lZWRzIHRvIGJlIHR5cGVvZiBgRGlzcGxheU9iamVjdGAsIGdvdCBgJXNgJywgX3R5cGVvZihpbnN0YW5jZSkpO1xuXG4gIC8vIHVwZGF0ZSBldmVudCBoYW5kbGVyc1xuICBpZiAoIW5ld1Byb3BzLmlnbm9yZUV2ZW50cykge1xuICAgIHZhciBoYXNSZW1vdmVMaXN0ZW5lciA9IHR5cGVvZiBpbnN0YW5jZS5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgaGFzT24gPSB0eXBlb2YgaW5zdGFuY2Uub24gPT09ICdmdW5jdGlvbic7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudEhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXZ0ID0gZXZlbnRIYW5kbGVyc1tpXTtcbiAgICAgIGlmIChvbGRQcm9wc1tldnRdICE9PSBuZXdQcm9wc1tldnRdKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIG9sZFByb3BzW2V2dF0gPT09ICdmdW5jdGlvbicgJiYgaGFzUmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICBpbnN0YW5jZS5yZW1vdmVMaXN0ZW5lcihldnQsIG9sZFByb3BzW2V2dF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmV3UHJvcHNbZXZ0XSA9PT0gJ2Z1bmN0aW9uJyAmJiBoYXNPbikge1xuICAgICAgICAgIGluc3RhbmNlLm9uKGV2dCwgbmV3UHJvcHNbZXZ0XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIG5ld1Byb3BLZXlzID0gT2JqZWN0LmtleXMobmV3UHJvcHMgfHwge30pO1xuXG4gIC8vIGhhcmQgb3ZlcndyaXRlIGFsbCBwcm9wcz8gY2FuIHNwZWVkIHVwIHBlcmZvcm1hbmNlXG4gIGlmIChuZXdQcm9wcy5vdmVyd3JpdGVQcm9wcykge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZXdQcm9wS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBwID0gbmV3UHJvcEtleXNbX2ldO1xuICAgICAgaWYgKG9sZFByb3BzW3BdICE9PSBuZXdQcm9wc1twXSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgc2V0VmFsdWUoaW5zdGFuY2UsIHAsIG5ld1Byb3BzW3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBwcmV2aW91c2x5IHRoaXMgcmV0dXJuZWQgbm90aGluZyBpZS4gZmFsc3ksIHNob3VsZCB3ZSBleHBsaWNpdGx5IHJldHVybiBmYWxzZSBoZXJlIGluc3RlYWQgb3Igd2FzIGl0IGFsd2F5c1xuICAgIC8vIGEgc3VidGxlIGJ1ZywgdGVzdCB0aGUgaW50ZW50aW9uXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgdmFyIHByb3BzID0gbmV3UHJvcEtleXMuZmlsdGVyKGZpbHRlclByb3BzKTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbX2kyXTtcbiAgICB2YXIgdmFsdWUgPSBuZXdQcm9wc1twcm9wXTtcbiAgICBpZiAobmV3UHJvcHNbcHJvcF0gIT09IG9sZFByb3BzW3Byb3BdKSB7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHNldCB2YWx1ZSBpZiBkZWZpbmVkXG4gICAgICBzZXRWYWx1ZShpbnN0YW5jZSwgcHJvcCwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBQUk9QU19ESVNQTEFZX09CSkVDVCkge1xuICAgICAgLy8gaXMgYSBkZWZhdWx0IHZhbHVlLCB1c2UgdGhhdFxuICAgICAgY29uc29sZS53YXJuKFwic2V0dGluZyBkZWZhdWx0IHZhbHVlOiBcIi5jb25jYXQocHJvcCwgXCIsIGZyb206IFwiKS5jb25jYXQoaW5zdGFuY2VbcHJvcF0sIFwiIHRvOiBcIikuY29uY2F0KHZhbHVlLCBcIiBmb3JcIiksIGluc3RhbmNlKTtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgc2V0VmFsdWUoaW5zdGFuY2UsIHByb3AsIFBST1BTX0RJU1BMQVlfT0JKRUNUW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiaWdub3JpbmcgcHJvcDogXCIuY29uY2F0KHByb3AsIFwiLCBmcm9tIFwiKS5jb25jYXQoaW5zdGFuY2VbcHJvcF0sIFwiIHRvIFwiKS5jb25jYXQodmFsdWUsIFwiIGZvclwiKSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlZDtcbn1cblxudmFyIEJpdG1hcFRleHQkMSA9IGZ1bmN0aW9uIEJpdG1hcFRleHQocm9vdCwgcHJvcHMpIHtcbiAgdmFyIHRleHQgPSBwcm9wcy50ZXh0LFxuICAgIHN0eWxlID0gcHJvcHMuc3R5bGU7XG4gIHJldHVybiBuZXcgQml0bWFwVGV4dCQzKHRleHQsIHN0eWxlKTtcbn07XG52YXIgQml0bWFwVGV4dCQyID0gQml0bWFwVGV4dCQxO1xuXG52YXIgQ29udGFpbmVyJDEgPSBmdW5jdGlvbiBDb250YWluZXIoKSB7XG4gIHJldHVybiBuZXcgQ29udGFpbmVyJDMoKTtcbn07XG52YXIgQ29udGFpbmVyJDIgPSBDb250YWluZXIkMTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIF9leGNsdWRlZCQ3ID0gW1wiZHJhd1wiLCBcImdlb21ldHJ5XCJdO1xudmFyIEdyYXBoaWNzJDEgPSBmdW5jdGlvbiBHcmFwaGljcyhyb290LCBfcmVmKSB7XG4gIHZhciBnZW9tZXRyeSA9IF9yZWYuZ2VvbWV0cnk7XG4gIGludmFyaWFudCghZ2VvbWV0cnkgfHwgZ2VvbWV0cnkgaW5zdGFuY2VvZiBHcmFwaGljcyQzLCBcIkdyYXBoaWNzIGdlb21ldHJ5IG5lZWRzIHRvIGJlIGEgYFBJWEkuR3JhcGhpY3NgXCIpO1xuICB2YXIgZyA9IGdlb21ldHJ5ID8gbmV3IEdyYXBoaWNzJDMoZ2VvbWV0cnkuZ2VvbWV0cnkpIDogbmV3IEdyYXBoaWNzJDMoKTtcbiAgZy5hcHBseVByb3BzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICB2YXIgZHJhdyA9IG5ld1Byb3BzLmRyYXc7XG4gICAgICBuZXdQcm9wcy5nZW9tZXRyeTtcbiAgICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhuZXdQcm9wcywgX2V4Y2x1ZGVkJDcpO1xuICAgIHZhciBjaGFuZ2VkID0gYXBwbHlEZWZhdWx0UHJvcHMoaW5zdGFuY2UsIG9sZFByb3BzLCBwcm9wcyk7XG4gICAgaWYgKG9sZFByb3BzLmRyYXcgIT09IGRyYXcgJiYgdHlwZW9mIGRyYXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgZHJhdy5jYWxsKGcsIGcpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcbiAgcmV0dXJuIGc7XG59O1xudmFyIEdyYXBoaWNzJDIgPSBHcmFwaGljcyQxO1xuXG52YXIgX2V4Y2x1ZGVkJDYgPSBbXCJpbWFnZVwiLCBcInRleHR1cmVcIl07XG52YXIgTmluZVNsaWNlUGxhbmUkMSA9IGZ1bmN0aW9uIE5pbmVTbGljZVBsYW5lKHJvb3QsIHByb3BzKSB7XG4gIHZhciBfcHJvcHMkbGVmdFdpZHRoID0gcHJvcHMubGVmdFdpZHRoLFxuICAgIGxlZnRXaWR0aCA9IF9wcm9wcyRsZWZ0V2lkdGggPT09IHZvaWQgMCA/IDEwIDogX3Byb3BzJGxlZnRXaWR0aCxcbiAgICBfcHJvcHMkdG9wSGVpZ2h0ID0gcHJvcHMudG9wSGVpZ2h0LFxuICAgIHRvcEhlaWdodCA9IF9wcm9wcyR0b3BIZWlnaHQgPT09IHZvaWQgMCA/IDEwIDogX3Byb3BzJHRvcEhlaWdodCxcbiAgICBfcHJvcHMkcmlnaHRXaWR0aCA9IHByb3BzLnJpZ2h0V2lkdGgsXG4gICAgcmlnaHRXaWR0aCA9IF9wcm9wcyRyaWdodFdpZHRoID09PSB2b2lkIDAgPyAxMCA6IF9wcm9wcyRyaWdodFdpZHRoLFxuICAgIF9wcm9wcyRib3R0b21IZWlnaHQgPSBwcm9wcy5ib3R0b21IZWlnaHQsXG4gICAgYm90dG9tSGVpZ2h0ID0gX3Byb3BzJGJvdHRvbUhlaWdodCA9PT0gdm9pZCAwID8gMTAgOiBfcHJvcHMkYm90dG9tSGVpZ2h0O1xuICB2YXIgdGV4dHVyZSA9IGdldFRleHR1cmVGcm9tUHJvcHMoJ05pbmVTbGljZVBsYW5lJywgcm9vdCwgcHJvcHMpO1xuICB2YXIgbmluZVNsaWNlUGxhbmUgPSBuZXcgTmluZVNsaWNlUGxhbmUkMyh0ZXh0dXJlLCBsZWZ0V2lkdGgsIHRvcEhlaWdodCwgcmlnaHRXaWR0aCwgYm90dG9tSGVpZ2h0KTtcbiAgbmluZVNsaWNlUGxhbmUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgdmFyIGltYWdlID0gbmV3UHJvcHMuaW1hZ2UsXG4gICAgICB0ZXh0dXJlID0gbmV3UHJvcHMudGV4dHVyZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5ld1Byb3BzLCBfZXhjbHVkZWQkNik7XG4gICAgdmFyIGNoYW5nZWQgPSBhcHBseURlZmF1bHRQcm9wcyhpbnN0YW5jZSwgb2xkUHJvcHMsIHByb3BzKTtcbiAgICBpZiAoaW1hZ2UgfHwgdGV4dHVyZSkge1xuICAgICAgLy8gY2hhbmdlID0gdHJ1ZSBub3QgcmVxdWlyZWQgZm9yIGltYWdlLCBnZXRUZXh0dXJlRnJvbVByb3BzIHdpbGwgY2FsbCB1cGRhdGVcbiAgICAgIGlmICh0ZXh0dXJlICE9PSBvbGRQcm9wcy50ZXh0dXJlKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UudGV4dHVyZSA9IGdldFRleHR1cmVGcm9tUHJvcHMoJ05pbmVTbGljZVBsYW5lJywgcm9vdCwgbmV3UHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcbiAgcmV0dXJuIG5pbmVTbGljZVBsYW5lO1xufTtcbnZhciBOaW5lU2xpY2VQbGFuZSQyID0gTmluZVNsaWNlUGxhbmUkMTtcblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBQYXJ0aWNsZUNvbnRhaW5lciQxID0gZnVuY3Rpb24gUGFydGljbGVDb250YWluZXIocm9vdCwgcHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRtYXhTaXplID0gcHJvcHMubWF4U2l6ZSxcbiAgICBtYXhTaXplID0gX3Byb3BzJG1heFNpemUgPT09IHZvaWQgMCA/IDE1MDAgOiBfcHJvcHMkbWF4U2l6ZSxcbiAgICBfcHJvcHMkYmF0Y2hTaXplID0gcHJvcHMuYmF0Y2hTaXplLFxuICAgIGJhdGNoU2l6ZSA9IF9wcm9wcyRiYXRjaFNpemUgPT09IHZvaWQgMCA/IDE2Mzg0IDogX3Byb3BzJGJhdGNoU2l6ZSxcbiAgICBfcHJvcHMkYXV0b1Jlc2l6ZSA9IHByb3BzLmF1dG9SZXNpemUsXG4gICAgYXV0b1Jlc2l6ZSA9IF9wcm9wcyRhdXRvUmVzaXplID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvUmVzaXplO1xuICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIHtcbiAgICB2ZXJ0aWNlczogZmFsc2UsXG4gICAgc2NhbGU6IHRydWUsXG4gICAgcG9zaXRpb246IHRydWUsXG4gICAgcm90YXRpb246IHRydWUsXG4gICAgdXZzOiB0cnVlLFxuICAgIHRpbnQ6IHRydWVcbiAgfSksIHByb3BzLnByb3BlcnRpZXMgfHwge30pO1xuICB2YXIgZGVzdHJveU9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCB7XG4gICAgY2hpbGRyZW46IGZhbHNlLFxuICAgIHRleHR1cmU6IGZhbHNlLFxuICAgIGJhc2VUZXh0dXJlOiBmYWxzZVxuICB9KSwgcHJvcHMuZGVzdHJveU9wdGlvbnMgfHwge30pO1xuICB2YXIgY29udGFpbmVyID0gbmV3IFBhcnRpY2xlQ29udGFpbmVyJDMobWF4U2l6ZSwgcHJvcGVydGllcywgYmF0Y2hTaXplLCBhdXRvUmVzaXplKTtcbiAgY29udGFpbmVyLndpbGxVbm1vdW50ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBjaGlsZCwgcGFyZW50KSB7XG4gICAgaW5zdGFuY2UuZGVzdHJveShkZXN0cm95T3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBjb250YWluZXI7XG59O1xudmFyIFBhcnRpY2xlQ29udGFpbmVyJDIgPSBQYXJ0aWNsZUNvbnRhaW5lciQxO1xuXG52YXIgX2V4Y2x1ZGVkJDUgPSBbXCJpbWFnZVwiLCBcInRleHR1cmVcIl07XG52YXIgU3ByaXRlJDEgPSBmdW5jdGlvbiBTcHJpdGUocm9vdCwgcHJvcHMpIHtcbiAgdmFyIHNwcml0ZSA9IG5ldyBTcHJpdGUkMyhnZXRUZXh0dXJlRnJvbVByb3BzKCdTcHJpdGUnLCByb290LCBwcm9wcykpO1xuICBzcHJpdGUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgdmFyIGltYWdlID0gbmV3UHJvcHMuaW1hZ2UsXG4gICAgICB0ZXh0dXJlID0gbmV3UHJvcHMudGV4dHVyZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5ld1Byb3BzLCBfZXhjbHVkZWQkNSk7XG4gICAgdmFyIGNoYW5nZWQgPSBhcHBseURlZmF1bHRQcm9wcyhpbnN0YW5jZSwgb2xkUHJvcHMsIHByb3BzKTtcbiAgICBpZiAodGV4dHVyZSAmJiBvbGRQcm9wcy50ZXh0dXJlICE9PSBuZXdQcm9wcy50ZXh0dXJlIHx8IGltYWdlICYmIG9sZFByb3BzLmltYWdlICE9PSBuZXdQcm9wcy5pbWFnZSkge1xuICAgICAgLy8gZ2V0VGV4dHVyZUZyb21Qcm9wcyB3aWxsIGNhbGwgdXBkYXRlIGZvciBpbWFnZVxuICAgICAgaWYgKG9sZFByb3BzLnRleHR1cmUgIT09IG5ld1Byb3BzLnRleHR1cmUpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS50ZXh0dXJlID0gZ2V0VGV4dHVyZUZyb21Qcm9wcygnU3ByaXRlJywgcm9vdCwgbmV3UHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcbiAgcmV0dXJuIHNwcml0ZTtcbn07XG52YXIgU3ByaXRlJDIgPSBTcHJpdGUkMTtcblxudmFyIF9leGNsdWRlZCQ0ID0gW1widGV4dHVyZXNcIiwgXCJpc1BsYXlpbmdcIiwgXCJpbml0aWFsRnJhbWVcIl07XG52YXIgQW5pbWF0ZWRTcHJpdGUkMSA9IGZ1bmN0aW9uIEFuaW1hdGVkU3ByaXRlKHJvb3QsIHByb3BzKSB7XG4gIHZhciB0ZXh0dXJlcyA9IHByb3BzLnRleHR1cmVzLFxuICAgIGltYWdlcyA9IHByb3BzLmltYWdlcyxcbiAgICBfcHJvcHMkaXNQbGF5aW5nID0gcHJvcHMuaXNQbGF5aW5nLFxuICAgIGlzUGxheWluZyA9IF9wcm9wcyRpc1BsYXlpbmcgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkaXNQbGF5aW5nLFxuICAgIGluaXRpYWxGcmFtZSA9IHByb3BzLmluaXRpYWxGcmFtZTtcbiAgdmFyIG1ha2VUZXh0dXJlID0gZnVuY3Rpb24gbWFrZVRleHR1cmUodGV4dHVyZXMpIHtcbiAgICByZXR1cm4gdGV4dHVyZXMubWFwKGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICBpbnZhcmlhbnQodGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUgfHwgKHRleHR1cmUgPT09IG51bGwgfHwgdGV4dHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dHVyZS50ZXh0dXJlKSwgXCJBbmltYXRpb25TcHJpdGUgdGV4dHVyZSBuZWVkcyB0byBiZSBhbiBhcnJheSBvZiBgUElYSS5UZXh0dXJlYCBvciBgeyB0ZXh0dXJlOiBQSVhJLlRleHR1cmUsIHRpbWU6XFxuICAgICAgICAgICAgICAgIG51bWJlciB9YFwiKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICB9O1xuICB2YXIgYW5pbWF0ZWRTcHJpdGUgPSBpbWFnZXMgPyBBbmltYXRlZFNwcml0ZSQzLmZyb21JbWFnZXMoaW1hZ2VzKSA6IG5ldyBBbmltYXRlZFNwcml0ZSQzKG1ha2VUZXh0dXJlKHRleHR1cmVzKSk7XG4gIGFuaW1hdGVkU3ByaXRlW2lzUGxheWluZyA/ICdnb3RvQW5kUGxheScgOiAnZ290b0FuZFN0b3AnXShpbml0aWFsRnJhbWUgfHwgMCk7XG4gIGFuaW1hdGVkU3ByaXRlLmFwcGx5UHJvcHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIHZhciB0ZXh0dXJlcyA9IG5ld1Byb3BzLnRleHR1cmVzLFxuICAgICAgaXNQbGF5aW5nID0gbmV3UHJvcHMuaXNQbGF5aW5nLFxuICAgICAgaW5pdGlhbEZyYW1lID0gbmV3UHJvcHMuaW5pdGlhbEZyYW1lLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobmV3UHJvcHMsIF9leGNsdWRlZCQ0KTtcbiAgICB2YXIgY2hhbmdlZCA9IGFwcGx5RGVmYXVsdFByb3BzKGluc3RhbmNlLCBvbGRQcm9wcywgcHJvcHMpO1xuICAgIGlmICh0ZXh0dXJlcyAmJiBvbGRQcm9wcy50ZXh0dXJlcyAhPT0gdGV4dHVyZXMpIHtcbiAgICAgIGluc3RhbmNlLnRleHR1cmVzID0gbWFrZVRleHR1cmUodGV4dHVyZXMpO1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc1BsYXlpbmcgIT09IG9sZFByb3BzLmlzUGxheWluZyB8fCBpbml0aWFsRnJhbWUgIT09IG9sZFByb3BzLmluaXRpYWxGcmFtZSkge1xuICAgICAgdmFyIGZyYW1lID0gdHlwZW9mIGluaXRpYWxGcmFtZSA9PT0gJ251bWJlcicgPyBpbml0aWFsRnJhbWUgOiBhbmltYXRlZFNwcml0ZS5jdXJyZW50RnJhbWUgfHwgMDtcbiAgICAgIGFuaW1hdGVkU3ByaXRlW2lzUGxheWluZyA/ICdnb3RvQW5kUGxheScgOiAnZ290b0FuZFN0b3AnXShmcmFtZSk7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG4gIHJldHVybiBhbmltYXRlZFNwcml0ZTtcbn07XG52YXIgQW5pbWF0ZWRTcHJpdGUkMiA9IEFuaW1hdGVkU3ByaXRlJDE7XG5cbnZhciBUZXh0JDEgPSBmdW5jdGlvbiBUZXh0KHJvb3QsIHByb3BzKSB7XG4gIHZhciBfcHJvcHMkdGV4dCA9IHByb3BzLnRleHQsXG4gICAgdGV4dCA9IF9wcm9wcyR0ZXh0ID09PSB2b2lkIDAgPyAnJyA6IF9wcm9wcyR0ZXh0LFxuICAgIF9wcm9wcyRzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgIHN0eWxlID0gX3Byb3BzJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRzdHlsZSxcbiAgICBpc1Nwcml0ZSA9IHByb3BzLmlzU3ByaXRlO1xuICB2YXIgcGl4aVRleHQgPSBuZXcgVGV4dCQzKHRleHQsIHN0eWxlKTtcbiAgaWYgKGlzU3ByaXRlKSB7XG4gICAgcGl4aVRleHQudXBkYXRlVGV4dCgpO1xuICAgIHJldHVybiBuZXcgU3ByaXRlJDMocGl4aVRleHQudGV4dHVyZSk7XG4gIH1cbiAgcmV0dXJuIHBpeGlUZXh0O1xufTtcbnZhciBUZXh0JDIgPSBUZXh0JDE7XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcInRpbGVTY2FsZVwiLCBcInRpbGVQb3NpdGlvblwiLCBcImltYWdlXCIsIFwidGV4dHVyZVwiXTtcbnZhciBUaWxpbmdTcHJpdGUkMSA9IGZ1bmN0aW9uIFRpbGluZ1Nwcml0ZShyb290LCBwcm9wcykge1xuICB2YXIgX3Byb3BzJHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgd2lkdGggPSBfcHJvcHMkd2lkdGggPT09IHZvaWQgMCA/IDEwMCA6IF9wcm9wcyR3aWR0aCxcbiAgICBfcHJvcHMkaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgIGhlaWdodCA9IF9wcm9wcyRoZWlnaHQgPT09IHZvaWQgMCA/IDEwMCA6IF9wcm9wcyRoZWlnaHQ7XG4gIHZhciB0ZXh0dXJlID0gZ2V0VGV4dHVyZUZyb21Qcm9wcygnVGlsaW5nU3ByaXRlJywgcm9vdCwgcHJvcHMpO1xuICB2YXIgdHMgPSBuZXcgVGlsaW5nU3ByaXRlJDModGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gIHRzLmFwcGx5UHJvcHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIHZhciB0aWxlU2NhbGUgPSBuZXdQcm9wcy50aWxlU2NhbGUsXG4gICAgICB0aWxlUG9zaXRpb24gPSBuZXdQcm9wcy50aWxlUG9zaXRpb24sXG4gICAgICBpbWFnZSA9IG5ld1Byb3BzLmltYWdlLFxuICAgICAgdGV4dHVyZSA9IG5ld1Byb3BzLnRleHR1cmUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhuZXdQcm9wcywgX2V4Y2x1ZGVkJDMpO1xuICAgIHZhciBjaGFuZ2VkID0gYXBwbHlEZWZhdWx0UHJvcHMoaW5zdGFuY2UsIG9sZFByb3BzLCBwcm9wcyk7XG4gICAgaWYgKHRpbGVQb3NpdGlvbikge1xuICAgICAgdmFyIF9pbnN0YW5jZSR0aWxlUG9zaXRpbztcbiAgICAgIHZhciBuZXdUaWxlUG9zaXRpb24gPSBwYXJzZVBvaW50KHRpbGVQb3NpdGlvbik7XG4gICAgICAoX2luc3RhbmNlJHRpbGVQb3NpdGlvID0gaW5zdGFuY2UudGlsZVBvc2l0aW9uKS5zZXQuYXBwbHkoX2luc3RhbmNlJHRpbGVQb3NpdGlvLCBfdG9Db25zdW1hYmxlQXJyYXkobmV3VGlsZVBvc2l0aW9uKSk7XG4gICAgICBjaGFuZ2VkID0gIXBvaW50c0FyZUVxdWFsKHBhcnNlUG9pbnQob2xkUHJvcHMudGlsZVBvc2l0aW9uKSwgbmV3VGlsZVBvc2l0aW9uKSB8fCBjaGFuZ2VkO1xuICAgIH1cbiAgICBpZiAodGlsZVNjYWxlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHRpbGVTY2FsZTtcbiAgICAgIHZhciBuZXdUaWxlU2NhbGUgPSBwYXJzZVBvaW50KHRpbGVTY2FsZSk7XG4gICAgICAoX2luc3RhbmNlJHRpbGVTY2FsZSA9IGluc3RhbmNlLnRpbGVTY2FsZSkuc2V0LmFwcGx5KF9pbnN0YW5jZSR0aWxlU2NhbGUsIF90b0NvbnN1bWFibGVBcnJheShuZXdUaWxlU2NhbGUpKTtcbiAgICAgIGNoYW5nZWQgPSAhcG9pbnRzQXJlRXF1YWwocGFyc2VQb2ludChvbGRQcm9wcy50aWxlU2NhbGUpLCBuZXdUaWxlU2NhbGUpIHx8IGNoYW5nZWQ7XG4gICAgfVxuICAgIGlmIChpbWFnZSB8fCB0ZXh0dXJlKSB7XG4gICAgICAvLyBjaGFuZ2UgPSB0cnVlIG5vdCByZXF1aXJlZCBmb3IgaW1hZ2UsIGdldFRleHR1cmVGcm9tUHJvcHMgd2lsbCBjYWxsIHVwZGF0ZVxuICAgICAgaWYgKHRleHR1cmUgIT09IG9sZFByb3BzLnRleHR1cmUpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS50ZXh0dXJlID0gZ2V0VGV4dHVyZUZyb21Qcm9wcygnU3ByaXRlJywgcm9vdCwgbmV3UHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcbiAgcmV0dXJuIHRzO1xufTtcbnZhciBUaWxpbmdTcHJpdGUkMiA9IFRpbGluZ1Nwcml0ZSQxO1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJpbWFnZVwiLCBcInRleHR1cmVcIl07XG52YXIgU2ltcGxlTWVzaCQxID0gZnVuY3Rpb24gU2ltcGxlTWVzaChyb290LCBwcm9wcykge1xuICB2YXIgdGV4dHVyZSA9IGdldFRleHR1cmVGcm9tUHJvcHMoJ01lc2gnLCByb290LCBwcm9wcyk7XG4gIHZhciB2ZXJ0aWNlcyA9IHByb3BzLnZlcnRpY2VzLFxuICAgIHV2cyA9IHByb3BzLnV2cyxcbiAgICBpbmRpY2VzID0gcHJvcHMuaW5kaWNlcyxcbiAgICBfcHJvcHMkZHJhd01vZGUgPSBwcm9wcy5kcmF3TW9kZSxcbiAgICBkcmF3TW9kZSA9IF9wcm9wcyRkcmF3TW9kZSA9PT0gdm9pZCAwID8gRFJBV19NT0RFUy5UUklBTkdMRVMgOiBfcHJvcHMkZHJhd01vZGU7XG4gIHZhciBzaW1wbGVNZXNoID0gbmV3IFNpbXBsZU1lc2gkMyh0ZXh0dXJlLCB2ZXJ0aWNlcywgdXZzLCBpbmRpY2VzLCBkcmF3TW9kZSk7XG4gIHNpbXBsZU1lc2guYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgdmFyIGltYWdlID0gbmV3UHJvcHMuaW1hZ2UsXG4gICAgICB0ZXh0dXJlID0gbmV3UHJvcHMudGV4dHVyZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5ld1Byb3BzLCBfZXhjbHVkZWQkMik7XG4gICAgdmFyIGNoYW5nZWQgPSBhcHBseURlZmF1bHRQcm9wcyhpbnN0YW5jZSwgb2xkUHJvcHMsIHByb3BzKTtcbiAgICBpZiAoaW1hZ2UgfHwgdGV4dHVyZSkge1xuICAgICAgLy8gY2hhbmdlID0gdHJ1ZSBub3QgcmVxdWlyZWQgZm9yIGltYWdlLCBnZXRUZXh0dXJlRnJvbVByb3BzIHdpbGwgY2FsbCB1cGRhdGVcbiAgICAgIGlmICh0ZXh0dXJlICE9PSBvbGRQcm9wcy50ZXh0dXJlKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UudGV4dHVyZSA9IGdldFRleHR1cmVGcm9tUHJvcHMoJ01lc2gnLCByb290LCBuZXdQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xuICByZXR1cm4gc2ltcGxlTWVzaDtcbn07XG52YXIgU2ltcGxlTWVzaCQyID0gU2ltcGxlTWVzaCQxO1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJpbWFnZVwiLCBcInRleHR1cmVcIl07XG52YXIgU2ltcGxlUm9wZSQxID0gZnVuY3Rpb24gU2ltcGxlUm9wZShyb290LCBwcm9wcykge1xuICB2YXIgdGV4dHVyZSA9IGdldFRleHR1cmVGcm9tUHJvcHMoJ1NpbXBsZVJvcGUnLCByb290LCBwcm9wcyk7XG4gIHZhciBwb2ludHMgPSBwcm9wcy5wb2ludHM7XG4gIHZhciByb3BlID0gbmV3IFNpbXBsZVJvcGUkMyh0ZXh0dXJlLCBwb2ludHMpO1xuICByb3BlLmFwcGx5UHJvcHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIHZhciBpbWFnZSA9IG5ld1Byb3BzLmltYWdlLFxuICAgICAgdGV4dHVyZSA9IG5ld1Byb3BzLnRleHR1cmUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhuZXdQcm9wcywgX2V4Y2x1ZGVkJDEpO1xuICAgIGludmFyaWFudChBcnJheS5pc0FycmF5KG5ld1Byb3BzLnBvaW50cyksICdTaW1wbGVSb3BlIHBvaW50cyBuZWVkcyB0byBiZSAlcycsICdBcnJheTxQSVhJLlBvaW50PicpO1xuICAgIHZhciBjaGFuZ2VkID0gYXBwbHlEZWZhdWx0UHJvcHMoaW5zdGFuY2UsIG9sZFByb3BzLCBwcm9wcyk7XG4gICAgaWYgKGltYWdlIHx8IHRleHR1cmUpIHtcbiAgICAgIGlmICh0ZXh0dXJlICE9PSBvbGRQcm9wcy50ZXh0dXJlKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UudGV4dHVyZSA9IGdldFRleHR1cmVGcm9tUHJvcHMoJ1NpbXBsZVJvcGUnLCByb290LCBuZXdQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xuICByZXR1cm4gcm9wZTtcbn07XG52YXIgU2ltcGxlUm9wZSQyID0gU2ltcGxlUm9wZSQxO1xuXG52YXIgY29tcG9uZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBCaXRtYXBUZXh0OiBCaXRtYXBUZXh0JDIsXG4gIENvbnRhaW5lcjogQ29udGFpbmVyJDIsXG4gIEdyYXBoaWNzOiBHcmFwaGljcyQyLFxuICBOaW5lU2xpY2VQbGFuZTogTmluZVNsaWNlUGxhbmUkMixcbiAgUGFydGljbGVDb250YWluZXI6IFBhcnRpY2xlQ29udGFpbmVyJDIsXG4gIFNwcml0ZTogU3ByaXRlJDIsXG4gIFRleHQ6IFRleHQkMixcbiAgVGlsaW5nU3ByaXRlOiBUaWxpbmdTcHJpdGUkMixcbiAgU2ltcGxlTWVzaDogU2ltcGxlTWVzaCQyLFxuICBTaW1wbGVSb3BlOiBTaW1wbGVSb3BlJDIsXG4gIEFuaW1hdGVkU3ByaXRlOiBBbmltYXRlZFNwcml0ZSQyXG59KTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBBdmFpbGFibGUgdGFnIHR5cGVzXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIFRZUEVTID0ge1xuICBCaXRtYXBUZXh0OiAnQml0bWFwVGV4dCcsXG4gIENvbnRhaW5lcjogJ0NvbnRhaW5lcicsXG4gIEdyYXBoaWNzOiAnR3JhcGhpY3MnLFxuICBOaW5lU2xpY2VQbGFuZTogJ05pbmVTbGljZVBsYW5lJyxcbiAgUGFydGljbGVDb250YWluZXI6ICdQYXJ0aWNsZUNvbnRhaW5lcicsXG4gIFNwcml0ZTogJ1Nwcml0ZScsXG4gIEFuaW1hdGVkU3ByaXRlOiAnQW5pbWF0ZWRTcHJpdGUnLFxuICBUZXh0OiAnVGV4dCcsXG4gIFRpbGluZ1Nwcml0ZTogJ1RpbGluZ1Nwcml0ZScsXG4gIFNpbXBsZU1lc2g6ICdTaW1wbGVNZXNoJyxcbiAgU2ltcGxlUm9wZTogJ1NpbXBsZVJvcGUnXG59O1xudmFyIEVMRU1FTlRTID0gT2JqZWN0LmtleXMoVFlQRVMpLnJlZHVjZShmdW5jdGlvbiAoZWxlbWVudHMsIHR5cGUpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIGVsZW1lbnRzKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdHlwZSwgY29tcG9uZW50c1t0eXBlXSkpO1xufSwge30pO1xuXG4vKipcbiAqIEluamVjdCB0eXBlc1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBUWVBFU19JTkpFQ1RFRCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50IGJhc2VkIG9uIHRhZyB0eXBlXG4gKiBTaW1pbGFyIHRvIHJlYWN0LWRvbSdzIGBSZWFjdC5jcmVhdGVFbGVtZW50KClgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWxlbWVudCB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQ29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gcm9vdCBSb290IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgcm9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdmFyIGZuID0gRUxFTUVOVFNbdHlwZV07XG4gIHZhciBpbnN0YW5jZTtcbiAgdmFyIGFwcGx5UHJvcHM7XG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZSA9IGZuKHJvb3QsIHByb3BzKTtcbiAgfVxuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgLy8gbm90IGZvdW5kLCBpcyB0aGVyZSBhbnkgaW5qZWN0ZWQgY3VzdG9tIGNvbXBvbmVudD9cbiAgICB2YXIgaW5qZWN0ZWQgPSBUWVBFU19JTkpFQ1RFRFt0eXBlXTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGluc3RhbmNlID0gaW5qZWN0ZWQuY3JlYXRlKHByb3BzKTtcbiAgICAgIGluc3RhbmNlLmRpZE1vdW50ID0gaW5qZWN0ZWQuZGlkTW91bnQgPyBpbmplY3RlZC5kaWRNb3VudC5iaW5kKGluc3RhbmNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGluc3RhbmNlLndpbGxVbm1vdW50ID0gaW5qZWN0ZWQud2lsbFVubW91bnQgPyBpbmplY3RlZC53aWxsVW5tb3VudC5iaW5kKGluc3RhbmNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGluc3RhbmNlLmFwcGx5UHJvcHMgPSBpbmplY3RlZC5hcHBseVByb3BzID8gaW5qZWN0ZWQuYXBwbHlQcm9wcy5iaW5kKGluc3RhbmNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGluc3RhbmNlLmNvbmZpZyA9IGluamVjdGVkLmNvbmZpZztcbiAgICB9XG4gIH1cblxuICAvLyBhcHBseSBpbml0aWFsIHByb3BzIVxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlO1xuICAgIGFwcGx5UHJvcHMgPSB0eXBlb2YgKChfaW5zdGFuY2UgPSBpbnN0YW5jZSkgPT09IG51bGwgfHwgX2luc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5zdGFuY2UuYXBwbHlQcm9wcykgPT09ICdmdW5jdGlvbicgPyBpbnN0YW5jZS5hcHBseVByb3BzIDogYXBwbHlEZWZhdWx0UHJvcHM7XG4gICAgYXBwbHlQcm9wcyhpbnN0YW5jZSwge30sIHByb3BzKTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0cGl4aSA9IHtcbiAgICAgIHJvb3Q6IHJvb3RcbiAgICB9O1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgQ29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWZlY3ljbGUgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBQaXhpQ29tcG9uZW50KHR5cGUsIGxpZmVjeWNsZSkge1xuICBpbnZhcmlhbnQoISF0eXBlLCAnRXhwZWN0IHR5cGUgdG8gYmUgZGVmaW5lZCwgZ290IGAlc2AnLCB0eXBlKTtcbiAgaW52YXJpYW50KCFUWVBFU1t0eXBlXSwgJ0NvbXBvbmVudCBgJXNgIGNvdWxkIG5vdCBiZSBjcmVhdGVkLCBhbHJlYWR5IGV4aXN0cyBpbiBkZWZhdWx0IGNvbXBvbmVudHMuJywgdHlwZSk7XG4gIFRZUEVTX0lOSkVDVEVEW3R5cGVdID0gbGlmZWN5Y2xlO1xuICByZXR1cm4gdHlwZTtcbn1cblxudmFyIHJlYWN0UmVjb25jaWxlckV4cG9ydHMgPSB7fTtcbnZhciByZWFjdFJlY29uY2lsZXIgPSB7XG4gIGdldCBleHBvcnRzKCl7IHJldHVybiByZWFjdFJlY29uY2lsZXJFeHBvcnRzOyB9LFxuICBzZXQgZXhwb3J0cyh2KXsgcmVhY3RSZWNvbmNpbGVyRXhwb3J0cyA9IHY7IH0sXG59O1xuXG52YXIgc2NoZWR1bGVyRXhwb3J0cyA9IHt9O1xudmFyIHNjaGVkdWxlciA9IHtcbiAgZ2V0IGV4cG9ydHMoKXsgcmV0dXJuIHNjaGVkdWxlckV4cG9ydHM7IH0sXG4gIHNldCBleHBvcnRzKHYpeyBzY2hlZHVsZXJFeHBvcnRzID0gdjsgfSxcbn07XG5cbnZhciBzY2hlZHVsZXJfZGV2ZWxvcG1lbnQgPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkU2NoZWR1bGVyX2RldmVsb3BtZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlU2NoZWR1bGVyX2RldmVsb3BtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2NoZWR1bGVyX2RldmVsb3BtZW50KSByZXR1cm4gc2NoZWR1bGVyX2RldmVsb3BtZW50O1xuXHRoYXNSZXF1aXJlZFNjaGVkdWxlcl9kZXZlbG9wbWVudCA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG5cdFx0e1xuXHRcdCAgKGZ1bmN0aW9uKCkge1xuXG5cdFx0LyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuXHRcdGlmIChcblx0XHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdFx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cblx0XHQgICAgJ2Z1bmN0aW9uJ1xuXHRcdCkge1xuXHRcdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG5cdFx0fVxuXHRcdCAgICAgICAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG5cdFx0dmFyIGVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xuXHRcdHZhciBmcmFtZVlpZWxkTXMgPSA1O1xuXG5cdFx0ZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG5cdFx0ICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcblx0XHQgIGhlYXAucHVzaChub2RlKTtcblx0XHQgIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuXHRcdCAgcmV0dXJuIGhlYXAubGVuZ3RoID09PSAwID8gbnVsbCA6IGhlYXBbMF07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHBvcChoZWFwKSB7XG5cdFx0ICBpZiAoaGVhcC5sZW5ndGggPT09IDApIHtcblx0XHQgICAgcmV0dXJuIG51bGw7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBmaXJzdCA9IGhlYXBbMF07XG5cdFx0ICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cblx0XHQgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuXHRcdCAgICBoZWFwWzBdID0gbGFzdDtcblx0XHQgICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBmaXJzdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuXHRcdCAgdmFyIGluZGV4ID0gaTtcblxuXHRcdCAgd2hpbGUgKGluZGV4ID4gMCkge1xuXHRcdCAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG5cdFx0ICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuXHRcdCAgICBpZiAoY29tcGFyZShwYXJlbnQsIG5vZGUpID4gMCkge1xuXHRcdCAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cblx0XHQgICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG5cdFx0ICAgICAgaGVhcFtpbmRleF0gPSBwYXJlbnQ7XG5cdFx0ICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICAvLyBUaGUgcGFyZW50IGlzIHNtYWxsZXIuIEV4aXQuXG5cdFx0ICAgICAgcmV0dXJuO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuXHRcdCAgdmFyIGluZGV4ID0gaTtcblx0XHQgIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcblx0XHQgIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuXG5cdFx0ICB3aGlsZSAoaW5kZXggPCBoYWxmTGVuZ3RoKSB7XG5cdFx0ICAgIHZhciBsZWZ0SW5kZXggPSAoaW5kZXggKyAxKSAqIDIgLSAxO1xuXHRcdCAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcblx0XHQgICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuXHRcdCAgICB2YXIgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdOyAvLyBJZiB0aGUgbGVmdCBvciByaWdodCBub2RlIGlzIHNtYWxsZXIsIHN3YXAgd2l0aCB0aGUgc21hbGxlciBvZiB0aG9zZS5cblxuXHRcdCAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcblx0XHQgICAgICBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcblx0XHQgICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG5cdFx0ICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcblx0XHQgICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcblx0XHQgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuXHRcdCAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcblx0XHQgICAgICAgIGluZGV4ID0gbGVmdEluZGV4O1xuXHRcdCAgICAgIH1cblx0XHQgICAgfSBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuXHRcdCAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG5cdFx0ICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG5cdFx0ICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cblx0XHQgICAgICByZXR1cm47XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcblx0XHQgIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuXHRcdCAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuXHRcdCAgcmV0dXJuIGRpZmYgIT09IDAgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogVXNlIHN5bWJvbHM/XG5cdFx0dmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gMTtcblx0XHR2YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xuXHRcdHZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG5cdFx0dmFyIExvd1ByaW9yaXR5ID0gNDtcblx0XHR2YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuXHRcdGZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xuXHRcdH1cblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG5cdFx0dmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5cdFx0aWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG5cdFx0ICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG5cdFx0ICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0ICB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0ICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcblx0XHQgIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuXHRcdCAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcblx0XHQgIH07XG5cdFx0fSAvLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cblx0XHQvLyBNYXRoLnBvdygyLCAzMCkgLSAxXG5cdFx0Ly8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuXG5cdFx0dmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cblx0XHR2YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxuXHRcdHZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG5cdFx0dmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcblx0XHR2YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cblx0XHR2YXIgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG5cdFx0dmFyIHRhc2tRdWV1ZSA9IFtdO1xuXHRcdHZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxuXHRcdHZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuXHRcdHZhciBjdXJyZW50VGFzayA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jZS5cblxuXHRcdHZhciBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG5cdFx0dmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cdFx0dmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTsgLy8gQ2FwdHVyZSBsb2NhbCByZWZlcmVuY2VzIHRvIG5hdGl2ZSBBUElzLCBpbiBjYXNlIGEgcG9seWZpbGwgb3ZlcnJpZGVzIHRoZW0uXG5cblx0XHR2YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogbnVsbDtcblx0XHR2YXIgbG9jYWxDbGVhclRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogbnVsbDtcblx0XHR2YXIgbG9jYWxTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyA/IHNldEltbWVkaWF0ZSA6IG51bGw7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cblxuXHRcdHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCA/IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpIDogbnVsbDtcblxuXHRcdGZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcblx0XHQgIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuXHRcdCAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuXHRcdCAgd2hpbGUgKHRpbWVyICE9PSBudWxsKSB7XG5cdFx0ICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuXHRcdCAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG5cdFx0ICAgICAgcG9wKHRpbWVyUXVldWUpO1xuXHRcdCAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuXHRcdCAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cblx0XHQgICAgICBwb3AodGltZXJRdWV1ZSk7XG5cdFx0ICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG5cdFx0ICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuXHRcdCAgICAgIHJldHVybjtcblx0XHQgICAgfVxuXG5cdFx0ICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG5cdFx0ICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG5cdFx0ICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcblxuXHRcdCAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuXHRcdCAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG5cdFx0ICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuXHRcdCAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cblx0XHQgICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuXHRcdCAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuXG5cblx0XHQgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cblx0XHQgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG5cdFx0ICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuXHRcdCAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG5cdFx0ICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG5cdFx0ICB9XG5cblx0XHQgIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuXHRcdCAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuXG5cdFx0ICB0cnkge1xuXHRcdCAgICB2YXIgY3VycmVudFRpbWU7IGlmIChlbmFibGVQcm9maWxpbmcpIDsgZWxzZSB7XG5cdFx0ICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG5cdFx0ICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcblx0XHQgICAgfVxuXHRcdCAgfSBmaW5hbGx5IHtcblx0XHQgICAgY3VycmVudFRhc2sgPSBudWxsO1xuXHRcdCAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcblx0XHQgICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG5cdFx0ICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcblx0XHQgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXHRcdCAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG5cblx0XHQgIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG5cdFx0ICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmICghaGFzVGltZVJlbWFpbmluZyB8fCBzaG91bGRZaWVsZFRvSG9zdCgpKSkge1xuXHRcdCAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cblx0XHQgICAgICBicmVhaztcblx0XHQgICAgfVxuXG5cdFx0ICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG5cdFx0ICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG5cdFx0ICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuXHRcdCAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG5cblx0XHQgICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0KTtcblx0XHQgICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cblx0XHQgICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuXHRcdCAgICAgIH0gZWxzZSB7XG5cblx0XHQgICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG5cdFx0ICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH1cblxuXHRcdCAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIHBvcCh0YXNrUXVldWUpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG5cdFx0ICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuXHRcdCAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG5cdFx0ICAgIHJldHVybiB0cnVlO1xuXHRcdCAgfSBlbHNlIHtcblx0XHQgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG5cdFx0ICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG5cdFx0ICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcblx0XHQgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuXHRcdCAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuXHRcdCAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuXHRcdCAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuXHRcdCAgICBjYXNlIExvd1ByaW9yaXR5OlxuXHRcdCAgICBjYXNlIElkbGVQcmlvcml0eTpcblx0XHQgICAgICBicmVhaztcblxuXHRcdCAgICBkZWZhdWx0OlxuXHRcdCAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcblx0XHQgIH1cblxuXHRcdCAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuXHRcdCAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG5cdFx0ICB0cnkge1xuXHRcdCAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG5cdFx0ICB9IGZpbmFsbHkge1xuXHRcdCAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuXHRcdCAgdmFyIHByaW9yaXR5TGV2ZWw7XG5cblx0XHQgIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcblx0XHQgICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcblx0XHQgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcblx0XHQgICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcblx0XHQgICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuXHRcdCAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcblx0XHQgICAgICBicmVhaztcblxuXHRcdCAgICBkZWZhdWx0OlxuXHRcdCAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG5cdFx0ICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuXHRcdCAgICAgIGJyZWFrO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cdFx0ICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cblx0XHQgIHRyeSB7XG5cdFx0ICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcblx0XHQgIH0gZmluYWxseSB7XG5cdFx0ICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuXHRcdCAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblx0XHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG5cdFx0ICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblx0XHQgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG5cdFx0ICAgIHRyeSB7XG5cdFx0ICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0ICAgIH0gZmluYWxseSB7XG5cdFx0ICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG5cdFx0ICAgIH1cblx0XHQgIH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuXHRcdCAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblx0XHQgIHZhciBzdGFydFRpbWU7XG5cblx0XHQgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuXHRcdCAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG5cdFx0ICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuXHRcdCAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG5cdFx0ICAgIH1cblx0XHQgIH0gZWxzZSB7XG5cdFx0ICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgdGltZW91dDtcblxuXHRcdCAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG5cdFx0ICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG5cdFx0ICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuXHRcdCAgICAgIGJyZWFrO1xuXG5cdFx0ICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG5cdFx0ICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcblx0XHQgICAgICBicmVhaztcblxuXHRcdCAgICBjYXNlIElkbGVQcmlvcml0eTpcblx0XHQgICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuXHRcdCAgICAgIGJyZWFrO1xuXG5cdFx0ICAgIGNhc2UgTG93UHJpb3JpdHk6XG5cdFx0ICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuXHRcdCAgICAgIGJyZWFrO1xuXG5cdFx0ICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG5cdFx0ICAgIGRlZmF1bHQ6XG5cdFx0ICAgICAgdGltZW91dCA9IE5PUk1BTF9QUklPUklUWV9USU1FT1VUO1xuXHRcdCAgICAgIGJyZWFrO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xuXHRcdCAgdmFyIG5ld1Rhc2sgPSB7XG5cdFx0ICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG5cdFx0ICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHQgICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcblx0XHQgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG5cdFx0ICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcblx0XHQgICAgc29ydEluZGV4OiAtMVxuXHRcdCAgfTtcblxuXHRcdCAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG5cdFx0ICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG5cdFx0ICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuXHRcdCAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG5cdFx0ICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuXHRcdCAgICAgIC8vIEFsbCB0YXNrcyBhcmUgZGVsYXllZCwgYW5kIHRoaXMgaXMgdGhlIHRhc2sgd2l0aCB0aGUgZWFybGllc3QgZGVsYXkuXG5cdFx0ICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcblx0XHQgICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuXHRcdCAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcblx0XHQgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG5cdFx0ICAgICAgfSAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG5cblxuXHRcdCAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG5cdFx0ICAgIH1cblx0XHQgIH0gZWxzZSB7XG5cdFx0ICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG5cdFx0ICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcblx0XHQgICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG5cblx0XHQgICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuXHRcdCAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcblx0XHQgICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIG5ld1Rhc2s7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zdGFibGVfY29udGludWVFeGVjdXRpb24oKSB7XG5cblx0XHQgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcblx0XHQgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuXHRcdCAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG5cdFx0ICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKHRhc2spIHtcblx0XHQgIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cblx0XHQgIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuXHRcdCAgdGFzay5jYWxsYmFjayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG5cdFx0ICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cdFx0fVxuXG5cdFx0dmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG5cdFx0dmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG5cdFx0dmFyIHRhc2tUaW1lb3V0SUQgPSAtMTsgLy8gU2NoZWR1bGVyIHBlcmlvZGljYWxseSB5aWVsZHMgaW4gY2FzZSB0aGVyZSBpcyBvdGhlciB3b3JrIG9uIHRoZSBtYWluXG5cdFx0Ly8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuXHRcdC8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG5cdFx0Ly8gbmVlZCB0byBiZSBmcmFtZSBhbGlnbmVkOyBmb3IgdGhvc2UgdGhhdCBkbywgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cblxuXHRcdHZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuXHRcdHZhciBzdGFydFRpbWUgPSAtMTtcblxuXHRcdGZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuXHRcdCAgdmFyIHRpbWVFbGFwc2VkID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZTtcblxuXHRcdCAgaWYgKHRpbWVFbGFwc2VkIDwgZnJhbWVJbnRlcnZhbCkge1xuXHRcdCAgICAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIG9ubHkgYmVlbiBibG9ja2VkIGZvciBhIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZTtcblx0XHQgICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG5cdFx0ICAgIHJldHVybiBmYWxzZTtcblx0XHQgIH0gLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBiZWVuIGJsb2NrZWQgZm9yIGEgbm9uLW5lZ2xpZ2libGUgYW1vdW50IG9mIHRpbWUuIFdlXG5cblxuXHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVxdWVzdFBhaW50KCkge1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZm9yY2VGcmFtZVJhdGUoZnBzKSB7XG5cdFx0ICBpZiAoZnBzIDwgMCB8fCBmcHMgPiAxMjUpIHtcblx0XHQgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cdFx0ICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdFx0ICAgIHJldHVybjtcblx0XHQgIH1cblxuXHRcdCAgaWYgKGZwcyA+IDApIHtcblx0XHQgICAgZnJhbWVJbnRlcnZhbCA9IE1hdGguZmxvb3IoMTAwMCAvIGZwcyk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdCAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG5cdFx0ICAgIGZyYW1lSW50ZXJ2YWwgPSBmcmFtZVlpZWxkTXM7XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0dmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQgIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcblx0XHQgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gbWVhc3VyZSBob3cgbG9uZyB0aGUgbWFpbiB0aHJlYWRcblx0XHQgICAgLy8gaGFzIGJlZW4gYmxvY2tlZC5cblxuXHRcdCAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcblx0XHQgICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlOyAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG5cdFx0ICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cblx0XHQgICAgLy9cblx0XHQgICAgLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYSB0cnktY2F0Y2gsIHNpbmNlIHRoYXQgbWFrZXMgc29tZSBkZWJ1Z2dpbmdcblx0XHQgICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBzY2hlZHVsZWRIb3N0Q2FsbGJhY2tgIGVycm9ycywgdGhlblxuXHRcdCAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG5cdFx0ICAgIHZhciBoYXNNb3JlV29yayA9IHRydWU7XG5cblx0XHQgICAgdHJ5IHtcblx0XHQgICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG5cdFx0ICAgIH0gZmluYWxseSB7XG5cdFx0ICAgICAgaWYgKGhhc01vcmVXb3JrKSB7XG5cdFx0ICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG5cdFx0ICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cblx0XHQgICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG5cdFx0ICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfSBlbHNlIHtcblx0XHQgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcblx0XHQgIH0gLy8gWWllbGRpbmcgdG8gdGhlIGJyb3dzZXIgd2lsbCBnaXZlIGl0IGEgY2hhbmNlIHRvIHBhaW50LCBzbyB3ZSBjYW5cblx0XHR9O1xuXG5cdFx0dmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5cdFx0aWYgKHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgLy8gTm9kZS5qcyBhbmQgb2xkIElFLlxuXHRcdCAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cblx0XHQgIC8vXG5cdFx0ICAvLyBVbmxpa2UgTWVzc2FnZUNoYW5uZWwsIGl0IGRvZXNuJ3QgcHJldmVudCBhIE5vZGUuanMgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG5cdFx0ICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuXHRcdCAgLy8gd2l0aCBhIG1peCBvZiBOb2RlLmpzIDE1Kywgd2hpY2ggaGFzIGEgTWVzc2FnZUNoYW5uZWwsIGFuZCBqc2RvbS4pXG5cdFx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNzU2XG5cdFx0ICAvL1xuXHRcdCAgLy8gQnV0IGFsc28sIGl0IHJ1bnMgZWFybGllciB3aGljaCBpcyB0aGUgc2VtYW50aWMgd2Ugd2FudC5cblx0XHQgIC8vIElmIG90aGVyIGJyb3dzZXJzIGV2ZXIgaW1wbGVtZW50IGl0LCBpdCdzIGJldHRlciB0byB1c2UgaXQuXG5cdFx0ICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuXHRcdCAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG5cdFx0ICB9O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdCAgLy8gRE9NIGFuZCBXb3JrZXIgZW52aXJvbm1lbnRzLlxuXHRcdCAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuXHRcdCAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcblx0XHQgIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0Mjtcblx0XHQgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5cdFx0ICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcblx0XHQgIH07XG5cdFx0fSBlbHNlIHtcblx0XHQgIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuXHRcdCAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuXHRcdCAgfTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKGNhbGxiYWNrKSB7XG5cdFx0ICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdCAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuXHRcdCAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG5cdFx0ICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuXHRcdCAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuXHRcdCAgfSwgbXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbmNlbEhvc3RUaW1lb3V0KCkge1xuXHRcdCAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCk7XG5cdFx0ICB0YXNrVGltZW91dElEID0gLTE7XG5cdFx0fVxuXG5cdFx0dmFyIHVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcblx0XHR2YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gIG51bGw7XG5cblx0XHRleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcblx0XHRleHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5cdFx0ZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuXHRcdGV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcblx0XHRleHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IHVuc3RhYmxlX1Byb2ZpbGluZztcblx0XHRleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5cdFx0ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuXHRcdGV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbjtcblx0XHRleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZm9yY2VGcmFtZVJhdGU7XG5cdFx0ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuXHRcdGV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZTtcblx0XHRleHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuXHRcdGV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcblx0XHRleHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHVuc3RhYmxlX3JlcXVlc3RQYWludDtcblx0XHRleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcblx0XHRleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuXHRcdGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcblx0XHRleHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcblx0XHQgICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuXHRcdGlmIChcblx0XHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdFx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuXHRcdCAgICAnZnVuY3Rpb24nXG5cdFx0KSB7XG5cdFx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuXHRcdH1cblx0XHQgICAgICAgIFxuXHRcdCAgfSkoKTtcblx0XHR9XG59IChzY2hlZHVsZXJfZGV2ZWxvcG1lbnQpKTtcblx0cmV0dXJuIHNjaGVkdWxlcl9kZXZlbG9wbWVudDtcbn1cblxudmFyIGhhc1JlcXVpcmVkU2NoZWR1bGVyO1xuXG5mdW5jdGlvbiByZXF1aXJlU2NoZWR1bGVyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2NoZWR1bGVyKSByZXR1cm4gc2NoZWR1bGVyRXhwb3J0cztcblx0aGFzUmVxdWlyZWRTY2hlZHVsZXIgPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG5cdFx0e1xuXHRcdCAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlU2NoZWR1bGVyX2RldmVsb3BtZW50KCk7XG5cdFx0fVxufSAoc2NoZWR1bGVyKSk7XG5cdHJldHVybiBzY2hlZHVsZXJFeHBvcnRzO1xufVxuXG52YXIgcmVhY3RSZWNvbmNpbGVyX2RldmVsb3BtZW50RXhwb3J0cyA9IHt9O1xudmFyIHJlYWN0UmVjb25jaWxlcl9kZXZlbG9wbWVudCA9IHtcbiAgZ2V0IGV4cG9ydHMoKXsgcmV0dXJuIHJlYWN0UmVjb25jaWxlcl9kZXZlbG9wbWVudEV4cG9ydHM7IH0sXG4gIHNldCBleHBvcnRzKHYpeyByZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnRFeHBvcnRzID0gdjsgfSxcbn07XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRSZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnQpIHJldHVybiByZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnRFeHBvcnRzO1xuXHRoYXNSZXF1aXJlZFJlYWN0UmVjb25jaWxlcl9kZXZlbG9wbWVudCA9IDE7XG5cblx0e1xuXHQgIHJlYWN0UmVjb25jaWxlcl9kZXZlbG9wbWVudC5leHBvcnRzID0gZnVuY3Rpb24gJCQkcmVjb25jaWxlcigkJCRob3N0Q29uZmlnKSB7XG5cdCAgICB2YXIgZXhwb3J0cyA9IHt9O1xuXG5cdHZhciBSZWFjdCQxID0gUmVhY3Q7XG5cdHZhciBTY2hlZHVsZXIgPSByZXF1aXJlU2NoZWR1bGVyKCk7XG5cblx0dmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QkMS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuXHR2YXIgc3VwcHJlc3NXYXJuaW5nID0gZmFsc2U7XG5cdGZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcblx0ICB7XG5cdCAgICBzdXBwcmVzc1dhcm5pbmcgPSBuZXdTdXBwcmVzc1dhcm5pbmc7XG5cdCAgfVxuXHR9IC8vIEluIERFViwgY2FsbHMgdG8gY29uc29sZS53YXJuIGFuZCBjb25zb2xlLmVycm9yIGdldCByZXBsYWNlZFxuXHQvLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuXHQvL1xuXHQvLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuXHQvLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cblx0ZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcblx0ICB7XG5cdCAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuXHQgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcblx0ICB7XG5cdCAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuXHQgIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuXHQgIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuXHQgIHtcblx0ICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblx0ICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG5cdCAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG5cdCAgICAgIGZvcm1hdCArPSAnJXMnO1xuXHQgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG5cdCAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cblx0ICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG5cdCAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuXHQgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG5cdCAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblx0ICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG5cdCAgfVxuXHR9XG5cblx0dmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cblx0LyoqXG5cdCAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG5cdCAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG5cdCAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuXHQgKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG5cdCAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdCAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG5cdH1cblx0ZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0ICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG5cdH1cblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyB0aGUgcmVhY3QtcmVjb25jaWxlciBwYWNrYWdlLlxuXG5cdHZhciBlbmFibGVOZXdSZWNvbmNpbGVyID0gZmFsc2U7IC8vIFN1cHBvcnQgbGVnYWN5IFByaW1lciBzdXBwb3J0IG9uIGludGVybmFsIEZCIHd3d1xuXG5cdHZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uID0gZmFsc2U7IC8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxuXG5cdHZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG5cblx0dmFyIGVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2sgPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpenpcblx0dmFyIHdhcm5BYm91dFN0cmluZ1JlZnMgPSBmYWxzZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gRGVidWdnaW5nIGFuZCBEZXZUb29sc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuXHQvLyBmb3IgYW4gZXhwZXJpbWVudGFsIHRpbWVsaW5lIHRvb2wuXG5cblx0dmFyIGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlciA9IHRydWU7IC8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiByZW5kZXItcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZVxuXG5cdHZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG5cdHZhciBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzID0gdHJ1ZTsgLy8gUGhhc2UgcGFyYW0gcGFzc2VkIHRvIG9uUmVuZGVyIGNhbGxiYWNrIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYW4gXCJ1cGRhdGVcIiBhbmQgYSBcImNhc2NhZGluZy11cGRhdGVcIi5cblxuXHR2YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xuXHR2YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xuXHR2YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDI7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb24gb3IgY2xhc3NcblxuXHR2YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cblxuXHR2YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cblx0dmFyIEhvc3RDb21wb25lbnQgPSA1O1xuXHR2YXIgSG9zdFRleHQgPSA2O1xuXHR2YXIgRnJhZ21lbnQgPSA3O1xuXHR2YXIgTW9kZSA9IDg7XG5cdHZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xuXHR2YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG5cdHZhciBGb3J3YXJkUmVmID0gMTE7XG5cdHZhciBQcm9maWxlciA9IDEyO1xuXHR2YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcblx0dmFyIE1lbW9Db21wb25lbnQgPSAxNDtcblx0dmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcblx0dmFyIExhenlDb21wb25lbnQgPSAxNjtcblx0dmFyIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IDE3O1xuXHR2YXIgRGVoeWRyYXRlZEZyYWdtZW50ID0gMTg7XG5cdHZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcblx0dmFyIFNjb3BlQ29tcG9uZW50ID0gMjE7XG5cdHZhciBPZmZzY3JlZW5Db21wb25lbnQgPSAyMjtcblx0dmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xuXHR2YXIgQ2FjaGVDb21wb25lbnQgPSAyNDtcblx0dmFyIFRyYWNpbmdNYXJrZXJDb21wb25lbnQgPSAyNTtcblxuXHQvLyBBVFRFTlRJT05cblx0Ly8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuXHQvLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG5cdC8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxuXHR2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xuXHR2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcblx0dmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuXHR2YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG5cdHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcblx0dmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xuXHR2YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xuXHR2YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG5cdHZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcblx0dmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcblx0dmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcblx0dmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcblx0dmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpO1xuXHR2YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG5cdHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuXHR2YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xuXHR2YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG5cdHZhciBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcblx0dmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcblx0dmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXHRmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcblx0ICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuXHQgIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcblx0ICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cblx0ICBpZiAoZGlzcGxheU5hbWUpIHtcblx0ICAgIHJldHVybiBkaXNwbGF5TmFtZTtcblx0ICB9XG5cblx0ICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuXHQgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG5cdH0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuXHRmdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG5cdCAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xuXHR9IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5cdGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG5cdCAgaWYgKHR5cGUgPT0gbnVsbCkge1xuXHQgICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuXHQgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHR5cGU7XG5cdCAgfVxuXG5cdCAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG5cdCAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG5cdCAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuXHQgICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cblx0ICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcblx0ICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cblx0ICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcblx0ICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuXHQgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG5cdCAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuXHQgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcblx0ICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG5cdCAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuXHQgICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG5cdCAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG5cdCAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcblx0ICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG5cdCAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuXHQgICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcblx0ICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuXHQgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG5cdCAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG5cdCAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG5cdCAgICAgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFdyYXBwZWROYW1lJDEob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG5cdCAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcblx0ICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xuXHR9IC8vIEtlZXAgaW4gc3luYyB3aXRoIHNoYXJlZC9nZXRDb21wb25lbnROYW1lRnJvbVR5cGVcblxuXG5cdGZ1bmN0aW9uIGdldENvbnRleHROYW1lJDEodHlwZSkge1xuXHQgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcblx0ICB2YXIgdGFnID0gZmliZXIudGFnLFxuXHQgICAgICB0eXBlID0gZmliZXIudHlwZTtcblxuXHQgIHN3aXRjaCAodGFnKSB7XG5cdCAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuXHQgICAgICByZXR1cm4gJ0NhY2hlJztcblxuXHQgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG5cdCAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblx0ICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lJDEoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuXHQgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG5cdCAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG5cdCAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZSQxKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG5cdCAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcblx0ICAgICAgcmV0dXJuICdEZWh5ZHJhdGVkRnJhZ21lbnQnO1xuXG5cdCAgICBjYXNlIEZvcndhcmRSZWY6XG5cdCAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG5cdCAgICBjYXNlIEZyYWdtZW50OlxuXHQgICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuXHQgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICAvLyBIb3N0IGNvbXBvbmVudCB0eXBlIGlzIHRoZSBkaXNwbGF5IG5hbWUgKGUuZy4gXCJkaXZcIiwgXCJWaWV3XCIpXG5cdCAgICAgIHJldHVybiB0eXBlO1xuXG5cdCAgICBjYXNlIEhvc3RQb3J0YWw6XG5cdCAgICAgIHJldHVybiAnUG9ydGFsJztcblxuXHQgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgcmV0dXJuICdSb290JztcblxuXHQgICAgY2FzZSBIb3N0VGV4dDpcblx0ICAgICAgcmV0dXJuICdUZXh0JztcblxuXHQgICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuXHQgICAgICAvLyBOYW1lIGNvbWVzIGZyb20gdGhlIHR5cGUgaW4gdGhpcyBjYXNlOyB3ZSBkb24ndCBoYXZlIGEgdGFnLlxuXHQgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG5cdCAgICBjYXNlIE1vZGU6XG5cdCAgICAgIGlmICh0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFKSB7XG5cdCAgICAgICAgLy8gRG9uJ3QgYmUgbGVzcyBzcGVjaWZpYyB0aGFuIHNoYXJlZC9nZXRDb21wb25lbnROYW1lRnJvbVR5cGVcblx0ICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuICdNb2RlJztcblxuXHQgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG5cdCAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcblxuXHQgICAgY2FzZSBQcm9maWxlcjpcblx0ICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cblx0ICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiAnU2NvcGUnO1xuXG5cdCAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuXHQgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuXHQgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuXHQgICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXHQgICAgICByZXR1cm4gJ1RyYWNpbmdNYXJrZXInO1xuXHQgICAgLy8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhpcyB0YWdzIGNvbWUgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB0eXBlOlxuXG5cdCAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuXHQgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuXHQgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuXHQgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlcy4gVGhleSdyZSB1c2VkIGJ5IFJlYWN0IERldiBUb29scy5cblx0dmFyIE5vRmxhZ3MgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQwO1xuXHR2YXIgUGVyZm9ybWVkV29yayA9XG5cdC8qICAgICAgICAgICAgICAgICovXG5cdDE7IC8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxuXG5cdHZhciBQbGFjZW1lbnQgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgKi9cblx0Mjtcblx0dmFyIFVwZGF0ZSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQ0O1xuXHR2YXIgQ2hpbGREZWxldGlvbiA9XG5cdC8qICAgICAgICAgICAgICAgICovXG5cdDE2O1xuXHR2YXIgQ29udGVudFJlc2V0ID1cblx0LyogICAgICAgICAgICAgICAgICovXG5cdDMyO1xuXHR2YXIgQ2FsbGJhY2sgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICovXG5cdDY0O1xuXHR2YXIgRGlkQ2FwdHVyZSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICovXG5cdDEyODtcblx0dmFyIEZvcmNlQ2xpZW50UmVuZGVyID1cblx0LyogICAgICAgICAgICAqL1xuXHQyNTY7XG5cdHZhciBSZWYgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0NTEyO1xuXHR2YXIgU25hcHNob3QgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICovXG5cdDEwMjQ7XG5cdHZhciBQYXNzaXZlID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgKi9cblx0MjA0ODtcblx0dmFyIEh5ZHJhdGluZyA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAqL1xuXHQ0MDk2O1xuXHR2YXIgVmlzaWJpbGl0eSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICovXG5cdDgxOTI7XG5cdHZhciBTdG9yZUNvbnNpc3RlbmN5ID1cblx0LyogICAgICAgICAgICAgKi9cblx0MTYzODQ7XG5cdHZhciBMaWZlY3ljbGVFZmZlY3RNYXNrID0gUGFzc2l2ZSB8IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgU25hcHNob3QgfCBTdG9yZUNvbnNpc3RlbmN5OyAvLyBVbmlvbiBvZiBhbGwgY29tbWl0IGZsYWdzIChmbGFncyB3aXRoIHRoZSBsaWZldGltZSBvZiBhIHBhcnRpY3VsYXIgY29tbWl0KVxuXG5cdHZhciBIb3N0RWZmZWN0TWFzayA9XG5cdC8qICAgICAgICAgICAgICAgKi9cblx0MzI3Njc7IC8vIFRoZXNlIGFyZSBub3QgcmVhbGx5IHNpZGUgZWZmZWN0cywgYnV0IHdlIHN0aWxsIHJldXNlIHRoaXMgZmllbGQuXG5cblx0dmFyIEluY29tcGxldGUgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAqL1xuXHQzMjc2ODtcblx0dmFyIFNob3VsZENhcHR1cmUgPVxuXHQvKiAgICAgICAgICAgICAgICAqL1xuXHQ2NTUzNjtcblx0dmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuXHQvKiAqL1xuXHQxMzEwNzI7XG5cdHZhciBGb3JrZWQgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0MTA0ODU3NjsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcblx0Ly8gZS5nLiBhIGZpYmVyIHVzZXMgYSBwYXNzaXZlIGVmZmVjdCAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBvbiB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyKS5cblx0Ly8gVGhpcyBlbmFibGVzIHVzIHRvIGRlZmVyIG1vcmUgd29yayBpbiB0aGUgdW5tb3VudCBjYXNlLFxuXHQvLyBzaW5jZSB3ZSBjYW4gZGVmZXIgdHJhdmVyc2luZyB0aGUgdHJlZSBkdXJpbmcgbGF5b3V0IHRvIGxvb2sgZm9yIFBhc3NpdmUgZWZmZWN0cyxcblx0Ly8gYW5kIGluc3RlYWQgcmVseSBvbiB0aGUgc3RhdGljIGZsYWcgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSBtYXkgYmUgY2xlYW51cCB3b3JrLlxuXG5cdHZhciBSZWZTdGF0aWMgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgKi9cblx0MjA5NzE1Mjtcblx0dmFyIExheW91dFN0YXRpYyA9XG5cdC8qICAgICAgICAgICAgICAgICAqL1xuXHQ0MTk0MzA0O1xuXHR2YXIgUGFzc2l2ZVN0YXRpYyA9XG5cdC8qICAgICAgICAgICAgICAgICovXG5cdDgzODg2MDg7IC8vIFRoZXNlIGZsYWdzIGFsbG93IHVzIHRvIHRyYXZlcnNlIHRvIGZpYmVycyB0aGF0IGhhdmUgZWZmZWN0cyBvbiBtb3VudFxuXHQvLyB3aXRob3V0IHRyYXZlcnNpbmcgdGhlIGVudGlyZSB0cmVlIGFmdGVyIGV2ZXJ5IGNvbW1pdCBmb3Jcblx0Ly8gZG91YmxlIGludm9raW5nXG5cblx0dmFyIE1vdW50TGF5b3V0RGV2ID1cblx0LyogICAgICAgICAgICAgICAqL1xuXHQxNjc3NzIxNjtcblx0dmFyIE1vdW50UGFzc2l2ZURldiA9XG5cdC8qICAgICAgICAgICAgICAqL1xuXHQzMzU1NDQzMjsgLy8gR3JvdXBzIG9mIGZsYWdzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGNvbW1pdCBwaGFzZSB0byBza2lwIG92ZXIgdHJlZXMgdGhhdFxuXHQvLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cblxuXHR2YXIgQmVmb3JlTXV0YXRpb25NYXNrID0gLy8gVE9ETzogUmVtb3ZlIFVwZGF0ZSBmbGFnIGZyb20gYmVmb3JlIG11dGF0aW9uIHBoYXNlIGJ5IHJlLWxhbmRpbmcgVmlzaWJpbGl0eVxuXHQvLyBmbGFnIGxvZ2ljIChzZWUgIzIwMDQzKVxuXHRVcGRhdGUgfCBTbmFwc2hvdCB8ICggMCk7XG5cdHZhciBNdXRhdGlvbk1hc2sgPSBQbGFjZW1lbnQgfCBVcGRhdGUgfCBDaGlsZERlbGV0aW9uIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgSHlkcmF0aW5nIHwgVmlzaWJpbGl0eTtcblx0dmFyIExheW91dE1hc2sgPSBVcGRhdGUgfCBDYWxsYmFjayB8IFJlZiB8IFZpc2liaWxpdHk7IC8vIFRPRE86IFNwbGl0IGludG8gUGFzc2l2ZU1vdW50TWFzayBhbmQgUGFzc2l2ZVVubW91bnRNYXNrXG5cblx0dmFyIFBhc3NpdmVNYXNrID0gUGFzc2l2ZSB8IENoaWxkRGVsZXRpb247IC8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuXHQvLyBUaGlzIGFsbG93cyBjZXJ0YWluIGNvbmNlcHRzIHRvIHBlcnNpc3Qgd2l0aG91dCByZWNhbGN1bGF0aW5nIHRoZW0sXG5cdC8vIGUuZy4gd2hldGhlciBhIHN1YnRyZWUgY29udGFpbnMgcGFzc2l2ZSBlZmZlY3RzIG9yIHBvcnRhbHMuXG5cblx0dmFyIFN0YXRpY01hc2sgPSBMYXlvdXRTdGF0aWMgfCBQYXNzaXZlU3RhdGljIHwgUmVmU3RhdGljO1xuXG5cdHZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXHRmdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG5cdCAgdmFyIG5vZGUgPSBmaWJlcjtcblx0ICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcblxuXHQgIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG5cdCAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG5cdCAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cblx0ICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgbm9kZSA9IG5leHROb2RlO1xuXG5cdCAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuXHQgICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcblx0ICAgICAgICAvLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuXHQgICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG5cdCAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG5cdCAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdoaWxlIChub2RlLnJldHVybikge1xuXHQgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuXHQgICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcblx0ICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuXHQgICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuXHQgIH0gLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG5cdCAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cdGZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG5cdCAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcblx0fVxuXHRmdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG5cdCAge1xuXHQgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuXHQgICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcblx0ICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcblx0ICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cblx0ICAgICAgaWYgKCFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpIHtcblx0ICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cblx0ICBpZiAoIWZpYmVyKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuXHQgIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG5cdCAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuXHQgIGlmICghYWx0ZXJuYXRlKSB7XG5cdCAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG5cdCAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuXHQgICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmliZXI7XG5cdCAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3Rcblx0ICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcblx0ICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG5cdCAgdmFyIGEgPSBmaWJlcjtcblx0ICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuXHQgIHdoaWxlICh0cnVlKSB7XG5cdCAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG5cdCAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cblx0ICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG5cdCAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuXHQgICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuXHQgICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG5cdCAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG5cdCAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cblx0ICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cblx0ICAgICAgYnJlYWs7XG5cdCAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuXHQgICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG5cdCAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuXHQgICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcblx0ICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuXHQgICAgICB3aGlsZSAoY2hpbGQpIHtcblx0ICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcblx0ICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cblx0ICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcblx0ICAgICAgICAgIHJldHVybiBmaWJlcjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcblx0ICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cblx0ICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcblx0ICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuXHQgICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG5cdCAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG5cdCAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcblx0ICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuXHQgICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG5cdCAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cblx0ICAgICAgYSA9IHBhcmVudEE7XG5cdCAgICAgIGIgPSBwYXJlbnRCO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG5cdCAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG5cdCAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcblx0ICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuXHQgICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuXHQgICAgICB3aGlsZSAoX2NoaWxkKSB7XG5cdCAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuXHQgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcblx0ICAgICAgICAgIGEgPSBwYXJlbnRBO1xuXHQgICAgICAgICAgYiA9IHBhcmVudEI7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG5cdCAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuXHQgICAgICAgICAgYiA9IHBhcmVudEE7XG5cdCAgICAgICAgICBhID0gcGFyZW50Qjtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcblx0ICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcblx0ICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuXG5cdCAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuXHQgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuXHQgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuXHQgICAgICAgICAgICBhID0gcGFyZW50Qjtcblx0ICAgICAgICAgICAgYiA9IHBhcmVudEE7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG5cdCAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG5cdCAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuXHQgICAgICAgICAgICBhID0gcGFyZW50QTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH0gLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cblx0ICAvLyB1bm1vdW50ZWQuXG5cblxuXHQgIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuXHQgIH1cblxuXHQgIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG5cdCAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG5cdCAgICByZXR1cm4gZmliZXI7XG5cdCAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuXHQgIHJldHVybiBhbHRlcm5hdGU7XG5cdH1cblx0ZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG5cdCAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXHQgIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGN1cnJlbnRQYXJlbnQpIDogbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG5cdCAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cblx0ICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG5cdCAgICByZXR1cm4gbm9kZTtcblx0ICB9XG5cblx0ICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG5cdCAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO1xuXG5cdCAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgfVxuXG5cdCAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG5cdCAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXHQgIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjdXJyZW50UGFyZW50KSA6IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcblx0ICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuXHQgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcblx0ICAgIHJldHVybiBub2RlO1xuXHQgIH1cblxuXHQgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cblx0ICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgIGlmIChjaGlsZC50YWcgIT09IEhvc3RQb3J0YWwpIHtcblx0ICAgICAgdmFyIG1hdGNoID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjaGlsZCk7XG5cblx0ICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXHRmdW5jdGlvbiBpc0FycmF5KGEpIHtcblx0ICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG5cdH1cblxuXHQvLyBUaGlzIGlzIGEgaG9zdCBjb25maWcgdGhhdCdzIHVzZWQgZm9yIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgcGFja2FnZSBvbiBucG0uXG5cdC8vIEl0IGlzIG9ubHkgdXNlZCBieSB0aGlyZC1wYXJ0eSByZW5kZXJlcnMuXG5cdC8vXG5cdC8vIEl0cyBBUEkgbGV0cyB5b3UgcGFzcyB0aGUgaG9zdCBjb25maWcgYXMgYW4gYXJndW1lbnQuXG5cdC8vIEhvd2V2ZXIsIGluc2lkZSB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIHdlIHRyZWF0IGhvc3QgY29uZmlnIGFzIGEgbW9kdWxlLlxuXHQvLyBUaGlzIGZpbGUgaXMgYSBzaGltIGJldHdlZW4gdHdvIHdvcmxkcy5cblx0Ly9cblx0Ly8gSXQgd29ya3MgYmVjYXVzZSB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIGJ1bmRsZSBpcyB3cmFwcGVkIGluIHNvbWV0aGluZyBsaWtlOlxuXHQvL1xuXHQvLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcblx0Ly8gICAvKiByZWNvbmNpbGVyIGNvZGUgKi9cblx0Ly8gfVxuXHQvL1xuXHQvLyBTbyBgJCQkY29uZmlnYCBsb29rcyBsaWtlIGEgZ2xvYmFsIHZhcmlhYmxlLCBidXQgaXQnc1xuXHQvLyByZWFsbHkgYW4gYXJndW1lbnQgdG8gYSB0b3AtbGV2ZWwgd3JhcHBpbmcgZnVuY3Rpb24uXG5cdC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0Ly8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHR2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xuXHR2YXIgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkaG9zdENvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cdHZhciBnZXRDaGlsZEhvc3RDb250ZXh0ID0gJCQkaG9zdENvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0O1xuXHR2YXIgcHJlcGFyZUZvckNvbW1pdCA9ICQkJGhvc3RDb25maWcucHJlcGFyZUZvckNvbW1pdDtcblx0dmFyIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRob3N0Q29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cdHZhciBjcmVhdGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY3JlYXRlSW5zdGFuY2U7XG5cdHZhciBhcHBlbmRJbml0aWFsQ2hpbGQgPSAkJCRob3N0Q29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZDtcblx0dmFyIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbjtcblx0dmFyIHByZXBhcmVVcGRhdGUgPSAkJCRob3N0Q29uZmlnLnByZXBhcmVVcGRhdGU7XG5cdHZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9ICQkJGhvc3RDb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQ7XG5cdHZhciBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZTtcblx0dmFyIHNjaGVkdWxlVGltZW91dCA9ICQkJGhvc3RDb25maWcuc2NoZWR1bGVUaW1lb3V0O1xuXHR2YXIgY2FuY2VsVGltZW91dCA9ICQkJGhvc3RDb25maWcuY2FuY2VsVGltZW91dDtcblx0dmFyIG5vVGltZW91dCA9ICQkJGhvc3RDb25maWcubm9UaW1lb3V0O1xuXHR2YXIgaXNQcmltYXJ5UmVuZGVyZXIgPSAkJCRob3N0Q29uZmlnLmlzUHJpbWFyeVJlbmRlcmVyO1xuXHR2YXIgd2FybnNJZk5vdEFjdGluZyA9ICQkJGhvc3RDb25maWcud2FybnNJZk5vdEFjdGluZztcblx0dmFyIHN1cHBvcnRzTXV0YXRpb24gPSAkJCRob3N0Q29uZmlnLnN1cHBvcnRzTXV0YXRpb247XG5cdHZhciBzdXBwb3J0c1BlcnNpc3RlbmNlID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlO1xuXHR2YXIgc3VwcG9ydHNIeWRyYXRpb24gPSAkJCRob3N0Q29uZmlnLnN1cHBvcnRzSHlkcmF0aW9uO1xuXHR2YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9ICQkJGhvc3RDb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcblx0JCQkaG9zdENvbmZpZy5iZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI7XG5cdCQkJGhvc3RDb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG5cdHZhciBwcmVwYXJlUG9ydGFsTW91bnQgPSAkJCRob3N0Q29uZmlnLnByZXBhcmVQb3J0YWxNb3VudDtcblx0JCQkaG9zdENvbmZpZy5wcmVwYXJlU2NvcGVVcGRhdGU7XG5cdCQkJGhvc3RDb25maWcuZ2V0SW5zdGFuY2VGcm9tU2NvcGU7XG5cdHZhciBnZXRDdXJyZW50RXZlbnRQcmlvcml0eSA9ICQkJGhvc3RDb25maWcuZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHk7XG5cdHZhciBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyAgICAgIE1pY3JvdGFza3Ncblx0Ly8gICAgIChvcHRpb25hbClcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdHZhciBzdXBwb3J0c01pY3JvdGFza3MgPSAkJCRob3N0Q29uZmlnLnN1cHBvcnRzTWljcm90YXNrcztcblx0dmFyIHNjaGVkdWxlTWljcm90YXNrID0gJCQkaG9zdENvbmZpZy5zY2hlZHVsZU1pY3JvdGFzazsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyAgICAgIFRlc3Qgc2VsZWN0b3JzXG5cdC8vICAgICAob3B0aW9uYWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHR2YXIgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnM7XG5cdHZhciBmaW5kRmliZXJSb290ID0gJCQkaG9zdENvbmZpZy5maW5kRmliZXJSb290O1xuXHR2YXIgZ2V0Qm91bmRpbmdSZWN0ID0gJCQkaG9zdENvbmZpZy5nZXRCb3VuZGluZ1JlY3Q7XG5cdHZhciBnZXRUZXh0Q29udGVudCA9ICQkJGhvc3RDb25maWcuZ2V0VGV4dENvbnRlbnQ7XG5cdHZhciBpc0hpZGRlblN1YnRyZWUgPSAkJCRob3N0Q29uZmlnLmlzSGlkZGVuU3VidHJlZTtcblx0dmFyIG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUgPSAkJCRob3N0Q29uZmlnLm1hdGNoQWNjZXNzaWJpbGl0eVJvbGU7XG5cdHZhciBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkaG9zdENvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlO1xuXHR2YXIgc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciA9ICQkJGhvc3RDb25maWcuc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcjsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyAgICAgIE11dGF0aW9uXG5cdC8vICAgICAob3B0aW9uYWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHR2YXIgYXBwZW5kQ2hpbGQgPSAkJCRob3N0Q29uZmlnLmFwcGVuZENoaWxkO1xuXHR2YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjtcblx0dmFyIGNvbW1pdFRleHRVcGRhdGUgPSAkJCRob3N0Q29uZmlnLmNvbW1pdFRleHRVcGRhdGU7XG5cdHZhciBjb21taXRNb3VudCA9ICQkJGhvc3RDb25maWcuY29tbWl0TW91bnQ7XG5cdHZhciBjb21taXRVcGRhdGUgPSAkJCRob3N0Q29uZmlnLmNvbW1pdFVwZGF0ZTtcblx0dmFyIGluc2VydEJlZm9yZSA9ICQkJGhvc3RDb25maWcuaW5zZXJ0QmVmb3JlO1xuXHR2YXIgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUgPSAkJCRob3N0Q29uZmlnLmluc2VydEluQ29udGFpbmVyQmVmb3JlO1xuXHR2YXIgcmVtb3ZlQ2hpbGQgPSAkJCRob3N0Q29uZmlnLnJlbW92ZUNoaWxkO1xuXHR2YXIgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7XG5cdHZhciByZXNldFRleHRDb250ZW50ID0gJCQkaG9zdENvbmZpZy5yZXNldFRleHRDb250ZW50O1xuXHR2YXIgaGlkZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oaWRlSW5zdGFuY2U7XG5cdHZhciBoaWRlVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oaWRlVGV4dEluc3RhbmNlO1xuXHR2YXIgdW5oaWRlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLnVuaGlkZUluc3RhbmNlO1xuXHR2YXIgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2U7XG5cdHZhciBjbGVhckNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY2xlYXJDb250YWluZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gICAgIFBlcnNpc3RlbmNlXG5cdC8vICAgICAob3B0aW9uYWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHR2YXIgY2xvbmVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2xvbmVJbnN0YW5jZTtcblx0dmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkaG9zdENvbmZpZy5jcmVhdGVDb250YWluZXJDaGlsZFNldDtcblx0dmFyIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0O1xuXHR2YXIgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9ICQkJGhvc3RDb25maWcuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblx0dmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGhvc3RDb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuO1xuXHR2YXIgY2xvbmVIaWRkZW5JbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2xvbmVIaWRkZW5JbnN0YW5jZTtcblx0dmFyIGNsb25lSGlkZGVuVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jbG9uZUhpZGRlblRleHRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyAgICAgSHlkcmF0aW9uXG5cdC8vICAgICAob3B0aW9uYWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHR2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2U7XG5cdHZhciBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jYW5IeWRyYXRlVGV4dEluc3RhbmNlO1xuXHR2YXIgY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlO1xuXHR2YXIgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZztcblx0dmFyIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrID0gJCQkaG9zdENvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjaztcblx0dmFyIGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyA9ICQkJGhvc3RDb25maWcuZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzO1xuXHR2YXIgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRob3N0Q29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5O1xuXHR2YXIgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gJCQkaG9zdENvbmZpZy5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc7XG5cdHZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9ICQkJGhvc3RDb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ7XG5cdHZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXI7XG5cdHZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZTtcblx0dmFyIGh5ZHJhdGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZUluc3RhbmNlO1xuXHR2YXIgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZTtcblx0dmFyIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oeWRyYXRlU3VzcGVuc2VJbnN0YW5jZTtcblx0dmFyIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2U7XG5cdHZhciBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXI7XG5cdHZhciBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZTtcblx0dmFyIGNsZWFyU3VzcGVuc2VCb3VuZGFyeSA9ICQkJGhvc3RDb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5O1xuXHR2YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcjtcblx0dmFyIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzID0gJCQkaG9zdENvbmZpZy5zaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcztcblx0dmFyIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U7XG5cdHZhciBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlO1xuXHR2YXIgZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG5cdHZhciBkaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xuXHR2YXIgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2U7XG5cdHZhciBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyO1xuXHR2YXIgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyO1xuXHR2YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG5cdHZhciBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG5cdHZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZTtcblx0dmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG5cdHZhciBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlO1xuXHR2YXIgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXHR2YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2U7XG5cdHZhciBlcnJvckh5ZHJhdGluZ0NvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZXJyb3JIeWRyYXRpbmdDb250YWluZXI7XG5cblx0Ly8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuXHQvLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuXHQvLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG5cdC8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxuXHR2YXIgZGlzYWJsZWREZXB0aCA9IDA7XG5cdHZhciBwcmV2TG9nO1xuXHR2YXIgcHJldkluZm87XG5cdHZhciBwcmV2V2Fybjtcblx0dmFyIHByZXZFcnJvcjtcblx0dmFyIHByZXZHcm91cDtcblx0dmFyIHByZXZHcm91cENvbGxhcHNlZDtcblx0dmFyIHByZXZHcm91cEVuZDtcblxuXHRmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cblx0ZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcblx0ZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG5cdCAge1xuXHQgICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcblx0ICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG5cdCAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcblx0ICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG5cdCAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuXHQgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXHQgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuXHQgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuXHQgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cblx0ICAgICAgdmFyIHByb3BzID0ge1xuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcblx0ICAgICAgICB3cml0YWJsZTogdHJ1ZVxuXHQgICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcblx0ICAgICAgICBpbmZvOiBwcm9wcyxcblx0ICAgICAgICBsb2c6IHByb3BzLFxuXHQgICAgICAgIHdhcm46IHByb3BzLFxuXHQgICAgICAgIGVycm9yOiBwcm9wcyxcblx0ICAgICAgICBncm91cDogcHJvcHMsXG5cdCAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuXHQgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuXHQgICAgICB9KTtcblx0ICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cblx0ICAgIH1cblxuXHQgICAgZGlzYWJsZWREZXB0aCsrO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG5cdCAge1xuXHQgICAgZGlzYWJsZWREZXB0aC0tO1xuXG5cdCAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuXHQgICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cblx0ICAgICAgdmFyIHByb3BzID0ge1xuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHdyaXRhYmxlOiB0cnVlXG5cdCAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuXHQgICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZMb2dcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldkluZm9cblx0ICAgICAgICB9KSxcblx0ICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldldhcm5cblx0ICAgICAgICB9KSxcblx0ICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdCAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0ICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcblx0ICAgICAgICB9KSxcblx0ICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuXHQgICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuXHQgICAgICAgIH0pXG5cdCAgICAgIH0pO1xuXHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcblx0ICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcblx0dmFyIHByZWZpeDtcblx0ZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG5cdCAge1xuXHQgICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHQgICAgICB9IGNhdGNoICh4KSB7XG5cdCAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcblx0ICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcblx0ICAgICAgfVxuXHQgICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG5cdCAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuXHQgIH1cblx0fVxuXHR2YXIgcmVlbnRyeSA9IGZhbHNlO1xuXHR2YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxuXHR7XG5cdCAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblx0ICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG5cdCAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG5cdCAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuXHQgICAgcmV0dXJuICcnO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuXHQgICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmV0dXJuIGZyYW1lO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBjb250cm9sO1xuXHQgIHJlZW50cnkgPSB0cnVlO1xuXHQgIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG5cdCAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG5cdCAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuXHQgIHtcblx0ICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG5cdCAgICAvLyBmb3Igd2FybmluZ3MuXG5cblx0ICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG5cdCAgICBkaXNhYmxlTG9ncygpO1xuXHQgIH1cblxuXHQgIHRyeSB7XG5cdCAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cblx0ICAgIGlmIChjb25zdHJ1Y3QpIHtcblx0ICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG5cdCAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuXHQgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuXHQgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcblx0ICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG5cdCAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuXHQgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgIGNvbnRyb2wgPSB4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIEZha2UuY2FsbCgpO1xuXHQgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgIGNvbnRyb2wgPSB4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICBjb250cm9sID0geDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZuKCk7XG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoc2FtcGxlKSB7XG5cdCAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuXHQgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG5cdCAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuXHQgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuXHQgICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG5cdCAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuXHQgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG5cdCAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG5cdCAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuXHQgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG5cdCAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcblx0ICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuXHQgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuXHQgICAgICAgIGMtLTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuXHQgICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuXHQgICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuXHQgICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG5cdCAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuXHQgICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuXHQgICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcblx0ICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cblx0ICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG5cdCAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG5cdCAgICAgICAgICAgIGRvIHtcblx0ICAgICAgICAgICAgICBzLS07XG5cdCAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG5cdCAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cblx0ICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuXHQgICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG5cdCAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcblx0ICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcblx0ICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cblx0ICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcblx0ICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGZpbmFsbHkge1xuXHQgICAgcmVlbnRyeSA9IGZhbHNlO1xuXG5cdCAgICB7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcblx0ICAgICAgcmVlbmFibGVMb2dzKCk7XG5cdCAgICB9XG5cblx0ICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcblx0ICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG5cdCAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcblx0ICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuXHQgIHtcblx0ICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gc3ludGhldGljRnJhbWU7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG5cdCAge1xuXHQgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG5cdCAge1xuXHQgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG5cdCAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cdCAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cblx0ICBpZiAodHlwZSA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gJyc7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB7XG5cdCAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuXHQgIH1cblxuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuXHQgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cblx0ICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuXHQgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuXHQgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG5cdCAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG5cdCAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cblx0ICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuXHQgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG5cdCAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG5cdCAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiAnJztcblx0fVxuXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0dmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXHR2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cblx0ZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuXHQgIHtcblx0ICAgIGlmIChlbGVtZW50KSB7XG5cdCAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXHQgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuXHQgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcblx0ICB7XG5cdCAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG5cdCAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuXHQgICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuXHQgICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuXHQgICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuXHQgICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cblx0ICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG5cdCAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG5cdCAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cdCAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuXHQgICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcblx0ICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcblx0ICAgICAgICB9IGNhdGNoIChleCkge1xuXHQgICAgICAgICAgZXJyb3IkMSA9IGV4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuXHQgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cblx0ICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG5cdCAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0ICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuXHQgICAgICAgICAgLy8gc2FtZSBlcnJvci5cblx0ICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcblx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG5cdCAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cblx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciB2YWx1ZVN0YWNrID0gW107XG5cdHZhciBmaWJlclN0YWNrO1xuXG5cdHtcblx0ICBmaWJlclN0YWNrID0gW107XG5cdH1cblxuXHR2YXIgaW5kZXggPSAtMTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgIHtcblx0ICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuXHQgICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblx0ICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cblx0ICB7XG5cdCAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaW5kZXgtLTtcblx0fVxuXG5cdGZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcblx0ICBpbmRleCsrO1xuXHQgIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cblx0ICB7XG5cdCAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuXHQgIH1cblxuXHQgIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG5cdH1cblxuXHR2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG5cdHtcblx0ICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcblx0fVxuXG5cdHZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcblxuXHR7XG5cdCAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuXHR9IC8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG5cblxuXHR2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7IC8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cblx0dmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG5cdC8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuXHQvLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxuXG5cdHZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cblx0ZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlcikge1xuXHQgIHtcblx0ICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuXHQgICAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG5cdCAgICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuXHQgICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcblx0ICAgICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG5cdCAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuXHQgIHtcblx0ICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblx0ICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG5cdCAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG5cdCAge1xuXHQgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXHQgICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG5cdCAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuXHQgICAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuXHQgICAgfSAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuXHQgICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG5cdCAgICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG5cblxuXHQgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG5cdCAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbnRleHQgPSB7fTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuXHQgICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcblx0ICAgIH1cblxuXHQgICAge1xuXHQgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblx0ICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuXHQgICAgfSAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG5cdCAgICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYmVmb3JlIHRoZSBjbGFzcyBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIHNvIGNoZWNrIGZvciBpbnN0YW5jZS5cblxuXG5cdCAgICBpZiAoaW5zdGFuY2UpIHtcblx0ICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY29udGV4dDtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcblx0ICB7XG5cdCAgICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKHR5cGUpIHtcblx0ICB7XG5cdCAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXHQgICAgcmV0dXJuIGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcikge1xuXHQgIHtcblx0ICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG5cdCAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG5cdCAge1xuXHQgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcblx0ICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcblx0ICB7XG5cdCAgICBpZiAoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGV4dCBmb3VuZCBvbiBzdGFjay4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXG5cdCAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuXHQgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCB0eXBlLCBwYXJlbnRDb250ZXh0KSB7XG5cdCAge1xuXHQgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXHQgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlczsgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cblx0ICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuXHQgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG5cdCAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcblx0ICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG5cblx0ICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcblxuXHQgICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcblx0ICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHtcblx0ICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cdCAgICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuXHQgIHtcblx0ICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuXHQgICAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG5cdCAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG5cblx0ICAgIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5Q29udGV4dE9iamVjdDsgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuXHQgICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG5cblx0ICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuXHQgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHlwZSwgZGlkQ2hhbmdlKSB7XG5cdCAge1xuXHQgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG5cdCAgICBpZiAoIWluc3RhbmNlKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChkaWRDaGFuZ2UpIHtcblx0ICAgICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cblx0ICAgICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuXHQgICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cblx0ICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcmV2aW91c0NvbnRleHQpO1xuXHQgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7IC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cblx0ICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cblxuXHQgICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7IC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuXG5cdCAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG5cdCAge1xuXHQgICAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG5cdCAgICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcblx0ICAgIGlmICghaXNGaWJlck1vdW50ZWQoZmliZXIpIHx8IGZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBub2RlID0gZmliZXI7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuXHQgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcblxuXHQgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG5cblx0ICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblx0ICAgIH0gd2hpbGUgKG5vZGUgIT09IG51bGwpO1xuXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgTGVnYWN5Um9vdCA9IDA7XG5cdHZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cblx0dmFyIE5vTW9kZSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDA7IC8vIFRPRE86IFJlbW92ZSBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3QgdGFnIGluc3RlYWRcblxuXHR2YXIgQ29uY3VycmVudE1vZGUgPVxuXHQvKiAgICAgICAgICAgICAgICAgKi9cblx0MTtcblx0dmFyIFByb2ZpbGVNb2RlID1cblx0LyogICAgICAgICAgICAgICAgICAgICovXG5cdDI7XG5cdHZhciBTdHJpY3RMZWdhY3lNb2RlID1cblx0LyogICAgICAgICAgICAgICAqL1xuXHQ4O1xuXHR2YXIgU3RyaWN0RWZmZWN0c01vZGUgPVxuXHQvKiAgICAgICAgICAgICAgKi9cblx0MTY7XG5cblx0Ly8gVE9ETzogVGhpcyBpcyBwcmV0dHkgd2VsbCBzdXBwb3J0ZWQgYnkgYnJvd3NlcnMuIE1heWJlIHdlIGNhbiBkcm9wIGl0LlxuXHR2YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuXG5cdC8vIEJhc2VkIG9uOlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cblx0dmFyIGxvZyA9IE1hdGgubG9nO1xuXHR2YXIgTE4yID0gTWF0aC5MTjI7XG5cblx0ZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG5cdCAgdmFyIGFzVWludCA9IHggPj4+IDA7XG5cblx0ICBpZiAoYXNVaW50ID09PSAwKSB7XG5cdCAgICByZXR1cm4gMzI7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xuXHR9XG5cblx0Ly8gSWYgdGhvc2UgdmFsdWVzIGFyZSBjaGFuZ2VkIHRoYXQgcGFja2FnZSBzaG91bGQgYmUgcmVidWlsdCBhbmQgcmVkZXBsb3llZC5cblxuXHR2YXIgVG90YWxMYW5lcyA9IDMxO1xuXHR2YXIgTm9MYW5lcyA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0MDtcblx0dmFyIE5vTGFuZSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQwO1xuXHR2YXIgU3luY0xhbmUgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDE7XG5cdHZhciBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lID1cblx0LyogICAgKi9cblx0Mjtcblx0dmFyIElucHV0Q29udGludW91c0xhbmUgPVxuXHQvKiAgICAgICAgICAgICAqL1xuXHQ0O1xuXHR2YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgPVxuXHQvKiAgICAgICAgICAgICovXG5cdDg7XG5cdHZhciBEZWZhdWx0TGFuZSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgKi9cblx0MTY7XG5cdHZhciBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSA9XG5cdC8qICAgICAgICAgICAgICAgICovXG5cdDMyO1xuXHR2YXIgVHJhbnNpdGlvbkxhbmVzID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICovXG5cdDQxOTQyNDA7XG5cdHZhciBUcmFuc2l0aW9uTGFuZTEgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDY0O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmUyID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQxMjg7XG5cdHZhciBUcmFuc2l0aW9uTGFuZTMgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDI1Njtcblx0dmFyIFRyYW5zaXRpb25MYW5lNCA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0NTEyO1xuXHR2YXIgVHJhbnNpdGlvbkxhbmU1ID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQxMDI0O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmU2ID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQyMDQ4O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmU3ID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQ0MDk2O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmU4ID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQ4MTkyO1xuXHR2YXIgVHJhbnNpdGlvbkxhbmU5ID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQxNjM4NDtcblx0dmFyIFRyYW5zaXRpb25MYW5lMTAgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0MzI3Njg7XG5cdHZhciBUcmFuc2l0aW9uTGFuZTExID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICovXG5cdDY1NTM2O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmUxMiA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQxMzEwNzI7XG5cdHZhciBUcmFuc2l0aW9uTGFuZTEzID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICovXG5cdDI2MjE0NDtcblx0dmFyIFRyYW5zaXRpb25MYW5lMTQgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0NTI0Mjg4O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmUxNSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQxMDQ4NTc2O1xuXHR2YXIgVHJhbnNpdGlvbkxhbmUxNiA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQyMDk3MTUyO1xuXHR2YXIgUmV0cnlMYW5lcyA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDEzMDAyMzQyNDtcblx0dmFyIFJldHJ5TGFuZTEgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0NDE5NDMwNDtcblx0dmFyIFJldHJ5TGFuZTIgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0ODM4ODYwODtcblx0dmFyIFJldHJ5TGFuZTMgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0MTY3NzcyMTY7XG5cdHZhciBSZXRyeUxhbmU0ID1cblx0LyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDMzNTU0NDMyO1xuXHR2YXIgUmV0cnlMYW5lNSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQ2NzEwODg2NDtcblx0dmFyIFNvbWVSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xuXHR2YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG5cdC8qICAgICAgICAgICovXG5cdDEzNDIxNzcyODtcblx0dmFyIE5vbklkbGVMYW5lcyA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQyNjg0MzU0NTU7XG5cdHZhciBJZGxlSHlkcmF0aW9uTGFuZSA9XG5cdC8qICAgICAgICAgICAgICAgKi9cblx0MjY4NDM1NDU2O1xuXHR2YXIgSWRsZUxhbmUgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDUzNjg3MDkxMjtcblx0dmFyIE9mZnNjcmVlbkxhbmUgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAqL1xuXHQxMDczNzQxODI0OyAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHRoZSBleHBlcmltZW50YWwgdGltZWxpbmUgKHJlYWN0LWRldnRvb2xzLXRpbWVsaW5lKVxuXHQvLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuXHRmdW5jdGlvbiBnZXRMYWJlbEZvckxhbmUobGFuZSkge1xuXHQgIHtcblx0ICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcblx0ICAgICAgcmV0dXJuICdTeW5jJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG5cdCAgICAgIHJldHVybiAnSW5wdXRDb250aW51b3VzSHlkcmF0aW9uJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG5cdCAgICAgIHJldHVybiAnSW5wdXRDb250aW51b3VzJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuXHQgICAgICByZXR1cm4gJ0RlZmF1bHRIeWRyYXRpb24nO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG5cdCAgICAgIHJldHVybiAnRGVmYXVsdCc7XG5cdCAgICB9XG5cblx0ICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcblx0ICAgICAgcmV0dXJuICdUcmFuc2l0aW9uSHlkcmF0aW9uJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcblx0ICAgICAgcmV0dXJuICdUcmFuc2l0aW9uJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG5cdCAgICAgIHJldHVybiAnUmV0cnknO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcblx0ICAgICAgcmV0dXJuICdTZWxlY3RpdmVIeWRyYXRpb24nO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG5cdCAgICAgIHJldHVybiAnSWRsZUh5ZHJhdGlvbic7XG5cdCAgICB9XG5cblx0ICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcblx0ICAgICAgcmV0dXJuICdJZGxlJztcblx0ICAgIH1cblxuXHQgICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG5cdCAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0dmFyIE5vVGltZXN0YW1wID0gLTE7XG5cdHZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG5cdHZhciBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcblxuXHRmdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lcykge1xuXHQgIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcblx0ICAgIGNhc2UgU3luY0xhbmU6XG5cdCAgICAgIHJldHVybiBTeW5jTGFuZTtcblxuXHQgICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuXHQgICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcblxuXHQgICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuXHQgICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuXHQgICAgY2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZTpcblx0ICAgICAgcmV0dXJuIERlZmF1bHRIeWRyYXRpb25MYW5lO1xuXG5cdCAgICBjYXNlIERlZmF1bHRMYW5lOlxuXHQgICAgICByZXR1cm4gRGVmYXVsdExhbmU7XG5cblx0ICAgIGNhc2UgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU6XG5cdCAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTQ6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTc6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEwOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEzOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE2OlxuXHQgICAgICByZXR1cm4gbGFuZXMgJiBUcmFuc2l0aW9uTGFuZXM7XG5cblx0ICAgIGNhc2UgUmV0cnlMYW5lMTpcblx0ICAgIGNhc2UgUmV0cnlMYW5lMjpcblx0ICAgIGNhc2UgUmV0cnlMYW5lMzpcblx0ICAgIGNhc2UgUmV0cnlMYW5lNDpcblx0ICAgIGNhc2UgUmV0cnlMYW5lNTpcblx0ICAgICAgcmV0dXJuIGxhbmVzICYgUmV0cnlMYW5lcztcblxuXHQgICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuXHQgICAgICByZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcblxuXHQgICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZTpcblx0ICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG5cdCAgICBjYXNlIElkbGVMYW5lOlxuXHQgICAgICByZXR1cm4gSWRsZUxhbmU7XG5cblx0ICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcblx0ICAgICAgcmV0dXJuIE9mZnNjcmVlbkxhbmU7XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG5cdCAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlLCBidXQgYXMgYSBmYWxsYmFjaywgcmV0dXJuIHRoZSBlbnRpcmUgYml0bWFzay5cblxuXG5cdCAgICAgIHJldHVybiBsYW5lcztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcblx0ICAvLyBFYXJseSBiYWlsb3V0IGlmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrIGxlZnQuXG5cdCAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXG5cdCAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuXHQgICAgcmV0dXJuIE5vTGFuZXM7XG5cdCAgfVxuXG5cdCAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblx0ICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzOyAvLyBEbyBub3Qgd29yayBvbiBhbnkgaWRsZSB3b3JrIHVudGlsIGFsbCB0aGUgbm9uLWlkbGUgd29yayBoYXMgZmluaXNoZWQsXG5cdCAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cblx0ICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIE5vbklkbGVMYW5lcztcblxuXHQgIGlmIChub25JZGxlUGVuZGluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG5cdCAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuXHQgICAgaWYgKG5vbklkbGVVbmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuXHQgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlVW5ibG9ja2VkTGFuZXMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIG5vbklkbGVQaW5nZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiBwaW5nZWRMYW5lcztcblxuXHQgICAgICBpZiAobm9uSWRsZVBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG5cdCAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBUaGUgb25seSByZW1haW5pbmcgd29yayBpcyBJZGxlLlxuXHQgICAgdmFyIHVuYmxvY2tlZExhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG5cdCAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcblx0ICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXModW5ibG9ja2VkTGFuZXMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG5cdCAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKG5leHRMYW5lcyA9PT0gTm9MYW5lcykge1xuXHQgICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG5cdCAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG5cdCAgICByZXR1cm4gTm9MYW5lcztcblx0ICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG5cdCAgLy8gaXQgYW5kIHdlJ2xsIGxvc2Ugb3VyIHByb2dyZXNzLiBXZSBzaG91bGQgb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgbGFuZXMgYXJlXG5cdCAgLy8gaGlnaGVyIHByaW9yaXR5LlxuXG5cblx0ICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG5cdCAgLy8gYm90aGVyIHdhaXRpbmcgdW50aWwgdGhlIHJvb3QgaXMgY29tcGxldGUuXG5cdCAgKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzKSB7XG5cdCAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG5cdCAgICB2YXIgd2lwTGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUod2lwTGFuZXMpO1xuXG5cdCAgICBpZiAoIC8vIFRlc3RzIHdoZXRoZXIgdGhlIG5leHQgbGFuZSBpcyBlcXVhbCBvciBsb3dlciBwcmlvcml0eSB0aGFuIHRoZSB3aXBcblx0ICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuXHQgICAgbmV4dExhbmUgPj0gd2lwTGFuZSB8fCAvLyBEZWZhdWx0IHByaW9yaXR5IHVwZGF0ZXMgc2hvdWxkIG5vdCBpbnRlcnJ1cHQgdHJhbnNpdGlvbiB1cGRhdGVzLiBUaGVcblx0ICAgIC8vIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGRlZmF1bHQgdXBkYXRlcyBhbmQgdHJhbnNpdGlvbiB1cGRhdGVzIGlzIHRoYXRcblx0ICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuXHQgICAgbmV4dExhbmUgPT09IERlZmF1bHRMYW5lICYmICh3aXBMYW5lICYgVHJhbnNpdGlvbkxhbmVzKSAhPT0gTm9MYW5lcykge1xuXHQgICAgICAvLyBLZWVwIHdvcmtpbmcgb24gdGhlIGV4aXN0aW5nIGluLXByb2dyZXNzIHRyZWUuIERvIG5vdCBpbnRlcnJ1cHQuXG5cdCAgICAgIHJldHVybiB3aXBMYW5lcztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoKG5leHRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG5cdCAgICAvLyBXaGVuIHVwZGF0ZXMgYXJlIHN5bmMgYnkgZGVmYXVsdCwgd2UgZW50YW5nbGUgY29udGludW91cyBwcmlvcml0eSB1cGRhdGVzXG5cdCAgICAvLyBhbmQgZGVmYXVsdCB1cGRhdGVzLCBzbyB0aGV5IHJlbmRlciBpbiB0aGUgc2FtZSBiYXRjaC4gVGhlIG9ubHkgcmVhc29uXG5cdCAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG5cdCAgICAvLyB0cmFuc2l0aW9ucywgYnV0IGRlZmF1bHQgdXBkYXRlcyBzaG91bGQgbm90LlxuXHQgICAgbmV4dExhbmVzIHw9IHBlbmRpbmdMYW5lcyAmIERlZmF1bHRMYW5lO1xuXHQgIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuXHQgIC8vXG5cdCAgLy8gQSBsYW5lIGlzIHNhaWQgdG8gYmUgZW50YW5nbGVkIHdpdGggYW5vdGhlciB3aGVuIGl0J3Mgbm90IGFsbG93ZWQgdG8gcmVuZGVyXG5cdCAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcblx0ICAvLyB3aGVuIG11bHRpcGxlIHVwZGF0ZXMgaGF2ZSB0aGUgc2FtZSBzb3VyY2UsIGFuZCB3ZSBvbmx5IHdhbnQgdG8gcmVzcG9uZCB0b1xuXHQgIC8vIHRoZSBtb3N0IHJlY2VudCBldmVudCBmcm9tIHRoYXQgc291cmNlLlxuXHQgIC8vXG5cdCAgLy8gTm90ZSB0aGF0IHdlIGFwcGx5IGVudGFuZ2xlbWVudHMgKmFmdGVyKiBjaGVja2luZyBmb3IgcGFydGlhbCB3b3JrIGFib3ZlLlxuXHQgIC8vIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGxhbmUgaXMgZW50YW5nbGVkIGR1cmluZyBhbiBpbnRlcmxlYXZlZCBldmVudCB3aGlsZVxuXHQgIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2Vcblx0ICAvLyBlbnRhbmdsZW1lbnQgaXMgdXN1YWxseSBcImJlc3QgZWZmb3J0XCI6IHdlJ2xsIHRyeSBvdXIgYmVzdCB0byByZW5kZXIgdGhlXG5cdCAgLy8gbGFuZXMgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBpdCdzIG5vdCB3b3J0aCB0aHJvd2luZyBvdXQgcGFydGlhbGx5XG5cdCAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG5cdCAgLy8gVE9ETzogUmVjb25zaWRlciB0aGlzLiBUaGUgY291bnRlci1hcmd1bWVudCBpcyB0aGF0IHRoZSBwYXJ0aWFsIHdvcmtcblx0ICAvLyByZXByZXNlbnRzIGFuIGludGVybWVkaWF0ZSBzdGF0ZSwgd2hpY2ggd2UgZG9uJ3Qgd2FudCB0byBzaG93IHRvIHRoZSB1c2VyLlxuXHQgIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG5cdCAgLy8gdGltZSBpdCB0YWtlcyB0byBzaG93IHRoZSBmaW5hbCBzdGF0ZSwgd2hpY2ggaXMgd2hhdCB0aGV5IGFyZSBhY3R1YWxseVxuXHQgIC8vIHdhaXRpbmcgZm9yLlxuXHQgIC8vXG5cdCAgLy8gRm9yIHRob3NlIGV4Y2VwdGlvbnMgd2hlcmUgZW50YW5nbGVtZW50IGlzIHNlbWFudGljYWxseSBpbXBvcnRhbnQsIGxpa2Vcblx0ICAvLyB1c2VNdXRhYmxlU291cmNlLCB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuXHQgIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG5cdCAgdmFyIGVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcblxuXHQgIGlmIChlbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuXHQgICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG5cdCAgICB2YXIgbGFuZXMgPSBuZXh0TGFuZXMgJiBlbnRhbmdsZWRMYW5lcztcblxuXHQgICAgd2hpbGUgKGxhbmVzID4gMCkge1xuXHQgICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcblx0ICAgICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuXHQgICAgICBuZXh0TGFuZXMgfD0gZW50YW5nbGVtZW50c1tpbmRleF07XG5cdCAgICAgIGxhbmVzICY9IH5sYW5lO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBuZXh0TGFuZXM7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcykge1xuXHQgIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuXHQgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG5cblx0ICB3aGlsZSAobGFuZXMgPiAwKSB7XG5cdCAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcblx0ICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblx0ICAgIHZhciBldmVudFRpbWUgPSBldmVudFRpbWVzW2luZGV4XTtcblxuXHQgICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcblx0ICAgICAgbW9zdFJlY2VudEV2ZW50VGltZSA9IGV2ZW50VGltZTtcblx0ICAgIH1cblxuXHQgICAgbGFuZXMgJj0gfmxhbmU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG1vc3RSZWNlbnRFdmVudFRpbWU7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcblx0ICBzd2l0Y2ggKGxhbmUpIHtcblx0ICAgIGNhc2UgU3luY0xhbmU6XG5cdCAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU6XG5cdCAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG5cdCAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBOT1RFOiBUaGlzIGlzIHNldCB0byB0aGUgY29ycmVzcG9uZGluZyBjb25zdGFudCBhcyBpbiBTY2hlZHVsZXIuanMuXG5cdCAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuXHQgICAgICAvLyB0aGVyZSdzIGEgdXNlciBpbnRlcmFjdGlvbiB0aGF0J3MgYmVpbmcgc3RhcnZlZCBieSBhIHNlcmllcyBvZlxuXHQgICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGVzLiBJZiB0aGF0IHRoZW9yeSBpcyBjb3JyZWN0LCB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzXG5cdCAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG5cdCAgICAgIC8vIGV4cGlyYXRpb24gdGltZXMgYXJlIGFuIGltcG9ydGFudCBzYWZlZ3VhcmQgd2hlbiBzdGFydmF0aW9uXG5cdCAgICAgIC8vIGRvZXMgaGFwcGVuLlxuXHQgICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG5cblx0ICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG5cdCAgICBjYXNlIERlZmF1bHRMYW5lOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTI6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTU6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTg6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMTpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNDpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcblx0ICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgNTAwMDtcblxuXHQgICAgY2FzZSBSZXRyeUxhbmUxOlxuXHQgICAgY2FzZSBSZXRyeUxhbmUyOlxuXHQgICAgY2FzZSBSZXRyeUxhbmUzOlxuXHQgICAgY2FzZSBSZXRyeUxhbmU0OlxuXHQgICAgY2FzZSBSZXRyeUxhbmU1OlxuXHQgICAgICAvLyBUT0RPOiBSZXRyaWVzIHNob3VsZCBiZSBhbGxvd2VkIHRvIGV4cGlyZSBpZiB0aGV5IGFyZSBDUFUgYm91bmQgZm9yXG5cdCAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuXHQgICAgICAvLyBjcmFzaGVzLiBUaGVyZSBtdXN0IGJlIHNvbWUgb3RoZXIgdW5kZXJseWluZyBidWc7IG5vdCBzdXBlciB1cmdlbnQgYnV0XG5cdCAgICAgIC8vIGlkZWFsbHkgc2hvdWxkIGZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIFVuZm9ydHVuYXRlbHkgd2UgZG9uJ3QgaGF2ZVxuXHQgICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuXHQgICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cblx0ICAgIGNhc2UgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTpcblx0ICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG5cdCAgICBjYXNlIElkbGVMYW5lOlxuXHQgICAgY2FzZSBPZmZzY3JlZW5MYW5lOlxuXHQgICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG5cdCAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAge1xuXHQgICAgICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG5cdCAgLy8gVE9ETzogVGhpcyBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHdlIHlpZWxkLiBXZSBjYW4gb3B0aW1pemUgYnkgc3RvcmluZ1xuXHQgIC8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuXHQgIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG5cdCAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXHQgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG5cdCAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcblx0ICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGVuZGluZyBsYW5lcyBhbmQgY2hlY2sgaWYgd2UndmUgcmVhY2hlZCB0aGVpclxuXHQgIC8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcblx0ICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuXHQgIHZhciBsYW5lcyA9IHBlbmRpbmdMYW5lcztcblxuXHQgIHdoaWxlIChsYW5lcyA+IDApIHtcblx0ICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuXHQgICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuXHQgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcblxuXHQgICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuXHQgICAgICAvLyBGb3VuZCBhIHBlbmRpbmcgbGFuZSB3aXRoIG5vIGV4cGlyYXRpb24gdGltZS4gSWYgaXQncyBub3Qgc3VzcGVuZGVkLCBvclxuXHQgICAgICAvLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuXHQgICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuXHQgICAgICBpZiAoKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMgfHwgKGxhbmUgJiBwaW5nZWRMYW5lcykgIT09IE5vTGFuZXMpIHtcblx0ICAgICAgICAvLyBBc3N1bWVzIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cblx0ICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuXHQgICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuXHQgICAgICByb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lO1xuXHQgICAgfVxuXG5cdCAgICBsYW5lcyAmPSB+bGFuZTtcblx0ICB9XG5cdH0gLy8gVGhpcyByZXR1cm5zIHRoZSBoaWdoZXN0IHByaW9yaXR5IHBlbmRpbmcgbGFuZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXlcblx0Ly8gYXJlIHN1c3BlbmRlZC5cblxuXHRmdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCkge1xuXHQgIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhyb290LnBlbmRpbmdMYW5lcyk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCkge1xuXHQgIHZhciBldmVyeXRoaW5nQnV0T2Zmc2NyZWVuID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+T2Zmc2NyZWVuTGFuZTtcblxuXHQgIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG5cdCAgICByZXR1cm4gZXZlcnl0aGluZ0J1dE9mZnNjcmVlbjtcblx0ICB9XG5cblx0ICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcblx0ICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXHQgIH1cblxuXHQgIHJldHVybiBOb0xhbmVzO1xuXHR9XG5cdGZ1bmN0aW9uIGluY2x1ZGVzU3luY0xhbmUobGFuZXMpIHtcblx0ICByZXR1cm4gKGxhbmVzICYgU3luY0xhbmUpICE9PSBOb0xhbmVzO1xuXHR9XG5cdGZ1bmN0aW9uIGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZXMpIHtcblx0ICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcblx0fVxuXHRmdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSB7XG5cdCAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcblx0fVxuXHRmdW5jdGlvbiBpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyhsYW5lcykge1xuXHQgIHZhciBVcmdlbnRMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lO1xuXHQgIHJldHVybiAobGFuZXMgJiBVcmdlbnRMYW5lcykgPT09IE5vTGFuZXM7XG5cdH1cblx0ZnVuY3Rpb24gaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpIHtcblx0ICByZXR1cm4gKGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gbGFuZXM7XG5cdH1cblx0ZnVuY3Rpb24gaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpIHtcblxuXHQgIHZhciBTeW5jRGVmYXVsdExhbmVzID0gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSB8IElucHV0Q29udGludW91c0xhbmUgfCBEZWZhdWx0SHlkcmF0aW9uTGFuZSB8IERlZmF1bHRMYW5lO1xuXHQgIHJldHVybiAobGFuZXMgJiBTeW5jRGVmYXVsdExhbmVzKSAhPT0gTm9MYW5lcztcblx0fVxuXHRmdW5jdGlvbiBpbmNsdWRlc0V4cGlyZWRMYW5lKHJvb3QsIGxhbmVzKSB7XG5cdCAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG5cdCAgLy8gZXhwaXJlIGFmdGVyIGEgcmVuZGVyIGhhcyBhbHJlYWR5IHN0YXJ0ZWQuXG5cdCAgcmV0dXJuIChsYW5lcyAmIHJvb3QuZXhwaXJlZExhbmVzKSAhPT0gTm9MYW5lcztcblx0fVxuXHRmdW5jdGlvbiBpc1RyYW5zaXRpb25MYW5lKGxhbmUpIHtcblx0ICByZXR1cm4gKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpICE9PSBOb0xhbmVzO1xuXHR9XG5cdGZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuXHQgIC8vIEN5Y2xlIHRocm91Z2ggdGhlIGxhbmVzLCBhc3NpZ25pbmcgZWFjaCBuZXcgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBsYW5lLlxuXHQgIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgbWVhbnMgZXZlcnkgdHJhbnNpdGlvbiBnZXRzIGl0cyBvd24gbGFuZSwgdW50aWwgd2Vcblx0ICAvLyBydW4gb3V0IG9mIGxhbmVzIGFuZCBjeWNsZSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcuXG5cdCAgdmFyIGxhbmUgPSBuZXh0VHJhbnNpdGlvbkxhbmU7XG5cdCAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuXG5cdCAgaWYgKChuZXh0VHJhbnNpdGlvbkxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBOb0xhbmVzKSB7XG5cdCAgICBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGxhbmU7XG5cdH1cblx0ZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuXHQgIHZhciBsYW5lID0gbmV4dFJldHJ5TGFuZTtcblx0ICBuZXh0UmV0cnlMYW5lIDw8PSAxO1xuXG5cdCAgaWYgKChuZXh0UmV0cnlMYW5lICYgUmV0cnlMYW5lcykgPT09IE5vTGFuZXMpIHtcblx0ICAgIG5leHRSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xuXHQgIH1cblxuXHQgIHJldHVybiBsYW5lO1xuXHR9XG5cdGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpIHtcblx0ICByZXR1cm4gbGFuZXMgJiAtbGFuZXM7XG5cdH1cblx0ZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmUobGFuZXMpIHtcblx0ICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG5cdCAgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG5cdCAgLy8gYWZmZWN0aW5nIHRoZSBhbGdvcml0aG1zIHdoZXJlIGl0cyB1c2VkLiBIZXJlIEknbSB1c2luZ1xuXHQgIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG5cdCAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuXHQgIHJldHVybiAzMSAtIGNsejMyKGxhbmVzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcblx0ICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuXHQgIHJldHVybiAoYSAmIGIpICE9PSBOb0xhbmVzO1xuXHR9XG5cdGZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuXHQgIHJldHVybiAoc2V0ICYgc3Vic2V0KSA9PT0gc3Vic2V0O1xuXHR9XG5cdGZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuXHQgIHJldHVybiBhIHwgYjtcblx0fVxuXHRmdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuXHQgIHJldHVybiBzZXQgJiB+c3Vic2V0O1xuXHR9XG5cdGZ1bmN0aW9uIGludGVyc2VjdExhbmVzKGEsIGIpIHtcblx0ICByZXR1cm4gYSAmIGI7XG5cdH0gLy8gU2VlbXMgcmVkdW5kYW50LCBidXQgaXQgY2hhbmdlcyB0aGUgdHlwZSBmcm9tIGEgc2luZ2xlIGxhbmUgKHVzZWQgZm9yXG5cdC8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5cdGZ1bmN0aW9uIGxhbmVUb0xhbmVzKGxhbmUpIHtcblx0ICByZXR1cm4gbGFuZTtcblx0fVxuXHRmdW5jdGlvbiBoaWdoZXJQcmlvcml0eUxhbmUoYSwgYikge1xuXHQgIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cblx0ICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG5cdCAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG5cdCAgLy8gaHR0cHM6Ly92OC5kZXYvYmxvZy9lbGVtZW50cy1raW5kcyNhdm9pZC1jcmVhdGluZy1ob2xlc1xuXHQgIHZhciBsYW5lTWFwID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuXHQgICAgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuXHQgIH1cblxuXHQgIHJldHVybiBsYW5lTWFwO1xuXHR9XG5cdGZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZChyb290LCB1cGRhdGVMYW5lLCBldmVudFRpbWUpIHtcblx0ICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBJZiB0aGVyZSBhcmUgYW55IHN1c3BlbmRlZCB0cmFuc2l0aW9ucywgaXQncyBwb3NzaWJsZSB0aGlzIG5ldyB1cGRhdGVcblx0ICAvLyBjb3VsZCB1bmJsb2NrIHRoZW0uIENsZWFyIHRoZSBzdXNwZW5kZWQgbGFuZXMgc28gdGhhdCB3ZSBjYW4gdHJ5IHJlbmRlcmluZ1xuXHQgIC8vIHRoZW0gYWdhaW4uXG5cdCAgLy9cblx0ICAvLyBUT0RPOiBXZSByZWFsbHkgb25seSBuZWVkIHRvIHVuc3VzcGVuZCBvbmx5IGxhbmVzIHRoYXQgYXJlIGluIHRoZVxuXHQgIC8vIGBzdWJ0cmVlTGFuZXNgIG9mIHRoZSB1cGRhdGVkIGZpYmVyLCBvciB0aGUgdXBkYXRlIGxhbmVzIG9mIHRoZSByZXR1cm5cblx0ICAvLyBwYXRoLiBUaGlzIHdvdWxkIGV4Y2x1ZGUgc3VzcGVuZGVkIHVwZGF0ZXMgaW4gYW4gdW5yZWxhdGVkIHNpYmxpbmcgdHJlZSxcblx0ICAvLyBzaW5jZSB0aGVyZSdzIG5vIHdheSBmb3IgdGhpcyB1cGRhdGUgdG8gdW5ibG9jayBpdC5cblx0ICAvL1xuXHQgIC8vIFdlIGRvbid0IGRvIHRoaXMgaWYgdGhlIGluY29taW5nIHVwZGF0ZSBpcyBpZGxlLCBiZWNhdXNlIHdlIG5ldmVyIHByb2Nlc3Ncblx0ICAvLyBpZGxlIHVwZGF0ZXMgdW50aWwgYWZ0ZXIgYWxsIHRoZSByZWd1bGFyIHVwZGF0ZXMgaGF2ZSBmaW5pc2hlZDsgdGhlcmUncyBub1xuXHQgIC8vIHdheSBpdCBjb3VsZCB1bmJsb2NrIGEgdHJhbnNpdGlvbi5cblxuXHQgIGlmICh1cGRhdGVMYW5lICE9PSBJZGxlTGFuZSkge1xuXHQgICAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgICByb290LnBpbmdlZExhbmVzID0gTm9MYW5lcztcblx0ICB9XG5cblx0ICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcblx0ICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleCh1cGRhdGVMYW5lKTsgLy8gV2UgY2FuIGFsd2F5cyBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdGltZXN0YW1wIGJlY2F1c2Ugd2UgcHJlZmVyIHRoZSBtb3N0XG5cdCAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG5cdCAgZXZlbnRUaW1lc1tpbmRleF0gPSBldmVudFRpbWU7XG5cdH1cblx0ZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcblx0ICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuXHQgIHJvb3QucGluZ2VkTGFuZXMgJj0gfnN1c3BlbmRlZExhbmVzOyAvLyBUaGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBubyBsb25nZXIgQ1BVLWJvdW5kLiBDbGVhciB0aGVpciBleHBpcmF0aW9uIHRpbWVzLlxuXG5cdCAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuXHQgIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG5cdCAgd2hpbGUgKGxhbmVzID4gMCkge1xuXHQgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG5cdCAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG5cdCAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG5cdCAgICBsYW5lcyAmPSB+bGFuZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuXHQgIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xuXHR9XG5cdGZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcblx0ICB2YXIgbm9Mb25nZXJQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcblx0ICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyBMZXQncyB0cnkgZXZlcnl0aGluZyBhZ2FpblxuXG5cdCAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG5cdCAgcm9vdC5tdXRhYmxlUmVhZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuXHQgIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG5cdCAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG5cdCAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG5cdCAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBDbGVhciB0aGUgbGFuZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBwZW5kaW5nIHdvcmtcblxuXHQgIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG5cdCAgd2hpbGUgKGxhbmVzID4gMCkge1xuXHQgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG5cdCAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG5cdCAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG5cdCAgICBldmVudFRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuXHQgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuXHQgICAgbGFuZXMgJj0gfmxhbmU7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG5cdCAgLy8gSW4gYWRkaXRpb24gdG8gZW50YW5nbGluZyBlYWNoIG9mIHRoZSBnaXZlbiBsYW5lcyB3aXRoIGVhY2ggb3RoZXIsIHdlIGFsc29cblx0ICAvLyBoYXZlIHRvIGNvbnNpZGVyIF90cmFuc2l0aXZlXyBlbnRhbmdsZW1lbnRzLiBGb3IgZWFjaCBsYW5lIHRoYXQgaXMgYWxyZWFkeVxuXHQgIC8vIGVudGFuZ2xlZCB3aXRoICphbnkqIG9mIHRoZSBnaXZlbiBsYW5lcywgdGhhdCBsYW5lIGlzIG5vdyB0cmFuc2l0aXZlbHlcblx0ICAvLyBlbnRhbmdsZWQgd2l0aCAqYWxsKiB0aGUgZ2l2ZW4gbGFuZXMuXG5cdCAgLy9cblx0ICAvLyBUcmFuc2xhdGVkOiBJZiBDIGlzIGVudGFuZ2xlZCB3aXRoIEEsIHRoZW4gZW50YW5nbGluZyBBIHdpdGggQiBhbHNvXG5cdCAgLy8gZW50YW5nbGVzIEMgd2l0aCBCLlxuXHQgIC8vXG5cdCAgLy8gSWYgdGhpcyBpcyBoYXJkIHRvIGdyYXNwLCBpdCBtaWdodCBoZWxwIHRvIGludGVudGlvbmFsbHkgYnJlYWsgdGhpc1xuXHQgIC8vIGZ1bmN0aW9uIGFuZCBsb29rIGF0IHRoZSB0ZXN0cyB0aGF0IGZhaWwgaW4gUmVhY3RUcmFuc2l0aW9uLXRlc3QuanMuIFRyeVxuXHQgIC8vIGNvbW1lbnRpbmcgb3V0IG9uZSBvZiB0aGUgY29uZGl0aW9ucyBiZWxvdy5cblx0ICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcztcblx0ICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcblx0ICB2YXIgbGFuZXMgPSByb290RW50YW5nbGVkTGFuZXM7XG5cblx0ICB3aGlsZSAobGFuZXMpIHtcblx0ICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuXHQgICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuXG5cdCAgICBpZiAoIC8vIElzIHRoaXMgb25lIG9mIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG5cdCAgICBsYW5lICYgZW50YW5nbGVkTGFuZXMgfCAvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG5cdCAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSAmIGVudGFuZ2xlZExhbmVzKSB7XG5cdCAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuXHQgICAgfVxuXG5cdCAgICBsYW5lcyAmPSB+bGFuZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihyb290LCByZW5kZXJMYW5lcykge1xuXHQgIHZhciByZW5kZXJMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShyZW5kZXJMYW5lcyk7XG5cdCAgdmFyIGxhbmU7XG5cblx0ICBzd2l0Y2ggKHJlbmRlckxhbmUpIHtcblx0ICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcblx0ICAgICAgbGFuZSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIERlZmF1bHRMYW5lOlxuXHQgICAgICBsYW5lID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTM6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTY6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcblx0ICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuXHQgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTk6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTI6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTU6XG5cdCAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG5cdCAgICBjYXNlIFJldHJ5TGFuZTE6XG5cdCAgICBjYXNlIFJldHJ5TGFuZTI6XG5cdCAgICBjYXNlIFJldHJ5TGFuZTM6XG5cdCAgICBjYXNlIFJldHJ5TGFuZTQ6XG5cdCAgICBjYXNlIFJldHJ5TGFuZTU6XG5cdCAgICAgIGxhbmUgPSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgSWRsZUxhbmU6XG5cdCAgICAgIGxhbmUgPSBJZGxlSHlkcmF0aW9uTGFuZTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3Rcblx0ICAgICAgLy8gYmUgcmV0cmllZCBhdCBhIGh5ZHJhdGlvbiBsYW5lLlxuXHQgICAgICBsYW5lID0gTm9MYW5lO1xuXHQgICAgICBicmVhaztcblx0ICB9IC8vIENoZWNrIGlmIHRoZSBsYW5lIHdlIGNob3NlIGlzIHN1c3BlbmRlZC4gSWYgc28sIHRoYXQgaW5kaWNhdGVzIHRoYXQgd2Vcblx0ICAvLyBhbHJlYWR5IGF0dGVtcHRlZCBhbmQgZmFpbGVkIHRvIGh5ZHJhdGUgYXQgdGhhdCBsZXZlbC4gQWxzbyBjaGVjayBpZiB3ZSdyZVxuXHQgIC8vIGFscmVhZHkgcmVuZGVyaW5nIHRoYXQgbGFuZSwgd2hpY2ggaXMgcmFyZSBidXQgY291bGQgaGFwcGVuLlxuXG5cblx0ICBpZiAoKGxhbmUgJiAocm9vdC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSkgIT09IE5vTGFuZSkge1xuXHQgICAgLy8gR2l2ZSB1cCB0cnlpbmcgdG8gaHlkcmF0ZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCByZW5kZXIuXG5cdCAgICByZXR1cm4gTm9MYW5lO1xuXHQgIH1cblxuXHQgIHJldHVybiBsYW5lO1xuXHR9XG5cdGZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcblxuXHQgIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcblxuXHQgIHdoaWxlIChsYW5lcyA+IDApIHtcblx0ICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcblx0ICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblx0ICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuXHQgICAgdXBkYXRlcnMuYWRkKGZpYmVyKTtcblx0ICAgIGxhbmVzICY9IH5sYW5lO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpIHtcblxuXHQgIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcblx0ICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuXHQgIHdoaWxlIChsYW5lcyA+IDApIHtcblx0ICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcblx0ICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblx0ICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuXG5cdCAgICBpZiAodXBkYXRlcnMuc2l6ZSA+IDApIHtcblx0ICAgICAgdXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcblx0ICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG5cdCAgICAgICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCAhbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkge1xuXHQgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIHVwZGF0ZXJzLmNsZWFyKCk7XG5cdCAgICB9XG5cblx0ICAgIGxhbmVzICY9IH5sYW5lO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKHJvb3QsIGxhbmVzKSB7XG5cdCAge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHR9XG5cblx0dmFyIERpc2NyZXRlRXZlbnRQcmlvcml0eSA9IFN5bmNMYW5lO1xuXHR2YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xuXHR2YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcblx0dmFyIElkbGVFdmVudFByaW9yaXR5ID0gSWRsZUxhbmU7XG5cdHZhciBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBOb0xhbmU7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpIHtcblx0ICByZXR1cm4gY3VycmVudFVwZGF0ZVByaW9yaXR5O1xuXHR9XG5cdGZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuXHQgIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IG5ld1ByaW9yaXR5O1xuXHR9XG5cdGZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcblx0ICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcblxuXHQgIHRyeSB7XG5cdCAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmlvcml0eTtcblx0ICAgIHJldHVybiBmbigpO1xuXHQgIH0gZmluYWxseSB7XG5cdCAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmV2aW91c1ByaW9yaXR5O1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcblx0ICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYiA/IGEgOiBiO1xuXHR9XG5cdGZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG5cdCAgcmV0dXJuIGEgPT09IDAgfHwgYSA+IGIgPyBhIDogYjtcblx0fVxuXHRmdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuXHQgIHJldHVybiBhICE9PSAwICYmIGEgPCBiO1xuXHR9XG5cdGZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG5cdCAgdmFyIGxhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcblxuXHQgIGlmICghaXNIaWdoZXJFdmVudFByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcblx0ICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5cdCAgfVxuXG5cdCAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHksIGxhbmUpKSB7XG5cdCAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG5cdCAgfVxuXG5cdCAgaWYgKGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZSkpIHtcblx0ICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcblx0ICB9XG5cblx0ICByZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7XG5cdH1cblxuXHQvLyBUaGlzIG1vZHVsZSBvbmx5IGV4aXN0cyBhcyBhbiBFU00gd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIENvbW1vbkpTXG5cdHZhciBzY2hlZHVsZUNhbGxiYWNrID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5cdHZhciBjYW5jZWxDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcblx0dmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkO1xuXHR2YXIgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludDtcblx0dmFyIG5vdyA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG5cdHZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcblx0dmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXHR2YXIgTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk7XG5cdHZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuXHQvLyB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3Qgb24gdGhlIHNjaGVkdWxlciwgYnV0IGl0ICpkb2VzKlxuXHQvLyBvbiBzY2hlZHVsZXIvdW5zdGFibGVfbW9jaywgd2hpY2ggd2UnbGwgbmVlZCBmb3IgaW50ZXJuYWwgdGVzdGluZ1xuXHR2YXIgdW5zdGFibGVfeWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlO1xuXHR2YXIgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUgPSBTY2hlZHVsZXIudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWU7XG5cblx0dmFyIHJlbmRlcmVySUQgPSBudWxsO1xuXHR2YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcblx0dmFyIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBudWxsO1xuXHR2YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblx0dmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5cdGZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcblx0ICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIC8vIE5vIERldlRvb2xzXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cblx0ICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG5cdCAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuXHQgICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4Nzdcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG5cdCAgICB7XG5cdCAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcblx0ICAgIH0gLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG5cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgdHJ5IHtcblx0ICAgIGlmIChlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIpIHtcblx0ICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cblx0ICAgICAgLy8gVGhpcyBnaXZlcyBEZXZUb29scyBhIHdheSB0byBmZWF0dXJlIGRldGVjdCB0aGF0IGlzbid0IHRpZWQgdG8gdmVyc2lvbiBudW1iZXJcblx0ICAgICAgLy8gKHNpbmNlIHByb2ZpbGluZyBhbmQgdGltZWxpbmUgYXJlIGNvbnRyb2xsZWQgYnkgZGlmZmVyZW50IGZlYXR1cmUgZmxhZ3MpLlxuXHQgICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuXHQgICAgICAgIGdldExhbmVMYWJlbE1hcDogZ2V0TGFuZUxhYmVsTWFwLFxuXHQgICAgICAgIGluamVjdFByb2ZpbGluZ0hvb2tzOiBpbmplY3RQcm9maWxpbmdIb29rc1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cblx0ICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG5cdCAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cblx0ICAgIHtcblx0ICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoaG9vay5jaGVja0RDRSkge1xuXHQgICAgLy8gVGhpcyBpcyB0aGUgcmVhbCBEZXZUb29scy5cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBUaGlzIGlzIGxpa2VseSBhIGhvb2sgaW5zdGFsbGVkIGJ5IEZhc3QgUmVmcmVzaCBydW50aW1lLlxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgY2hpbGRyZW4pO1xuXHQgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuXHQgICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG5cdCAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290LCBldmVudFByaW9yaXR5KSB7XG5cdCAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICB2YXIgZGlkRXJyb3IgPSAocm9vdC5jdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IERpZENhcHR1cmU7XG5cblx0ICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcblx0ICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHk7XG5cblx0ICAgICAgICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcblx0ICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuXHQgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcblx0ICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG5cdCAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuXHQgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBzY2hlZHVsZXJQcmlvcml0eSwgZGlkRXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAge1xuXHQgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcblx0ICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuXHQgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBvblBvc3RDb21taXRSb290KHJvb3QpIHtcblx0ICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuXHQgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgIHtcblx0ICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG5cdCAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cblx0ICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG5cdCAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuXHQgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgIHtcblx0ICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG5cdCAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cblx0ICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG5cdCAge1xuXHQgICAgaWYgKHR5cGVvZiB1bnN0YWJsZV95aWVsZFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIC8vIFdlJ3JlIGluIGEgdGVzdCBiZWNhdXNlIFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlIG9ubHkgZXhpc3RzXG5cdCAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG5cdCAgICAgIC8vIHN1cHByZXNzIHdhcm5pbmdzIGFuZCBkaXNhYmxlIHNjaGVkdWxlciB5aWVsZGluZyBkdXJpbmcgdGhlIGRvdWJsZSByZW5kZXJcblx0ICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtcblx0ICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUocmVuZGVyZXJJRCwgbmV3SXNTdHJpY3RNb2RlKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuXHQgICAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cblx0ICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuXHRmdW5jdGlvbiBpbmplY3RQcm9maWxpbmdIb29rcyhwcm9maWxpbmdIb29rcykge1xuXHQgIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBwcm9maWxpbmdIb29rcztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldExhbmVMYWJlbE1hcCgpIHtcblx0ICB7XG5cdCAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuXHQgICAgdmFyIGxhbmUgPSAxO1xuXG5cdCAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgVG90YWxMYW5lczsgaW5kZXgrKykge1xuXHQgICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG5cdCAgICAgIG1hcC5zZXQobGFuZSwgbGFiZWwpO1xuXHQgICAgICBsYW5lICo9IDI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXA7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGxhbmVzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG5cdCAge1xuXHQgICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCgpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG5cdCAge1xuXHQgICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaWJlcik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG5cdCAge1xuXHQgICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCkge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsIHRocm93blZhbHVlLCBsYW5lcykge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoZmliZXIsIHRocm93blZhbHVlLCBsYW5lcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcykge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkKGZpYmVyLCB3YWtlYWJsZSwgbGFuZXMpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKSB7XG5cdCAge1xuXHQgICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG5cdCAge1xuXHQgICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gbWFya1JlbmRlcllpZWxkZWQoKSB7XG5cdCAge1xuXHQgICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlcllpZWxkZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSkge1xuXHQgIHtcblx0ICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcblx0ICB7XG5cdCAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG5cdCAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuXHQgKi9cblx0ZnVuY3Rpb24gaXMoeCwgeSkge1xuXHQgIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdCAgO1xuXHR9XG5cblx0dmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG5cdHZhciBzeW5jUXVldWUgPSBudWxsO1xuXHR2YXIgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gZmFsc2U7XG5cdHZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlID0gZmFsc2U7XG5cdGZ1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKSB7XG5cdCAgLy8gUHVzaCB0aGlzIGNhbGxiYWNrIGludG8gYW4gaW50ZXJuYWwgcXVldWUuIFdlJ2xsIGZsdXNoIHRoZXNlIGVpdGhlciBpblxuXHQgIC8vIHRoZSBuZXh0IHRpY2ssIG9yIGVhcmxpZXIgaWYgc29tZXRoaW5nIGNhbGxzIGBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlYC5cblx0ICBpZiAoc3luY1F1ZXVlID09PSBudWxsKSB7XG5cdCAgICBzeW5jUXVldWUgPSBbY2FsbGJhY2tdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBQdXNoIG9udG8gZXhpc3RpbmcgcXVldWUuIERvbid0IG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBiZWNhdXNlXG5cdCAgICAvLyB3ZSBhbHJlYWR5IHNjaGVkdWxlZCBvbmUgd2hlbiB3ZSBjcmVhdGVkIHRoZSBxdWV1ZS5cblx0ICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcblx0ICBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSB0cnVlO1xuXHQgIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKTtcblx0fVxuXHRmdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCkge1xuXHQgIC8vIE9ubHkgZmx1c2hlcyB0aGUgcXVldWUgaWYgdGhlcmUncyBhIGxlZ2FjeSBzeW5jIGNhbGxiYWNrIHNjaGVkdWxlZC5cblx0ICAvLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG5cdCAgLy8gaXQgbWlnaHQgbWFrZSBtb3JlIHNlbnNlIGZvciB0aGUgcXVldWUgdG8gYmUgYSBsaXN0IG9mIHJvb3RzIGluc3RlYWQgb2YgYVxuXHQgIC8vIGxpc3Qgb2YgZ2VuZXJpYyBjYWxsYmFja3MuIFRoZW4gd2UgY2FuIGhhdmUgdHdvOiBvbmUgZm9yIGxlZ2FjeSByb290cywgb25lXG5cdCAgLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cblx0ICBpZiAoaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzKSB7XG5cdCAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tzKCkge1xuXHQgIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcblx0ICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG5cdCAgICBpc0ZsdXNoaW5nU3luY1F1ZXVlID0gdHJ1ZTtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIHZhciBwcmV2aW91c1VwZGF0ZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHZhciBpc1N5bmMgPSB0cnVlO1xuXHQgICAgICB2YXIgcXVldWUgPSBzeW5jUXVldWU7IC8vIFRPRE86IElzIHRoaXMgbmVjZXNzYXJ5IGFueW1vcmU/IFRoZSBvbmx5IHVzZXIgY29kZSB0aGF0IHJ1bnMgaW4gdGhpc1xuXHQgICAgICAvLyBxdWV1ZSBpcyBpbiB0aGUgcmVuZGVyIG9yIGNvbW1pdCBwaGFzZXMuXG5cblx0ICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cblx0ICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG5cdCAgICAgICAgZG8ge1xuXHQgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhpc1N5bmMpO1xuXHQgICAgICAgIH0gd2hpbGUgKGNhbGxiYWNrICE9PSBudWxsKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHN5bmNRdWV1ZSA9IG51bGw7XG5cdCAgICAgIGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcyA9IGZhbHNlO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuXHQgICAgICBpZiAoc3luY1F1ZXVlICE9PSBudWxsKSB7XG5cdCAgICAgICAgc3luY1F1ZXVlID0gc3luY1F1ZXVlLnNsaWNlKGkgKyAxKTtcblx0ICAgICAgfSAvLyBSZXN1bWUgZmx1c2hpbmcgaW4gdGhlIG5leHQgdGlja1xuXG5cblx0ICAgICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSwgZmx1c2hTeW5jQ2FsbGJhY2tzKTtcblx0ICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVQcmlvcml0eSk7XG5cdCAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFRoaXMgaXMgaW1wb3J0ZWQgYnkgdGhlIGV2ZW50IHJlcGxheWluZyBpbXBsZW1lbnRhdGlvbiBpbiBSZWFjdCBET00uIEl0J3Ncblx0Ly8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcblx0Ly8gdGhlIHJlY29uY2lsZXIuXG5cdGZ1bmN0aW9uIGlzUm9vdERlaHlkcmF0ZWQocm9vdCkge1xuXHQgIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblx0ICByZXR1cm4gY3VycmVudFN0YXRlLmlzRGVoeWRyYXRlZDtcblx0fVxuXG5cdC8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cblx0Ly8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgaXQgeWV0IHRvIGRlcmlzayB0aGUgaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZVxuXHQvLyB0aGUgd2F5IHdlIHB1c2gvcG9wIHRoZXNlIHZhbHVlcyBpcyBhIGJpdCB1bnVzdWFsLiBJZiB0aGVyZSdzIGEgbWlzdGFrZSwgSSdkXG5cdC8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG5cdHZhciBmb3JrU3RhY2sgPSBbXTtcblx0dmFyIGZvcmtTdGFja0luZGV4ID0gMDtcblx0dmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xuXHR2YXIgdHJlZUZvcmtDb3VudCA9IDA7XG5cdHZhciBpZFN0YWNrID0gW107XG5cdHZhciBpZFN0YWNrSW5kZXggPSAwO1xuXHR2YXIgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGw7XG5cdHZhciB0cmVlQ29udGV4dElkID0gMTtcblx0dmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcblx0ZnVuY3Rpb24gaXNGb3JrZWRDaGlsZCh3b3JrSW5Qcm9ncmVzcykge1xuXHQgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXHQgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzO1xuXHR9XG5cdGZ1bmN0aW9uIGdldEZvcmtzQXRMZXZlbCh3b3JrSW5Qcm9ncmVzcykge1xuXHQgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXHQgIHJldHVybiB0cmVlRm9ya0NvdW50O1xuXHR9XG5cdGZ1bmN0aW9uIGdldFRyZWVJZCgpIHtcblx0ICB2YXIgb3ZlcmZsb3cgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuXHQgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcblx0ICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG5cdCAgcmV0dXJuIGlkLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xuXHR9XG5cdGZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuXHQgIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHdlIHJlY29uY2lsZSBhbiBhcnJheSAob3IgaXRlcmF0b3IpIG9mIGNoaWxkXG5cdCAgLy8gZmliZXJzLCBiZWNhdXNlIHRoYXQncyB0aGUgb25seSBwbGFjZSB3aGVyZSB3ZSBrbm93IGhvdyBtYW55IGNoaWxkcmVuIGluXG5cdCAgLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG5cdCAgLy8gaW5mb3JtYXRpb24gb24gdGhlIGZpYmVyLlxuXHQgIC8vXG5cdCAgLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG5cdCAgLy8gdGhlIHJlbmRlciBwaGFzZSBvZiB0aGUgZm9yayBwYXJlbnQsIG5vdCB0aGUgY2hpbGQsIHdoaWNoIGlzIHdoZXJlIHdlIHB1c2hcblx0ICAvLyB0aGUgb3RoZXIgY29udGV4dCB2YWx1ZXMuXG5cdCAgLy9cblx0ICAvLyBJbiB0aGUgRml6eiBpbXBsZW1lbnRhdGlvbiB0aGlzIGlzIG11Y2ggc2ltcGxlciBiZWNhdXNlIHRoZSBjaGlsZCBpc1xuXHQgIC8vIHJlbmRlcmVkIGluIHRoZSBzYW1lIGNhbGxzdGFjayBhcyB0aGUgcGFyZW50LlxuXHQgIC8vXG5cdCAgLy8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgYWRkIGEgYGZvcmtzYCBmaWVsZCB0byB0aGUgRmliZXIgdHlwZS4gSXQgd291bGRcblx0ICAvLyBtYWtlIHRoaXMgbW9kdWxlIHNpbXBsZXIuXG5cdCAgd2FybklmTm90SHlkcmF0aW5nKCk7XG5cdCAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcblx0ICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya1Byb3ZpZGVyO1xuXHQgIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcblx0ICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcblx0fVxuXHRmdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuXHQgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXHQgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcblx0ICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG5cdCAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuXHQgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcblx0ICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuXHQgIHZhciBiYXNlT3ZlcmZsb3cgPSB0cmVlQ29udGV4dE92ZXJmbG93OyAvLyBUaGUgbGVmdG1vc3QgMSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgbm9uLWluY2x1c2l2ZS4gSXQncyBub3QgcGFydFxuXHQgIC8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG5cblx0ICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuXHQgIHZhciBiYXNlSWQgPSBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCBiYXNlTGVuZ3RoKTtcblx0ICB2YXIgc2xvdCA9IGluZGV4ICsgMTtcblx0ICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG5cdCAgLy8gY29uc2lkZXJhdGlvbiB0aGUgbGVhZGluZyAxIHdlIHVzZSB0byBtYXJrIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuXG5cdCAgaWYgKGxlbmd0aCA+IDMwKSB7XG5cdCAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuXHQgICAgLy8gVGhpcyBicmFuY2ggYXNzdW1lcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXNlIGlkIGlzIGdyZWF0ZXIgdGhhbiA1OyBpdCB3b24ndFxuXHQgICAgLy8gd29yayBmb3Igc21hbGxlciBpZHMsIGJlY2F1c2UgeW91IG5lZWQgNSBiaXRzIHBlciBjaGFyYWN0ZXIuXG5cdCAgICAvL1xuXHQgICAgLy8gV2UgZW5jb2RlIHRoZSBpZCBpbiBtdWx0aXBsZSBzdGVwczogZmlyc3QgdGhlIGJhc2UgaWQsIHRoZW4gdGhlXG5cdCAgICAvLyByZW1haW5pbmcgZGlnaXRzLlxuXHQgICAgLy9cblx0ICAgIC8vIEVhY2ggNSBiaXQgc2VxdWVuY2UgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgYmFzZSAzMiBjaGFyYWN0ZXIuIFNvIGZvclxuXHQgICAgLy8gZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgaWQgaXMgMjMgYml0cyBsb25nLCB3ZSBjYW4gY29udmVydCAyMCBvZiB0aG9zZVxuXHQgICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuXHQgICAgLy9cblx0ICAgIC8vIEZpcnN0IGNhbGN1bGF0ZSBob3cgbWFueSBiaXRzIGluIHRoZSBiYXNlIGlkIHJlcHJlc2VudCBhIGNvbXBsZXRlXG5cdCAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuXHQgICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIGJhc2VMZW5ndGggJSA1OyAvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cblxuXHQgICAgdmFyIG5ld092ZXJmbG93Qml0cyA9ICgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDE7IC8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxuXG5cdCAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuXHQgICAgdmFyIHJlc3RPZkJhc2VJZCA9IGJhc2VJZCA+PiBudW1iZXJPZk92ZXJmbG93Qml0cztcblx0ICAgIHZhciByZXN0T2ZCYXNlTGVuZ3RoID0gYmFzZUxlbmd0aCAtIG51bWJlck9mT3ZlcmZsb3dCaXRzOyAvLyBGaW5hbGx5LCBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIGJpdHMgdXNpbmcgdGhlIG5vcm1hbCBhbGdvcml0aG0uIEJlY2F1c2Vcblx0ICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cblx0ICAgIHZhciByZXN0T2ZMZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyByZXN0T2ZCYXNlTGVuZ3RoO1xuXHQgICAgdmFyIHJlc3RPZk5ld0JpdHMgPSBzbG90IDw8IHJlc3RPZkJhc2VMZW5ndGg7XG5cdCAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuXHQgICAgdmFyIG92ZXJmbG93ID0gbmV3T3ZlcmZsb3cgKyBiYXNlT3ZlcmZsb3c7XG5cdCAgICB0cmVlQ29udGV4dElkID0gMSA8PCByZXN0T2ZMZW5ndGggfCBpZDtcblx0ICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBvdmVyZmxvdztcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gTm9ybWFsIHBhdGhcblx0ICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG5cdCAgICB2YXIgX2lkID0gbmV3Qml0cyB8IGJhc2VJZDtcblxuXHQgICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcblx0ICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IGxlbmd0aCB8IF9pZDtcblx0ICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBfb3ZlcmZsb3c7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpIHtcblx0ICB3YXJuSWZOb3RIeWRyYXRpbmcoKTsgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBUaGlzIHdpbGwgYWZmZWN0IGFueSBpZHMgdGhhdCBhcHBlYXJcblx0ICAvLyBpbiBpdHMgY2hpbGRyZW4uXG5cblx0ICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cblx0ICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcblx0ICAgIHZhciBudW1iZXJPZkZvcmtzID0gMTtcblx0ICAgIHZhciBzbG90SW5kZXggPSAwO1xuXHQgICAgcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzKTtcblx0ICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuXHQgIHJldHVybiAzMiAtIGNsejMyKG51bWJlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG5cdCAgcmV0dXJuIDEgPDwgZ2V0Qml0TGVuZ3RoKGlkKSAtIDE7XG5cdH1cblxuXHRmdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuXHQgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHZhbHVlcy5cblx0ICAvLyBUaGlzIGlzIGEgYml0IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBvdGhlciBjb250ZXh0LWxpa2UgbW9kdWxlcyBpbiBGaWJlclxuXHQgIC8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuXHQgIC8vIGRpZmZlcmVudCByZWFzb25zLiBXZSBoYXZlIHRvIGtlZXAgcG9wcGluZyB1bnRpbCB0aGUgd29yay1pbi1wcm9ncmVzcyBpc1xuXHQgIC8vIG5vIGxvbmdlciBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cblx0ICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXIpIHtcblx0ICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG5cdCAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbDtcblx0ICAgIHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG5cdCAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbDtcblx0ICB9XG5cblx0ICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXIpIHtcblx0ICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcblx0ICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG5cdCAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG5cdCAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuXHQgICAgdHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuXHQgICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSB7XG5cdCAgd2FybklmTm90SHlkcmF0aW5nKCk7XG5cblx0ICBpZiAodHJlZUNvbnRleHRQcm92aWRlciAhPT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgaWQ6IHRyZWVDb250ZXh0SWQsXG5cdCAgICAgIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5kZWRDb250ZXh0KSB7XG5cdCAgd2FybklmTm90SHlkcmF0aW5nKCk7XG5cdCAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuXHQgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcblx0ICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG5cdCAgdHJlZUNvbnRleHRJZCA9IHN1c3BlbmRlZENvbnRleHQuaWQ7XG5cdCAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IHN1c3BlbmRlZENvbnRleHQub3ZlcmZsb3c7XG5cdCAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2FybklmTm90SHlkcmF0aW5nKCkge1xuXHQgIHtcblx0ICAgIGlmICghZ2V0SXNIeWRyYXRpbmcoKSkge1xuXHQgICAgICBlcnJvcignRXhwZWN0ZWQgdG8gYmUgaHlkcmF0aW5nLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cblx0dmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcblx0dmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuXHR2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTsgLy8gVGhpcyBmbGFnIGFsbG93cyBmb3Igd2FybmluZyBzdXByZXNzaW9uIHdoZW4gd2UgZXhwZWN0IHRoZXJlIHRvIGJlIG1pc21hdGNoZXNcblx0Ly8gZHVlIHRvIGVhcmxpZXIgbWlzbWF0Y2hlcyBvciBhIHN1c3BlbmRlZCBmaWJlci5cblxuXHR2YXIgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTsgLy8gSHlkcmF0aW9uIGVycm9ycyB0aGF0IHdlcmUgdGhyb3duIGluc2lkZSB0aGlzIGJvdW5kYXJ5XG5cblx0dmFyIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG5cblx0ZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuXHQgIHtcblx0ICAgIGlmIChpc0h5ZHJhdGluZykge1xuXHQgICAgICBlcnJvcignV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuJyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKSB7XG5cdCAge1xuXHQgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSB0cnVlO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBkaWRTdXNwZW5kT3JFcnJvcldoaWxlSHlkcmF0aW5nREVWKCkge1xuXHQgIHtcblx0ICAgIHJldHVybiBkaWRTdXNwZW5kT3JFcnJvckRFVjtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG5cdCAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXHQgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRJbnN0YW5jZSk7XG5cdCAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcblx0ICBpc0h5ZHJhdGluZyA9IHRydWU7XG5cdCAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcblx0ICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyLCBzdXNwZW5zZUluc3RhbmNlLCB0cmVlQ29udGV4dCkge1xuXHQgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuXHQgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG5cdCAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuXHQgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG5cdCAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTtcblxuXHQgIGlmICh0cmVlQ29udGV4dCAhPT0gbnVsbCkge1xuXHQgICAgcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KGZpYmVyLCB0cmVlQ29udGV4dCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuXHQgIHtcblx0ICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG5cdCAgICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcblx0ICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlLCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuXHQgICAgICAgICAgaXNDb25jdXJyZW50TW9kZSk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHJldHVybkZpYmVyLm1lbW9pemVkU3RhdGU7XG5cdCAgICAgICAgICBpZiAoc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSBkaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCwgaW5zdGFuY2UpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcblx0ICB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSk7XG5cdCAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuXHQgIGNoaWxkVG9EZWxldGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG5cdCAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblx0ICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG5cdCAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdO1xuXHQgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcblx0ICB9IGVsc2Uge1xuXHQgICAgZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG5cdCAge1xuXHQgICAgaWYgKGRpZFN1c3BlbmRPckVycm9yREVWKSB7XG5cdCAgICAgIC8vIEluc2lkZSBhIGJvdW5kYXJ5IHRoYXQgYWxyZWFkeSBzdXNwZW5kZWQuIFdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgdGhlXG5cdCAgICAgIC8vIHNpYmxpbmdzIG9mIGEgc3VzcGVuZGVkIG5vZGUuIFRoZSBtaXNtYXRjaCBtYXkgYmUgZHVlIHRvIHRoZSBtaXNzaW5nXG5cdCAgICAgIC8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuXHQgICAgICBjYXNlIEhvc3RSb290OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuXHQgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcblx0ICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblx0ICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG5cdCAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcblx0ICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuXHQgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXHQgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcblx0ICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyKTtcblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG5cdCAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuXHQgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuXHQgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcblx0ICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaXNDb25jdXJyZW50TW9kZSA9IChyZXR1cm5GaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGU7XG5cdCAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUsIF9wcm9wcywgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cblx0ICAgICAgICAgICAgICAgIGlzQ29uY3VycmVudE1vZGUpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG5cdCAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgX2lzQ29uY3VycmVudE1vZGUgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG5cdCAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0LCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuXHQgICAgICAgICAgICAgICAgX2lzQ29uY3VycmVudE1vZGUpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gcmV0dXJuRmliZXIubWVtb2l6ZWRTdGF0ZTtcblx0ICAgICAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG5cdCAgICAgICAgICBpZiAoX3BhcmVudEluc3RhbmNlICE9PSBudWxsKSBzd2l0Y2ggKGZpYmVyLnRhZykge1xuXHQgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgICAgICAgICAgdmFyIF90eXBlMiA9IGZpYmVyLnR5cGU7XG5cdCAgICAgICAgICAgICAgdmFyIF9wcm9wczIgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG5cdCAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdHlwZTIsIF9wcm9wczIpO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG5cdCAgICAgICAgICAgICAgdmFyIF90ZXh0MiA9IGZpYmVyLnBlbmRpbmdQcm9wcztcblx0ICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdGV4dDIpO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UpO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG5cdCAgZmliZXIuZmxhZ3MgPSBmaWJlci5mbGFncyAmIH5IeWRyYXRpbmcgfCBQbGFjZW1lbnQ7XG5cdCAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuXHQgIHN3aXRjaCAoZmliZXIudGFnKSB7XG5cdCAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cdCAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXHQgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcblxuXHQgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG5cdCAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuXHQgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcblx0ICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEhvc3RUZXh0OlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG5cdCAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcblxuXHQgICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcblx0ICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IHRleHRJbnN0YW5jZTtcblx0ICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFRleHQgSW5zdGFuY2VzIGRvbid0IGhhdmUgY2hpbGRyZW4gc28gdGhlcmUncyBub3RoaW5nIHRvIGh5ZHJhdGUuXG5cblx0ICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSk7XG5cblx0ICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB7XG5cdCAgICAgICAgICAgIGRlaHlkcmF0ZWQ6IHN1c3BlbnNlSW5zdGFuY2UsXG5cdCAgICAgICAgICAgIHRyZWVDb250ZXh0OiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpLFxuXHQgICAgICAgICAgICByZXRyeUxhbmU6IE9mZnNjcmVlbkxhbmVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gc3VzcGVuc2VTdGF0ZTsgLy8gU3RvcmUgdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQgYXMgYSBjaGlsZCBmaWJlci5cblx0ICAgICAgICAgIC8vIFRoaXMgc2ltcGxpZmllcyB0aGUgY29kZSBmb3IgZ2V0SG9zdFNpYmxpbmcgYW5kIGRlbGV0aW5nIG5vZGVzLFxuXHQgICAgICAgICAgLy8gc2luY2UgaXQgZG9lc24ndCBoYXZlIHRvIGNvbnNpZGVyIGFsbCBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuXHQgICAgICAgICAgLy8gY2hlY2sgaWYgdGhleSdyZSBkZWh5ZHJhdGVkIG9uZXMgb3Igbm90LlxuXG5cdCAgICAgICAgICB2YXIgZGVoeWRyYXRlZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KHN1c3BlbnNlSW5zdGFuY2UpO1xuXHQgICAgICAgICAgZGVoeWRyYXRlZEZyYWdtZW50LnJldHVybiA9IGZpYmVyO1xuXHQgICAgICAgICAgZmliZXIuY2hpbGQgPSBkZWh5ZHJhdGVkRnJhZ21lbnQ7XG5cdCAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyOyAvLyBXaGlsZSBhIFN1c3BlbnNlIEluc3RhbmNlIGRvZXMgaGF2ZSBjaGlsZHJlbiwgd2Ugd29uJ3Qgc3RlcCBpbnRvXG5cdCAgICAgICAgICAvLyBpdCBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIEluc3RlYWQsIHdlJ2xsIHJlZW50ZXIgaXQgbGF0ZXIuXG5cblx0ICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSB7XG5cdCAgcmV0dXJuIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKGZpYmVyLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3M7XG5cdH1cblxuXHRmdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyAnICsgJ3JlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuJyk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuXHQgIGlmICghaXNIeWRyYXRpbmcpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuXHQgIGlmICghbmV4dEluc3RhbmNlKSB7XG5cdCAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcblx0ICAgICAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcblx0ICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7XG5cdCAgICB9IC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG5cblxuXHQgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuXHQgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0ICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG5cblx0ICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcblx0ICAgIGlmIChzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSkge1xuXHQgICAgICB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuXHQgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTtcblx0ICAgIH0gLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG5cdCAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG5cdCAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG5cblxuXHQgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuXHQgICAgdmFyIHByZXZIeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuXG5cdCAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuXHQgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuXHQgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG5cdCAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdCAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuXHQgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcblx0ICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcblx0ICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cblxuXG5cdCAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocHJldkh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG5cdCAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgfVxuXG5cdCAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXHQgIHZhciBzaG91bGRXYXJuSWZNaXNtYXRjaERldiA9ICFkaWRTdXNwZW5kT3JFcnJvckRFVjtcblx0ICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIsIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cblx0ICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuXHQgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG5cdCAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG5cdCAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgIH1cblxuXHQgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cdCAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcblx0ICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG5cdCAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIsIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTtcblxuXHQgIGlmIChzaG91bGRVcGRhdGUpIHtcblx0ICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG5cdCAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG5cdCAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcblxuXHQgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG5cdCAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG5cdCAgICAgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXHQgICAgICAgICAgICB2YXIgaXNDb25jdXJyZW50TW9kZSA9IChyZXR1cm5GaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGU7XG5cdCAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuXHQgICAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcblx0ICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcblx0ICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgICAgICAgIHZhciBfaXNDb25jdXJyZW50TW9kZTIgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG5cdCAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuXHQgICAgICAgICAgICBfaXNDb25jdXJyZW50TW9kZTIpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBzaG91bGRVcGRhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcblx0ICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgIH1cblxuXHQgIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblx0ICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG5cdCAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgIH1cblxuXHQgIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGZpYmVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcblx0ICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0ICB9XG5cblx0ICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cdCAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlICE9PSBudWxsID8gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIDogbnVsbDtcblxuXHQgIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0ICB9XG5cblx0ICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcblx0ICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG5cdCAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG5cdCAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuXHQgIH1cblxuXHQgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuXHR9XG5cblx0ZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcblx0ICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuXHQgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuXHQgICAgLy8gdHJlZS5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdCAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuXHQgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcblx0ICAgIC8vIHNpYmxpbmdzLlxuXHQgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cdCAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG5cdCAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG5cdCAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG5cdCAgLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuXG5cblx0ICBpZiAoZmliZXIudGFnICE9PSBIb3N0Um9vdCAmJiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpIHtcblx0ICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG5cdCAgICBpZiAobmV4dEluc3RhbmNlKSB7XG5cdCAgICAgIGlmIChzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSkge1xuXHQgICAgICAgIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpO1xuXHQgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcblx0ICAgICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcblx0ICAgICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuXG5cdCAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcblx0ICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFzVW5oeWRyYXRlZFRhaWxOb2RlcygpIHtcblx0ICByZXR1cm4gaXNIeWRyYXRpbmcgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSAhPT0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpIHtcblx0ICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuXHQgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcblx0ICAgIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG5cdCAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuXHQgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG5cdCAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG5cdCAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0ICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKSB7XG5cdCAgaWYgKGh5ZHJhdGlvbkVycm9ycyAhPT0gbnVsbCkge1xuXHQgICAgLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLiBUaGUgZXJyb3JzIHRoYXQgb2NjdXJyZWRcblx0ICAgIC8vIGR1cmluZyB0aGUgaHlkcmF0aW9uIGF0dGVtcHQgYXJlIG5vdyByZWNvdmVyZWQuIFdlIHdpbGwgbG9nIHRoZW0gaW5cblx0ICAgIC8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxuXHQgICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpO1xuXHQgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJc0h5ZHJhdGluZygpIHtcblx0ICByZXR1cm4gaXNIeWRyYXRpbmc7XG5cdH1cblxuXHRmdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG5cdCAgaWYgKGh5ZHJhdGlvbkVycm9ycyA9PT0gbnVsbCkge1xuXHQgICAgaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xuXHR2YXIgTm9UcmFuc2l0aW9uID0gbnVsbDtcblx0ZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuXHQgIHJldHVybiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2Vcblx0ICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG5cdCAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuXHQgIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG5cdCAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cblx0ICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9IC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG5cblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c0FbaV07XG5cblx0ICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fCAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuXHQgIGZpYmVyLl9kZWJ1Z093bmVyID8gZmliZXIuX2RlYnVnT3duZXIudHlwZSA6IG51bGwgO1xuXHQgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA7XG5cblx0ICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuXHQgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cblx0ICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcblx0ICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdMYXp5Jyk7XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuXHQgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cblx0ICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG5cdCAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cblx0ICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlcik7XG5cblx0ICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiAnJztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcblx0ICB0cnkge1xuXHQgICAgdmFyIGluZm8gPSAnJztcblx0ICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuXHQgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG5cdCAgICB9IHdoaWxlIChub2RlKTtcblxuXHQgICAgcmV0dXJuIGluZm87XG5cdCAgfSBjYXRjaCAoeCkge1xuXHQgICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuXHQgIH1cblx0fVxuXG5cdHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXHR2YXIgY3VycmVudCA9IG51bGw7XG5cdHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcblx0ICB7XG5cdCAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgdmFyIG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcblxuXHQgICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcblx0ICB7XG5cdCAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gJyc7XG5cdCAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuXHQgICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG5cdCAgICByZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuXHQgIHtcblx0ICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXHQgICAgY3VycmVudCA9IG51bGw7XG5cdCAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcblx0ICB7XG5cdCAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrID0gZmliZXIgPT09IG51bGwgPyBudWxsIDogZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcblx0ICAgIGN1cnJlbnQgPSBmaWJlcjtcblx0ICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlcigpIHtcblx0ICB7XG5cdCAgICByZXR1cm4gY3VycmVudDtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG5cdCAge1xuXHQgICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG5cdCAgfVxuXHR9XG5cblx0dmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuXHQgIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcblx0ICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG5cdCAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuXHQgIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9XG5cdH07XG5cblx0e1xuXHQgIHZhciBmaW5kU3RyaWN0Um9vdCA9IGZ1bmN0aW9uIChmaWJlcikge1xuXHQgICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG5cdCAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG5cdCAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuXHQgICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG5cdCAgICAgIH1cblxuXHQgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXliZVN0cmljdFJvb3Q7XG5cdCAgfTtcblxuXHQgIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcblx0ICAgIHZhciBhcnJheSA9IFtdO1xuXHQgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG5cdCAgfTtcblxuXHQgIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcblx0ICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuXHQgIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG5cdCAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG5cdCAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcblx0ICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuXHQgIHZhciBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuXG5cdCAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG5cdCAgICAvLyBEZWR1cGUgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXHQgICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG5cdCAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuXHQgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG5cdCAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcblx0ICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBXZSBkbyBhbiBpbml0aWFsIHBhc3MgdG8gZ2F0aGVyIGNvbXBvbmVudCBuYW1lc1xuXHQgICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG5cdCAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG5cdCAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG5cdCAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcblx0ICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuXHQgICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuXHQgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG5cdCAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG5cdCAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG5cdCAgICB9XG5cblx0ICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG5cdCAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuXHQgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuXHQgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cblx0ICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuXHQgICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuXHQgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuXHQgICAgICB9KTtcblx0ICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuXHQgICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcblx0ICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG5cdCAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuXHQgICAgfSAvLyBGaW5hbGx5LCB3ZSBmbHVzaCBhbGwgdGhlIHdhcm5pbmdzXG5cdCAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG5cdCAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG5cdCAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cblx0ICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIHNvcnRlZE5hbWVzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcblx0ICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG5cdCAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcblx0ICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuXHQgICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcblx0ICAgICAgdmFyIF9zb3J0ZWROYW1lczMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cblx0ICAgICAgd2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG5cdCAgICAgIHZhciBfc29ydGVkTmFtZXM0ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuXHQgICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG5cdCAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuXHQgICAgICB3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczUpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpOyAvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxuXG5cdCAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cblx0ICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcblx0ICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuXG5cdCAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuXHQgICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXG5cblx0ICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG5cdCAgICBpZiAoZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcblx0ICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuXHQgICAgICBpZiAoZmliZXJBcnJheS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF07XG5cdCAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblx0ICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuXHQgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG5cdCAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBzZXRDdXJyZW50RmliZXIoZmlyc3RGaWJlcik7XG5cblx0ICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG5cdCAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG5cdCAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG5cdCAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuXHQgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuXHQgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcblx0ICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcblx0ICB9O1xuXHR9XG5cblx0Lypcblx0ICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG5cdCAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG5cdCAqXG5cdCAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcblx0ICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuXHQgKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cblx0ICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cblx0ICovXG5cdC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cdGZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG5cdCAge1xuXHQgICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuXHQgICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG5cdCAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0Jztcblx0ICAgIHJldHVybiB0eXBlO1xuXHQgIH1cblx0fSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cblx0ZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcblx0ICB7XG5cdCAgICB0cnkge1xuXHQgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuXHQgIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuXHQgIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG5cdCAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuXHQgIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuXHQgIC8vXG5cdCAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG5cdCAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcblx0ICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcblx0ICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cblx0ICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cblx0ICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuXHQgIC8vXG5cdCAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuXHQgIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cblx0ICAvL1xuXHQgIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG5cdCAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG5cdCAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuXHQgIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG5cdCAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuXHQgIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cblx0ICAvL1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXHQgIHJldHVybiAnJyArIHZhbHVlO1xuXHR9XG5cdGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcblx0ICB7XG5cdCAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG5cdCAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cblx0ICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuXHQgIHtcblx0ICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcblx0ICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cblx0ICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuXHQgIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuXHQgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuXHQgICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuXHQgICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cblx0ICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuXHQgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwcm9wcztcblx0ICB9XG5cblx0ICByZXR1cm4gYmFzZVByb3BzO1xuXHR9XG5cblx0dmFyIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuXHR2YXIgcmVuZGVyZXJTaWdpbDtcblxuXHR7XG5cdCAgLy8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG5cdCAgcmVuZGVyZXJTaWdpbCA9IHt9O1xuXHR9XG5cblx0dmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcblx0dmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG5cdHZhciBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xuXHR2YXIgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuXHRmdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG5cdCAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG5cdCAgLy8gY2Fubm90IGJlIGNhbGxlZCBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuXG5cdCAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuXHQgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG5cdCAgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcblxuXHQgIHtcblx0ICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcblx0ICB7XG5cdCAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuXHQgIHtcblx0ICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIGNvbnRleHQsIG5leHRWYWx1ZSkge1xuXHQgIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuXHQgICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcblx0ICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuXHQgICAge1xuXHQgICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuXHQgICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlcik7XG5cdCAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlO1xuXG5cdCAgICB7XG5cdCAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG5cdCAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuXHQgIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuXHQgIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG5cblx0ICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcblx0ICAgIHtcblx0ICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICB7XG5cdCAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBjdXJyZW50VmFsdWU7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG5cdCAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuXHQgIHZhciBub2RlID0gcGFyZW50O1xuXG5cdCAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuXHQgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcblx0ICAgICAgbm9kZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcblxuXHQgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG5cdCAgICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuXHQgICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcblx0ICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcykge1xuXHQgIHtcblx0ICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcykge1xuXG5cdCAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cblx0ICBpZiAoZmliZXIgIT09IG51bGwpIHtcblx0ICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXHQgICAgZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cdCAgfVxuXG5cdCAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG5cdCAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwOyAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuXG5cdCAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuXHQgICAgaWYgKGxpc3QgIT09IG51bGwpIHtcblx0ICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG5cdCAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cblx0ICAgICAgd2hpbGUgKGRlcGVuZGVuY3kgIT09IG51bGwpIHtcblx0ICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuXHQgICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcblx0ICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cblx0ICAgICAgICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG5cdCAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuXHQgICAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcblx0ICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7XG5cdCAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcblx0ICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG5cdCAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3Ncblx0ICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuXHQgICAgICAgICAgICAvLyBJbmxpbmVkIGBlbnF1ZXVlVXBkYXRlYCB0byByZW1vdmUgaW50ZXJsZWF2ZWQgdXBkYXRlIGNoZWNrXG5cblx0ICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cblx0ICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHZhciBzaGFyZWRRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcblx0ICAgICAgICAgICAgICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cblx0ICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuXHQgICAgICAgICAgICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuXHQgICAgICAgICAgICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIHNoYXJlZFF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG5cdCAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cblx0ICAgICAgICAgIGxpc3QubGFuZXMgPSBtZXJnZUxhbmVzKGxpc3QubGFuZXMsIHJlbmRlckxhbmVzKTsgLy8gU2luY2Ugd2UgYWxyZWFkeSBmb3VuZCBhIG1hdGNoLCB3ZSBjYW4gc3RvcCB0cmF2ZXJzaW5nIHRoZVxuXHQgICAgICAgICAgLy8gZGVwZW5kZW5jeSBsaXN0LlxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeS5uZXh0O1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG5cdCAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxuXHQgICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuXHQgICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuXHQgICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG5cdCAgICAgIC8vIGlmIGl0IHdpbGwgaGF2ZSBhbnkgY29udGV4dCBjb25zdW1lcnMgaW4gaXQuIFRoZSBiZXN0IHdlIGNhbiBkbyBpc1xuXHQgICAgICAvLyBtYXJrIGl0IGFzIGhhdmluZyB1cGRhdGVzLlxuXHQgICAgICB2YXIgcGFyZW50U3VzcGVuc2UgPSBmaWJlci5yZXR1cm47XG5cblx0ICAgICAgaWYgKHBhcmVudFN1c3BlbnNlID09PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZSBqdXN0IGNhbWUgZnJvbSBhIHBhcmVudCBzbyB3ZSBtdXN0IGhhdmUgaGFkIGEgcGFyZW50LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcGFyZW50U3VzcGVuc2UubGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudFN1c3BlbnNlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIHZhciBfYWx0ZXJuYXRlID0gcGFyZW50U3VzcGVuc2UuYWx0ZXJuYXRlO1xuXG5cdCAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsKSB7XG5cdCAgICAgICAgX2FsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoX2FsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9IC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBwYXNzaW5nIHRoaXMgZmliZXIgYXMgdGhlIHBhcmVudFxuXHQgICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuXHQgICAgICAvLyBvbiBpdHMgY2hpbGRyZW4uIFdlJ2xsIHVzZSB0aGUgY2hpbGRMYW5lcyBvblxuXHQgICAgICAvLyB0aGlzIGZpYmVyIHRvIGluZGljYXRlIHRoYXQgYSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuXG5cblx0ICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnRTdXNwZW5zZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgbmV4dEZpYmVyID0gZmliZXIuc2libGluZztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG5cdCAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXHQgICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuXHQgICAgICBuZXh0RmliZXIgPSBmaWJlcjtcblxuXHQgICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcblx0ICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuXHQgICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cblx0ICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblx0ICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcblx0ICAgICAgICAgIG5leHRGaWJlciA9IHNpYmxpbmc7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cblx0ICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuXHQgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG5cdCAgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcblx0ICB2YXIgZGVwZW5kZW5jaWVzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuXG5cdCAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuXHQgICAge1xuXHQgICAgICB2YXIgZmlyc3RDb250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcblxuXHQgICAgICBpZiAoZmlyc3RDb250ZXh0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoZGVwZW5kZW5jaWVzLmxhbmVzLCByZW5kZXJMYW5lcykpIHtcblx0ICAgICAgICAgIC8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG5cdCAgICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuXHQgICAgICAgIH0gLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuXG5cblx0ICAgICAgICBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0ID0gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG5cdCAge1xuXHQgICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cblx0ICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG5cdCAgICBpZiAoaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVikge1xuXHQgICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuXG5cdCAgaWYgKGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9PT0gY29udGV4dCkgOyBlbHNlIHtcblx0ICAgIHZhciBjb250ZXh0SXRlbSA9IHtcblx0ICAgICAgY29udGV4dDogY29udGV4dCxcblx0ICAgICAgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsXG5cdCAgICAgIG5leHQ6IG51bGxcblx0ICAgIH07XG5cblx0ICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcblx0ICAgICAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID09PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcblx0ICAgICAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5cblxuXHQgICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0SXRlbTtcblx0ICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuXHQgICAgICAgIGxhbmVzOiBOb0xhbmVzLFxuXHQgICAgICAgIGZpcnN0Q29udGV4dDogY29udGV4dEl0ZW1cblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIEFwcGVuZCBhIG5ldyBjb250ZXh0IGl0ZW0uXG5cdCAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Ly8gcmVuZGVyLiBXaGVuIHRoaXMgcmVuZGVyIGV4aXRzLCBlaXRoZXIgYmVjYXVzZSBpdCBmaW5pc2hlcyBvciBiZWNhdXNlIGl0IGlzXG5cdC8vIGludGVycnVwdGVkLCB0aGUgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsIGJlIHRyYW5zZmVycmVkIG9udG8gdGhlIG1haW4gcGFydFxuXHQvLyBvZiB0aGUgcXVldWUuXG5cblx0dmFyIGNvbmN1cnJlbnRRdWV1ZXMgPSBudWxsO1xuXHRmdW5jdGlvbiBwdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlKHF1ZXVlKSB7XG5cdCAgaWYgKGNvbmN1cnJlbnRRdWV1ZXMgPT09IG51bGwpIHtcblx0ICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBbcXVldWVdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBjb25jdXJyZW50UXVldWVzLnB1c2gocXVldWUpO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuXHQgIC8vIFRyYW5zZmVyIHRoZSBpbnRlcmxlYXZlZCB1cGRhdGVzIG9udG8gdGhlIG1haW4gcXVldWUuIEVhY2ggcXVldWUgaGFzIGFcblx0ICAvLyBgcGVuZGluZ2AgZmllbGQgYW5kIGFuIGBpbnRlcmxlYXZlZGAgZmllbGQuIFdoZW4gdGhleSBhcmUgbm90IG51bGwsIHRoZXlcblx0ICAvLyBwb2ludCB0byB0aGUgbGFzdCBub2RlIGluIGEgY2lyY3VsYXIgbGlua2VkIGxpc3QuIFdlIG5lZWQgdG8gYXBwZW5kIHRoZVxuXHQgIC8vIGludGVybGVhdmVkIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgcGVuZGluZyBsaXN0IGJ5IGpvaW5pbmcgdGhlbSBpbnRvIGFcblx0ICAvLyBzaW5nbGUsIGNpcmN1bGFyIGxpc3QuXG5cdCAgaWYgKGNvbmN1cnJlbnRRdWV1ZXMgIT09IG51bGwpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uY3VycmVudFF1ZXVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgcXVldWUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuXHQgICAgICB2YXIgbGFzdEludGVybGVhdmVkVXBkYXRlID0gcXVldWUuaW50ZXJsZWF2ZWQ7XG5cblx0ICAgICAgaWYgKGxhc3RJbnRlcmxlYXZlZFVwZGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHF1ZXVlLmludGVybGVhdmVkID0gbnVsbDtcblx0ICAgICAgICB2YXIgZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZSA9IGxhc3RJbnRlcmxlYXZlZFVwZGF0ZS5uZXh0O1xuXHQgICAgICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG5cblx0ICAgICAgICBpZiAobGFzdFBlbmRpbmdVcGRhdGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuXHQgICAgICAgICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IGZpcnN0SW50ZXJsZWF2ZWRVcGRhdGU7XG5cdCAgICAgICAgICBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbGFzdEludGVybGVhdmVkVXBkYXRlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGNvbmN1cnJlbnRRdWV1ZXMgPSBudWxsO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcblx0ICB2YXIgaW50ZXJsZWF2ZWQgPSBxdWV1ZS5pbnRlcmxlYXZlZDtcblxuXHQgIGlmIChpbnRlcmxlYXZlZCA9PT0gbnVsbCkge1xuXHQgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuXHQgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7IC8vIEF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyLCB0aGlzIHF1ZXVlJ3MgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsXG5cdCAgICAvLyBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGVuZGluZyBxdWV1ZS5cblxuXHQgICAgcHVzaENvbmN1cnJlbnRVcGRhdGVRdWV1ZShxdWV1ZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcblx0ICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG5cdCAgfVxuXG5cdCAgcXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG5cdCAgcmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcblx0fVxuXHRmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dChmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuXHQgIHZhciBpbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG5cdCAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG5cdCAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG5cdCAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcblx0ICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG5cdCAgICBwdXNoQ29uY3VycmVudFVwZGF0ZVF1ZXVlKHF1ZXVlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdXBkYXRlLm5leHQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuXHQgICAgaW50ZXJsZWF2ZWQubmV4dCA9IHVwZGF0ZTtcblx0ICB9XG5cblx0ICBxdWV1ZS5pbnRlcmxlYXZlZCA9IHVwZGF0ZTtcblx0fVxuXHRmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG5cdCAgdmFyIGludGVybGVhdmVkID0gcXVldWUuaW50ZXJsZWF2ZWQ7XG5cblx0ICBpZiAoaW50ZXJsZWF2ZWQgPT09IG51bGwpIHtcblx0ICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cblx0ICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlOyAvLyBBdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHJlbmRlciwgdGhpcyBxdWV1ZSdzIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbFxuXHQgICAgLy8gYmUgdHJhbnNmZXJyZWQgdG8gdGhlIHBlbmRpbmcgcXVldWUuXG5cblx0ICAgIHB1c2hDb25jdXJyZW50VXBkYXRlUXVldWUocXVldWUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB1cGRhdGUubmV4dCA9IGludGVybGVhdmVkLm5leHQ7XG5cdCAgICBpbnRlcmxlYXZlZC5uZXh0ID0gdXBkYXRlO1xuXHQgIH1cblxuXHQgIHF1ZXVlLmludGVybGVhdmVkID0gdXBkYXRlO1xuXHQgIHJldHVybiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG5cdH1cblx0ZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKSB7XG5cdCAgcmV0dXJuIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcblx0fSAvLyBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBiZSBkb25lIGZvciBiYWNrd2FyZHNcblx0Ly8gY29tcGF0aWJpbGl0eSBhbmQgc2hvdWxkIGFsd2F5cyBiZSBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcuXG5cblx0dmFyIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290O1xuXG5cdGZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG5cdCAgLy8gVXBkYXRlIHRoZSBzb3VyY2UgZmliZXIncyBsYW5lc1xuXHQgIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG5cdCAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuXHQgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcblx0ICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChzb3VyY2VGaWJlci5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuXHQgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcblx0ICAgIH1cblx0ICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGxhbmVzLlxuXG5cblx0ICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuXHQgIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG5cblx0ICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICBwYXJlbnQuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsIGxhbmUpO1xuXHQgICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuXHQgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIGxhbmUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAge1xuXHQgICAgICAgIGlmICgocGFyZW50LmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbm9kZSA9IHBhcmVudDtcblx0ICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG5cdCAgfVxuXG5cdCAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuXHQgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblx0ICAgIHJldHVybiByb290O1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cdH1cblxuXHR2YXIgVXBkYXRlU3RhdGUgPSAwO1xuXHR2YXIgUmVwbGFjZVN0YXRlID0gMTtcblx0dmFyIEZvcmNlVXBkYXRlID0gMjtcblx0dmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG5cdC8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG5cdC8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cblxuXHR2YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblx0dmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG5cdHZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWU7XG5cblx0e1xuXHQgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcblx0ICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG5cdCAgdmFyIHF1ZXVlID0ge1xuXHQgICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuXHQgICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuXHQgICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG5cdCAgICBzaGFyZWQ6IHtcblx0ICAgICAgcGVuZGluZzogbnVsbCxcblx0ICAgICAgaW50ZXJsZWF2ZWQ6IG51bGwsXG5cdCAgICAgIGxhbmVzOiBOb0xhbmVzXG5cdCAgICB9LFxuXHQgICAgZWZmZWN0czogbnVsbFxuXHQgIH07XG5cdCAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcblx0fVxuXHRmdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG5cdCAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cblx0ICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblx0ICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuXHQgIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG5cdCAgICB2YXIgY2xvbmUgPSB7XG5cdCAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcblx0ICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuXHQgICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuXHQgICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG5cdCAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG5cdCAgICB9O1xuXHQgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjbG9uZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSkge1xuXHQgIHZhciB1cGRhdGUgPSB7XG5cdCAgICBldmVudFRpbWU6IGV2ZW50VGltZSxcblx0ICAgIGxhbmU6IGxhbmUsXG5cdCAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuXHQgICAgcGF5bG9hZDogbnVsbCxcblx0ICAgIGNhbGxiYWNrOiBudWxsLFxuXHQgICAgbmV4dDogbnVsbFxuXHQgIH07XG5cdCAgcmV0dXJuIHVwZGF0ZTtcblx0fVxuXHRmdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcblx0ICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuXHQgIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuXHQgICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIHZhciBzaGFyZWRRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcblxuXHQgIHtcblx0ICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG5cdCAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG5cblx0ICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKGlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZSgpKSB7XG5cdCAgICAvLyBUaGlzIGlzIGFuIHVuc2FmZSByZW5kZXIgcGhhc2UgdXBkYXRlLiBBZGQgZGlyZWN0bHkgdG8gdGhlIHVwZGF0ZVxuXHQgICAgLy8gcXVldWUgc28gd2UgY2FuIHByb2Nlc3MgaXQgaW1tZWRpYXRlbHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlci5cblx0ICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuXHQgICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0ICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuXHQgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuXHQgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG5cdCAgICB9XG5cblx0ICAgIHNoYXJlZFF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7IC8vIFVwZGF0ZSB0aGUgY2hpbGRMYW5lcyBldmVuIHRob3VnaCB3ZSdyZSBtb3N0IGxpa2VseSBhbHJlYWR5IHJlbmRlcmluZ1xuXHQgICAgLy8gdGhpcyBmaWJlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gdGhlIGNhc2Ugd2hlcmUgeW91XG5cdCAgICAvLyB1cGRhdGUgYSBkaWZmZXJlbnQgY29tcG9uZW50IGR1cmluZyByZW5kZXIgcGhhc2UgdGhhbiB0aGUgb25lIHRoYXQgaXNcblx0ICAgIC8vIGN1cnJlbnRseSByZW5kZXJpbmdzIChhIHBhdHRlcm4gdGhhdCBpcyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcpLlxuXG5cdCAgICByZXR1cm4gdW5zYWZlX21hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIsIHNoYXJlZFF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG5cdCAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cblx0ICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcblx0ICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG5cdCAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcblx0ICAgIHZhciBxdWV1ZUxhbmVzID0gc2hhcmVkUXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXkgbXVzdFxuXHQgICAgLy8gaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuXHQgICAgLy8gYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZSBtYXkgZW50YW5nbGVcblx0ICAgIC8vIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWYgd2UgKmRvbid0KlxuXHQgICAgLy8gZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5cblx0ICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cblx0ICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcblx0ICAgIHNoYXJlZFF1ZXVlLmxhbmVzID0gbmV3UXVldWVMYW5lczsgLy8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuXHQgICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cblx0ICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cblx0ICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIG5ld1F1ZXVlTGFuZXMpO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG5cdCAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuXHQgIC8vIHBoYXNlLiBUaGV5IHNob3VsZCBiZSBkaXNjYXJkZWQgaWYgdGhlIHJlbmRlciBpcyBhYm9ydGVkLiBUaGVyZWZvcmUsXG5cdCAgLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG5cdCAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG5cblx0ICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuXHQgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuXHQgICAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcblx0ICAgICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cblx0ICAgICAgLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuXHQgICAgICAvLyBhIGNoaWxkLiBTaW5jZSB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgdXBkYXRlIG9ubHkgdG8gdGhlIHdvcmstaW5cblx0ICAgICAgLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuXHQgICAgICAvLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2Vcblx0ICAgICAgLy8gc2tpcHBlZCBvdmVyIHRoZSBwYXJlbnQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXHQgICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsO1xuXHQgICAgICB2YXIgbmV3TGFzdCA9IG51bGw7XG5cdCAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG5cblx0ICAgICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cblx0ICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG5cdCAgICAgICAgZG8ge1xuXHQgICAgICAgICAgdmFyIGNsb25lID0ge1xuXHQgICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZS5ldmVudFRpbWUsXG5cdCAgICAgICAgICAgIGxhbmU6IHVwZGF0ZS5sYW5lLFxuXHQgICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG5cdCAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuXHQgICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuXHQgICAgICAgICAgICBuZXh0OiBudWxsXG5cdCAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNsb25lO1xuXHQgICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXHQgICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cblx0ICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuXHQgICAgICAgICAgbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBUaGVyZSBhcmUgbm8gYmFzZSB1cGRhdGVzLlxuXHQgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcXVldWUgPSB7XG5cdCAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuXHQgICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG5cdCAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG5cdCAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuXHQgICAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG5cdCAgICAgIH07XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICB9IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cblxuXHQgIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG5cdCAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG5cdCAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuXHQgIH1cblxuXHQgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuXHQgIHN3aXRjaCAodXBkYXRlLnRhZykge1xuXHQgICAgY2FzZSBSZXBsYWNlU3RhdGU6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuXG5cdCAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcblx0ICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuXHQgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblx0ICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuXHQgICAgICAgIH0gLy8gU3RhdGUgb2JqZWN0XG5cblxuXHQgICAgICAgIHJldHVybiBwYXlsb2FkO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcblx0ICAgICAge1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cdCAgICAgIH1cblx0ICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cblx0ICAgIGNhc2UgVXBkYXRlU3RhdGU6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcblx0ICAgICAgICB2YXIgcGFydGlhbFN0YXRlO1xuXG5cdCAgICAgICAgaWYgKHR5cGVvZiBfcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG5cdCAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXHQgICAgICAgICAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG5cdCAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuXHQgICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcblx0ICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuXHQgICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEZvcmNlVXBkYXRlOlxuXHQgICAgICB7XG5cdCAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG5cdCAgICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcHJldlN0YXRlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG5cdCAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuXHQgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXHQgIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cblx0ICB7XG5cdCAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG5cdCAgfVxuXG5cdCAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcblx0ICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cblx0ICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cblx0ICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG5cdCAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7IC8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3Rcblx0ICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cblx0ICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZTtcblx0ICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuXHQgICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG5cdCAgICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcblx0ICAgICAgZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcblx0ICAgIH1cblxuXHQgICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG5cdCAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuXHQgICAgLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuXHQgICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cblx0ICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG5cblx0ICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG5cdCAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG5cdCAgICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXHQgICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG5cdCAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgIT09IGxhc3RCYXNlVXBkYXRlKSB7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IC8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuXG5cblx0ICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG5cdCAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG5cdCAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG5cdCAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuXHQgICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcblx0ICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuXHQgICAgdmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG51bGw7XG5cdCAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuXHQgICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuXHQgICAgZG8ge1xuXHQgICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXHQgICAgICB2YXIgdXBkYXRlRXZlbnRUaW1lID0gdXBkYXRlLmV2ZW50VGltZTtcblxuXHQgICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcblx0ICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdCAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG5cdCAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuXHQgICAgICAgIHZhciBjbG9uZSA9IHtcblx0ICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuXHQgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcblx0ICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcblx0ICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuXHQgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcblx0ICAgICAgICAgIG5leHQ6IG51bGxcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG5cdCAgICAgICAgICBuZXdGaXJzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZSA9IGNsb25lO1xuXHQgICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IGNsb25lO1xuXHQgICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuXG5cblx0ICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuXHQgICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgdmFyIF9jbG9uZSA9IHtcblx0ICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG5cdCAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG5cdCAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cblx0ICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuXHQgICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG5cdCAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcblx0ICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG5cdCAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG5cdCAgICAgICAgICAgIG5leHQ6IG51bGxcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBfY2xvbmU7XG5cdCAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cblx0ICAgICAgICBuZXdTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgbmV3U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG5cdCAgICAgICAgdmFyIGNhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuXG5cdCAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsICYmIC8vIElmIHRoZSB1cGRhdGUgd2FzIGFscmVhZHkgY29tbWl0dGVkLCB3ZSBzaG91bGQgbm90IHF1ZXVlIGl0c1xuXHQgICAgICAgIC8vIGNhbGxiYWNrIGFnYWluLlxuXHQgICAgICAgIHVwZGF0ZS5sYW5lICE9PSBOb0xhbmUpIHtcblx0ICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENhbGxiYWNrO1xuXHQgICAgICAgICAgdmFyIGVmZmVjdHMgPSBxdWV1ZS5lZmZlY3RzO1xuXG5cdCAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBxdWV1ZS5lZmZlY3RzID0gW3VwZGF0ZV07XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcblxuXHQgICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG5cdCAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cblx0ICAgICAgICBpZiAocGVuZGluZ1F1ZXVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYSByZWR1Y2VyLiBBZGQgdGhlIG5ld1xuXHQgICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2Vcblx0ICAgICAgICAgIC8vIHVucmF2ZWwgdGhlbSB3aGVuIHRyYW5zZmVycmluZyB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXG5cdCAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuXHQgICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuXHQgICAgICAgICAgdXBkYXRlID0gX2ZpcnN0UGVuZGluZ1VwZGF0ZTtcblx0ICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuXHQgICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSB3aGlsZSAodHJ1ZSk7XG5cblx0ICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcblx0ICAgIH1cblxuXHQgICAgcXVldWUuYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuXHQgICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuXHQgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuXHQgICAgLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcblx0ICAgIC8vIGFyZSByZW1haW5pbmcuXG5cblx0ICAgIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7XG5cblx0ICAgIGlmIChsYXN0SW50ZXJsZWF2ZWQgIT09IG51bGwpIHtcblx0ICAgICAgdmFyIGludGVybGVhdmVkID0gbGFzdEludGVybGVhdmVkO1xuXG5cdCAgICAgIGRvIHtcblx0ICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIGludGVybGVhdmVkLmxhbmUpO1xuXHQgICAgICAgIGludGVybGVhdmVkID0gaW50ZXJsZWF2ZWQubmV4dDtcblx0ICAgICAgfSB3aGlsZSAoaW50ZXJsZWF2ZWQgIT09IGxhc3RJbnRlcmxlYXZlZCk7XG5cdCAgICB9IGVsc2UgaWYgKGZpcnN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuXHQgICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuXHQgICAgICBxdWV1ZS5zaGFyZWQubGFuZXMgPSBOb0xhbmVzO1xuXHQgICAgfSAvLyBTZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgd2hhdGV2ZXIgaXMgcmVtYWluaW5nIGluIHRoZSBxdWV1ZS5cblx0ICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuXHQgICAgLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuXHQgICAgLy8gYmVnaW4gcGhhc2UgYnkgdGhlIHRpbWUgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgcXVldWUsIHNvIHdlJ3ZlIGFscmVhZHlcblx0ICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG5cdCAgICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuXHQgICAgLy8gdGhhdCByZWdhcmRsZXNzLlxuXG5cblx0ICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBuZXdMYW5lcztcblx0ICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuXHQgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgJyArIChcInJlY2VpdmVkOiBcIiArIGNhbGxiYWNrKSk7XG5cdCAgfVxuXG5cdCAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuXHQgIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cdH1cblx0ZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcblx0ICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG5cdH1cblx0ZnVuY3Rpb24gY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFF1ZXVlLCBpbnN0YW5jZSkge1xuXHQgIC8vIENvbW1pdCB0aGUgZWZmZWN0c1xuXHQgIHZhciBlZmZlY3RzID0gZmluaXNoZWRRdWV1ZS5lZmZlY3RzO1xuXHQgIGZpbmlzaGVkUXVldWUuZWZmZWN0cyA9IG51bGw7XG5cblx0ICBpZiAoZWZmZWN0cyAhPT0gbnVsbCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBlZmZlY3QgPSBlZmZlY3RzW2ldO1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBlZmZlY3QuY2FsbGJhY2s7XG5cblx0ICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG5cdCAgICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcblx0ICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGluc3RhbmNlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9OyAvLyBSZWFjdC5Db21wb25lbnQgdXNlcyBhIHNoYXJlZCBmcm96ZW4gb2JqZWN0IGJ5IGRlZmF1bHQuXG5cdC8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG5cblx0dmFyIGVtcHR5UmVmc09iamVjdCA9IG5ldyBSZWFjdCQxLkNvbXBvbmVudCgpLnJlZnM7XG5cdHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG5cdHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG5cdHZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7XG5cdHZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xuXHR2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xuXHR2YXIgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xuXHR2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xuXHR2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG5cdHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcblx0dmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxuXHR7XG5cdCAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuXHQgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcblx0ICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG5cdCAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcblx0ICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcblx0ICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG5cdCAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG5cdCAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuXHQgIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cblx0ICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcblx0ICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG5cdCAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuXHQgICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cblx0ICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcblx0ICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuXHQgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG5cdCAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9OyAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcblx0ICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG5cdCAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuXHQgIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcblx0ICAvLyBleGNlcHRpb24uXG5cblxuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuXHQgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSAnICsgJ21lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCAnICsgJ2EgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nICcgKyBcInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc24ndCBzdXBwb3J0ZWQuIFRyeSBcIiArICd0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCAnICsgJ3RvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXh0UHJvcHMpIHtcblx0ICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblx0ICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuXHQgIHtcblx0ICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcblx0ICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuXHQgICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLCBwYXJ0aWFsU3RhdGUpO1xuXHQgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG5cdCAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcblx0ICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbWVtb2l6ZWRTdGF0ZTsgLy8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG5cdCAgLy8gYmFzZSBzdGF0ZS5cblxuXHQgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuXHQgICAgLy8gUXVldWUgaXMgYWx3YXlzIG5vbi1udWxsIGZvciBjbGFzc2VzXG5cdCAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblx0ICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG5cdCAgfVxuXHR9XG5cblx0dmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcblx0ICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcblx0ICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuXHQgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblx0ICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuXHQgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuXHQgICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG5cdCAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuXHQgICAgICB7XG5cdCAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cblx0ICAgIGlmIChyb290ICE9PSBudWxsKSB7XG5cdCAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblx0ICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG5cdCAgICB9XG5cblx0ICAgIHtcblx0ICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuXHQgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblx0ICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuXHQgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuXHQgICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcblx0ICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuXHQgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcblx0ICAgICAge1xuXHQgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdCAgICB9XG5cblx0ICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuXHQgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXHQgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcblx0ICAgIH1cblxuXHQgICAge1xuXHQgICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcblx0ICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcblx0ICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG5cdCAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcblx0ICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcblx0ICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcblxuXHQgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcblx0ICAgICAge1xuXHQgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0ICAgIH1cblxuXHQgICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG5cdCAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cdCAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuXHQgICAgfVxuXG5cdCAgICB7XG5cdCAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcblx0ICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cblx0ICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdmFyIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcblxuXHQgICAge1xuXHQgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG5cdCAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cblx0ICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcblx0ICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGVycm9yKCclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG5cdCAgfVxuXG5cdCAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG5cdCAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpIHtcblx0ICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cblx0ICB7XG5cdCAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50Jztcblx0ICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG5cdCAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcblx0ICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuXHQgICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcblx0ICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG5cdCAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG5cdCAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG5cdCAgICB9XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuXHQgICAgICAgIGVycm9yKCdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5hZGQoY3Rvcik7XG5cblx0ICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuXHQgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG5cdCAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcblx0ICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcblx0ICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuXHQgICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cblx0ICAgIGlmIChfc3RhdGUgJiYgKHR5cGVvZiBfc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoX3N0YXRlKSkpIHtcblx0ICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3Rvci5jaGlsZENvbnRleHRUeXBlcyAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuXHQgIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG5cdCAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuXHQgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG5cdCAge1xuXHQgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG5cdCAgdmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gZmFsc2U7XG5cdCAgdmFyIHVubWFza2VkQ29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblx0ICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblx0ICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG5cdCAge1xuXHQgICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuXHQgICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG5cdCAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuXHQgICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuXHQgICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG5cdCAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcblx0ICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/Jztcblx0ICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuXHQgICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcblx0ICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG5cdCAgICB2YXIgY29udGV4dFR5cGVzID0gY3Rvci5jb250ZXh0VHlwZXM7XG5cdCAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcblx0ICAgIGNvbnRleHQgPSBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA/IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkgOiBlbXB0eUNvbnRleHRPYmplY3Q7XG5cdCAgfVxuXG5cdCAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cblx0ICB7XG5cdCAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG5cdCAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSBudWxsICYmIGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG5cdCAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nICYmIHN0YXRlID09PSBudWxsKSB7XG5cdCAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG5cdCAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuXHQgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cblx0ICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cblx0ICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuXHQgICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuXG5cblx0ICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuXHQgICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG5cdCAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuXHQgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuXHQgICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuXHQgICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG5cdCAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG5cdCAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG5cdCAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG5cdCAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcblx0ICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuXHQgICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cblx0ICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuXG5cblx0ICBpZiAoaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIpIHtcblx0ICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcblx0ICB9XG5cblx0ICByZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuXHQgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG5cdCAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuXHQgIH1cblxuXHQgIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcblx0ICAgIHtcblx0ICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50Jyk7XG5cdCAgICB9XG5cblx0ICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpIHtcblx0ICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuXHQgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG5cdCAgfVxuXG5cdCAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHQgICAge1xuXHQgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuXG5cdCAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuXHQgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cblx0ICAgICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuXHQgIH1cblx0fSAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5cblxuXHRmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuXHQgIHtcblx0ICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuXHQgIH1cblxuXHQgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblx0ICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuXHQgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblx0ICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuXHQgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuXHQgIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG5cdCAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcblx0ICAgIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbmV3UHJvcHMpIHtcblx0ICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cblx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcblx0ICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cblx0ICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcblx0ICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblx0ICAgIH1cblxuXHQgICAge1xuXHQgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblx0ICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cblx0ICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuXHQgICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXHQgIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG5cdCAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG5cdCAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG5cdCAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3Ncblx0ICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cblx0ICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG5cdCAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cblx0ICAgIHtcblx0ICAgICAgZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG5cdCAgICB9XG5cblx0ICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuXHQgICAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuXHQgICAgfVxuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBmaWJlckZsYWdzO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXHQgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG5cdCAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblx0ICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cdCAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblx0ICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cblx0ICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuXHQgICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcblx0ICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCk7XG5cdCAgfVxuXG5cdCAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXHQgIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcblx0ICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuXHQgIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cdCAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG5cdCAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXHQgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuXHQgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuXHQgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblx0ICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXHQgIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG5cdCAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcblx0ICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cblx0ICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG5cdCAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcblx0ICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuXHQgICAgICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG5cdCAgICAgIH1cblxuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBmaWJlckZsYWdzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcblx0ICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblx0ICB9XG5cblx0ICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG5cdCAgaWYgKHNob3VsZFVwZGF0ZSkge1xuXHQgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG5cdCAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXHQgICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuXHQgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgdmFyIF9maWJlckZsYWdzID0gVXBkYXRlO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICBfZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgICBfZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IF9maWJlckZsYWdzO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcblx0ICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhciBfZmliZXJGbGFnczIgPSBVcGRhdGU7XG5cblx0ICAgICAge1xuXHQgICAgICAgIF9maWJlckZsYWdzMiB8PSBMYXlvdXRTdGF0aWM7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgICBfZmliZXJGbGFnczIgfD0gTW91bnRMYXlvdXREZXY7XG5cdCAgICAgIH1cblxuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBfZmliZXJGbGFnczI7XG5cdCAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcblx0ICAgIC8vIG1lbW9pemVkIHN0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuXHQgIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuXHQgIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cblx0ICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuXHQgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG5cdCAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXHQgIHJldHVybiBzaG91bGRVcGRhdGU7XG5cdH0gLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cblxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuXHQgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblx0ICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblx0ICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblx0ICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA/IHVucmVzb2x2ZWRPbGRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgdW5yZXNvbHZlZE9sZFByb3BzKTtcblx0ICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuXHQgIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cdCAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuXHQgIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cdCAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5cdCAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcblx0ICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgbmV4dFVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG5cdCAgICBuZXh0Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5leHRVbm1hc2tlZENvbnRleHQpO1xuXHQgIH1cblxuXHQgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblx0ICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG5cdCAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcblx0ICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXHQgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuXHQgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblx0ICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0ICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IHVucmVzb2x2ZWROZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuXHQgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblx0ICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXHQgIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG5cdCAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcblx0ICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cblx0ICBpZiAodW5yZXNvbHZlZE9sZFByb3BzID09PSB1bnJlc29sdmVkTmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgJiYgIShlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uICAgKSkge1xuXHQgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG5cdCAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuXHQgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuXHQgICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXHQgIH1cblxuXHQgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkgfHwgLy8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG5cdCAgLy8gYm90aCBiZWZvcmUgYW5kIGFmdGVyIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGhhcyBiZWVuIGNhbGxlZC4gTm90IGlkZWFsLFxuXHQgIC8vIGJ1dCBJJ20gbG9hdGggdG8gcmVmYWN0b3IgdGhpcyBmdW5jdGlvbi4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIG1lbW9pemVkXG5cdCAgLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cblx0ICBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uICAgO1xuXG5cdCAgaWYgKHNob3VsZFVwZGF0ZSkge1xuXHQgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG5cdCAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXHQgICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcblx0ICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG5cdCAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuXHQgICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG5cdCAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG5cdCAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuXHQgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG5cdCAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcblx0ICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cdCAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcblx0fVxuXG5cdHZhciBkaWRXYXJuQWJvdXRNYXBzO1xuXHR2YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcblx0dmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cdHZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG5cdHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG5cblx0dmFyIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge307XG5cblx0e1xuXHQgIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblx0ICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG5cdCAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuXHQgIC8qKlxuXHQgICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3Jcblx0ICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cblx0ICAgKiB1cGRhdGVzLlxuXHQgICAqL1xuXG5cdCAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cdCAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cblx0ICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHtcblx0ICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXG5cdCAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblx0ICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cblx0ICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG5cdCAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCkge1xuXHQgIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuXG5cdCAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdvYmplY3QnKSB7XG5cdCAgICB7XG5cdCAgICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG5cdCAgICAgIC8vIGV2ZXJ5b25lLCBiZWNhdXNlIHRoZSBzdHJpY3QgbW9kZSBjYXNlIHdpbGwgbm8gbG9uZ2VyIGJlIHJlbGV2YW50XG5cdCAgICAgIGlmICgocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgfHwgd2FybkFib3V0U3RyaW5nUmVmcykgJiYgLy8gV2Ugd2FybiBpbiBSZWFjdEVsZW1lbnQuanMgaWYgb3duZXIgYW5kIHNlbGYgYXJlIGVxdWFsIGZvciBzdHJpbmcgcmVmc1xuXHQgICAgICAvLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuXHQgICAgICAvLyB1c2luZyBhIGNvZGVtb2QuIFRoZXJlZm9yZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YXJuIGFib3V0IHN0cmluZyByZWZzIGFnYWluLlxuXHQgICAgICAhKGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX3NlbGYgJiYgZWxlbWVudC5fb3duZXIuc3RhdGVOb2RlICE9PSBlbGVtZW50Ll9zZWxmKSkge1xuXHQgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cblx0ICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgZXJyb3IoJ0Egc3RyaW5nIHJlZiwgXCIlc1wiLCBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG5cdCAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXHQgICAgICB2YXIgaW5zdDtcblxuXHQgICAgICBpZiAob3duZXIpIHtcblx0ICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuXG5cdCAgICAgICAgaWYgKG93bmVyRmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCkge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghaW5zdCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBcIiArICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICB9IC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3Qgc28gRmxvdyBrbm93cyBpdCB3b24ndCBjaGFuZ2UgaW4gdGhlIGNsb3N1cmVcblxuXG5cdCAgICAgIHZhciByZXNvbHZlZEluc3QgPSBpbnN0O1xuXG5cdCAgICAgIHtcblx0ICAgICAgICBjaGVja1Byb3BTdHJpbmdDb2VyY2lvbihtaXhlZFJlZiwgJ3JlZicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG5cdCAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIHR5cGVvZiBjdXJyZW50LnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcblx0ICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHJlZnMgPSByZXNvbHZlZEluc3QucmVmcztcblxuXHQgICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcblx0ICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXp5IHBvb2xlZCBmcm96ZW4gb2JqZWN0LCBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUuXG5cdCAgICAgICAgICByZWZzID0gcmVzb2x2ZWRJbnN0LnJlZnMgPSB7fTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblxuXHQgICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcblx0ICAgICAgcmV0dXJuIHJlZjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh0eXBlb2YgbWl4ZWRSZWYgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC4nKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChcIiArIG1peGVkUmVmICsgXCIpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mXCIgKyAnIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuJyArIFwiMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcblwiICsgJzMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVmcy1tdXN0LWhhdmUtb3duZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbWl4ZWRSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG5cdCAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcblx0ICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG5cdCAge1xuXHQgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuXHQgICAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cblx0ICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlTGF6eShsYXp5VHlwZSkge1xuXHQgIHZhciBwYXlsb2FkID0gbGF6eVR5cGUuX3BheWxvYWQ7XG5cdCAgdmFyIGluaXQgPSBsYXp5VHlwZS5faW5pdDtcblx0ICByZXR1cm4gaW5pdChwYXlsb2FkKTtcblx0fSAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG5cdC8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcblx0Ly8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG5cdC8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cblx0ZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcblx0ICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuXHQgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG5cdCAgICAgIC8vIE5vb3AuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuXHQgICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV07XG5cdCAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcblx0ICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuXHQgICAgICAvLyBOb29wLlxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuXHQgICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cblx0ICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cblx0ICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG5cdCAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcblx0ICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG5cdCAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG5cdCAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG5cdCAgICAvLyBpbnN0ZWFkLlxuXHQgICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cdCAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG5cdCAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcblx0ICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG5cdCAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuXHQgICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cblx0ICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuXHQgICAgY2xvbmUuaW5kZXggPSAwO1xuXHQgICAgY2xvbmUuc2libGluZyA9IG51bGw7XG5cdCAgICByZXR1cm4gY2xvbmU7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuXHQgICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcblxuXHQgICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG5cdCAgICAgIC8vIER1cmluZyBoeWRyYXRpb24sIHRoZSB1c2VJZCBhbGdvcml0aG0gbmVlZHMgdG8ga25vdyB3aGljaCBmaWJlcnMgYXJlXG5cdCAgICAgIC8vIHBhcnQgb2YgYSBsaXN0IG9mIGNoaWxkcmVuIChhcnJheXMsIGl0ZXJhdG9ycykuXG5cdCAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IEZvcmtlZDtcblx0ICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG5cblx0ICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cblx0ICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG5cdCAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG5cdCAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuXHQgICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuXHQgICAgICAgIHJldHVybiBvbGRJbmRleDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG5cdCAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcblx0ICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG5cdCAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcblx0ICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cblx0ICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXdGaWJlcjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG5cdCAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcblx0ICAgICAgLy8gSW5zZXJ0XG5cdCAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXHQgICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICByZXR1cm4gY3JlYXRlZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFVwZGF0ZVxuXHQgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG5cdCAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICByZXR1cm4gZXhpc3Rpbmc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcblx0ICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcblxuXHQgICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG5cdCAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGVsZW1lbnQua2V5KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG5cdCAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY3VycmVudCwgZWxlbWVudCkgKSB8fCAvLyBMYXp5IHR5cGVzIHNob3VsZCByZWNvbmNpbGUgdGhlaXIgcmVzb2x2ZWQgdHlwZS5cblx0ICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuXHQgICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2Vcblx0ICAgICAgLy8gaXQgZG9lc24ndCByZXN1c3BlbmQuIFNvIHdlIGNhbid0IGxldCB0aGUgY2FsbCBiZWxvdyBzdXNwZW5kLlxuXHQgICAgICB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiYgcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpID09PSBjdXJyZW50LnR5cGUpIHtcblx0ICAgICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG5cdCAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG5cdCAgICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcblx0ICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblx0ICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIEluc2VydFxuXG5cblx0ICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cdCAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG5cdCAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgcmV0dXJuIGNyZWF0ZWQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG5cdCAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG5cdCAgICAgIC8vIEluc2VydFxuXHQgICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblx0ICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblx0ICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBVcGRhdGVcblx0ICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcblx0ICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cdCAgICAgIHJldHVybiBleGlzdGluZztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcblx0ICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuXHQgICAgICAvLyBJbnNlcnRcblx0ICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGtleSk7XG5cdCAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cdCAgICAgIHJldHVybiBjcmVhdGVkO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gVXBkYXRlXG5cdCAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcblx0ICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cdCAgICAgIHJldHVybiBleGlzdGluZztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG5cdCAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuXHQgICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuXHQgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuXHQgICAgICAvLyBub2RlLlxuXHQgICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXHQgICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICByZXR1cm4gY3JlYXRlZDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuXHQgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cblx0ICAgICAgICAgICAgX2NyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBuZXdDaGlsZCk7XG5cdCAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cblx0ICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG5cdCAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG5cdCAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG5cdCAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgbnVsbCk7XG5cblx0ICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cdCAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcblx0ICAgICAgfVxuXG5cdCAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuXHQgICAgfVxuXG5cdCAgICB7XG5cdCAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcblx0ICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblx0ICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cblx0ICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG5cdCAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG5cdCAgICAgIC8vIG5vZGUuXG5cdCAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuXHQgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuXHQgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcblx0ICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcblx0ICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcblx0ICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG5cdCAgICB9XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMpIHtcblx0ICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3Jcblx0ICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG5cdCAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cdCAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBsYW5lcyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcblx0ICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcblx0ICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG5cdCAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuXHQgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG5cdCAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuXG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuXHQgICAgfVxuXG5cdCAgICB7XG5cdCAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuXHQgICAqL1xuXG5cblx0ICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKSB7XG5cdCAgICB7XG5cdCAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGtub3duS2V5cztcblx0ICAgICAgfVxuXG5cdCAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcblx0ICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcblx0ICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuXHQgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQsIHJldHVybkZpYmVyKTtcblx0ICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG5cblx0ICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG5cdCAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG5cdCAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdCAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuXHQgICAgICAgICAgdmFyIGluaXQgPSBjaGlsZC5faW5pdDtcblx0ICAgICAgICAgIHdhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ga25vd25LZXlzO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMpIHtcblx0ICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGggZW5kcyBzaW5jZSB3ZVxuXHQgICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcblx0ICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG5cdCAgICAvLyBhZGQgaXQgbGF0ZXIuXG5cdCAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG5cdCAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2Zcblx0ICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuXHQgICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG5cdCAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcblx0ICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuXHQgICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG5cdCAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2Vcblx0ICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXHQgICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuXHQgICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cdCAgICB7XG5cdCAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuXHQgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG5cdCAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuXHQgICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXHQgICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cdCAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcblx0ICAgIHZhciBuZXdJZHggPSAwO1xuXHQgICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cblx0ICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG5cdCAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuXHQgICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuXHQgICAgICAgIG9sZEZpYmVyID0gbnVsbDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuXHQgICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcblx0ICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuXHQgICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcblx0ICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcblx0ICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cblx0ICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcblx0ICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcblx0ICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2Vcblx0ICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cblx0ICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG5cdCAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG5cdCAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuXHQgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG5cdCAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuXHQgICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3Rcblx0ICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG5cdCAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG5cdCAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcblx0ICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG5cdCAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cblx0ICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcblx0ICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcblx0ICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG51bWJlck9mRm9ya3MpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcblx0ICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cblx0ICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcblx0ICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuXHQgICAgICAgIGlmIChfbmV3RmliZXIgPT09IG51bGwpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cblx0ICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuXHQgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuXHQgICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcblx0ICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuXHQgICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG5cdCAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuXHQgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcblx0ICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuXHQgICAgICBpZiAoX25ld0ZpYmVyMiAhPT0gbnVsbCkge1xuXHQgICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG5cdCAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuXHQgICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcblx0ICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cblx0ICAgICAgICAgICAgLy8gbGlzdC5cblx0ICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cblx0ICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcblx0ICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcblx0ICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG5cdCAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG5cdCAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczIgPSBuZXdJZHg7XG5cdCAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MyKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGxhbmVzKSB7XG5cdCAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcblx0ICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblx0ICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuXHQgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgfVxuXG5cdCAgICB7XG5cdCAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG5cdCAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG5cdCAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcblx0ICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuXHQgICAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuXHQgICAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcblx0ICAgICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG5cdCAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcblx0ICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcblx0ICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcblx0ICAgICAgfSAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cblx0ICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuXG5cblx0ICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuXHQgICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG5cdCAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cblx0ICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuXG5cdCAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcblx0ICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuXHQgICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuXHQgICAgaWYgKG5ld0NoaWxkcmVuID09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcblx0ICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblx0ICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXHQgICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG5cdCAgICB2YXIgbmV3SWR4ID0gMDtcblx0ICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXHQgICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cblx0ICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuXHQgICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcblx0ICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcblx0ICAgICAgICBvbGRGaWJlciA9IG51bGw7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcyk7XG5cblx0ICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG5cdCAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3Ncblx0ICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG5cdCAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG5cdCAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG5cdCAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG5cdCAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG5cdCAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG5cdCAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG5cdCAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuXHQgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cblx0ICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuXHQgICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcblx0ICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG5cdCAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuXHQgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuXHQgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHN0ZXAuZG9uZSkge1xuXHQgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cblx0ICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuXHQgICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuXHQgICAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuXHQgICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG5cdCAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuXHQgICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuXHQgICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcblx0ICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcyk7XG5cblx0ICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cblx0ICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuXHQgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuXHQgICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczMgPSBuZXdJZHg7XG5cdCAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG5cdCAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cblx0ICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG5cdCAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcblx0ICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuXHQgICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuXHQgICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG5cdCAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuXHQgICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcblx0ICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cblx0ICAgICAgICAgICAgLy8gbGlzdC5cblx0ICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cblx0ICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcblx0ICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcblx0ICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG5cdCAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG5cdCAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczQgPSBuZXdJZHg7XG5cdCAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3M0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcblx0ICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuXHQgICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuXHQgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcblx0ICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuXHQgICAgICAvLyB0aGUgcmVzdC5cblx0ICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuXHQgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuXHQgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblx0ICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuXHQgICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuXHQgICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cblxuXG5cdCAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuXHQgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cdCAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgcmV0dXJuIGNyZWF0ZWQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGxhbmVzKSB7XG5cdCAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG5cdCAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuXHQgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG5cdCAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuXHQgICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcblx0ICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG5cblx0ICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcblx0ICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcblx0ICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuXHQgICAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuXHQgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXHQgICAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHwgKCAvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcblx0ICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY2hpbGQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG5cdCAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG5cdCAgICAgICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2Vcblx0ICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cblx0ICAgICAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGNoaWxkLnR5cGUpIHtcblx0ICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuXG5cdCAgICAgICAgICAgIHZhciBfZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cblx0ICAgICAgICAgICAgX2V4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuXHQgICAgICAgICAgICBfZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cblx0ICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cdCAgICAgICAgICAgICAgX2V4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gLy8gRGlkbid0IG1hdGNoLlxuXG5cblx0ICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcblx0ICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgZWxlbWVudC5rZXkpO1xuXHQgICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICByZXR1cm4gY3JlYXRlZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuXHQgICAgICBfY3JlYXRlZDQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG5cdCAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblx0ICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGxhbmVzKSB7XG5cdCAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcblx0ICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG5cdCAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cblx0ICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG5cdCAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuXHQgICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG5cdCAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG5cdCAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcblx0ICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXHQgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXHQgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblx0ICAgIHJldHVybiBjcmVhdGVkO1xuXHQgIH0gLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuXHQgIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcblx0ICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cblxuXG5cdCAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcblx0ICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cblx0ICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG5cdCAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcblx0ICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cdCAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG5cdCAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG5cdCAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuXHQgICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG5cdCAgICBpZiAoaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuXHQgICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuXHQgICAgfSAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cblxuXHQgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuXHQgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuXHQgICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG5cdCAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcblx0ICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG5cdCAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdCAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuXHQgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDsgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBub24tcmVjdXJzaXZlLlxuXG5cdCAgICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcblx0ICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcblx0ICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuXHQgICAgfVxuXG5cdCAgICB7XG5cdCAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuXHQgICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xuXHR9XG5cblx0dmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xuXHR2YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cdGZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcblx0ICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG5cdCAgfVxuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHQgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG5cdCAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblx0ICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcblxuXHQgIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuXHQgICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG5cdCAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuXHQgICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cdCAgfVxuXG5cdCAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG5cdH0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuXHRmdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuXHQgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG5cdCAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICByZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLCBsYW5lcyk7XG5cdCAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgfVxuXHR9XG5cblx0dmFyIE5PX0NPTlRFWFQgPSB7fTtcblx0dmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXHR2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cdHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuXHRmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuXHQgIGlmIChjID09PSBOT19DT05URVhUKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG5cdCAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcblx0ICByZXR1cm4gcm9vdEluc3RhbmNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcblx0ICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcblx0ICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuXHQgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTsgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuXHQgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuXHQgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cblx0ICAvLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuXHQgIC8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG5cdCAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuXHQgIC8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cblxuXHQgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcblx0ICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuXHQgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuXHQgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuXHQgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuXHQgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuXHQgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG5cdCAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG5cdCAgcmV0dXJuIGNvbnRleHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcblx0ICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuXHQgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuXHQgIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTsgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5cblx0ICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcblx0ICAgIHJldHVybjtcblx0ICB9IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cblx0ICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cblxuXHQgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG5cdCAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG5cdCAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuXHQgIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXHQgIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuXHQgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuXHR9XG5cblx0dmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQgPSAwOyAvLyBUaGUgU3VzcGVuc2UgQ29udGV4dCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhlIGxvd2VyIGJpdHMgaXNcblx0Ly8gaW5oZXJpdGVkIGRlZXBseSBkb3duIHRoZSBzdWJ0cmVlLiBUaGUgdXBwZXIgYml0cyBvbmx5IGFmZmVjdFxuXHQvLyB0aGlzIGltbWVkaWF0ZSBzdXNwZW5zZSBib3VuZGFyeSBhbmQgZ2V0cyByZXNldCBlYWNoIG5ld1xuXHQvLyBib3VuZGFyeSBvciBzdXNwZW5zZSBsaXN0LlxuXG5cdHZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIFN1YnRyZWUgRmxhZ3M6XG5cdC8vIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2Ygb3VyIHBhcmVudCBTdXNwZW5zZVxuXHQvLyBib3VuZGFyaWVzIGlzIG5vdCBjdXJyZW50bHkgc2hvd2luZyB2aXNpYmxlIG1haW4gY29udGVudC5cblx0Ly8gRWl0aGVyIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgb3IgaXMgbm90IG1vdW50ZWQgYXQgYWxsLlxuXHQvLyBXZSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGRlc2lyYWJsZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgYXRcblx0Ly8gdGhlIHBhcmVudC4gSWYgbm90LCB0aGVuIHdlIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciB1bmRlc2lyYWJsZSBib3VuZGFyaWVzXG5cdC8vIGFuZC9vciBzdXNwZW5kIHRoZSBjb21taXQgdG8gYXZvaWQgaGlkaW5nIHRoZSBwYXJlbnQgY29udGVudC5cblxuXHR2YXIgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0ID0gMTsgLy8gU2hhbGxvdyBGbGFnczpcblx0Ly8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuXHQvLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG5cblx0dmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDI7XG5cdHZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO1xuXHRmdW5jdGlvbiBoYXNTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuXHQgIHJldHVybiAocGFyZW50Q29udGV4dCAmIGZsYWcpICE9PSAwO1xuXHR9XG5cdGZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQpIHtcblx0ICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO1xuXHR9XG5cdGZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc2hhbGxvd0NvbnRleHQpIHtcblx0ICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIHwgc2hhbGxvd0NvbnRleHQ7XG5cdH1cblx0ZnVuY3Rpb24gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzdWJ0cmVlQ29udGV4dCkge1xuXHQgIHJldHVybiBwYXJlbnRDb250ZXh0IHwgc3VidHJlZUNvbnRleHQ7XG5cdH1cblx0ZnVuY3Rpb24gcHVzaFN1c3BlbnNlQ29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuXHQgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV3Q29udGV4dCwgZmliZXIpO1xuXHR9XG5cdGZ1bmN0aW9uIHBvcFN1c3BlbnNlQ29udGV4dChmaWJlcikge1xuXHQgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudCkge1xuXHQgIC8vIElmIGl0IHdhcyB0aGUgcHJpbWFyeSBjaGlsZHJlbiB0aGF0IGp1c3Qgc3VzcGVuZGVkLCBjYXB0dXJlIGFuZCByZW5kZXIgdGhlXG5cdCAgLy8gZmFsbGJhY2suIE90aGVyd2lzZSwgZG9uJ3QgY2FwdHVyZSBhbmQgYnViYmxlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuXHQgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG5cdCAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgaWYgKG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIEEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbHdheXMgY2FwdHVyZXMuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczsgLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG5cdCAge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG5cdH1cblx0ZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuXHQgIHZhciBub2RlID0gcm93O1xuXG5cdCAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcblx0ICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3RhdGUuZGVoeWRyYXRlZDtcblxuXHQgICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcblx0ICAgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50ICYmIC8vIHJldmVhbE9yZGVyIHVuZGVmaW5lZCBjYW4ndCBiZSB0cnVzdGVkIGJlY2F1c2UgaXQgZG9uJ3Rcblx0ICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBpdCBzdXNwZW5kZWQgb3Igbm90LlxuXHQgICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdmFyIGRpZFN1c3BlbmQgPSAobm9kZS5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG5cdCAgICAgIGlmIChkaWRTdXNwZW5kKSB7XG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG5cdCAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG5vZGUgPT09IHJvdykge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuXHQgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvdykge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG5cdCAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXHQgIH1cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIE5vRmxhZ3MkMSA9XG5cdC8qICAgKi9cblx0MDsgLy8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cblxuXHR2YXIgSGFzRWZmZWN0ID1cblx0LyogKi9cblx0MTsgLy8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG5cblx0dmFyIEluc2VydGlvbiA9XG5cdC8qICAqL1xuXHQyO1xuXHR2YXIgTGF5b3V0ID1cblx0LyogICAgKi9cblx0NDtcblx0dmFyIFBhc3NpdmUkMSA9XG5cdC8qICAgKi9cblx0ODtcblxuXHQvLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG5cdC8vIFRoaXMgdHJhY2tzIHdoaWNoIG11dGFibGUgc291cmNlcyBuZWVkIHRvIGJlIHJlc2V0IGFmdGVyIGEgcmVuZGVyLlxuXG5cdHZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMgPSBbXTtcblx0ZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0luUHJvZ3Jlc3NTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IHdvcmtJblByb2dyZXNzU291cmNlc1tpXTtcblxuXHQgICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG5cdCAgICAgIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnkgPSBudWxsO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uU2Vjb25kYXJ5ID0gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoID0gMDtcblx0fVxuXHQvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdmVyc2lvbiB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIG1hdGNoZXMgdGhlIG9uZVxuXHQvLyB0aGF0IGlzIGV2ZW50dWFsbHkgcmVhZCBkdXJpbmcgaHlkcmF0aW9uLlxuXHQvLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cblxuXHRmdW5jdGlvbiByZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24ocm9vdCwgbXV0YWJsZVNvdXJjZSkge1xuXHQgIHZhciBnZXRWZXJzaW9uID0gbXV0YWJsZVNvdXJjZS5fZ2V0VmVyc2lvbjtcblx0ICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsgLy8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cblx0ICAvLyBSZXRhaW5pbmcgaXQgZm9yZXZlciBtYXkgaW50ZXJmZXJlIHdpdGggR0MuXG5cblx0ICBpZiAocm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID09IG51bGwpIHtcblx0ICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IFttdXRhYmxlU291cmNlLCB2ZXJzaW9uXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2gobXV0YWJsZVNvdXJjZSwgdmVyc2lvbik7XG5cdCAgfVxuXHR9XG5cblx0dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG5cdCAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG5cdHZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ7XG5cdHZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcblxuXHR7XG5cdCAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuXHR9XG5cblx0Ly8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxuXHR2YXIgcmVuZGVyTGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gSSd2ZSBuYW1lZCBpdCBkaWZmZXJlbnRseSB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG5cdC8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cblx0dmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBIb29rcyBhcmUgc3RvcmVkIGFzIGEgbGlua2VkIGxpc3Qgb24gdGhlIGZpYmVyJ3MgbWVtb2l6ZWRTdGF0ZSBmaWVsZC4gVGhlXG5cdC8vIGN1cnJlbnQgaG9vayBsaXN0IGlzIHRoZSBsaXN0IHRoYXQgYmVsb25ncyB0byB0aGUgY3VycmVudCBmaWJlci4gVGhlXG5cdC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuXHQvLyB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXG5cdHZhciBjdXJyZW50SG9vayA9IG51bGw7XG5cdHZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuXHQvLyBkb2VzIG5vdCBnZXQgcmVzZXQgaWYgd2UgZG8gYW5vdGhlciByZW5kZXIgcGFzczsgb25seSB3aGVuIHdlJ3JlIGNvbXBsZXRlbHlcblx0Ly8gZmluaXNoZWQgZXZhbHVhdGluZyB0aGlzIGNvbXBvbmVudC4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gd2Uga25vd1xuXHQvLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxuXHR2YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBXaGVyZSBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbmx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcy4gVGhpc1xuXHQvLyBnZXRzIHJlc2V0IGFmdGVyIGVhY2ggYXR0ZW1wdC5cblx0Ly8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcblx0Ly8gYGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVgLiBPciB3aXRoIGBudW1iZXJPZlJlUmVuZGVyc2AuXG5cblx0dmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlOyAvLyBDb3VudHMgdGhlIG51bWJlciBvZiB1c2VJZCBob29rcyBpbiB0aGlzIGNvbXBvbmVudC5cblxuXHR2YXIgbG9jYWxJZENvdW50ZXIgPSAwOyAvLyBVc2VkIGZvciBpZHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGNvbXBsZXRlbHkgY2xpZW50LXNpZGUgKGkuZS4gbm90IGR1cmluZ1xuXHQvLyBoeWRyYXRpb24pLiBUaGlzIGNvdW50ZXIgaXMgZ2xvYmFsLCBzbyBjbGllbnQgaWRzIGFyZSBub3Qgc3RhYmxlIGFjcm9zc1xuXHQvLyByZW5kZXIgYXR0ZW1wdHMuXG5cblx0dmFyIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG5cdHZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cblx0dmFyIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDsgLy8gSW4gREVWLCB0aGlzIGxpc3QgZW5zdXJlcyB0aGF0IGhvb2tzIGFyZSBjYWxsZWQgaW4gdGhlIHNhbWUgb3JkZXIgYmV0d2VlbiByZW5kZXJzLlxuXHQvLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuXHQvLyBTdWJzZXF1ZW50IHJlbmRlcnMgKHVwZGF0ZXMpIHJlZmVyZW5jZSB0aGlzIGxpc3QuXG5cblx0dmFyIGhvb2tUeXBlc0RldiA9IG51bGw7XG5cdHZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG5cdC8vIHRoZSBkZXBlbmRlbmNpZXMgZm9yIEhvb2tzIHRoYXQgbmVlZCB0aGVtIChlLmcuIHVzZUVmZmVjdCBvciB1c2VNZW1vKS5cblx0Ly8gV2hlbiB0cnVlLCBzdWNoIEhvb2tzIHdpbGwgYWx3YXlzIGJlIFwicmVtb3VudGVkXCIuIE9ubHkgdXNlZCBkdXJpbmcgaG90IHJlbG9hZC5cblxuXHR2YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcblx0ICB7XG5cdCAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuXHQgICAgaWYgKGhvb2tUeXBlc0RldiA9PT0gbnVsbCkge1xuXHQgICAgICBob29rVHlwZXNEZXYgPSBbaG9va05hbWVdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcblx0ICB7XG5cdCAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuXHQgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuXHQgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG5cdCAgICAgIGlmIChob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSkge1xuXHQgICAgICAgIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGhvb2tOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcblx0ICB7XG5cdCAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIWlzQXJyYXkoZGVwcykpIHtcblx0ICAgICAgLy8gVmVyaWZ5IGRlcHMsIGJ1dCBvbmx5IG9uIG1vdW50IHRvIGF2b2lkIGV4dHJhIGNoZWNrcy5cblx0ICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGVpciB0eXBlIHdvdWxkIGNoYW5nZSBhcyB1c3VhbGx5IHlvdSBkZWZpbmUgdGhlbSBpbmxpbmUuXG5cdCAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihjdXJyZW50SG9va05hbWUpIHtcblx0ICB7XG5cdCAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cblx0ICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuXHQgICAgICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG5cdCAgICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcblx0ICAgICAgICB2YXIgdGFibGUgPSAnJztcblx0ICAgICAgICB2YXIgc2Vjb25kQ29sdW1uU3RhcnQgPSAzMDtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcblx0ICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcblx0ICAgICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gY3VycmVudEhvb2tOYW1lIDogb2xkSG9va05hbWU7XG5cdCAgICAgICAgICB2YXIgcm93ID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTsgLy8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuXHQgICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG5cdCAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHJvdyArPSAnICc7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuXHQgICAgICAgICAgdGFibGUgKz0gcm93O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJyArICdUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuJyArICcgICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbicgKyAnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyArICclcycgKyAnICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJywgY29tcG9uZW50TmFtZSwgdGFibGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuXHQgIHtcblx0ICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykge1xuXHQgICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcblx0ICAgIHtcblx0ICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICB7XG5cdCAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcblx0ICAgIC8vIHBhc3NlZCBpbmxpbmUuXG5cdCAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcblx0ICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcsIG5leHRSZW5kZXJMYW5lcykge1xuXHQgIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuXHQgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuXHQgIHtcblx0ICAgIGhvb2tUeXBlc0RldiA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG5cdCAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG5cdCAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXHQgIH1cblxuXHQgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXHQgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblx0ICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG5cdCAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuXHQgIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cdCAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuXHQgIC8vIGxvY2FsSWRDb3VudGVyID0gMDtcblx0ICAvLyBUT0RPIFdhcm4gaWYgbm8gaG9va3MgYXJlIHVzZWQgYXQgYWxsIGR1cmluZyBtb3VudCwgdGhlbiBzb21lIGFyZSB1c2VkIGR1cmluZyB1cGRhdGUuXG5cdCAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG5cdCAgLy8gVGhpcyBpcyB0cmlja3kgYmVjYXVzZSBpdCdzIHZhbGlkIGZvciBjZXJ0YWluIHR5cGVzIG9mIGNvbXBvbmVudHMgKGUuZy4gUmVhY3QubGF6eSlcblx0ICAvLyBVc2luZyBtZW1vaXplZFN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBtb3VudC91cGRhdGUgb25seSB3b3JrcyBpZiBhdCBsZWFzdCBvbmUgc3RhdGVmdWwgaG9vayBpcyB1c2VkLlxuXHQgIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcblx0ICAvLyBzbyBtZW1vaXplZFN0YXRlIHdvdWxkIGJlIG51bGwgZHVyaW5nIHVwZGF0ZXMgYW5kIG1vdW50cy5cblxuXHQgIHtcblx0ICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cdCAgICB9IGVsc2UgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuXHQgICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG5cdCAgICAgIC8vIGJ1dCBubyBzdGF0ZWZ1bCBob29rcyBoYXZlIGJlZW4gdXNlZC5cblx0ICAgICAgLy8gV2Ugd2FudCB0byBtYXRjaCB0aGUgcHJvZHVjdGlvbiBjb2RlIGJlaGF2aW9yICh3aGljaCB3aWxsIHVzZSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50KSxcblx0ICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cblx0ICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGRvZXMgdGhhdC5cblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpOyAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlXG5cblx0ICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKSB7XG5cdCAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cblx0ICAgIC8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXHQgICAgdmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcblxuXHQgICAgZG8ge1xuXHQgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcblx0ICAgICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuXG5cdCAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCAnICsgJ2FuIGluZmluaXRlIGxvb3AuJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICAvLyBFdmVuIHdoZW4gaG90IHJlbG9hZGluZywgYWxsb3cgZGVwZW5kZW5jaWVzIHRvIHN0YWJpbGl6ZVxuXHQgICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuXHQgICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG5cdCAgICAgIH0gLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuXG5cdCAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICAvLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuXHQgICAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG5cdCAgICAgIH1cblxuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9ICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgO1xuXHQgICAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcblx0ICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG5cdCAgfSAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG5cdCAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuXG5cblx0ICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuXHQgIHtcblx0ICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGhvb2tUeXBlc0Rldjtcblx0ICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuXHQgIC8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxuXG5cblx0ICB2YXIgZGlkUmVuZGVyVG9vRmV3SG9va3MgPSBjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBjdXJyZW50SG9vay5uZXh0ICE9PSBudWxsO1xuXHQgIHJlbmRlckxhbmVzID0gTm9MYW5lcztcblx0ICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcblx0ICBjdXJyZW50SG9vayA9IG51bGw7XG5cdCAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXHQgIHtcblx0ICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcblx0ICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG5cdCAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBDb25maXJtIHRoYXQgYSBzdGF0aWMgZmxhZyB3YXMgbm90IGFkZGVkIG9yIHJlbW92ZWQgc2luY2UgdGhlIGxhc3Rcblx0ICAgIC8vIHJlbmRlci4gSWYgdGhpcyBmaXJlcywgaXQgc3VnZ2VzdHMgdGhhdCB3ZSBpbmNvcnJlY3RseSByZXNldCB0aGUgc3RhdGljXG5cdCAgICAvLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuXHQgICAgLy8gZXhhbXBsZSwgaW4gdGhlIFN1c3BlbnNlTGlzdCBpbXBsZW1lbnRhdGlvbi5cblxuXHQgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBTdGF0aWNNYXNrKSAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgU3RhdGljTWFzaykgJiYgLy8gRGlzYWJsZSB0aGlzIHdhcm5pbmcgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgbGVnYWN5IFN1c3BlbnNlIGlzIHdlaXJkXG5cdCAgICAvLyBhbmQgY3JlYXRlcyBmYWxzZSBwb3NpdGl2ZXMuIFRvIG1ha2UgdGhpcyB3b3JrIGluIGxlZ2FjeSBtb2RlLCB3ZSdkXG5cdCAgICAvLyBuZWVkIHRvIG1hcmsgZmliZXJzIHRoYXQgY29tbWl0IGluIGFuIGluY29tcGxldGUgc3RhdGUsIHNvbWVob3cuIEZvclxuXHQgICAgLy8gbm93IEknbGwgZGlzYWJsZSB0aGUgd2FybmluZyB0aGF0IG1vc3Qgb2YgdGhlIGJ1Z3MgdGhhdCB3b3VsZCB0cmlnZ2VyXG5cdCAgICAvLyBpdCBhcmUgZWl0aGVyIGV4Y2x1c2l2ZSB0byBjb25jdXJyZW50IG1vZGUgb3IgZXhpc3QgaW4gYm90aC5cblx0ICAgIChjdXJyZW50Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuXHQgICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2UgJyArICdub3RpZnkgdGhlIFJlYWN0IHRlYW0uJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGlzIGlzIHJlc2V0IGJ5IGNoZWNrRGlkUmVuZGVySWRIb29rXG5cdCAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuXG5cdCAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsICcgKyAnZWFybHkgcmV0dXJuIHN0YXRlbWVudC4nKTtcblx0ICB9XG5cblx0ICByZXR1cm4gY2hpbGRyZW47XG5cdH1cblx0ZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG5cdCAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IHJlbmRlcldpdGhIb29rcyBjYWxsLlxuXHQgIC8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgcmVuZGVyV2l0aEhvb2tzOyBpdCdzIG9ubHkgYVxuXHQgIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuXHQgIHZhciBkaWRSZW5kZXJJZEhvb2sgPSBsb2NhbElkQ291bnRlciAhPT0gMDtcblx0ICBsb2NhbElkQ291bnRlciA9IDA7XG5cdCAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcblx0fVxuXHRmdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG5cdCAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG5cdCAgLy8gY29tcGxldGUgcGhhc2UgKGJ1YmJsZVByb3BlcnRpZXMpLlxuXG5cdCAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KE1vdW50UGFzc2l2ZURldiB8IE1vdW50TGF5b3V0RGV2IHwgUGFzc2l2ZSB8IFVwZGF0ZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oUGFzc2l2ZSB8IFVwZGF0ZSk7XG5cdCAgfVxuXG5cdCAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcblx0fVxuXHRmdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpIHtcblx0ICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG5cdCAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuXHQgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG5cdCAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcblx0ICAgIC8vIFRoZXJlIHdlcmUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuIFRoZXNlIGFyZSBvbmx5IHZhbGlkIGZvciB0aGlzIHJlbmRlclxuXHQgICAgLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cblx0ICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuXHQgICAgLy8gdGhhdCB3ZXJlbid0IHByb2Nlc3NlZC5cblx0ICAgIC8vXG5cdCAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG5cdCAgICAvLyBub3QgaGF2ZSBhIGNsb25lLCB0aGF0IG1lYW5zIGl0IHdhc24ndCBwcm9jZXNzZWQsIGFuZCB0aGUgdXBkYXRlcyB3ZXJlXG5cdCAgICAvLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cblx0ICAgIHZhciBob29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICB3aGlsZSAoaG9vayAhPT0gbnVsbCkge1xuXHQgICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG5cdCAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgICAgaG9vayA9IGhvb2submV4dDtcblx0ICAgIH1cblxuXHQgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIHJlbmRlckxhbmVzID0gTm9MYW5lcztcblx0ICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcblx0ICBjdXJyZW50SG9vayA9IG51bGw7XG5cdCAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXHQgIHtcblx0ICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG5cdCAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuXHQgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuXHQgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuXHQgIGxvY2FsSWRDb3VudGVyID0gMDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuXHQgIHZhciBob29rID0ge1xuXHQgICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcblx0ICAgIGJhc2VTdGF0ZTogbnVsbCxcblx0ICAgIGJhc2VRdWV1ZTogbnVsbCxcblx0ICAgIHF1ZXVlOiBudWxsLFxuXHQgICAgbmV4dDogbnVsbFxuXHQgIH07XG5cblx0ICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG5cdCAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG5cdCAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXHQgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rO1xuXHQgIH1cblxuXHQgIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG5cdCAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG5cdCAgLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG5cdCAgLy8gY2xvbmUsIG9yIGEgd29yay1pbi1wcm9ncmVzcyBob29rIGZyb20gYSBwcmV2aW91cyByZW5kZXIgcGFzcyB0aGF0IHdlIGNhblxuXHQgIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuXHQgIC8vIHRoZSBkaXNwYXRjaGVyIHVzZWQgZm9yIG1vdW50cy5cblx0ICB2YXIgbmV4dEN1cnJlbnRIb29rO1xuXG5cdCAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG5cdCAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG5cdCAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuXHQgICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBuZXh0Q3VycmVudEhvb2sgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuXHQgIH1cblxuXHQgIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuXHQgICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuXHQgIH1cblxuXHQgIGlmIChuZXh0V29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG5cdCAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cblx0ICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG5cdCAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG5cdCAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuXHQgICAgaWYgKG5leHRDdXJyZW50SG9vayA9PT0gbnVsbCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTtcblx0ICAgIH1cblxuXHQgICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG5cdCAgICB2YXIgbmV3SG9vayA9IHtcblx0ICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcblx0ICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG5cdCAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuXHQgICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG5cdCAgICAgIG5leHQ6IG51bGxcblx0ICAgIH07XG5cblx0ICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcblx0ICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdC5cblx0ICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gbmV3SG9vaztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXHQgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5ld0hvb2s7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGxhc3RFZmZlY3Q6IG51bGwsXG5cdCAgICBzdG9yZXM6IG51bGxcblx0ICB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuXHQgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG5cdCAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcblx0ICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cdCAgdmFyIGluaXRpYWxTdGF0ZTtcblxuXHQgIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGluaXRpYWxTdGF0ZSA9IGluaXQoaW5pdGlhbEFyZyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG5cdCAgfVxuXG5cdCAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cdCAgdmFyIHF1ZXVlID0ge1xuXHQgICAgcGVuZGluZzogbnVsbCxcblx0ICAgIGludGVybGVhdmVkOiBudWxsLFxuXHQgICAgbGFuZXM6IE5vTGFuZXMsXG5cdCAgICBkaXNwYXRjaDogbnVsbCxcblx0ICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG5cdCAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG5cdCAgfTtcblx0ICBob29rLnF1ZXVlID0gcXVldWU7XG5cdCAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG5cdCAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuXHQgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cdCAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuXHQgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgfVxuXG5cdCAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG5cdCAgdmFyIGN1cnJlbnQgPSBjdXJyZW50SG9vazsgLy8gVGhlIGxhc3QgcmViYXNlIHVwZGF0ZSB0aGF0IGlzIE5PVCBwYXJ0IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG5cdCAgdmFyIGJhc2VRdWV1ZSA9IGN1cnJlbnQuYmFzZVF1ZXVlOyAvLyBUaGUgbGFzdCBwZW5kaW5nIHVwZGF0ZSB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG5cblx0ICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuXHQgIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcblx0ICAgIC8vIFdlIGhhdmUgbmV3IHVwZGF0ZXMgdGhhdCBoYXZlbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblx0ICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXHQgICAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAvLyBNZXJnZSB0aGUgcGVuZGluZyBxdWV1ZSBhbmQgdGhlIGJhc2UgcXVldWUuXG5cdCAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcblx0ICAgICAgdmFyIHBlbmRpbmdGaXJzdCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuXHQgICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdGaXJzdDtcblx0ICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG5cdCAgICB9XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcblx0ICAgICAgICAvLyBJbnRlcm5hbCBpbnZhcmlhbnQgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgZmVhc2libHkgY291bGQgaW5cblx0ICAgICAgICAvLyB0aGUgZnV0dXJlIGlmIHdlIGltcGxlbWVudCByZXN1bWluZywgb3Igc29tZSBmb3JtIG9mIHRoYXQuXG5cdCAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcblx0ICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcblx0ICAgIC8vIFdlIGhhdmUgYSBxdWV1ZSB0byBwcm9jZXNzLlxuXHQgICAgdmFyIGZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG5cdCAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcblx0ICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuXHQgICAgdmFyIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbnVsbDtcblx0ICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcblx0ICAgIHZhciB1cGRhdGUgPSBmaXJzdDtcblxuXHQgICAgZG8ge1xuXHQgICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG5cdCAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuXHQgICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0ICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2Vcblx0ICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG5cdCAgICAgICAgdmFyIGNsb25lID0ge1xuXHQgICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcblx0ICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcblx0ICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuXHQgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG5cdCAgICAgICAgICBuZXh0OiBudWxsXG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICBuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSBjbG9uZTtcblx0ICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gY2xvbmU7XG5cdCAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cdCAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcblx0ICAgICAgICAvLyByZW5kZXJMYW5lcyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuXG5cdCAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG5cdCAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblx0ICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgdmFyIF9jbG9uZSA9IHtcblx0ICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcblx0ICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuXHQgICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG5cdCAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcblx0ICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuXHQgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcblx0ICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG5cdCAgICAgICAgICAgIG5leHQ6IG51bGxcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lO1xuXHQgICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG5cdCAgICAgICAgaWYgKHVwZGF0ZS5oYXNFYWdlclN0YXRlKSB7XG5cdCAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSBpcyBhIHN0YXRlIHVwZGF0ZSAobm90IGEgcmVkdWNlcikgYW5kIHdhcyBwcm9jZXNzZWQgZWFnZXJseSxcblx0ICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGVcblx0ICAgICAgICAgIG5ld1N0YXRlID0gdXBkYXRlLmVhZ2VyU3RhdGU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXHQgICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXHQgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsICYmIHVwZGF0ZSAhPT0gZmlyc3QpO1xuXG5cdCAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuXHQgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuXHQgICAgfSAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG5cdCAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG5cdCAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG5cdCAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG5cdCAgICB9XG5cblx0ICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuXHQgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG5cdCAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG5cdCAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuXHQgIH0gLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuXHQgIC8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG5cdCAgLy8gYXJlIHJlbWFpbmluZy5cblxuXG5cdCAgdmFyIGxhc3RJbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG5cdCAgaWYgKGxhc3RJbnRlcmxlYXZlZCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGludGVybGVhdmVkID0gbGFzdEludGVybGVhdmVkO1xuXG5cdCAgICBkbyB7XG5cdCAgICAgIHZhciBpbnRlcmxlYXZlZExhbmUgPSBpbnRlcmxlYXZlZC5sYW5lO1xuXHQgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBpbnRlcmxlYXZlZExhbmUpO1xuXHQgICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGludGVybGVhdmVkTGFuZSk7XG5cdCAgICAgIGludGVybGVhdmVkID0gaW50ZXJsZWF2ZWQubmV4dDtcblx0ICAgIH0gd2hpbGUgKGludGVybGVhdmVkICE9PSBsYXN0SW50ZXJsZWF2ZWQpO1xuXHQgIH0gZWxzZSBpZiAoYmFzZVF1ZXVlID09PSBudWxsKSB7XG5cdCAgICAvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuXHQgICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cblx0ICAgIHF1ZXVlLmxhbmVzID0gTm9MYW5lcztcblx0ICB9XG5cblx0ICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblx0ICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cblx0ICBpZiAocXVldWUgPT09IG51bGwpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgIH1cblxuXHQgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuXHQgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuXHQgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuXHQgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nO1xuXHQgIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuXHQgIGlmIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IG51bGwpIHtcblx0ICAgIC8vIFRoZSBxdWV1ZSBkb2Vzbid0IHBlcnNpc3QgcGFzdCB0aGlzIHJlbmRlciBwYXNzLlxuXHQgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG5cdCAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuXHQgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG5cdCAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcblx0ICAgICAgLy8gcmVuZGVyJ3MuXG5cdCAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXHQgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG5cdCAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXHQgICAgfSB3aGlsZSAodXBkYXRlICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTsgLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuXHQgICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuXHQgICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuXHQgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuXHQgICAgfVxuXG5cdCAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cblx0ICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG5cdCAgICAvLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIHNlbWFudGljcywgYnV0IGl0J3Mgd2hhdCB3ZVxuXHQgICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuXHQgICAgaWYgKGhvb2suYmFzZVF1ZXVlID09PSBudWxsKSB7XG5cdCAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7XG5cdCAgICB9XG5cblx0ICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuXHQgIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcblx0ICB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcblx0ICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuXHQgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblx0ICB2YXIgbmV4dFNuYXBzaG90O1xuXHQgIHZhciBpc0h5ZHJhdGluZyA9IGdldElzSHlkcmF0aW5nKCk7XG5cblx0ICBpZiAoaXNIeWRyYXRpbmcpIHtcblx0ICAgIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yICcgKyAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuJyk7XG5cdCAgICB9XG5cblx0ICAgIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuXHQgICAgICAgIGlmIChuZXh0U25hcHNob3QgIT09IGdldFNlcnZlclNuYXBzaG90KCkpIHtcblx0ICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG5cdCAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuXHQgICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cblx0ICAgICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG5cdCAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuXHQgICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSAvLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cblx0ICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcblx0ICAgIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG5cdCAgICAvL1xuXHQgICAgLy8gV2Ugd29uJ3QgZG8gdGhpcyBpZiB3ZSdyZSBoeWRyYXRpbmcgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQsIGJlY2F1c2UgaWZcblx0ICAgIC8vIHRoZSBjb250ZW50IGlzIHN0YWxlLCBpdCdzIGFscmVhZHkgdmlzaWJsZSBhbnl3YXkuIEluc3RlYWQgd2UnbGwgcGF0Y2hcblx0ICAgIC8vIGl0IHVwIGluIGEgcGFzc2l2ZSBlZmZlY3QuXG5cblxuXHQgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuXHQgICAgaWYgKHJvb3QgPT09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgcmVuZGVyTGFuZXMpKSB7XG5cdCAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuXHQgICAgfVxuXHQgIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuXHQgIC8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuXHQgIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG5cdCAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuXHQgIHZhciBpbnN0ID0ge1xuXHQgICAgdmFsdWU6IG5leHRTbmFwc2hvdCxcblx0ICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuXHQgIH07XG5cdCAgaG9vay5xdWV1ZSA9IGluc3Q7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlLlxuXG5cdCAgbW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byB1cGRhdGUgdGhlIG11dGFibGUgaW5zdGFuY2UgZmllbGRzLiBXZSB3aWxsIHVwZGF0ZVxuXHQgIC8vIHRoaXMgd2hlbmV2ZXIgc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgb3IgdmFsdWUgY2hhbmdlcy4gQmVjYXVzZSB0aGVyZSdzIG5vXG5cdCAgLy8gY2xlYW4tdXAgZnVuY3Rpb24sIGFuZCB3ZSB0cmFjayB0aGUgZGVwcyBjb3JyZWN0bHksIHdlIGNhbiBjYWxsIHB1c2hFZmZlY3Rcblx0ICAvLyBkaXJlY3RseSwgd2l0aG91dCBzdG9yaW5nIGFueSBhZGRpdGlvbmFsIHN0YXRlLiBGb3IgdGhlIHNhbWUgcmVhc29uLCB3ZVxuXHQgIC8vIGRvbid0IG5lZWQgdG8gc2V0IGEgc3RhdGljIGZsYWcsIGVpdGhlci5cblx0ICAvLyBUT0RPOiBXZSBjYW4gbW92ZSB0aGlzIHRvIHRoZSBwYXNzaXZlIHBoYXNlIG9uY2Ugd2UgYWRkIGEgcHJlLWNvbW1pdFxuXHQgIC8vIGNvbnNpc3RlbmN5IGNoZWNrLiBTZWUgdGhlIG5leHQgY29tbWVudC5cblxuXHQgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmU7XG5cdCAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7XG5cdCAgcmV0dXJuIG5leHRTbmFwc2hvdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG5cdCAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpOyAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG5cdCAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG5cdCAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cdCAgdmFyIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cblx0ICB7XG5cdCAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG5cdCAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cblx0ICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuXHQgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG5cdCAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHByZXZTbmFwc2hvdCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblx0ICB2YXIgc25hcHNob3RDaGFuZ2VkID0gIW9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcblxuXHQgIGlmIChzbmFwc2hvdENoYW5nZWQpIHtcblx0ICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcblx0ICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG5cdCAgfVxuXG5cdCAgdmFyIGluc3QgPSBob29rLnF1ZXVlO1xuXHQgIHVwZGF0ZUVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIHN1YnNjcmliZSksIFtzdWJzY3JpYmVdKTsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG5cdCAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG5cdCAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuXHQgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuXHQgIGlmIChpbnN0LmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fCBzbmFwc2hvdENoYW5nZWQgfHwgLy8gQ2hlY2sgaWYgdGhlIHN1c2JjcmliZSBmdW5jdGlvbiBjaGFuZ2VkLiBXZSBjYW4gc2F2ZSBzb21lIG1lbW9yeSBieVxuXHQgIC8vIGNoZWNraW5nIHdoZXRoZXIgd2Ugc2NoZWR1bGVkIGEgc3Vic2NyaXB0aW9uIGVmZmVjdCBhYm92ZS5cblx0ICB3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KSB7XG5cdCAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlO1xuXHQgICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuXHQgICAgLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuXHQgICAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cblxuXHQgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuXHQgICAgaWYgKHJvb3QgPT09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgcmVuZGVyTGFuZXMpKSB7XG5cdCAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBuZXh0U25hcHNob3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuXHQgIGZpYmVyLmZsYWdzIHw9IFN0b3JlQ29uc2lzdGVuY3k7XG5cdCAgdmFyIGNoZWNrID0ge1xuXHQgICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuXHQgICAgdmFsdWU6IHJlbmRlcmVkU25hcHNob3Rcblx0ICB9O1xuXHQgIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cblx0ICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcblx0ICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuXHQgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuXHQgICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHN0b3JlcyA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcztcblxuXHQgICAgaWYgKHN0b3JlcyA9PT0gbnVsbCkge1xuXHQgICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc3RvcmVzLnB1c2goY2hlY2spO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcblx0ICAvLyBUaGVzZSBhcmUgdXBkYXRlZCBpbiB0aGUgcGFzc2l2ZSBwaGFzZVxuXHQgIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG5cdCAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBTb21ldGhpbmcgbWF5IGhhdmUgYmVlbiBtdXRhdGVkIGluIGJldHdlZW4gcmVuZGVyIGFuZCBjb21taXQuIFRoaXMgY291bGRcblx0ICAvLyBoYXZlIGJlZW4gaW4gYW4gZXZlbnQgdGhhdCBmaXJlZCBiZWZvcmUgdGhlIHBhc3NpdmUgZWZmZWN0cywgb3IgaXQgY291bGRcblx0ICAvLyBoYXZlIGJlZW4gaW4gYSBsYXlvdXQgZWZmZWN0LiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkIGhhdmUgdXNlZCB0aGUgb2xkXG5cdCAgLy8gc25hcHNobyBhbmQgZ2V0U25hcHNob3QgdmFsdWVzIHRvIGJhaWwgb3V0LiBXZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIHRpbWUuXG5cblx0ICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG5cdCAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuXHQgIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG5cdCAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuXHQgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcblx0ICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG5cdCAgICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG5cdCAgICB9XG5cdCAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuXHQgIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG5cdCAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcblx0ICB2YXIgcHJldlZhbHVlID0gaW5zdC52YWx1ZTtcblxuXHQgIHRyeSB7XG5cdCAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcblx0ICAgIHJldHVybiAhb2JqZWN0SXMocHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcblx0ICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG5cdCAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHQgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuXHQgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuXHQgICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG5cdCAgfVxuXG5cdCAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cdCAgdmFyIHF1ZXVlID0ge1xuXHQgICAgcGVuZGluZzogbnVsbCxcblx0ICAgIGludGVybGVhdmVkOiBudWxsLFxuXHQgICAgbGFuZXM6IE5vTGFuZXMsXG5cdCAgICBkaXNwYXRjaDogbnVsbCxcblx0ICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuXHQgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuXHQgIH07XG5cdCAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuXHQgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcblx0ICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdCAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcblx0ICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcblx0ICB2YXIgZWZmZWN0ID0ge1xuXHQgICAgdGFnOiB0YWcsXG5cdCAgICBjcmVhdGU6IGNyZWF0ZSxcblx0ICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG5cdCAgICBkZXBzOiBkZXBzLFxuXHQgICAgLy8gQ2lyY3VsYXJcblx0ICAgIG5leHQ6IG51bGxcblx0ICB9O1xuXHQgIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cblx0ICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcblx0ICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuXHQgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuXHQgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cblx0ICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG5cdCAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcblx0ICAgICAgbGFzdEVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuXHQgICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuXHQgICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBlZmZlY3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcblx0ICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cblx0ICB7XG5cdCAgICB2YXIgX3JlZjIgPSB7XG5cdCAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuXHQgICAgfTtcblx0ICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IF9yZWYyO1xuXHQgICAgcmV0dXJuIF9yZWYyO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpIHtcblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcblx0ICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cdCAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cdCAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuXHQgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIHVuZGVmaW5lZCwgbmV4dERlcHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuXHQgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cdCAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cdCAgdmFyIGRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cblx0ICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcblx0ICAgIHZhciBwcmV2RWZmZWN0ID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcblx0ICAgIGRlc3Ryb3kgPSBwcmV2RWZmZWN0LmRlc3Ryb3k7XG5cblx0ICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuXHQgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2RWZmZWN0LmRlcHM7XG5cblx0ICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG5cdCAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcblx0ICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcblx0ICBpZiAoIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuXHQgICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChNb3VudFBhc3NpdmVEZXYgfCBQYXNzaXZlIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFBhc3NpdmUgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuXHQgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuXHQgIHJldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG5cdCAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcblx0ICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuXHQgIHtcblx0ICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuXHQgIH1cblxuXHQgIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuXHQgIH1cblxuXHQgIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuXHQgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUsIHJlZikge1xuXHQgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICB2YXIgcmVmQ2FsbGJhY2sgPSByZWY7XG5cblx0ICAgIHZhciBfaW5zdCA9IGNyZWF0ZSgpO1xuXG5cdCAgICByZWZDYWxsYmFjayhfaW5zdCk7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZWZDYWxsYmFjayhudWxsKTtcblx0ICAgIH07XG5cdCAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIHZhciByZWZPYmplY3QgPSByZWY7XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKCFyZWZPYmplY3QuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuXHQgICAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgJyArICdyZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCAnYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKHJlZk9iamVjdCkuam9pbignLCAnKSArICd9Jyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIF9pbnN0MiA9IGNyZWF0ZSgpO1xuXG5cdCAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0Mjtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJlZk9iamVjdC5jdXJyZW50ID0gbnVsbDtcblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG5cdCAge1xuXHQgICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG5cdCAgICB9XG5cdCAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cblx0ICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcblx0ICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuXHQgIHtcblx0ICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuXHQgIH1cblxuXHQgIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuXHQgIH1cblxuXHQgIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcblx0ICAgIH1cblx0ICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuXHQgIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuXHQgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cblx0ICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cblx0ICAvLyBzbyB0aGF0IGUuZy4gRGV2VG9vbHMgY2FuIGRpc3BsYXkgY3VzdG9tIGhvb2sgdmFsdWVzLlxuXHR9XG5cblx0dmFyIHVwZGF0ZURlYnVnVmFsdWUgPSBtb3VudERlYnVnVmFsdWU7XG5cblx0ZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuXHQgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblx0ICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblx0ICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcblx0ICByZXR1cm4gY2FsbGJhY2s7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuXHQgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cdCAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cdCAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuXHQgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblx0ICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuXHQgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cblx0ICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG5cdCAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuXHQgIHJldHVybiBjYWxsYmFjaztcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG5cdCAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuXHQgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cdCAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuXHQgIHJldHVybiBuZXh0VmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuXHQgIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cblx0ICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAvLyBBc3N1bWUgdGhlc2UgYXJlIGRlZmluZWQuIElmIHRoZXkncmUgbm90LCBhcmVIb29rSW5wdXRzRXF1YWwgd2lsbCB3YXJuLlxuXHQgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuXHQgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcblx0ICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblx0ICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG5cdCAgcmV0dXJuIG5leHRWYWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuXHQgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblx0ICBob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZTtcblx0ICByZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG5cdCAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblx0ICB2YXIgcmVzb2x2ZWRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rO1xuXHQgIHZhciBwcmV2VmFsdWUgPSByZXNvbHZlZEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG5cdCAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG5cdCAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuXHQgIGlmIChjdXJyZW50SG9vayA9PT0gbnVsbCkge1xuXHQgICAgLy8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhIG1vdW50LlxuXHQgICAgaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWU7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYW4gdXBkYXRlLlxuXHQgICAgdmFyIHByZXZWYWx1ZSA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG5cdCAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSkge1xuXHQgIHZhciBzaG91bGREZWZlclZhbHVlID0gIWluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKHJlbmRlckxhbmVzKTtcblxuXHQgIGlmIChzaG91bGREZWZlclZhbHVlKSB7XG5cdCAgICAvLyBUaGlzIGlzIGFuIHVyZ2VudCB1cGRhdGUuIElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwga2VlcCB1c2luZyB0aGVcblx0ICAgIC8vIHByZXZpb3VzIHZhbHVlIGFuZCBzcGF3biBhIGRlZmVycmVkIHJlbmRlciB0byB1cGRhdGUgaXQgbGF0ZXIuXG5cdCAgICBpZiAoIW9iamVjdElzKHZhbHVlLCBwcmV2VmFsdWUpKSB7XG5cdCAgICAgIC8vIFNjaGVkdWxlIGEgZGVmZXJyZWQgcmVuZGVyXG5cdCAgICAgIHZhciBkZWZlcnJlZExhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpO1xuXHQgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBkZWZlcnJlZExhbmUpO1xuXHQgICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGRlZmVycmVkTGFuZSk7IC8vIFNldCB0aGlzIHRvIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcmVuZGVyZWQgdmFsdWUgaXMgaW5jb25zaXN0ZW50XG5cdCAgICAgIC8vIGZyb20gdGhlIGxhdGVzdCB2YWx1ZS4gVGhlIG5hbWUgXCJiYXNlU3RhdGVcIiBkb2Vzbid0IHJlYWxseSBtYXRjaCBob3cgd2Vcblx0ICAgICAgLy8gdXNlIGl0IGJlY2F1c2Ugd2UncmUgcmV1c2luZyBhIHN0YXRlIGhvb2sgZmllbGQgaW5zdGVhZCBvZiBjcmVhdGluZyBhXG5cdCAgICAgIC8vIG5ldyBvbmUuXG5cblx0ICAgICAgaG9vay5iYXNlU3RhdGUgPSB0cnVlO1xuXHQgICAgfSAvLyBSZXVzZSB0aGUgcHJldmlvdXMgdmFsdWVcblxuXG5cdCAgICByZXR1cm4gcHJldlZhbHVlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBUaGlzIGlzIG5vdCBhbiB1cmdlbnQgdXBkYXRlLCBzbyB3ZSBjYW4gdXNlIHRoZSBsYXRlc3QgdmFsdWUgcmVnYXJkbGVzc1xuXHQgICAgLy8gb2Ygd2hhdCBpdCBpcy4gTm8gbmVlZCB0byBkZWZlciBpdC5cblx0ICAgIC8vIEhvd2V2ZXIsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBzcGF3bmVkIHJlbmRlciwgdGhlbiB3ZSBuZWVkIHRvIG1hcmtcblx0ICAgIC8vIHRoaXMgYXMgYW4gdXBkYXRlIHRvIHByZXZlbnQgdGhlIGZpYmVyIGZyb20gYmFpbGluZyBvdXQuXG5cdCAgICAvL1xuXHQgICAgLy8gYGJhc2VTdGF0ZWAgaXMgdHJ1ZSB3aGVuIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSByZW5kZXJlZFxuXHQgICAgLy8gdmFsdWUuIFRoZSBuYW1lIGRvZXNuJ3QgcmVhbGx5IG1hdGNoIGhvdyB3ZSB1c2UgaXQgYmVjYXVzZSB3ZSdyZSByZXVzaW5nXG5cdCAgICAvLyBhIHN0YXRlIGhvb2sgZmllbGQgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUuXG5cdCAgICBpZiAoaG9vay5iYXNlU3RhdGUpIHtcblx0ICAgICAgLy8gRmxpcCB0aGlzIGJhY2sgdG8gZmFsc2UuXG5cdCAgICAgIGhvb2suYmFzZVN0YXRlID0gZmFsc2U7XG5cdCAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG5cdCAgICB9XG5cblx0ICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzZXRQZW5kaW5nLCBjYWxsYmFjaywgb3B0aW9ucykge1xuXHQgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cdCAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGhpZ2hlckV2ZW50UHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSwgQ29udGludW91c0V2ZW50UHJpb3JpdHkpKTtcblx0ICBzZXRQZW5kaW5nKHRydWUpO1xuXHQgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcblx0ICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSB7fTtcblx0ICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG5cblx0ICB7XG5cdCAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG5cdCAgfVxuXG5cdCAgdHJ5IHtcblx0ICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuXHQgICAgY2FsbGJhY2soKTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cblx0ICAgIHtcblx0ICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG5cdCAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cblx0ICAgICAgICBpZiAodXBkYXRlZEZpYmVyc0NvdW50ID4gMTApIHtcblx0ICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuXHQgIHZhciBfbW91bnRTdGF0ZSA9IG1vdW50U3RhdGUoZmFsc2UpLFxuXHQgICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZVswXSxcblx0ICAgICAgc2V0UGVuZGluZyA9IF9tb3VudFN0YXRlWzFdOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgbmV2ZXIgY2hhbmdlcy5cblxuXG5cdCAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgc2V0UGVuZGluZyk7XG5cdCAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXJ0O1xuXHQgIHJldHVybiBbaXNQZW5kaW5nLCBzdGFydF07XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuXHQgIHZhciBfdXBkYXRlU3RhdGUgPSB1cGRhdGVTdGF0ZSgpLFxuXHQgICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGVbMF07XG5cblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblx0ICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuXHQgIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcblx0ICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGVbMF07XG5cblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblx0ICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xuXHR9XG5cblx0dmFyIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcblx0ZnVuY3Rpb24gZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkge1xuXHQgIHtcblx0ICAgIHJldHVybiBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50SWQoKSB7XG5cdCAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7IC8vIFRPRE86IEluIEZpenosIGlkIGdlbmVyYXRpb24gaXMgc3BlY2lmaWMgdG8gZWFjaCBzZXJ2ZXIgY29uZmlnLiBNYXliZSB3ZVxuXHQgIC8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuXHQgIC8vIHRoZXJlJ3Mgbm8gb3RoZXIgcGxhY2UgdG8gc3RvcmUgdGhlIHByZWZpeCBleGNlcHQgZm9yIGFuIGludGVybmFsIGZpZWxkIG9uXG5cdCAgLy8gdGhlIHB1YmxpYyBjcmVhdGVSb290IG9iamVjdCwgd2hpY2ggdGhlIGZpYmVyIHRyZWUgZG9lcyBub3QgY3VycmVudGx5IGhhdmVcblx0ICAvLyBhIHJlZmVyZW5jZSB0by5cblxuXHQgIHZhciBpZGVudGlmaWVyUHJlZml4ID0gcm9vdC5pZGVudGlmaWVyUHJlZml4O1xuXHQgIHZhciBpZDtcblxuXHQgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG5cdCAgICB2YXIgdHJlZUlkID0gZ2V0VHJlZUlkKCk7IC8vIFVzZSBhIGNhcHRpYWwgUiBwcmVmaXggZm9yIHNlcnZlci1nZW5lcmF0ZWQgaWRzLlxuXG5cdCAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAnUicgKyB0cmVlSWQ7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuXHQgICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuXHQgICAgLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG5cblx0ICAgIHZhciBsb2NhbElkID0gbG9jYWxJZENvdW50ZXIrKztcblxuXHQgICAgaWYgKGxvY2FsSWQgPiAwKSB7XG5cdCAgICAgIGlkICs9ICdIJyArIGxvY2FsSWQudG9TdHJpbmcoMzIpO1xuXHQgICAgfVxuXG5cdCAgICBpZCArPSAnOic7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFVzZSBhIGxvd2VyY2FzZSByIHByZWZpeCBmb3IgY2xpZW50LWdlbmVyYXRlZCBpZHMuXG5cdCAgICB2YXIgZ2xvYmFsQ2xpZW50SWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKztcblx0ICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdyJyArIGdsb2JhbENsaWVudElkLnRvU3RyaW5nKDMyKSArICc6Jztcblx0ICB9XG5cblx0ICBob29rLm1lbW9pemVkU3RhdGUgPSBpZDtcblx0ICByZXR1cm4gaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVJZCgpIHtcblx0ICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXHQgIHZhciBpZCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblx0ICByZXR1cm4gaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuXHQgIHZhciB1cGRhdGUgPSB7XG5cdCAgICBsYW5lOiBsYW5lLFxuXHQgICAgYWN0aW9uOiBhY3Rpb24sXG5cdCAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcblx0ICAgIGVhZ2VyU3RhdGU6IG51bGwsXG5cdCAgICBuZXh0OiBudWxsXG5cdCAgfTtcblxuXHQgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuXHQgICAgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG5cblx0ICAgIGlmIChyb290ICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG5cdCAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblx0ICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG5cdCAge1xuXHQgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcblx0ICB2YXIgdXBkYXRlID0ge1xuXHQgICAgbGFuZTogbGFuZSxcblx0ICAgIGFjdGlvbjogYWN0aW9uLFxuXHQgICAgaGFzRWFnZXJTdGF0ZTogZmFsc2UsXG5cdCAgICBlYWdlclN0YXRlOiBudWxsLFxuXHQgICAgbmV4dDogbnVsbFxuXHQgIH07XG5cblx0ICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcblx0ICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuXHQgICAgaWYgKGZpYmVyLmxhbmVzID09PSBOb0xhbmVzICYmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmxhbmVzID09PSBOb0xhbmVzKSkge1xuXHQgICAgICAvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuXHQgICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuXHQgICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cblx0ICAgICAgdmFyIGxhc3RSZW5kZXJlZFJlZHVjZXIgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO1xuXG5cdCAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG5cdCAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyO1xuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblx0ICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTtcblx0ICAgICAgICAgIHZhciBlYWdlclN0YXRlID0gbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7IC8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG5cdCAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuXHQgICAgICAgICAgLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuXHQgICAgICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxuXG5cdCAgICAgICAgICB1cGRhdGUuaGFzRWFnZXJTdGF0ZSA9IHRydWU7XG5cdCAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cblx0ICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG5cdCAgICAgICAgICAgIC8vIEZhc3QgcGF0aC4gV2UgY2FuIGJhaWwgb3V0IHdpdGhvdXQgc2NoZWR1bGluZyBSZWFjdCB0byByZS1yZW5kZXIuXG5cdCAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcblx0ICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcblx0ICAgICAgICAgICAgLy8gdGltZSB0aGUgcmVkdWNlciBoYXMgY2hhbmdlZC5cblx0ICAgICAgICAgICAgLy8gVE9ETzogRG8gd2Ugc3RpbGwgbmVlZCB0byBlbnRhbmdsZSB0cmFuc2l0aW9ucyBpbiB0aGlzIGNhc2U/XG5cdCAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3VwcHJlc3MgdGhlIGVycm9yLiBJdCB3aWxsIHRocm93IGFnYWluIGluIHRoZSByZW5kZXIgcGhhc2UuXG5cdCAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuXG5cdCAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuXHQgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cdCAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuXHQgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cdCAgcmV0dXJuIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG5cdH1cblxuXHRmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuXHQgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuXHQgIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcblx0ICAvLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblx0ICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcblx0ICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cblx0ICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHQgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuXHQgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuXHQgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuXHQgIH1cblxuXHQgIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG5cdH0gLy8gVE9ETzogTW92ZSB0byBSZWFjdEZpYmVyQ29uY3VycmVudFVwZGF0ZXM/XG5cblxuXHRmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpIHtcblx0ICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuXHQgICAgdmFyIHF1ZXVlTGFuZXMgPSBxdWV1ZS5sYW5lczsgLy8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleVxuXHQgICAgLy8gbXVzdCBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaFxuXHQgICAgLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG5cdCAgICAvLyBtYXkgZW50YW5nbGUgbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZlxuXHQgICAgLy8gd2UgKmRvbid0KiBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuXHQgICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuXHQgICAgdmFyIG5ld1F1ZXVlTGFuZXMgPSBtZXJnZUxhbmVzKHF1ZXVlTGFuZXMsIGxhbmUpO1xuXHQgICAgcXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG5cdCAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuXHQgICAgLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cblxuXHQgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUsIGFjdGlvbikge1xuXG5cdCAge1xuXHQgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuXHQgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcblx0ICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuXHQgIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcblx0ICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcblx0ICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG5cdCAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG5cdCAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG5cdCAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuXHQgIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcblx0ICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcblx0ICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuXHQgIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcblx0ICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG5cdCAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuXHQgIHVzZU11dGFibGVTb3VyY2U6IHRocm93SW52YWxpZEhvb2tFcnJvcixcblx0ICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuXHQgIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG5cdCAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG5cdH07XG5cblx0dmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG5cdHZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcblx0dmFyIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xuXHR2YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcblx0dmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xuXHR2YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xuXHR2YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cblx0e1xuXHQgIHZhciB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG5cdCAgfTtcblxuXHQgIHZhciB3YXJuSW52YWxpZEhvb2tBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG5cdCAgfTtcblxuXHQgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcblx0ICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuXHQgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcblx0ICAgIH0sXG5cdCAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0Jztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG5cdCAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG5cdCAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcblx0ICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuXHQgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuXHQgICAgfSxcblx0ICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuXHQgICAgfSxcblx0ICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcblx0ICAgIH0sXG5cdCAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuXHQgICAgfSxcblx0ICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50SWQoKTtcblx0ICAgIH0sXG5cdCAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcblx0ICB9O1xuXG5cdCAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcblx0ICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0Jztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcblx0ICAgIH0sXG5cdCAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO1xuXHQgICAgfSxcblx0ICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuXHQgICAgfSxcblx0ICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudElkKCk7XG5cdCAgICB9LFxuXHQgICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG5cdCAgfTtcblxuXHQgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG5cdCAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuXHQgICAgfSxcblx0ICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0Jztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcblx0ICAgIH0sXG5cdCAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0Jztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcblx0ICAgIH0sXG5cdCAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcblx0ICAgIH0sXG5cdCAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG5cdCAgICB9LFxuXHQgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG5cdCAgICB9LFxuXHQgICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG5cdCAgfTtcblxuXHQgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcblx0ICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuXHQgICAgfSxcblx0ICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0Jztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0Jztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuXHQgICAgfSxcblx0ICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcblx0ICAgIH0sXG5cdCAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKTtcblx0ICAgIH0sXG5cdCAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuXHQgICAgfSxcblx0ICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO1xuXHQgICAgfSxcblx0ICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xuXHQgICAgfSxcblx0ICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuXHQgICAgfSxcblx0ICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuXHQgIH07XG5cblx0ICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuXHQgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0Jztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcblx0ICAgIH0sXG5cdCAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO1xuXHQgICAgfSxcblx0ICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuXHQgICAgfSxcblx0ICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiBtb3VudElkKCk7XG5cdCAgICB9LFxuXHQgICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG5cdCAgfTtcblxuXHQgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuXHQgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0Jztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuXHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuXHQgICAgfSxcblx0ICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcblx0ICAgIH0sXG5cdCAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO1xuXHQgICAgfSxcblx0ICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcblx0ICAgIH0sXG5cdCAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG5cdCAgICB9LFxuXHQgICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG5cdCAgfTtcblxuXHQgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG5cdCAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG5cdCAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcblx0ICAgIH0sXG5cdCAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcblx0ICAgIH0sXG5cdCAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0Jztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcblx0ICAgIH0sXG5cdCAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0Jztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdCAgICB9LFxuXHQgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHQgICAgfSxcblx0ICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcblx0ICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG5cdCAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcblx0ICAgIH0sXG5cdCAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuXHQgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG5cdCAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG5cdCAgICB9LFxuXHQgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuXHQgICAgfSxcblx0ICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuXHQgICAgfSxcblx0ICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG5cdCAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuXHQgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcblx0ICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTtcblx0ICAgIH0sXG5cdCAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG5cdCAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcblx0ICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG5cdCAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuXHQgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG5cdCAgICB9LFxuXHQgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuXHQgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcblx0ICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG5cdCAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuXHQgICAgfSxcblx0ICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuXHQgIH07XG5cdH1cblxuXHR2YXIgbm93JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xuXHR2YXIgY29tbWl0VGltZSA9IDA7XG5cdHZhciBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSAtMTtcblx0dmFyIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG5cdHZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7XG5cdC8qKlxuXHQgKiBUcmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkL2Nhc2NhZGluZyB1cGRhdGUgKHNjaGVkdWxlZCBmcm9tIGEgbGF5b3V0IGVmZmVjdCkuXG5cdCAqXG5cdCAqIFRoZSBvdmVyYWxsIHNlcXVlbmNlIGlzOlxuXHQgKiAgIDEuIHJlbmRlclxuXHQgKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcblx0ICogICAzLiBjaGVjayBmb3IgbmVzdGVkIHVwZGF0ZXNcblx0ICogICA0LiBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgKGFuZCBjYWxsIGBvblBvc3RDb21taXRgKVxuXHQgKlxuXHQgKiBOZXN0ZWQgdXBkYXRlcyBhcmUgaWRlbnRpZmllZCBpbiBzdGVwIDMgYWJvdmUsXG5cdCAqIGJ1dCBzdGVwIDQgc3RpbGwgYXBwbGllcyB0byB0aGUgd29yayB0aGF0IHdhcyBqdXN0IGNvbW1pdHRlZC5cblx0ICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuXHQgKiBvbmUgdHJhY2tzIHdoZXRoZXIgdGhlIHVwY29taW5nIHVwZGF0ZSBpcyBhIG5lc3RlZCB1cGRhdGUsXG5cdCAqIGFuZCB0aGUgb3RoZXIgdHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZCB1cGRhdGUuXG5cdCAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuXHQgKi9cblxuXHR2YXIgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gZmFsc2U7XG5cdHZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSB7XG5cdCAgcmV0dXJuIGN1cnJlbnRVcGRhdGVJc05lc3RlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKSB7XG5cdCAge1xuXHQgICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKSB7XG5cdCAge1xuXHQgICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gZmFsc2U7XG5cdCAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpIHtcblx0ICB7XG5cdCAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG5cdCAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuXHQgIHJldHVybiBjb21taXRUaW1lO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuXHQgIGNvbW1pdFRpbWUgPSBub3ckMSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cblx0ICBwcm9maWxlclN0YXJ0VGltZSA9IG5vdyQxKCk7XG5cblx0ICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuXHQgICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDEoKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG5cdCAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuXHQgIGlmIChwcm9maWxlclN0YXJ0VGltZSA+PSAwKSB7XG5cdCAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG5cdCAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuXHQgICAgaWYgKG92ZXJyaWRlQmFzZVRpbWUpIHtcblx0ICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuXHQgICAgfVxuXG5cdCAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cblx0ICBpZiAobGF5b3V0RWZmZWN0U3RhcnRUaW1lID49IDApIHtcblx0ICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBsYXlvdXRFZmZlY3RTdGFydFRpbWU7XG5cdCAgICBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuXHQgICAgLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcblxuXHQgICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG5cdCAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcblx0ICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcblx0ICAgICAgICBjYXNlIEhvc3RSb290OlxuXHQgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cdCAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXG5cdCAgICAgICAgY2FzZSBQcm9maWxlcjpcblx0ICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cdCAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmliZXIpIHtcblxuXHQgIGlmIChwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID49IDApIHtcblx0ICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuXHQgICAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IC0xOyAvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG5cdCAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG5cdCAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cblx0ICAgIHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuXHQgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuXHQgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybjtcblxuXHQgICAgICAgIGNhc2UgUHJvZmlsZXI6XG5cdCAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgICAgICBpZiAocGFyZW50U3RhdGVOb2RlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIC8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG5cdCAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHJldHVybiBwb2ludGVyIGlzIGFsc28gY2xlYXJlZCBvdXQsXG5cdCAgICAgICAgICAgIC8vIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gcmVwb3J0IHRoZSB0aW1lIHNwZW50IGluIHRoaXMgUHJvZmlsZXIncyBzdWJ0cmVlLlxuXHQgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzdGFydExheW91dEVmZmVjdFRpbWVyKCkge1xuXG5cdCAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gbm93JDEoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCkge1xuXG5cdCAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdyQxKCk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG5cdCAgLy8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuXHQgIC8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuXHQgIC8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG5cdCAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cblx0ICB3aGlsZSAoY2hpbGQpIHtcblx0ICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuXHQgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2UpIHtcblx0ICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cblx0ICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG5cdCAgcmV0dXJuIHtcblx0ICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpLFxuXHQgICAgZGlnZXN0OiBudWxsXG5cdCAgfTtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBkaWdlc3QsIHN0YWNrKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgIHNvdXJjZTogbnVsbCxcblx0ICAgIHN0YWNrOiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiBudWxsLFxuXHQgICAgZGlnZXN0OiBkaWdlc3QgIT0gbnVsbCA/IGRpZ2VzdCA6IG51bGxcblx0ICB9O1xuXHR9XG5cblx0Ly8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG5cdC8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cblx0Ly8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuXHRmdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbykge1xuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKTsgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cblx0ICAgIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cblxuXHQgICAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuXHQgICAgaWYgKHRydWUpIHtcblx0ICAgICAgdmFyIHNvdXJjZSA9IGVycm9ySW5mby5zb3VyY2U7XG5cdCAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcblx0ICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnOyAvLyBCcm93c2VycyBzdXBwb3J0IHNpbGVuY2luZyB1bmNhdWdodCBlcnJvcnMgYnkgY2FsbGluZ1xuXHQgICAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaW4gd2luZG93IGBlcnJvcmAgaGFuZGxlci5cblx0ICAgICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cblx0ICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuXHQgICAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG5cdCAgICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cblx0ICAgICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuXHQgICAgICAgICAgLy8gVGhpcyBpcyBoYW5keSBmb3IgdGVzdGluZyBlcnJvciBib3VuZGFyaWVzIHdpdGhvdXQgbm9pc2UuXG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfSAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuXHQgICAgICAgIC8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG5cdCAgICAgICAgLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3Jcblx0ICAgICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuXG5cblx0ICAgICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG5cdCAgICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG5cdCAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBjb21wb25lbnROYW1lID0gc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihzb3VyY2UpIDogbnVsbDtcblx0ICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXHQgICAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG5cblx0ICAgICAgaWYgKGJvdW5kYXJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcblx0ICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoYm91bmRhcnkpIHx8ICdBbm9ueW1vdXMnO1xuXHQgICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBcIlxcblwiICsgY29tcG9uZW50U3RhY2sgKyBcIlxcblxcblwiICsgKFwiXCIgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cblx0ICAgICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuXHQgICAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG5cdCAgICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuXG5cdCAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oY29tYmluZWRNZXNzYWdlKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG5cdCAgICB9XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cblx0ICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuXHQgICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aHJvdyBlO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cblx0dmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG5cdCAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cblx0ICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuXHQgIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuXHQgIHVwZGF0ZS5wYXlsb2FkID0ge1xuXHQgICAgZWxlbWVudDogbnVsbFxuXHQgIH07XG5cdCAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG5cdCAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgb25VbmNhdWdodEVycm9yKGVycm9yKTtcblx0ICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiB1cGRhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcblx0ICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcblx0ICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcblx0ICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG5cblx0ICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cblx0ICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuXHQgICAgfTtcblxuXHQgICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB7XG5cdCAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cblx0ICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG5cdCAgICAgIHtcblx0ICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG5cdCAgICAgIH1cblxuXHQgICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG5cdCAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuXHQgICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cblx0ICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuXHQgICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuXHQgICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcblx0ICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuXHQgICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yJDEsIHtcblx0ICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgLy8gSWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWQsXG5cdCAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cblx0ICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cblx0ICAgICAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShmaWJlci5sYW5lcywgU3luY0xhbmUpKSB7XG5cdCAgICAgICAgICAgIGVycm9yKCclczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiAnICsgJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIHJldHVybiB1cGRhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG5cdCAgLy8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuXHQgIC8vXG5cdCAgLy8gVGhlIGRhdGEgbWlnaHQgcmVzb2x2ZSBiZWZvcmUgd2UgaGF2ZSBhIGNoYW5jZSB0byBjb21taXQgdGhlIGZhbGxiYWNrLiBPcixcblx0ICAvLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG5cdCAgLy8gYXR0YWNoIGEgbGlzdGVuZXIgbm93LiBXaGVuIGl0IHJlc29sdmVzIChcInBpbmdzXCIpLCB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cblx0ICAvLyB0cnkgcmVuZGVyaW5nIHRoZSB0cmVlIGFnYWluLlxuXHQgIC8vXG5cdCAgLy8gT25seSBhdHRhY2ggYSBsaXN0ZW5lciBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzXG5cdCAgLy8gd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyAod2hpY2ggYWN0cyBsaWtlIGEgXCJ0aHJlYWQgSURcIiBoZXJlKS5cblx0ICAvL1xuXHQgIC8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuXHQgIC8vIGNvbW1pdHMgZmFsbGJhY2tzIHN5bmNocm9ub3VzbHksIHNvIHRoZXJlIGFyZSBubyBwaW5ncy5cblx0ICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cdCAgdmFyIHRocmVhZElEcztcblxuXHQgIGlmIChwaW5nQ2FjaGUgPT09IG51bGwpIHtcblx0ICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG5cdCAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG5cdCAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuXHQgICAgaWYgKHRocmVhZElEcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcblx0ICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG5cdCAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuXHQgICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG5cdCAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcblxuXHQgICAge1xuXHQgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcblx0ICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB3YWtlYWJsZS50aGVuKHBpbmcsIHBpbmcpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGF0dGFjaFJldHJ5TGlzdGVuZXIoc3VzcGVuc2VCb3VuZGFyeSwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG5cdCAgLy8gUmV0cnkgbGlzdGVuZXJcblx0ICAvL1xuXHQgIC8vIElmIHRoZSBmYWxsYmFjayBkb2VzIGNvbW1pdCwgd2UgbmVlZCB0byBhdHRhY2ggYSBkaWZmZXJlbnQgdHlwZSBvZlxuXHQgIC8vIGxpc3RlbmVyLiBUaGlzIG9uZSBzY2hlZHVsZXMgYW4gdXBkYXRlIG9uIHRoZSBTdXNwZW5zZSBib3VuZGFyeSB0byB0dXJuXG5cdCAgLy8gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cblx0ICAvL1xuXHQgIC8vIFN0YXNoIHRoZSB3YWtlYWJsZSBvbiB0aGUgYm91bmRhcnkgZmliZXIgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGVcblx0ICAvLyBjb21taXQgcGhhc2UuXG5cdCAgLy9cblx0ICAvLyBXaGVuIHRoZSB3YWtlYWJsZSByZXNvbHZlcywgd2UnbGwgYXR0ZW1wdCB0byByZW5kZXIgdGhlIGJvdW5kYXJ5XG5cdCAgLy8gYWdhaW4gKFwicmV0cnlcIikuXG5cdCAgdmFyIHdha2VhYmxlcyA9IHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU7XG5cblx0ICBpZiAod2FrZWFibGVzID09PSBudWxsKSB7XG5cdCAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG5cdCAgICB1cGRhdGVRdWV1ZS5hZGQod2FrZWFibGUpO1xuXHQgICAgc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB3YWtlYWJsZXMuYWRkKHdha2VhYmxlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNldFN1c3BlbmRlZENvbXBvbmVudChzb3VyY2VGaWJlciwgcm9vdFJlbmRlckxhbmVzKSB7XG5cdCAgLy8gQSBsZWdhY3kgbW9kZSBTdXNwZW5zZSBxdWlyaywgb25seSByZWxldmFudCB0byBob29rIGNvbXBvbmVudHMuXG5cblxuXHQgIHZhciB0YWcgPSBzb3VyY2VGaWJlci50YWc7XG5cblx0ICBpZiAoKHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiAodGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCB8fCB0YWcgPT09IEZvcndhcmRSZWYgfHwgdGFnID09PSBTaW1wbGVNZW1vQ29tcG9uZW50KSkge1xuXHQgICAgdmFyIGN1cnJlbnRTb3VyY2UgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cblx0ICAgIGlmIChjdXJyZW50U291cmNlKSB7XG5cdCAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3VycmVudFNvdXJjZS51cGRhdGVRdWV1ZTtcblx0ICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtcblx0ICAgICAgc291cmNlRmliZXIubGFuZXMgPSBjdXJyZW50U291cmNlLmxhbmVzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuXHQgICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcikge1xuXHQgIHZhciBub2RlID0gcmV0dXJuRmliZXI7XG5cblx0ICBkbyB7XG5cdCAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIHNob3VsZENhcHR1cmVTdXNwZW5zZShub2RlKSkge1xuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH0gLy8gVGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGR1cmluZyB0aGlzIHJlbmRlci4gQ29udGludWUgdG8gdGhlIG5leHRcblx0ICAgIC8vIGJvdW5kYXJ5LlxuXG5cblx0ICAgIG5vZGUgPSBub2RlLnJldHVybjtcblx0ICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKSB7XG5cdCAgLy8gVGhpcyBtYXJrcyBhIFN1c3BlbnNlIGJvdW5kYXJ5IHNvIHRoYXQgd2hlbiB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLFxuXHQgIC8vIGl0IGNhcHR1cmVzIHRoZSBzdXNwZW5kZWQgXCJleGNlcHRpb25cIiBhbmQgZG9lcyBhIHNlY29uZCAoZmFsbGJhY2spIHBhc3MuXG5cdCAgaWYgKChzdXNwZW5zZUJvdW5kYXJ5Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuXHQgICAgLy8gTGVnYWN5IE1vZGUgU3VzcGVuc2Vcblx0ICAgIC8vXG5cdCAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgaW4gbGVnYWN5IG1vZGUsIHdlIHNob3VsZCAqbm90KlxuXHQgICAgLy8gc3VzcGVuZCB0aGUgY29tbWl0LiBQcmV0ZW5kIGFzIGlmIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHJlbmRlcmVkXG5cdCAgICAvLyBudWxsIGFuZCBrZWVwIHJlbmRlcmluZy4gV2hlbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgY29tcGxldGVzLFxuXHQgICAgLy8gd2UnbGwgZG8gYSBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxuXHQgICAgaWYgKHN1c3BlbnNlQm91bmRhcnkgPT09IHJldHVybkZpYmVyKSB7XG5cdCAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBzdXNwZW5kZWQgd2hpbGUgcmVjb25jaWxpbmcgdGhlIGNoaWxkcmVuIG9mXG5cdCAgICAgIC8vIGEgU3VzcGVuc2UgYm91bmRhcnkncyBpbm5lciBPZmZzY3JlZW4gd3JhcHBlciBmaWJlci4gVGhpcyBoYXBwZW5zXG5cdCAgICAgIC8vIHdoZW4gYSBSZWFjdC5sYXp5IGNvbXBvbmVudCBpcyBhIGRpcmVjdCBjaGlsZCBvZiBhXG5cdCAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBTdXNwZW5zZSBib3VuZGFyaWVzIGFyZSBpbXBsZW1lbnRlZCBhcyBtdWx0aXBsZSBmaWJlcnMsIGJ1dCB0aGV5XG5cdCAgICAgIC8vIGFyZSBhIHNpbmdsZSBjb25jZXB0dWFsIHVuaXQuIFRoZSBsZWdhY3kgbW9kZSBiZWhhdmlvciB3aGVyZSB3ZVxuXHQgICAgICAvLyBwcmV0ZW5kIHRoZSBzdXNwZW5kZWQgZmliZXIgY29tbWl0dGVkIGFzIGBudWxsYCB3b24ndCB3b3JrLFxuXHQgICAgICAvLyBiZWNhdXNlIGluIHRoaXMgY2FzZSB0aGUgXCJzdXNwZW5kZWRcIiBmaWJlciBpcyB0aGUgaW5uZXJcblx0ICAgICAgLy8gT2Zmc2NyZWVuIHdyYXBwZXIuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIEJlY2F1c2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBib3VuZGFyeSBoYXZlbid0IHN0YXJ0ZWQgcmVuZGVyaW5nXG5cdCAgICAgIC8vIHlldCAoaS5lLiBub3RoaW5nIGluIHRoZSB0cmVlIGhhcyBwYXJ0aWFsbHkgcmVuZGVyZWQpIHdlIGNhblxuXHQgICAgICAvLyBzd2l0Y2ggdG8gdGhlIHJlZ3VsYXIsIGNvbmN1cnJlbnQgbW9kZSBiZWhhdmlvcjogbWFyayB0aGVcblx0ICAgICAgLy8gYm91bmRhcnkgd2l0aCBTaG91bGRDYXB0dXJlIGFuZCBlbnRlciB0aGUgdW53aW5kIHBoYXNlLlxuXHQgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IERpZENhcHR1cmU7XG5cdCAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2U7IC8vIFdlJ3JlIGdvaW5nIHRvIGNvbW1pdCB0aGlzIGZpYmVyIGV2ZW4gdGhvdWdoIGl0IGRpZG4ndCBjb21wbGV0ZS5cblx0ICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuXHQgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGVmZmVjdCB0YWdzLlxuXG5cdCAgICAgIHNvdXJjZUZpYmVyLmZsYWdzICY9IH4oTGlmZWN5Y2xlRWZmZWN0TWFzayB8IEluY29tcGxldGUpO1xuXG5cdCAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRTb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuXHQgICAgICAgIGlmIChjdXJyZW50U291cmNlRmliZXIgPT09IG51bGwpIHtcblx0ICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgbW91bnQuIENoYW5nZSB0aGUgdGFnIHNvIGl0J3Mgbm90IG1pc3Rha2VuIGZvciBhXG5cdCAgICAgICAgICAvLyBjb21wbGV0ZWQgY2xhc3MgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgd2Ugc2hvdWxkIG5vdCBjYWxsXG5cdCAgICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuXHQgICAgICAgICAgc291cmNlRmliZXIudGFnID0gSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG5cdCAgICAgICAgICAvLyBzaW5jZSBpdCdzIGtub3duIHRvIGJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVXNlIGEgZm9yY2UgdXBkYXRlIHRvXG5cdCAgICAgICAgICAvLyBwcmV2ZW50IGEgYmFpbCBvdXQuXG5cdCAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBTeW5jTGFuZSk7XG5cdCAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cdCAgICAgICAgICBlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLCB1cGRhdGUsIFN5bmNMYW5lKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLiBNYXJrIGl0IHdpdGggU3luYyBwcmlvcml0eSB0b1xuXHQgICAgICAvLyBpbmRpY2F0ZSB0aGF0IGl0IHN0aWxsIGhhcyBwZW5kaW5nIHdvcmsuXG5cblxuXHQgICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN1c3BlbnNlQm91bmRhcnk7XG5cdCAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcblx0ICAvLyB3aXRoIHRoZSBub3JtYWwgc3VzcGVuZCBwYXRoLlxuXHQgIC8vXG5cdCAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG5cdCAgLy8gcmVuZGVyIHBhc3Mgd2lsbCBydW4gdG8gY29tcGxldGlvbiBvciByZXN0YXJ0IG9yIFwic3VzcGVuZFwiIHRoZSBjb21taXQuXG5cdCAgLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG5cdCAgLy9cblx0ICAvLyBUaGlzIGZpcnN0IHByaW5jaXBsZSBpcyB0aGF0IGlmIHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2hlbiB3ZSBjb21wbGV0ZVxuXHQgIC8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG5cdCAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcblx0ICAvLyBiZWNhdXNlIHlvdSB0aGluayB5b3UgbWlnaHQgd2FudCB0byByZXN0YXJ0IGJlZm9yZSBjb21taXR0aW5nLiBIb3dldmVyLFxuXHQgIC8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG5cdCAgLy9cblx0ICAvLyBSZXN0YXJ0aW5nIHRvbyBhZ2dyZXNzaXZlbHkgaXMgYWxzbyBub3QgZ29vZCBiZWNhdXNlIGl0IHN0YXJ2ZXMgb3V0IGFueVxuXHQgIC8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cblx0ICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG5cdCAgLy9cblx0ICAvLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG5cdCAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG5cdCAgLy9cblx0ICAvLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcblx0ICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuXHQgIC8vIHRoYXQgd2UgY2FuIHNob3cgdGhlIGluaXRpYWwgbG9hZGluZyBzdGF0ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuXHQgIC8vXG5cdCAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cblx0ICAvLyBhIGZhbGxiYWNrLCB0aGVuIHdlIHNob3VsZCBhbHdheXMgc3VzcGVuZC9yZXN0YXJ0LiBUcmFuc2l0aW9ucyBhcHBseVxuXHQgIC8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuXHQgIC8vXG5cdCAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgYW5kIGl0IGdldHMgXCJyZXRyaWVkXCIsIGFsbG93aW5nIHVzIHRvIHNob3dcblx0ICAvLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcblx0ICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuXHQgIC8vIGFueXdoZXJlIGluIHRoZSB0cmVlLiBUaGlzIGVmZmVjdGl2ZWx5IHRocm90dGxlcyBwcm9ncmVzc2l2ZSBsb2FkaW5nIGludG8gYVxuXHQgIC8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cblx0ICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuXHQgIC8vXG5cdCAgLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcblx0ICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG5cdCAgLy9cblx0ICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG5cdCAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cblx0ICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7IC8vIFRPRE86IEkgdGhpbmsgd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSBub3cgdXNlIGBEaWRDYXB0dXJlYCBpblxuXHQgIC8vIHRoZSBiZWdpbiBwaGFzZSB0byBwcmV2ZW50IGFuIGVhcmx5IGJhaWxvdXQuXG5cblx0ICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuXHQgIHJldHVybiBzdXNwZW5zZUJvdW5kYXJ5O1xuXHR9XG5cblx0ZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG5cdCAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuXHQgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG5cblx0ICB7XG5cdCAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcblx0ICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG5cdCAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgLy8gVGhpcyBpcyBhIHdha2VhYmxlLiBUaGUgY29tcG9uZW50IHN1c3BlbmRlZC5cblx0ICAgIHZhciB3YWtlYWJsZSA9IHZhbHVlO1xuXHQgICAgcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO1xuXG5cdCAgICB7XG5cdCAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuXHQgICAgICAgIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXG5cdCAgICB2YXIgc3VzcGVuc2VCb3VuZGFyeSA9IGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTtcblxuXHQgICAgaWYgKHN1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcblx0ICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmPSB+Rm9yY2VDbGllbnRSZW5kZXI7XG5cdCAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuXHQgICAgICAvLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG5cblx0ICAgICAgaWYgKHN1c3BlbnNlQm91bmRhcnkubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG5cdCAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgYXR0YWNoUmV0cnlMaXN0ZW5lcihzdXNwZW5zZUJvdW5kYXJ5LCByb290LCB3YWtlYWJsZSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gVW5sZXNzIHRoaXMgaXMgYSBzeW5jIHVwZGF0ZSwgdGhpcyBpcyBPSy5cblx0ICAgICAgLy8gV2UgY2FuIHN1c3BlbmQgYW5kIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cdCAgICAgIGlmICghaW5jbHVkZXNTeW5jTGFuZShyb290UmVuZGVyTGFuZXMpKSB7XG5cdCAgICAgICAgLy8gVGhpcyBpcyBub3QgYSBzeW5jIHVwZGF0ZS4gU3VzcGVuZC4gU2luY2Ugd2UncmUgbm90IGFjdGl2YXRpbmcgYVxuXHQgICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGlzIHdpbGwgdW53aW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IHdpdGhvdXRcblx0ICAgICAgICAvLyBwZXJmb3JtaW5nIGEgc2Vjb25kIHBhc3MgdG8gcmVuZGVyIGEgZmFsbGJhY2suIChUaGlzIGlzIGFyZ3VhYmx5IGhvd1xuXHQgICAgICAgIC8vIHJlZnJlc2ggdHJhbnNpdGlvbnMgc2hvdWxkIHdvcmssIHRvbywgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIGNvbW1pdFxuXHQgICAgICAgIC8vIHRoZSBmYWxsYmFja3MgYW55d2F5Lilcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vIFRoaXMgY2FzZSBhbHNvIGFwcGxpZXMgdG8gaW5pdGlhbCBoeWRyYXRpb24uXG5cdCAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuXHQgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH0gLy8gVGhpcyBpcyBhIHN5bmMvZGlzY3JldGUgdXBkYXRlLiBXZSB0cmVhdCB0aGlzIGNhc2UgbGlrZSBhbiBlcnJvclxuXHQgICAgICAvLyBiZWNhdXNlIGRpc2NyZXRlIHJlbmRlcnMgYXJlIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBjb21wbGV0ZSB0cmVlXG5cdCAgICAgIC8vIHN5bmNocm9ub3VzbHkgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3kgd2l0aCBleHRlcm5hbCBzdGF0ZS5cblxuXG5cdCAgICAgIHZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3IgPSBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzICcgKyAnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyAnICsgJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJyArICd3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTsgLy8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuXHQgICAgICAvLyBUaGUgZXJyb3Igd2lsbCBiZSBjYXVnaHQgYnkgdGhlIG5lYXJlc3Qgc3VzcGVuc2UgYm91bmRhcnkuXG5cblx0ICAgICAgdmFsdWUgPSB1bmNhdWdodFN1c3BlbnNlRXJyb3I7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFRoaXMgaXMgYSByZWd1bGFyIGVycm9yLCBub3QgYSBTdXNwZW5zZSB3YWtlYWJsZS5cblx0ICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuXHQgICAgICBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO1xuXG5cdCAgICAgIHZhciBfc3VzcGVuc2VCb3VuZGFyeSA9IGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTsgLy8gSWYgdGhlIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIGh5ZHJhdGlvbiwgd2UgbWF5IGJlIGFibGUgdG8gcmVjb3ZlciBieVxuXHQgICAgICAvLyBkaXNjYXJkaW5nIHRoZSBkZWh5ZHJhdGVkIGNvbnRlbnQgYW5kIHN3aXRjaGluZyB0byBhIGNsaWVudCByZW5kZXIuXG5cdCAgICAgIC8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuXHQgICAgICAvLyBhbmQgcmVuZGVyIGl0IGFnYWluIHdpdGhvdXQgaHlkcmF0aW9uLlxuXG5cblx0ICAgICAgaWYgKF9zdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKChfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmIFNob3VsZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG5cdCAgICAgICAgICAvLyBTZXQgYSBmbGFnIHRvIGluZGljYXRlIHRoYXQgd2Ugc2hvdWxkIHRyeSByZW5kZXJpbmcgdGhlIG5vcm1hbFxuXHQgICAgICAgICAgLy8gY2hpbGRyZW4gYWdhaW4sIG5vdCB0aGUgZmFsbGJhY2suXG5cdCAgICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoX3N1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKTsgLy8gRXZlbiB0aG91Z2ggdGhlIHVzZXIgbWF5IG5vdCBiZSBhZmZlY3RlZCBieSB0aGlzIGVycm9yLCB3ZSBzaG91bGRcblx0ICAgICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG5cdCAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG5cdCAgcmVuZGVyRGlkRXJyb3IodmFsdWUpOyAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG5cdCAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG5cdCAgLy8gYXMgYW4gZXJyb3IuXG5cblx0ICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuXHQgIGRvIHtcblx0ICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG5cdCAgICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFyIF9lcnJvckluZm8gPSB2YWx1ZTtcblx0ICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cdCAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuXHQgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgbGFuZSk7XG5cdCAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSk7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcblx0ICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG5cdCAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXHQgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuXHQgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKSB7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG5cdCAgICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cblx0ICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCBfbGFuZSk7XG5cblx0ICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXHQgIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCkge1xuXHQgIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0gLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IHN1c3BlbmRzLiBJdCByZXR1cm5zIHRoZVxuXHR9XG5cblx0dmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblx0dmFyIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblx0dmFyIGRpZFdhcm5BYm91dEJhZENsYXNzO1xuXHR2YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcblx0dmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudDtcblx0dmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQ7XG5cdHZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG5cdHZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzO1xuXHR2YXIgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXI7XG5cdHZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxuXHR7XG5cdCAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcblx0ICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG5cdCAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG5cdCAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuXHQgIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuXHQgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcblx0ICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciA9IHt9O1xuXHQgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG5cdH1cblxuXHRmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuXHQgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2Vcblx0ICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuXHQgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG5cdCAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuXHQgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2Vcblx0ICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cdCAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuXHQgICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuXHQgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuXHQgIC8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG5cdCAgLy8gd2FudCB0byByZWNvbmNpbGUgd2l0aG91dCBtYXRjaGluZyBhZ2FpbnN0IHRoZSBleGlzdGluZyBzZXQuIFRoaXMgaGFzIHRoZVxuXHQgIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuXHQgIC8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG5cdCAgLy9cblx0ICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuXHQgIC8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcblx0ICAvLyBwYXNzaW5nIG51bGwuXG5cdCAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2Vcblx0ICAvLyBwYXNzIG51bGwgaW4gcGxhY2Ugb2Ygd2hlcmUgd2UgdXN1YWxseSBwYXNzIHRoZSBjdXJyZW50IGNoaWxkIHNldC4gVGhpcyBoYXNcblx0ICAvLyB0aGUgZWZmZWN0IG9mIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpclxuXHQgIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cblx0ICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuXHQgIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG5cdCAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBzdXNwZW5kcy5cblx0ICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG5cdCAge1xuXHQgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG5cdCAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG5cdCAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cblx0ICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuXHQgICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcblx0ICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuXHQgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG5cdCAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjsgLy8gVGhlIHJlc3QgaXMgYSBmb3JrIG9mIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50XG5cblx0ICB2YXIgbmV4dENoaWxkcmVuO1xuXHQgIHZhciBoYXNJZDtcblx0ICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG5cdCAge1xuXHQgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuXHQgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG5cdCAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcblx0ICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuXHQgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuXHQgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuXHQgICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cdCAgfVxuXG5cdCAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcblx0ICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblx0ICB9XG5cblx0ICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuXHQgICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuXHQgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cdCAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuXHQgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuXG5cdCAgICBpZiAoaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSAmJiBDb21wb25lbnQuY29tcGFyZSA9PT0gbnVsbCAmJiAvLyBTaW1wbGVNZW1vQ29tcG9uZW50IGNvZGVwYXRoIGRvZXNuJ3QgcmVzb2x2ZSBvdXRlciBwcm9wcyBlaXRoZXIuXG5cdCAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cblx0ICAgICAge1xuXHQgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcblx0ICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcblx0ICAgICAgLy8gYW5kIHdpdGggb25seSB0aGUgZGVmYXVsdCBzaGFsbG93IGNvbXBhcmlzb24sIHdlIHVwZ3JhZGUgaXRcblx0ICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cblx0ICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU2ltcGxlTWVtb0NvbXBvbmVudDtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVkVHlwZTtcblxuXHQgICAgICB7XG5cdCAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgfVxuXG5cdCAgICB7XG5cdCAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG5cdCAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuXHQgICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG5cdCAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cblx0ICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuXHQgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgY2hpbGQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoQ29tcG9uZW50LnR5cGUsIG51bGwsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLm1vZGUsIHJlbmRlckxhbmVzKTtcblx0ICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcblx0ICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcblx0ICAgIHJldHVybiBjaGlsZDtcblx0ICB9XG5cblx0ICB7XG5cdCAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcblx0ICAgIHZhciBfaW5uZXJQcm9wVHlwZXMgPSBfdHlwZS5wcm9wVHlwZXM7XG5cblx0ICAgIGlmIChfaW5uZXJQcm9wVHlwZXMpIHtcblx0ICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cblx0ICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cblx0ICAgICAgY2hlY2tQcm9wVHlwZXMoX2lubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG5cdCAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlKSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cblx0ICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG5cdCAgaWYgKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQpIHtcblx0ICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG5cdCAgICAvLyB1bmxpa2UgY3VycmVudC5tZW1vaXplZFByb3BzIHdoaWNoIHdpbGwgYmUgdGhlIHVucmVzb2x2ZWQgb25lcy5cblx0ICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wczsgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cblxuXHQgICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcblx0ICAgIGNvbXBhcmUgPSBjb21wYXJlICE9PSBudWxsID8gY29tcGFyZSA6IHNoYWxsb3dFcXVhbDtcblxuXHQgICAgaWYgKGNvbXBhcmUocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcblx0ICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblx0ICAgIH1cblx0ICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG5cdCAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblx0ICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIG5leHRQcm9wcyk7XG5cdCAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuXHQgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXHQgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cdCAgcmV0dXJuIG5ld0NoaWxkO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG5cdCAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcblx0ICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG5cdCAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuXHQgIHtcblx0ICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuXHQgICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuXHQgICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG5cdCAgICAgIHZhciBvdXRlck1lbW9UeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cblx0ICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuXHQgICAgICAgIC8vIFdlIHdhcm4gd2hlbiB5b3UgZGVmaW5lIHByb3BUeXBlcyBvbiBsYXp5KClcblx0ICAgICAgICAvLyBzbyBsZXQncyBqdXN0IHNraXAgb3ZlciBpdCB0byBmaW5kIG1lbW8oKSBvdXRlciB3cmFwcGVyLlxuXHQgICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG5cdCAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSBvdXRlck1lbW9UeXBlO1xuXHQgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcblx0ICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IGluaXQocGF5bG9hZCk7XG5cdCAgICAgICAgfSBjYXRjaCAoeCkge1xuXHQgICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IG51bGw7XG5cdCAgICAgICAgfSAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuXG5cblx0ICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBvdXRlck1lbW9UeXBlICYmIG91dGVyTWVtb1R5cGUucHJvcFR5cGVzO1xuXG5cdCAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG5cdCAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuXHQgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3V0ZXJNZW1vVHlwZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG5cdCAgICBpZiAoc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJiBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmICYmICggLy8gUHJldmVudCBiYWlsb3V0IGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkLlxuXHQgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG5cdCAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTsgLy8gVGhlIHByb3BzIGFyZSBzaGFsbG93bHkgZXF1YWwuIFJldXNlIHRoZSBwcmV2aW91cyBwcm9wcyBvYmplY3QsIGxpa2Ugd2Vcblx0ICAgICAgLy8gd291bGQgZHVyaW5nIGEgbm9ybWFsIGZpYmVyIGJhaWxvdXQuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIFdlIGRvbid0IGhhdmUgc3Ryb25nIGd1YXJhbnRlZXMgdGhhdCB0aGUgcHJvcHMgb2JqZWN0IGlzIHJlZmVyZW50aWFsbHlcblx0ICAgICAgLy8gZXF1YWwgZHVyaW5nIHVwZGF0ZXMgd2hlcmUgd2UgY2FuJ3QgYmFpbCBvdXQgYW55d2F5IOKAlCBsaWtlIGlmIHRoZSBwcm9wc1xuXHQgICAgICAvLyBhcmUgc2hhbGxvd2x5IGVxdWFsLCBidXQgdGhlcmUncyBhIGxvY2FsIHN0YXRlIG9yIGNvbnRleHQgdXBkYXRlIGluIHRoZVxuXHQgICAgICAvLyBzYW1lIGJhdGNoLlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBIb3dldmVyLCBhcyBhIHByaW5jaXBsZSwgd2Ugc2hvdWxkIGFpbSB0byBtYWtlIHRoZSBiZWhhdmlvciBjb25zaXN0ZW50XG5cdCAgICAgIC8vIGFjcm9zcyBkaWZmZXJlbnQgd2F5cyBvZiBtZW1vaXppbmcgYSBjb21wb25lbnQuIEZvciBleGFtcGxlLCBSZWFjdC5tZW1vXG5cdCAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBpbnRlcm5hbCBGaWJlciBsYXlvdXQgaWYgeW91IHBhc3MgYSBub3JtYWwgZnVuY3Rpb25cblx0ICAgICAgLy8gY29tcG9uZW50IChTaW1wbGVNZW1vQ29tcG9uZW50KSB2ZXJzdXMgaWYgeW91IHBhc3MgYSBkaWZmZXJlbnQgdHlwZVxuXHQgICAgICAvLyBsaWtlIGZvcndhcmRSZWYgKE1lbW9Db21wb25lbnQpLiBCdXQgdGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG5cdCAgICAgIC8vIFdyYXBwaW5nIGEgY29tcG9uZW50IGluIGZvcndhcmRSZWYgKG9yIFJlYWN0LmxhenksIGV0Yykgc2hvdWxkbid0XG5cdCAgICAgIC8vIGFmZmVjdCB3aGV0aGVyIHRoZSBwcm9wcyBvYmplY3QgaXMgcmV1c2VkIGR1cmluZyBhIGJhaWxvdXQuXG5cblx0ICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzO1xuXG5cdCAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG5cdCAgICAgICAgLy8gVGhlIHBlbmRpbmcgbGFuZXMgd2VyZSBjbGVhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYmVnaW5Xb3JrLiBXZSdyZVxuXHQgICAgICAgIC8vIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbGFuZXMgdGhhdCB3ZXJlbid0XG5cdCAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG5cdCAgICAgICAgLy8gcmVtYWluaW5nIHVwZGF0ZXMgaXMgYWNjdW11bGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuXHQgICAgICAgIC8vIGNvbXBvbmVudCAoaS5lLiB3aGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZSkuIEJ1dCBzaW5jZSBzaW5jZVxuXHQgICAgICAgIC8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcblx0ICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cblx0ICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgYXBwbGllcyB0byBTaW1wbGVNZW1vQ29tcG9uZW50LCBub3QgTWVtb0NvbXBvbmVudCxcblx0ICAgICAgICAvLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcblx0ICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG5cdCAgICAgICAgLy8gY29udGFpbnMgaG9va3MuXG5cdCAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuXHQgICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG5cdCAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cblx0ICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG5cdCAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblx0ICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXHQgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuXHQgIGlmIChuZXh0UHJvcHMubW9kZSA9PT0gJ2hpZGRlbicgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICkge1xuXHQgICAgLy8gUmVuZGVyaW5nIGEgaGlkZGVuIHRyZWUuXG5cdCAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuXHQgICAgICAvLyBJbiBsZWdhY3kgc3luYyBtb2RlLCBkb24ndCBkZWZlciB0aGUgc3VidHJlZS4gUmVuZGVyIGl0IG5vdy5cblx0ICAgICAgLy8gVE9ETzogQ29uc2lkZXIgaG93IE9mZnNjcmVlbiBzaG91bGQgd29yayB3aXRoIHRyYW5zaXRpb25zIGluIHRoZSBmdXR1cmVcblx0ICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcblx0ICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXMsXG5cdCAgICAgICAgY2FjaGVQb29sOiBudWxsLFxuXHQgICAgICAgIHRyYW5zaXRpb25zOiBudWxsXG5cdCAgICAgIH07XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG5cblx0ICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cdCAgICB9IGVsc2UgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuXHQgICAgICB2YXIgc3Bhd25lZENhY2hlUG9vbCA9IG51bGw7IC8vIFdlJ3JlIGhpZGRlbiwgYW5kIHdlJ3JlIG5vdCByZW5kZXJpbmcgYXQgT2Zmc2NyZWVuLiBXZSB3aWxsIGJhaWwgb3V0XG5cdCAgICAgIC8vIGFuZCByZXN1bWUgdGhpcyB0cmVlIGxhdGVyLlxuXG5cdCAgICAgIHZhciBuZXh0QmFzZUxhbmVzO1xuXG5cdCAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblx0ICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG5cdCAgICAgICAgbmV4dEJhc2VMYW5lcyA9IG1lcmdlTGFuZXMocHJldkJhc2VMYW5lcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcblx0ICAgICAgfSAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cblxuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuXHQgICAgICB2YXIgX25leHRTdGF0ZSA9IHtcblx0ICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG5cdCAgICAgICAgY2FjaGVQb29sOiBzcGF3bmVkQ2FjaGVQb29sLFxuXHQgICAgICAgIHRyYW5zaXRpb25zOiBudWxsXG5cdCAgICAgIH07XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlO1xuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cdCAgICAgIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG5cblx0ICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzKTtcblxuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcblx0ICAgICAgLy8gY29tbWl0dGVkLiBOb3cgd2UgcmVzdW1lIHJlbmRlcmluZyB0aGUgaGlkZGVuIHRyZWUuXG5cdCAgICAgIC8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cblx0ICAgICAgdmFyIF9uZXh0U3RhdGUyID0ge1xuXHQgICAgICAgIGJhc2VMYW5lczogTm9MYW5lcyxcblx0ICAgICAgICBjYWNoZVBvb2w6IG51bGwsXG5cdCAgICAgICAgdHJhbnNpdGlvbnM6IG51bGxcblx0ICAgICAgfTtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGUyOyAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cblx0ICAgICAgdmFyIHN1YnRyZWVSZW5kZXJMYW5lcyA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgOiByZW5kZXJMYW5lcztcblxuXHQgICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cblx0ICAgIHZhciBfc3VidHJlZVJlbmRlckxhbmVzO1xuXG5cdCAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG5cdCAgICAgIF9zdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZTdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcblxuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFdlIHdlcmVuJ3QgcHJldmlvdXNseSBoaWRkZW4sIGFuZCB3ZSBzdGlsbCBhcmVuJ3QsIHNvIHRoZXJlJ3Mgbm90aGluZ1xuXHQgICAgICAvLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcblx0ICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cdCAgICAgIF9zdWJ0cmVlUmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcztcblx0ICAgIH1cblxuXHQgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBfc3VidHJlZVJlbmRlckxhbmVzKTtcblx0ICB9XG5cblx0ICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHR9IC8vIE5vdGU6IFRoZXNlIGhhcHBlbiB0byBoYXZlIGlkZW50aWNhbCBiZWdpbiBwaGFzZXMsIGZvciBub3cuIFdlIHNob3VsZG4ndCBob2xkXG5cblx0ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblx0ICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuXHQgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICB7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG5cblx0ICAgIHtcblx0ICAgICAgLy8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuXHQgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXHQgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXHQgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuXHQgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXHQgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cdCAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcblx0ICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuXG5cdCAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuXHQgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG5cblx0ICAgIHtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmU3RhdGljO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcblx0ICB7XG5cdCAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcblx0ICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcblx0ICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuXHQgICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG5cdCAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuXHQgICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG5cdCAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgY29udGV4dDtcblxuXHQgIHtcblx0ICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG5cdCAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblx0ICB9XG5cblx0ICB2YXIgbmV4dENoaWxkcmVuO1xuXHQgIHZhciBoYXNJZDtcblx0ICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG5cdCAge1xuXHQgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuXHQgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG5cdCAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cdCAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG5cblx0ICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcblx0ICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcblx0ICB9XG5cblx0ICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuXHQgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cdCAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgIH1cblxuXHQgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG5cdCAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcblx0ICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG5cdCAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblx0ICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuXHQgIHtcblx0ICAgIC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuXHQgICAgc3dpdGNoIChzaG91bGRFcnJvcih3b3JrSW5Qcm9ncmVzcykpIHtcblx0ICAgICAgY2FzZSBmYWxzZTpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXHQgICAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUT0RPIFRoaXMgd2F5IG9mIHJlc2V0dGluZyB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUgaXMgYSBoYWNrLlxuXHQgICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG5cblx0ICAgICAgICAgIHZhciB0ZW1wSW5zdGFuY2UgPSBuZXcgY3Rvcih3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLCBfaW5zdGFuY2UuY29udGV4dCk7XG5cdCAgICAgICAgICB2YXIgc3RhdGUgPSB0ZW1wSW5zdGFuY2Uuc3RhdGU7XG5cblx0ICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgdHJ1ZTpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuXHQgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuXHQgICAgICAgICAgdmFyIGVycm9yJDEgPSBuZXcgRXJyb3IoJ1NpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29scycpO1xuXHQgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuXHQgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsIHdvcmtJblByb2dyZXNzKSwgbGFuZSk7XG5cdCAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuXHQgICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuXHQgICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG5cdCAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cblx0ICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG5cdCAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcblx0ICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cblx0ICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG5cdCAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cblx0ICB2YXIgaGFzQ29udGV4dDtcblxuXHQgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG5cdCAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcblx0ICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG5cdCAgfVxuXG5cdCAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblx0ICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cdCAgdmFyIHNob3VsZFVwZGF0ZTtcblxuXHQgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuXHQgICAgcmVzZXRTdXNwZW5kZWRDdXJyZW50T25Nb3VudEluTGVnYWN5TW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuXG5cdCAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG5cdCAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHQgIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG5cdCAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgfVxuXG5cdCAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cblx0ICB7XG5cdCAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuXHQgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiBpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcblx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG5cdCAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ2EgY29tcG9uZW50Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG5cdCAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2Vcblx0ICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblx0ICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cblx0ICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG5cdCAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcblx0ICAgIGlmIChoYXNDb250ZXh0KSB7XG5cdCAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgIH1cblxuXHQgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gUmVyZW5kZXJcblxuXHQgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuXHQgIHZhciBuZXh0Q2hpbGRyZW47XG5cblx0ICBpZiAoZGlkQ2FwdHVyZUVycm9yICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcblx0ICAgIC8vIHVubW91bnQgYWxsIHRoZSBjaGlsZHJlbi4gY29tcG9uZW50RGlkQ2F0Y2ggd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9cblx0ICAgIC8vIHJlLXJlbmRlciBhIGZhbGxiYWNrLiBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCB3ZSBtaWdyYXRlIGV2ZXJ5b25lIHRvXG5cdCAgICAvLyB0aGUgbmV3IEFQSS5cblx0ICAgIC8vIFRPRE86IFdhcm4gaW4gYSBmdXR1cmUgcmVsZWFzZS5cblx0ICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG5cblx0ICAgIHtcblx0ICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAge1xuXHQgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICB9XG5cblx0ICAgIHtcblx0ICAgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG5cdCAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG5cdCAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcblx0ICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcblx0ICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcblx0ICAgIH1cblxuXHQgICAge1xuXHQgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuXHQgICAgfVxuXHQgIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cblx0ICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG5cdCAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgZGlkQ2FwdHVyZUVycm9yKSB7XG5cdCAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG5cdCAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG5cdCAgICAvLyB0aGF0IGFyZSBzaG93biBvbiBlcnJvciBhcmUgdHdvIGRpZmZlcmVudCBzZXRzLCBzbyB3ZSBzaG91bGRuJ3QgcmV1c2Vcblx0ICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG5cdCAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG5cdCAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG5cblxuXHQgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cblx0ICBpZiAoaGFzQ29udGV4dCkge1xuXHQgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlKTtcblx0ICB9XG5cblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG5cdCAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cblx0ICBpZiAocm9vdC5wZW5kaW5nQ29udGV4dCkge1xuXHQgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcblx0ICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuXHQgICAgLy8gU2hvdWxkIGFsd2F5cyBiZSBzZXRcblx0ICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuXHQgIH1cblxuXHQgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cdCAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG5cdCAgfVxuXG5cdCAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblx0ICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblx0ICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlLmVsZW1lbnQ7XG5cdCAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcblx0ICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblx0ICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cdCAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG5cblx0ICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cblx0ICBpZiAoc3VwcG9ydHNIeWRyYXRpb24gJiYgcHJldlN0YXRlLmlzRGVoeWRyYXRlZCkge1xuXHQgICAgLy8gVGhpcyBpcyBhIGh5ZHJhdGlvbiByb290IHdob3NlIHNoZWxsIGhhcyBub3QgeWV0IGh5ZHJhdGVkLiBXZSBzaG91bGRcblx0ICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cblx0ICAgIC8vIEZsaXAgaXNEZWh5ZHJhdGVkIHRvIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2hlbiB0aGlzIHJlbmRlclxuXHQgICAgLy8gZmluaXNoZXMsIHRoZSByb290IHdpbGwgbm8gbG9uZ2VyIGJlIGRlaHlkcmF0ZWQuXG5cdCAgICB2YXIgb3ZlcnJpZGVTdGF0ZSA9IHtcblx0ICAgICAgZWxlbWVudDogbmV4dENoaWxkcmVuLFxuXHQgICAgICBpc0RlaHlkcmF0ZWQ6IGZhbHNlLFxuXHQgICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlLFxuXHQgICAgICBwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOiBuZXh0U3RhdGUucGVuZGluZ1N1c3BlbnNlQm91bmRhcmllcyxcblx0ICAgICAgdHJhbnNpdGlvbnM6IG5leHRTdGF0ZS50cmFuc2l0aW9uc1xuXHQgICAgfTtcblx0ICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBgYmFzZVN0YXRlYCBjYW4gYWx3YXlzIGJlIHRoZSBsYXN0IHN0YXRlIGJlY2F1c2UgdGhlIHJvb3QgZG9lc24ndFxuXHQgICAgLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG5cblx0ICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG92ZXJyaWRlU3RhdGU7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gb3ZlcnJpZGVTdGF0ZTtcblxuXHQgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcblx0ICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGEgcHJldmlvdXMgYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBzaGVsbCwgc28gd2Vcblx0ICAgICAgLy8gZm9yY2VkIGEgY2xpZW50IHJlbmRlci5cblx0ICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJyArICdvZiBhIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGUgZW50aXJlIHJvb3Qgd2lsbCBzd2l0Y2ggdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpLCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgIHJldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcywgcmVjb3ZlcmFibGVFcnJvcik7XG5cdCAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPT0gcHJldkNoaWxkcmVuKSB7XG5cdCAgICAgIHZhciBfcmVjb3ZlcmFibGVFcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKG5ldyBFcnJvcignVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlICcgKyAnaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuJyksIHdvcmtJblByb2dyZXNzKTtcblxuXHQgICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIF9yZWNvdmVyYWJsZUVycm9yKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFRoZSBvdXRlcm1vc3Qgc2hlbGwgaGFzIG5vdCBoeWRyYXRlZCB5ZXQuIFN0YXJ0IGh5ZHJhdGluZy5cblx0ICAgICAgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgICAgdmFyIGNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG5cdCAgICAgIHZhciBub2RlID0gY2hpbGQ7XG5cblx0ICAgICAgd2hpbGUgKG5vZGUpIHtcblx0ICAgICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG5cdCAgICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuXHQgICAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuXHQgICAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuXHQgICAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuXHQgICAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuXHQgICAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcblx0ICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJvb3QgaXMgbm90IGRlaHlkcmF0ZWQuIEVpdGhlciB0aGlzIGlzIGEgY2xpZW50LW9ubHkgcm9vdCwgb3IgaXRcblx0ICAgIC8vIGFscmVhZHkgaHlkcmF0ZWQuXG5cdCAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cblx0ICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IHByZXZDaGlsZHJlbikge1xuXHQgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgfVxuXG5cdCAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIHJlY292ZXJhYmxlRXJyb3IpIHtcblx0ICAvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cblx0ICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cdCAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcblx0ICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcblx0ICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG5cdCAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcblx0ICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcblx0ICB9XG5cblx0ICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cdCAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblx0ICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cdCAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblx0ICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG5cdCAgaWYgKGlzRGlyZWN0VGV4dENoaWxkKSB7XG5cdCAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuXHQgICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuXHQgICAgLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGFzIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcblx0ICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG5cdCAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuXHQgIH0gZWxzZSBpZiAocHJldlByb3BzICE9PSBudWxsICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcblx0ICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG5cdCAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuXHQgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ29udGVudFJlc2V0O1xuXHQgIH1cblxuXHQgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXHQgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuXHQgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgfSAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcblx0ICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG5cdCAgcmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgcmVuZGVyTGFuZXMpIHtcblx0ICByZXNldFN1c3BlbmRlZEN1cnJlbnRPbk1vdW50SW5MZWdhY3lNb2RlKF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXHQgIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG5cdCAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuXHQgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblx0ICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cblx0ICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50O1xuXHQgIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG5cdCAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuXHQgIHZhciBjaGlsZDtcblxuXHQgIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcblx0ICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2hpbGQgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgICAge1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNoaWxkID0gdXBkYXRlRm9yd2FyZFJlZihudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuXHQgICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG5cdCAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuXHQgICAgICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCByZXNvbHZlZFByb3BzLCAvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuXHQgICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2hpbGQgPSB1cGRhdGVNZW1vQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LnR5cGUsIHJlc29sdmVkUHJvcHMpLCAvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cblx0ICAgICAgICByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGhpbnQgPSAnJztcblxuXHQgIHtcblx0ICAgIGlmIChDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcblx0ICAgICAgaGludCA9ICcgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT8nO1xuXHQgICAgfVxuXHQgIH0gLy8gVGhpcyBtZXNzYWdlIGludGVudGlvbmFsbHkgZG9lc24ndCBtZW50aW9uIEZvcndhcmRSZWYgb3IgTWVtb0NvbXBvbmVudFxuXHQgIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG5cdCAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cblx0ICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICsgQ29tcG9uZW50ICsgXCIuIFwiICsgKFwiTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgKyBoaW50KSk7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuXHQgIHJlc2V0U3VzcGVuZGVkQ3VycmVudE9uTW91bnRJbkxlZ2FjeU1vZGUoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzKTsgLy8gUHJvbW90ZSB0aGUgZmliZXIgdG8gYSBjbGFzcyBhbmQgdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cblxuXHQgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG5cdCAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cblx0ICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG5cdCAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cdCAgdmFyIGhhc0NvbnRleHQ7XG5cblx0ICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuXHQgICAgaGFzQ29udGV4dCA9IHRydWU7XG5cdCAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cdCAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuXHQgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcblx0ICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcykge1xuXHQgIHJlc2V0U3VzcGVuZGVkQ3VycmVudE9uTW91bnRJbkxlZ2FjeU1vZGUoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblx0ICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cdCAgdmFyIGNvbnRleHQ7XG5cblx0ICB7XG5cdCAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcblx0ICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXHQgIH1cblxuXHQgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cdCAgdmFyIHZhbHVlO1xuXHQgIHZhciBoYXNJZDtcblxuXHQgIHtcblx0ICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cblx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuXHQgICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG5cdCAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuXHQgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG5cdCAgICB9XG5cblx0ICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuXHQgICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG5cdCAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXHQgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuXHQgICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cdCAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuXHQgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cblx0ICB7XG5cdCAgICAvLyBTdXBwb3J0IGZvciBtb2R1bGUgY29tcG9uZW50cyBpcyBkZXByZWNhdGVkIGFuZCBpcyByZW1vdmVkIGJlaGluZCBhIGZsYWcuXG5cdCAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cblx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuXHQgICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUpO1xuXG5cdCAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG5cdCAgLy8gRXZlbnR1YWxseSB3ZSdsbCBkZWxldGUgdGhpcyBicmFuY2ggYWx0b2dldGhlci5cblx0ICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHtcblx0ICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuXHQgICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSkge1xuXHQgICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG5cdCAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG5cblx0ICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsOyAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuXHQgICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuXHQgICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cdCAgICB2YXIgaGFzQ29udGV4dCA9IGZhbHNlO1xuXG5cdCAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuXHQgICAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcblx0ICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXHQgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcblx0ICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuXHQgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuXHQgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG5cblx0ICAgIHtcblxuXHQgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG5cdCAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblx0ICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuXHQgICAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcblx0ICAgIH1cblxuXHQgICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgIHtcblx0ICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcblx0ICB7XG5cdCAgICBpZiAoQ29tcG9uZW50KSB7XG5cdCAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcblx0ICAgICAgICBlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBpbmZvID0gJyc7XG5cdCAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuXG5cdCAgICAgIGlmIChvd25lck5hbWUpIHtcblx0ICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCAnJztcblx0ICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuXG5cdCAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuXHQgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuXHQgICAgICAgIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG5cblx0ICAgICAgICBlcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnICsgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJywgaW5mbyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cblx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcblx0ICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsIF9jb21wb25lbnROYW1lMyk7XG5cblx0ICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcblx0ICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuXHQgICAgICBpZiAoIWRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTRdKSB7XG5cdCAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cblx0ICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHR2YXIgU1VTUEVOREVEX01BUktFUiA9IHtcblx0ICBkZWh5ZHJhdGVkOiBudWxsLFxuXHQgIHRyZWVDb250ZXh0OiBudWxsLFxuXHQgIHJldHJ5TGFuZTogTm9MYW5lXG5cdH07XG5cblx0ZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGJhc2VMYW5lczogcmVuZGVyTGFuZXMsXG5cdCAgICBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCksXG5cdCAgICB0cmFuc2l0aW9uczogbnVsbFxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcblx0ICB2YXIgY2FjaGVQb29sID0gbnVsbDtcblxuXHQgIHJldHVybiB7XG5cdCAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpLFxuXHQgICAgY2FjaGVQb29sOiBjYWNoZVBvb2wsXG5cdCAgICB0cmFuc2l0aW9uczogcHJldk9mZnNjcmVlblN0YXRlLnRyYW5zaXRpb25zXG5cdCAgfTtcblx0fSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cblx0ZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuXHQgIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgbmVlZCB0b1xuXHQgIC8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG5cdCAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG5cdCAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgIHZhciBzdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBDdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBEb24ndCBoaWRlIGl0LCBldmVuIGlmIEZvcmNlU3VzcGVuc2VGYWxsYmFja1xuXHQgICAgICAvLyBpcyB0cnVlLiBNb3JlIHByZWNpc2UgbmFtZSBtaWdodCBiZSBcIkZvcmNlUmVtYWluU3VzcGVuc2VGYWxsYmFja1wiLlxuXHQgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG5cdCAgICAgIC8vIG5vIGZhbGxiYWNrIHRvIHJlbWFpbiBvbi5cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0gLy8gTm90IGN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIENvbnN1bHQgdGhlIFN1c3BlbnNlIGNvbnRleHQuXG5cblxuXHQgIHJldHVybiBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcblx0ICAvLyBUT0RPOiBTaG91bGQgbm90IHJlbW92ZSByZW5kZXIgbGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCBkdXJpbmcgdGhpcyByZW5kZXJcblx0ICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG5cdCAge1xuXHQgICAgaWYgKHNob3VsZFN1c3BlbmQod29ya0luUHJvZ3Jlc3MpKSB7XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblx0ICB2YXIgc2hvd0ZhbGxiYWNrID0gZmFsc2U7XG5cdCAgdmFyIGRpZFN1c3BlbmQgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuXHQgIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuXHQgICAgLy8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cblx0ICAgIC8vIHJlbmRlcmluZyB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG5cdCAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkRpZENhcHR1cmU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuXHQgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIFRoaXMgaXMgYSBuZXcgbW91bnQgb3IgdGhpcyBib3VuZGFyeSBpcyBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBzdGF0ZS5cblx0ICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuXHQgICAgICAvLyBoYW5kbGUgdGhlIGZhbGxiYWNrIHN0YXRlLlxuXHQgICAgICAvLyBBdm9pZGVkIGJvdW5kYXJpZXMgYXJlIG5vdCBjb25zaWRlcmVkIHNpbmNlIHRoZXkgY2Fubm90IGhhbmRsZSBwcmVmZXJyZWQgZmFsbGJhY2sgc3RhdGVzLlxuXHQgICAgICB7XG5cdCAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuXHQgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuXHQgIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxpYXRpb24gbG9naWMuIFR3b1xuXHQgIC8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuXHQgIC8vXG5cdCAgLy8gRmlyc3QsIExlZ2FjeSBNb2RlIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhlXG5cdCAgLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcblx0ICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG5cdCAgLy8gaGFja3MgdG8gbWFrZSB0aGF0IG5vdCB0b3RhbGx5IGJyZWFrLiBMaWtlIHRyYW5zZmVycmluZyBlZmZlY3RzIGFuZFxuXHQgIC8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuXHQgIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcblx0ICAvLyBzdGF0ZSwgbm8gZWZmZWN0cy4gU2FtZSBhcyB3aGF0IHdlIGRvIGZvciBPZmZzY3JlZW4gKGV4Y2VwdCB0aGF0XG5cdCAgLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuXHQgIC8vXG5cdCAgLy8gU2Vjb25kIGlzIGh5ZHJhdGlvbi4gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIFN1c3BlbnNlIGZpYmVyIGhhcyBhIHNsaWdodGx5XG5cdCAgLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG5cdCAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuXHQgIC8vXG5cdCAgLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG5cdCAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG5cdCAgLy8gYW5kIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0cmVlLiBMaWtlIGEgdHJ5L2NhdGNoIGJsb2NrLiBTbyB3ZSBoYXZlIHRvIHRyYWNrXG5cdCAgLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuXHQgIC8vIGEgc3RhY2suXG5cblx0ICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgLy8gSW5pdGlhbCBtb3VudFxuXHQgICAgLy8gU3BlY2lhbCBwYXRoIGZvciBoeWRyYXRpb25cblx0ICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG5cdCAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG5cdCAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cblx0ICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO1xuXG5cdCAgICAgIGlmIChkZWh5ZHJhdGVkICE9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLCBkZWh5ZHJhdGVkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblx0ICAgIHZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcblxuXHQgICAgaWYgKHNob3dGYWxsYmFjaykge1xuXHQgICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0ICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuXG5cdCAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4pO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS5cblx0ICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG5cdCAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBfZGVoeWRyYXRlZCA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG5cdCAgICAgIGlmIChfZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGRpZFN1c3BlbmQsIG5leHRQcm9wcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzaG93RmFsbGJhY2spIHtcblx0ICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcblx0ICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXHQgICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgX25leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdCAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG5cdCAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIubWVtb2l6ZWRTdGF0ZSA9IHByZXZPZmZzY3JlZW5TdGF0ZSA9PT0gbnVsbCA/IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykgOiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpO1xuXG5cdCAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG5cdCAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG5cdCAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiwgcmVuZGVyTGFuZXMpO1xuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXHQgICAgICByZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mztcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuXHQgIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcblx0ICAgIG1vZGU6ICd2aXNpYmxlJyxcblx0ICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cblx0ICB9O1xuXHQgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG5cdCAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cdCAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblx0ICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuXHQgIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcblx0ICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHQgIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcblx0ICAgIG1vZGU6ICdoaWRkZW4nLFxuXHQgICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuXHQgIH07XG5cdCAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXHQgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cblx0ICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50ICE9PSBudWxsKSB7XG5cdCAgICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG5cdCAgICAvLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O1xuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuXHQgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcblx0ICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuXHQgICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcblx0ICAgICAgLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2Vcblx0ICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuXHQgICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG5cdCAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuXHQgICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gMDtcblx0ICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUpO1xuXHQgICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuXHQgIH1cblxuXHQgIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXHQgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcblx0ICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXHQgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cdCAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgcmVuZGVyTGFuZXMpIHtcblx0ICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbmAgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZVxuXHQgIC8vIHRoaXMgd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG5cdCAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgTm9MYW5lcywgbnVsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKSB7XG5cdCAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG5cdCAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG5cdCAgcmV0dXJuIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG5cdCAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcblx0ICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuXHQgICAgbW9kZTogJ3Zpc2libGUnLFxuXHQgICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuXHQgIH0pO1xuXG5cdCAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcblx0ICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmxhbmVzID0gcmVuZGVyTGFuZXM7XG5cdCAgfVxuXG5cdCAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cdCAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IG51bGw7XG5cblx0ICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuXHQgICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuXHQgICAgdmFyIGRlbGV0aW9ucyA9IHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucztcblxuXHQgICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudF07XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWxldGlvbnMucHVzaChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50KTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXHQgIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuXHQgIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcblx0ICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcblx0ICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuXHQgIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcblx0ICAgIG1vZGU6ICdoaWRkZW4nLFxuXHQgICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuXHQgIH07XG5cdCAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG5cdCAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG5cdCAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cblx0ICAobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG5cdCAgLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuXHQgIC8vIHdoZW4gRGV2VG9vbHMgZm9yY2VzIHVzIHRvIGRpc3BsYXkgYSBmYWxsYmFjazsgd2Ugc2tpcCB0aGUgZmlyc3QgcmVuZGVyXG5cdCAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcblx0ICAvLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cblx0ICAvLyBvbmx5IGNvZGVwYXRoLilcblx0ICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG5cdCAgICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O1xuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuXHQgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcblx0ICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuXHQgICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcblx0ICAgICAgLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2Vcblx0ICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuXHQgICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG5cdCAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuXHQgICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG5cdCAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcblx0ICAgIH0gLy8gVGhlIGZhbGxiYWNrIGZpYmVyIHdhcyBhZGRlZCBhcyBhIGRlbGV0aW9uIGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cblx0ICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIHJlbWFpbiBvbiB0aGUgZmFsbGJhY2ssIHdlIG5vIGxvbmdlciB3YW50XG5cdCAgICAvLyB0byBkZWxldGUgaXQuXG5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwgcHJpbWFyeUNoaWxkUHJvcHMpOyAvLyBTaW5jZSB3ZSdyZSByZXVzaW5nIGEgY3VycmVudCB0cmVlLCB3ZSBuZWVkIHRvIHJldXNlIHRoZSBmbGFncywgdG9vLlxuXHQgICAgLy8gKFdlIGRvbid0IGRvIHRoaXMgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgaW4gbGVnYWN5IG1vZGUgd2UgZG9uJ3QgcmUtdXNlXG5cdCAgICAvLyB0aGUgY3VycmVudCB0cmVlOyBzZWUgcHJldmlvdXMgYnJhbmNoLilcblxuXHQgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG5cdCAgfVxuXG5cdCAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcblxuXHQgIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG5cdCAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcblx0ICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cblx0ICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG5cdCAgfVxuXG5cdCAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXHQgIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXHQgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cdCAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblx0ICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXHR9XG5cblx0ZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKSB7XG5cdCAgLy8gRmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuIEJlY2F1c2UgdGhpcyBoYXMgcGVyZm9ybWFuY2Vcblx0ICAvLyBpbXBsaWNhdGlvbnMsIGl0J3MgY29uc2lkZXJlZCBhIHJlY292ZXJhYmxlIGVycm9yLCBldmVuIHRob3VnaCB0aGUgdXNlclxuXHQgIC8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuXHQgIC8vXG5cdCAgLy8gVGhlIGVycm9yIGlzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCB0byBlbmZvcmNlIHRoYXQgZXZlcnkgY2FsbGVyIHByb3ZpZGVcblx0ICAvLyBhIGN1c3RvbSBtZXNzYWdlLCBvciBleHBsaWNpdGx5IG9wdCBvdXQgKGN1cnJlbnRseSB0aGUgb25seSBwYXRoIHRoYXQgb3B0c1xuXHQgIC8vIG91dCBpcyBsZWdhY3kgbW9kZTsgZXZlcnkgY29uY3VycmVudCBwYXRoIHByb3ZpZGVzIGFuIGVycm9yKS5cblx0ICBpZiAocmVjb3ZlcmFibGVFcnJvciAhPT0gbnVsbCkge1xuXHQgICAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcblx0ICB9IC8vIFRoaXMgd2lsbCBhZGQgdGhlIG9sZCBmaWJlciB0byB0aGUgZGVsZXRpb24gbGlzdFxuXG5cblx0ICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBXZSdyZSBub3cgbm90IHN1c3BlbmRlZCBub3IgZGVoeWRyYXRlZC5cblxuXHQgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cdCAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblx0ICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcblx0ICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG5cdCAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuXHQgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXHQgIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIGZpYmVyTW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG5cdCAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuXHQgICAgbW9kZTogJ3Zpc2libGUnLFxuXHQgICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuXHQgIH07XG5cdCAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBmaWJlck1vZGUpO1xuXHQgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBmaWJlck1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlXG5cdCAgLy8gYm91bmRhcnkpIGFscmVhZHkgbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuXHQgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG5cdCAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cdCAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXHQgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cdCAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuXHQgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAvLyBXZSB3aWxsIGhhdmUgZHJvcHBlZCB0aGUgZWZmZWN0IGxpc3Qgd2hpY2ggY29udGFpbnMgdGhlXG5cdCAgICAvLyBkZWxldGlvbi4gV2UgbmVlZCB0byByZWNvbmNpbGUgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGNoaWxkLlxuXHQgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcblx0ICB9XG5cblx0ICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG5cdCAgLy8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuXHQgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHRoZSBjb250ZW50IGluIHBsYWNlIGFuZCB0cnkgdG8gaHlkcmF0ZSBpdCBsYXRlci5cblx0ICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuXHQgICAge1xuXHQgICAgICBlcnJvcignQ2Fubm90IGh5ZHJhdGUgU3VzcGVuc2UgaW4gbGVnYWN5IG1vZGUuIFN3aXRjaCBmcm9tICcgKyAnUmVhY3RET00uaHlkcmF0ZShlbGVtZW50LCBjb250YWluZXIpIHRvICcgKyAnUmVhY3RET01DbGllbnQuaHlkcmF0ZVJvb3QoY29udGFpbmVyLCA8QXBwIC8+KScgKyAnLnJlbmRlcihlbGVtZW50KSBvciByZW1vdmUgdGhlIFN1c3BlbnNlIGNvbXBvbmVudHMgZnJvbSAnICsgJ3RoZSBzZXJ2ZXIgcmVuZGVyZWQgY29tcG9uZW50cy4nKTtcblx0ICAgIH1cblxuXHQgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhTeW5jTGFuZSk7XG5cdCAgfSBlbHNlIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuXHQgICAgLy8gVGhpcyBpcyBhIGNsaWVudC1vbmx5IGJvdW5kYXJ5LiBTaW5jZSB3ZSB3b24ndCBnZXQgYW55IGNvbnRlbnQgZnJvbSB0aGUgc2VydmVyXG5cdCAgICAvLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcblx0ICAgIC8vIGhhdmUgdGltZWQgb3V0LiBJbiB0aGVvcnkgd2UgY291bGQgcmVuZGVyIGl0IGluIHRoaXMgcGFzcyBidXQgaXQgd291bGQgaGF2ZSB0aGVcblx0ICAgIC8vIHdyb25nIHByaW9yaXR5IGFzc29jaWF0ZWQgd2l0aCBpdCBhbmQgd2lsbCBwcmV2ZW50IGh5ZHJhdGlvbiBvZiBwYXJlbnQgcGF0aC5cblx0ICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG5cdCAgICAvLyBUT0RPIFRoaXMgdGltZSBzaG91bGQgYmUgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIHNlcnZlciByZW5kZXJlZCByZXNwb25zZSB0aGF0IGlzXG5cdCAgICAvLyBhIHBhcmVudCB0byB0aGlzIGJvdW5kYXJ5IHdhcyBkaXNwbGF5ZWQuIEhvd2V2ZXIsIHNpbmNlIHdlIGN1cnJlbnRseSBkb24ndCBoYXZlXG5cdCAgICAvLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuXHQgICAgLy8gdGltZS4gVGhpcyB3aWxsIG1lYW4gdGhhdCBTdXNwZW5zZSB0aW1lb3V0cyBhcmUgc2xpZ2h0bHkgc2hpZnRlZCB0byBsYXRlciB0aGFuXG5cdCAgICAvLyB0aGV5IHNob3VsZCBiZS5cblx0ICAgIC8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cblx0ICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoRGVmYXVsdEh5ZHJhdGlvbkxhbmUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcblx0ICAgIC8vIGJlIHNob3dpbmcgdGhlIHJpZ2h0IGNvbnRlbnQgY29taW5nIGZyb20gdGhlIHNlcnZlciwgaXQgaXMgbm8gcnVzaC5cblx0ICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGRpZFN1c3BlbmQsIG5leHRQcm9wcywgc3VzcGVuc2VJbnN0YW5jZSwgc3VzcGVuc2VTdGF0ZSwgcmVuZGVyTGFuZXMpIHtcblx0ICBpZiAoIWRpZFN1c3BlbmQpIHtcblx0ICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBwYXNzLiBBdHRlbXB0IHRvIGh5ZHJhdGUuXG5cdCAgICAvLyBXZSBzaG91bGQgbmV2ZXIgYmUgaHlkcmF0aW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCBpcyB0aGUgZmlyc3QgcGFzcyxcblx0ICAgIC8vIGJ1dCBhZnRlciB3ZSd2ZSBhbHJlYWR5IGNvbW1pdHRlZCBvbmNlLlxuXHQgICAgd2FybklmSHlkcmF0aW5nKCk7XG5cblx0ICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG5cdCAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIC8vIFRPRE86IFdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIGFyZ3VtZW50XG5cdCAgICAgIC8vIHJlcXVpcmVkIOKAlCBldmVyeSBjb25jdXJyZW50IG1vZGUgcGF0aCB0aGF0IGNhdXNlcyBoeWRyYXRpb24gdG9cblx0ICAgICAgLy8gZGUtb3B0IHRvIGNsaWVudCByZW5kZXJpbmcgc2hvdWxkIGhhdmUgYW4gZXJyb3IgbWVzc2FnZS5cblx0ICAgICAgbnVsbCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuXHQgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGluIGEgcGVybWFuZW50IGZhbGxiYWNrIHN0YXRlLiBJbiB0aGlzIGNhc2UsIHdlJ2xsIG5ldmVyXG5cdCAgICAgIC8vIGdldCBhbiB1cGRhdGUgYW5kIHdlJ2xsIG5ldmVyIGJlIGFibGUgdG8gaHlkcmF0ZSB0aGUgZmluYWwgY29udGVudC4gTGV0J3MganVzdCB0cnkgdGhlXG5cdCAgICAgIC8vIGNsaWVudCBzaWRlIHJlbmRlciBpbnN0ZWFkLlxuXHQgICAgICB2YXIgZGlnZXN0LCBtZXNzYWdlLCBzdGFjaztcblxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIF9nZXRTdXNwZW5zZUluc3RhbmNlRiA9IGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyhzdXNwZW5zZUluc3RhbmNlKTtcblxuXHQgICAgICAgIGRpZ2VzdCA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5kaWdlc3Q7XG5cdCAgICAgICAgbWVzc2FnZSA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5tZXNzYWdlO1xuXHQgICAgICAgIHN0YWNrID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLnN0YWNrO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGVycm9yO1xuXG5cdCAgICAgIGlmIChtZXNzYWdlKSB7XG5cdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblx0ICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVGhlIHNlcnZlciBjb3VsZCBub3QgZmluaXNoIHRoaXMgU3VzcGVuc2UgYm91bmRhcnksIGxpa2VseSAnICsgJ2R1ZSB0byBhbiBlcnJvciBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4gU3dpdGNoZWQgdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNhcHR1cmVkVmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBkaWdlc3QsIHN0YWNrKTtcblx0ICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgY2FwdHVyZWRWYWx1ZSk7XG5cdCAgICB9XG5cdCAgICAvLyBhbnkgY29udGV4dCBoYXMgY2hhbmdlZCwgd2UgbmVlZCB0byB0cmVhdCBpcyBhcyBpZiB0aGUgaW5wdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLlxuXG5cblx0ICAgIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cblx0ICAgIGlmIChkaWRSZWNlaXZlVXBkYXRlIHx8IGhhc0NvbnRleHRDaGFuZ2VkKSB7XG5cdCAgICAgIC8vIFRoaXMgYm91bmRhcnkgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGZpcnN0IHJlbmRlci4gVGhpcyBtZWFucyB0aGF0IHdlIGFyZSBub3cgdW5hYmxlIHRvXG5cdCAgICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuXHQgICAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG5cdCAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuXHQgICAgICAgIGlmIChhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBOb0xhbmUgJiYgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSAhPT0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpIHtcblx0ICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbXV0YXRpbmcgc2luY2UgdGhpcyByZW5kZXIgd2lsbCBnZXQgaW50ZXJydXB0ZWQuIFRoaXNcblx0ICAgICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG5cdCAgICAgICAgICAvLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblx0ICAgICAgICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZTsgLy8gVE9ETzogSWRlYWxseSB0aGlzIHdvdWxkIGluaGVyaXQgdGhlIGV2ZW50IHRpbWUgb2YgdGhlIGN1cnJlbnQgcmVuZGVyXG5cblx0ICAgICAgICAgIHZhciBldmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcblx0ICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LCBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lKTtcblx0ICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBjdXJyZW50LCBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lLCBldmVudFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSAvLyBJZiB3ZSBoYXZlIHNjaGVkdWxlZCBoaWdoZXIgcHJpIHdvcmsgYWJvdmUsIHRoaXMgd2lsbCBwcm9iYWJseSBqdXN0IGFib3J0IHRoZSByZW5kZXJcblx0ICAgICAgLy8gc2luY2Ugd2Ugbm93IGhhdmUgaGlnaGVyIHByaW9yaXR5IHdvcmssIGJ1dCBpbiBjYXNlIGl0IGRvZXNuJ3QsIHdlIG5lZWQgdG8gcHJlcGFyZSB0b1xuXHQgICAgICAvLyByZW5kZXIgc29tZXRoaW5nLCBpZiB3ZSB0aW1lIG91dC4gRXZlbiBpZiB0aGF0IHJlcXVpcmVzIHVzIHRvIGRlbGV0ZSBldmVyeXRoaW5nIGFuZFxuXHQgICAgICAvLyBza2lwIGh5ZHJhdGlvbi5cblx0ICAgICAgLy8gRGVsYXkgaGF2aW5nIHRvIGRvIHRoaXMgYXMgbG9uZyBhcyB0aGUgc3VzcGVuc2UgdGltZW91dCBhbGxvd3MgdXMuXG5cblxuXHQgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG5cblx0ICAgICAgdmFyIF9jYXB0dXJlZFZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShuZXcgRXJyb3IoJ1RoaXMgU3VzcGVuc2UgYm91bmRhcnkgcmVjZWl2ZWQgYW4gdXBkYXRlIGJlZm9yZSBpdCBmaW5pc2hlZCAnICsgJ2h5ZHJhdGluZy4gVGhpcyBjYXVzZWQgdGhlIGJvdW5kYXJ5IHRvIHN3aXRjaCB0byBjbGllbnQgcmVuZGVyaW5nLiAnICsgJ1RoZSB1c3VhbCB3YXkgdG8gZml4IHRoaXMgaXMgdG8gd3JhcCB0aGUgb3JpZ2luYWwgdXBkYXRlICcgKyAnaW4gc3RhcnRUcmFuc2l0aW9uLicpKTtcblxuXHQgICAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCBfY2FwdHVyZWRWYWx1ZSk7XG5cdCAgICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIHtcblx0ICAgICAgLy8gVGhpcyBjb21wb25lbnQgaXMgc3RpbGwgcGVuZGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBoeWRyYXRlIGl0c1xuXHQgICAgICAvLyBjb250ZW50LiBXZSB0cmVhdCBpdCBhcyBpZiB0aGlzIGNvbXBvbmVudCBzdXNwZW5kZWQgaXRzZWxmLiBJdCBtaWdodCBzZWVtIGFzIGlmXG5cdCAgICAgIC8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG5cdCAgICAgIC8vIGxvdCBvZiB1bm5lY2Vzc2FyeSB3b3JrIGFuZCBpcyB1bmxpa2VseSB0byBjb21wbGV0ZSBzaW5jZSBpdCBvZnRlbiB3aWxsIHN1c3BlbmRcblx0ICAgICAgLy8gb24gbWlzc2luZyBkYXRhIGFueXdheS4gQWRkaXRpb25hbGx5LCB0aGUgc2VydmVyIG1pZ2h0IGJlIGFibGUgdG8gcmVuZGVyIG1vcmVcblx0ICAgICAgLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG5cdCAgICAgIC8vIG9uIHRoZSBjbGllbnQgdGhhbiBpZiB3ZSBqdXN0IGxlYXZlIGl0IGFsb25lLiBJZiB0aGUgc2VydmVyIHRpbWVzIG91dCBvciBlcnJvcnNcblx0ICAgICAgLy8gdGhlc2Ugc2hvdWxkIHVwZGF0ZSB0aGlzIGJvdW5kYXJ5IHRvIHRoZSBwZXJtYW5lbnQgRmFsbGJhY2sgc3RhdGUgaW5zdGVhZC5cblx0ICAgICAgLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cblx0ICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gTGVhdmUgdGhlIGNoaWxkIGluIHBsYWNlLiBJLmUuIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50LlxuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gUmVnaXN0ZXIgYSBjYWxsYmFjayB0byByZXRyeSB0aGlzIGJvdW5kYXJ5IG9uY2UgdGhlIHNlcnZlciBoYXMgc2VudCB0aGUgcmVzdWx0LlxuXG5cdCAgICAgIHZhciByZXRyeSA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLCBjdXJyZW50KTtcblx0ICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoc3VzcGVuc2VJbnN0YW5jZSwgcmV0cnkpO1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG5cdCAgICAgIHJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VJbnN0YW5jZSwgc3VzcGVuc2VTdGF0ZS50cmVlQ29udGV4dCk7XG5cdCAgICAgIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cdCAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE1hcmsgdGhlIGNoaWxkcmVuIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuXHQgICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG5cdCAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuXHQgICAgICAvLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcblx0ICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG5cdCAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuXG5cdCAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IEh5ZHJhdGluZztcblx0ICAgICAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBUaGlzIGlzIHRoZSBzZWNvbmQgcmVuZGVyIHBhc3MuIFdlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIGh5ZHJhdGVkLCBidXRcblx0ICAgIC8vIHNvbWV0aGluZyBlaXRoZXIgc3VzcGVuZGVkIG9yIGVycm9yZWQuXG5cdCAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuXHQgICAgICAvLyBTb21ldGhpbmcgZXJyb3JlZCBkdXJpbmcgaHlkcmF0aW9uLiBUcnkgYWdhaW4gd2l0aG91dCBoeWRyYXRpbmcuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcblxuXHQgICAgICB2YXIgX2NhcHR1cmVkVmFsdWUyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgdGhpcyBTdXNwZW5zZSBib3VuZGFyeS4gJyArICdTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nLicpKTtcblxuXHQgICAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCBfY2FwdHVyZWRWYWx1ZTIpO1xuXHQgICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYW5kIHdlIHNob3VsZCBzdGlsbCBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG5cdCAgICAgIC8vIExlYXZlIHRoZSBleGlzdGluZyBjaGlsZCBpbiBwbGFjZS5cblx0ICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcblx0ICAgICAgLy8gYnV0IHRoZSBub3JtYWwgc3VzcGVuc2UgcGFzcyBkb2Vzbid0LlxuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gU3VzcGVuZGVkIGJ1dCB3ZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGluIGRlaHlkcmF0ZWQgbW9kZS5cblx0ICAgICAgLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG5cdCAgICAgIHZhciBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXHQgICAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cdCAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0ICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG5cdCAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGZpYmVyLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG5cdCAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG5cdCAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuXHQgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcblx0ICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG5cdCAgfVxuXG5cdCAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChmaWJlci5yZXR1cm4sIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBmaXJzdENoaWxkLCByZW5kZXJMYW5lcykge1xuXHQgIC8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG5cdCAgLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuXHQgIC8vIHRvIHVuYmxvY2suXG5cdCAgdmFyIG5vZGUgPSBmaXJzdENoaWxkO1xuXG5cdCAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcblx0ICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQpIHtcblx0ICAgICAgLy8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG5cdCAgICAgIC8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuXHQgICAgICAvLyBsaXN0IGl0c2VsZi5cblx0ICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2Vcblx0ICAgICAgLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cblx0ICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuXHQgICAgICBub2RlID0gbm9kZS5jaGlsZDtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcblx0ICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblx0ICAgIH1cblxuXHQgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuXHQgICAgbm9kZSA9IG5vZGUuc2libGluZztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kTGFzdENvbnRlbnRSb3coZmlyc3RDaGlsZCkge1xuXHQgIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG5cdCAgLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3Jcblx0ICAvLyBuZXcuIElmIGEgcm93IGhhcyBtdWx0aXBsZSBTdXNwZW5zZSBib3VuZGFyaWVzLCBhbnkgb2YgdGhlbSBiZWluZyBpbiB0aGVcblx0ICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cblx0ICAvLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG5cdCAgLy8gd2lsbCBzdGlsbCBiZSBjdXJyZW50IHNpbmNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlbSB5ZXQuIFRoZSBtb3VudGVkXG5cdCAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cblx0ICB2YXIgcm93ID0gZmlyc3RDaGlsZDtcblx0ICB2YXIgbGFzdENvbnRlbnRSb3cgPSBudWxsO1xuXG5cdCAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cblx0ICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuXHQgICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcblx0ICAgIH1cblxuXHQgICAgcm93ID0gcm93LnNpYmxpbmc7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGxhc3RDb250ZW50Um93O1xuXHR9XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuXHQgIHtcblx0ICAgIGlmIChyZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkICYmIHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ3RvZ2V0aGVyJyAmJiAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdKSB7XG5cdCAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cblx0ICAgICAgaWYgKHR5cGVvZiByZXZlYWxPcmRlciA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcblx0ICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcblx0ICAgICAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcblx0ICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgY2FzZSAnZm9yd2FyZCc6XG5cdCAgICAgICAgICBjYXNlICdiYWNrd2FyZCc6XG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpIHtcblx0ICB7XG5cdCAgICBpZiAodGFpbE1vZGUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKSB7XG5cdCAgICAgIGlmICh0YWlsTW9kZSAhPT0gJ2NvbGxhcHNlZCcgJiYgdGFpbE1vZGUgIT09ICdoaWRkZW4nKSB7XG5cdCAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuXHQgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLCB0YWlsTW9kZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAocmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnKSB7XG5cdCAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuXHQgICAgICAgIGVycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJyArICdcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJyArICdEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JywgdGFpbE1vZGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG5cdCAge1xuXHQgICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXkoY2hpbGRTbG90KTtcblx0ICAgIHZhciBpc0l0ZXJhYmxlID0gIWlzQW5BcnJheSAmJiB0eXBlb2YgZ2V0SXRlcmF0b3JGbihjaGlsZFNsb3QpID09PSAnZnVuY3Rpb24nO1xuXG5cdCAgICBpZiAoaXNBbkFycmF5IHx8IGlzSXRlcmFibGUpIHtcblx0ICAgICAgdmFyIHR5cGUgPSBpc0FuQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuXHQgICAgICBlcnJvcignQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gJyArICdhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiAnICsgJzwvU3VzcGVuc2VMaXN0PicsIHR5cGUsIGluZGV4LCB0eXBlKTtcblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKGNoaWxkcmVuLCByZXZlYWxPcmRlcikge1xuXHQgIHtcblx0ICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuXHQgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuXHQgICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgdmFyIGNoaWxkcmVuSXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuXG5cdCAgICAgICAgICBpZiAoY2hpbGRyZW5JdGVyYXRvcikge1xuXHQgICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgICAgICB2YXIgX2kgPSAwO1xuXG5cdCAgICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCkpIHtcblx0ICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgX2krKztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBlcnJvcignQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gJyArICdUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gJyArICdEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLCByZXZlYWxPcmRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBpc0JhY2t3YXJkcywgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlKSB7XG5cdCAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuXHQgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcblx0ICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuXHQgICAgICByZW5kZXJpbmc6IG51bGwsXG5cdCAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcblx0ICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG5cdCAgICAgIHRhaWw6IHRhaWwsXG5cdCAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZVxuXHQgICAgfTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyBvYmplY3QgZnJvbSBwcmV2aW91cyByZW5kZXJzLlxuXHQgICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcblx0ICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG5cdCAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwO1xuXHQgICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuXHQgICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG5cdCAgICByZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlO1xuXHQgIH1cblx0fSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cblx0Ly8gVGhlIGZpcnN0IHBhc3Mgc3BsaXRzIHRoZSBjaGlsZHJlbiBmaWJlcnMgaW50byB0d28gc2V0cy4gQSBoZWFkIGFuZCB0YWlsLlxuXHQvLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG5cdC8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcblx0Ly8gdGhlIGZvcmNlIHN1c3BlbmQgY29udGV4dC4gSWYgdGhlIGZpcnN0IHJlbmRlciBkaWRuJ3QgaGF2ZSBhbnl0aGluZyBpblxuXHQvLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cblx0Ly8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXHQgIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcblx0ICB2YXIgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcblx0ICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cdCAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG5cdCAgdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpO1xuXHQgIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcblx0ICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuXHQgIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuXHQgIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG5cdCAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblx0ICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG5cdCAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuXHQgICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcblx0ICAgICAgLy8gb24gYW55IG5lc3RlZCBib3VuZGFyaWVzIHRvIGxldCB0aGVtIGtub3cgdG8gdHJ5IHRvIHJlbmRlclxuXHQgICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuXHQgICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG5cdCAgICB9XG5cblx0ICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG5cdCAgfVxuXG5cdCAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTtcblxuXHQgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG5cdCAgICAvLyBJbiBsZWdhY3kgbW9kZSwgU3VzcGVuc2VMaXN0IGRvZXNuJ3Qgd29yayBzbyB3ZSBqdXN0XG5cdCAgICAvLyB1c2UgbWFrZSBpdCBhIG5vb3AgYnkgdHJlYXRpbmcgaXQgYXMgdGhlIGRlZmF1bHQgcmV2ZWFsT3JkZXIuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblx0ICB9IGVsc2Uge1xuXHQgICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuXHQgICAgICBjYXNlICdmb3J3YXJkcyc6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcblx0ICAgICAgICAgIHZhciB0YWlsO1xuXG5cdCAgICAgICAgICBpZiAobGFzdENvbnRlbnRSb3cgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cblx0ICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cblx0ICAgICAgICAgICAgdGFpbCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHQgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSB0YWlsIHJvd3MgYWZ0ZXIgdGhlIGNvbnRlbnQgcm93LlxuXHQgICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuXHQgICAgICAgICAgICB0YWlsID0gbGFzdENvbnRlbnRSb3cuc2libGluZztcblx0ICAgICAgICAgICAgbGFzdENvbnRlbnRSb3cuc2libGluZyA9IG51bGw7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG5cdCAgICAgICAgICB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG5cdCAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIGdvaW5nIHRvIHJldmVyc2UgdGhlIGxpc3Qgb2YgZXZlcnl0aGluZ1xuXHQgICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG5cdCAgICAgICAgICAvLyBvcmRlci5cblx0ICAgICAgICAgIHZhciBfdGFpbCA9IG51bGw7XG5cdCAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cblx0ICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQuXG5cdCAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuXHQgICAgICAgICAgICByb3cuc2libGluZyA9IF90YWlsO1xuXHQgICAgICAgICAgICBfdGFpbCA9IHJvdztcblx0ICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcblx0ICAgICAgICAgIH0gLy8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuXG5cblx0ICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgLy8gaXNCYWNrd2FyZHNcblx0ICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG5cdCAgICAgICAgICB0YWlsTW9kZSk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSAndG9nZXRoZXInOlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG5cdCAgICAgICAgICBudWxsLCAvLyB0YWlsXG5cdCAgICAgICAgICBudWxsLCAvLyBsYXN0XG5cdCAgICAgICAgICB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcmV2ZWFsIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG5vdCBoYXZpbmdcblx0ICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuXHQgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG5cdCAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuXHQgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcblx0ICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuXHQgICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG5cdCAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cblx0ICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgIH1cblxuXHQgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0fVxuXG5cdHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICB2YXIgcHJvdmlkZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblx0ICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcblx0ICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cdCAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblx0ICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcblxuXHQgIHtcblx0ICAgIGlmICghKCd2YWx1ZScgaW4gbmV3UHJvcHMpKSB7XG5cdCAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpIHtcblx0ICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IHRydWU7XG5cblx0ICAgICAgICBlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG5cdCAgICBpZiAocHJvdmlkZXJQcm9wVHlwZXMpIHtcblx0ICAgICAgY2hlY2tQcm9wVHlwZXMocHJvdmlkZXJQcm9wVHlwZXMsIG5ld1Byb3BzLCAncHJvcCcsICdDb250ZXh0LlByb3ZpZGVyJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG5cblx0ICB7XG5cdCAgICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcblx0ICAgICAgdmFyIG9sZFZhbHVlID0gb2xkUHJvcHMudmFsdWU7XG5cblx0ICAgICAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcblx0ICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuXHQgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcblx0ICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuXHQgICAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuXHQgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXHQgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXHQgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0fVxuXG5cdHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cblx0ICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuXHQgIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuXHQgIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG5cdCAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcblx0ICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcblx0ICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG5cblx0ICB7XG5cdCAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuXHQgICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG5cdCAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cblx0ICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcblx0ICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuXHQgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuXHQgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbnRleHQgPSBjb250ZXh0Ll9jb250ZXh0O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblx0ICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cblx0ICB7XG5cdCAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQpO1xuXG5cdCAge1xuXHQgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuXHQgIH1cblxuXHQgIHZhciBuZXdDaGlsZHJlbjtcblxuXHQgIHtcblx0ICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuXHQgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG5cdCAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG5cdCAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcblx0ICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG5cdCAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblx0ICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpIHtcblx0ICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0U3VzcGVuZGVkQ3VycmVudE9uTW91bnRJbkxlZ2FjeU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcblx0ICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuXHQgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgLy8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuXHQgICAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG5cdCAgICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuXHQgICAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG5cdCAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuXHQgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICAvLyBSZXVzZSBwcmV2aW91cyBkZXBlbmRlbmNpZXNcblx0ICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuXHQgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcblx0ICB9XG5cblx0ICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuXHQgIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpIHtcblx0ICAgIC8vIFRoZSBjaGlsZHJlbiBkb24ndCBoYXZlIGFueSB3b3JrIGVpdGhlci4gV2UgY2FuIHNraXAgdGhlbS5cblx0ICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG5cdCAgICAvLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxuXHQgICAge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICB9IC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcblx0ICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cblx0ICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdW50RmliZXIoY3VycmVudCwgb2xkV29ya0luUHJvZ3Jlc3MsIG5ld1dvcmtJblByb2dyZXNzKSB7XG5cdCAge1xuXHQgICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG5cdCAgICBpZiAocmV0dXJuRmliZXIgPT09IG51bGwpIHtcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcblx0ICAgIH0gLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cblx0ICAgIC8vIEl0IHdpbGwgZ2V0IGRlbGV0ZWQuXG5cblxuXHQgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuXHQgICAgb2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5cblx0ICAgIG5ld1dvcmtJblByb2dyZXNzLmluZGV4ID0gb2xkV29ya0luUHJvZ3Jlc3MuaW5kZXg7XG5cdCAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcblx0ICAgIG5ld1dvcmtJblByb2dyZXNzLnJldHVybiA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcblx0ICAgIG5ld1dvcmtJblByb2dyZXNzLnJlZiA9IG9sZFdvcmtJblByb2dyZXNzLnJlZjsgLy8gUmVwbGFjZSB0aGUgY2hpbGQvc2libGluZyBwb2ludGVycyBhYm92ZSBpdC5cblxuXHQgICAgaWYgKG9sZFdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZCkge1xuXHQgICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG5cblx0ICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG5cdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB3aGlsZSAocHJldlNpYmxpbmcuc2libGluZyAhPT0gb2xkV29ya0luUHJvZ3Jlc3MpIHtcblx0ICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cblx0ICAgICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcblx0ICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuXHQgICAgfSAvLyBEZWxldGUgdGhlIG9sZCBmaWJlciBhbmQgcGxhY2UgdGhlIG5ldyBvbmUuXG5cdCAgICAvLyBTaW5jZSB0aGUgb2xkIGZpYmVyIGlzIGRpc2Nvbm5lY3RlZCwgd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBtYW51YWxseS5cblxuXG5cdCAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG5cdCAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG5cdCAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XTtcblx0ICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlbGV0aW9ucy5wdXNoKGN1cnJlbnQpO1xuXHQgICAgfVxuXG5cdCAgICBuZXdXb3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7IC8vIFJlc3RhcnQgd29yayBmcm9tIHRoZSBuZXcgZmliZXIuXG5cblx0ICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuXHQgIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcblx0ICAvLyB1cGRhdGVzIG9yIGNvbnRleHQuXG5cdCAgdmFyIHVwZGF0ZUxhbmVzID0gY3VycmVudC5sYW5lcztcblxuXHQgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0gLy8gTm8gcGVuZGluZyB1cGRhdGUsIGJ1dCBiZWNhdXNlIGNvbnRleHQgaXMgcHJvcGFnYXRlZCBsYXppbHksIHdlIG5lZWRcblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuXHQgIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcblx0ICAvLyB0aGUgYmVnaW4gcGhhc2UuIFRoZXJlJ3Mgc3RpbGwgc29tZSBib29ra2VlcGluZyB3ZSB0aGF0IG5lZWRzIHRvIGJlIGRvbmVcblx0ICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cblx0ICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuXHQgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuXHQgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cblx0ICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuXHQgICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0UG9ydGFsOlxuXHQgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuXHQgICAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcblx0ICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIG5ld1ZhbHVlKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIFByb2ZpbGVyOlxuXHQgICAgICB7XG5cdCAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG5cdCAgICAgICAgdmFyIGhhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG5cdCAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuXHQgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cblx0ICAgICAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG5cdCAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXHQgICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcblx0ICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuXHQgICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgaWYgKHN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFdlIGtub3cgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIHN1c3BlbmQgYWdhaW4gYmVjYXVzZSBpZiBpdCBoYXNcblx0ICAgICAgICAgICAgLy8gYmVlbiB1bnN1c3BlbmRlZCBpdCBoYXMgY29tbWl0dGVkIGFzIGEgcmVzb2x2ZWQgU3VzcGVuc2UgY29tcG9uZW50LlxuXHQgICAgICAgICAgICAvLyBJZiBpdCBuZWVkcyB0byBiZSByZXRyaWVkLCBpdCBzaG91bGQgaGF2ZSB3b3JrIHNjaGVkdWxlZCBvbiBpdC5cblxuXHQgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBXZSBzaG91bGQgbmV2ZXIgcmVuZGVyIHRoZSBjaGlsZHJlbiBvZiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgdW50aWwgd2Vcblx0ICAgICAgICAgICAgLy8gdXBncmFkZSBpdC4gV2UgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrLlxuXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgfSAvLyBJZiB0aGlzIGJvdW5kYXJ5IGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHdlIG5lZWQgdG8gZGVjaWRlXG5cdCAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG5cdCAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuXHQgICAgICAgICAgLy8gY2hpbGQgZnJhZ21lbnQuXG5cblxuXHQgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdCAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG5cdCAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgcHJpbWFyeUNoaWxkTGFuZXMpKSB7XG5cdCAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG5cdCAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuXHQgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuXHQgICAgICAgICAgICAvLyBvbiBpdFxuXHQgICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuXHQgICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cblxuXHQgICAgICAgICAgICB2YXIgY2hpbGQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG5cdCAgICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbiBhbmQgd29yayBvbiB0aGUgZmFsbGJhY2suXG5cdCAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2FuIHJldHVybiBgbnVsbGAgaGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgY2hlY2tlZFxuXHQgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuXHQgICAgICAgICAgICAgIC8vIGBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrYCBhYm92ZS5cblx0ICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuXHQgICAgICAgIHZhciBfaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cblx0ICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuXHQgICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcblx0ICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBpbiBmYWxsYmFjayBzdGF0ZSBsYXN0IHRpbWUsIGFuZCB3ZSBoYXZlIGFsbCB0aGVcblx0ICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG5cdCAgICAgICAgICAgIC8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcblx0ICAgICAgICAgICAgLy8gdHJlZSB3aGljaCB3aWxsIGFmZmVjdCB0aGUgdGFpbC4gU28gd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbFxuXHQgICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cblx0ICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICAgICAgfSAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG5cdCAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcblx0ICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cblxuXHQgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcblx0ICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuXHQgICAgICAgIC8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuXHQgICAgICAgIC8vIGluIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSwgc28gd2UgY2FuIGNvbnRpbnVlIGZyb20gdGhlIHN0YXRlIHdlIGhhZC5cblxuXG5cdCAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuXHQgICAgICAgIGlmIChyZW5kZXJTdGF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIFwidG9nZXRoZXJcIiBtb2RlIGluIGNhc2Ugd2UndmUgc3RhcnRlZCBhIGRpZmZlcmVudFxuXHQgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG5cdCAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuXHQgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG5cdCAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuXG5cdCAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG5cdCAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcblx0ICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cdCAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG5cdCAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcblx0ICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG5cdCAgICAgICAgLy8gc28gd2UnbGwganVzdCBlbnRlciB0aGF0LiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHdlJ2xsIGJhaWwgb3V0XG5cdCAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcblx0ICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuXHQgICAgICAgIC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCByZWZhY3RvciBgYmVnaW5Xb3JrYCB0byBzcGxpdCB0aGUgYmFpbG91dFxuXHQgICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG5cdCAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7XG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICB7XG5cdCAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgLy8gVGhpcyB3aWxsIHJlc3RhcnQgdGhlIGJlZ2luIHBoYXNlIHdpdGggYSBuZXcgZmliZXIuXG5cdCAgICAgIHJldHVybiByZW1vdW50RmliZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5rZXksIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHwgbnVsbCwgd29ya0luUHJvZ3Jlc3MubW9kZSwgd29ya0luUHJvZ3Jlc3MubGFuZXMpKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXHQgICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG5cdCAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IGhhc0NvbnRleHRDaGFuZ2VkKCkgfHwgKCAvLyBGb3JjZSBhIHJlLXJlbmRlciBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZDpcblx0ICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuXHQgICAgICAvLyBJZiBwcm9wcyBvciBjb250ZXh0IGNoYW5nZWQsIG1hcmsgdGhlIGZpYmVyIGFzIGhhdmluZyBwZXJmb3JtZWQgd29yay5cblx0ICAgICAgLy8gVGhpcyBtYXkgYmUgdW5zZXQgaWYgdGhlIHByb3BzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIGVxdWFsIGxhdGVyIChtZW1vKS5cblx0ICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBOZWl0aGVyIHByb3BzIG5vciBsZWdhY3kgY29udGV4dCBjaGFuZ2VzLiBDaGVjayBpZiB0aGVyZSdzIGEgcGVuZGluZ1xuXHQgICAgICAvLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG5cdCAgICAgIHZhciBoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgPSBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcyk7XG5cblx0ICAgICAgaWYgKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgJiYgLy8gSWYgdGhpcyBpcyB0aGUgc2Vjb25kIHBhc3Mgb2YgYW4gZXJyb3Igb3Igc3VzcGVuc2UgYm91bmRhcnksIHRoZXJlXG5cdCAgICAgIC8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuXHQgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuXHQgICAgICAgIC8vIE5vIHBlbmRpbmcgdXBkYXRlcyBvciBjb250ZXh0LiBCYWlsIG91dCBub3cuXG5cdCAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuXHQgICAgICAgIHJldHVybiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcblx0ICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuXHQgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cblx0ICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbiB0aGlzIGZpYmVyLCBidXQgdGhlcmUgYXJlIG5vIG5ldyBwcm9wc1xuXHQgICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG5cdCAgICAgICAgLy8gY29uc3VtZXIgcHJvZHVjZXMgYSBjaGFuZ2VkIHZhbHVlLCBpdCB3aWxsIHNldCB0aGlzIHRvIHRydWUuIE90aGVyd2lzZSxcblx0ICAgICAgICAvLyB0aGUgY29tcG9uZW50IHdpbGwgYXNzdW1lIHRoZSBjaGlsZHJlbiBoYXZlIG5vdCBjaGFuZ2VkIGFuZCBiYWlsIG91dC5cblx0ICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuXG5cdCAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKSkge1xuXHQgICAgICAvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cblx0ICAgICAgLy8gaXRzIHBhcmVudC5cblx0ICAgICAgLy9cblx0ICAgICAgLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cblx0ICAgICAgLy8gcGFyYWxsZWwgdGhyZWFkcy4gVGhpcyB3b3VsZCByZXByZXNlbnQgdGhlIGJlZ2lubmluZyBvZiBhIG5ldyByZW5kZXJcblx0ICAgICAgLy8gdGhyZWFkIGZvciB0aGlzIHN1YnRyZWUuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIFdlIG9ubHkgdXNlIHRoaXMgZm9yIGlkIGdlbmVyYXRpb24gZHVyaW5nIGh5ZHJhdGlvbiwgd2hpY2ggaXMgd2h5IHRoZVxuXHQgICAgICAvLyBsb2dpYyBpcyBsb2NhdGVkIGluIHRoaXMgc3BlY2lhbCBicmFuY2guXG5cdCAgICAgIHZhciBzbG90SW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcblx0ICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBnZXRGb3Jrc0F0TGV2ZWwoKTtcblx0ICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcywgc2xvdEluZGV4KTtcblx0ICAgIH1cblx0ICB9IC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuXHQgIC8vIFRPRE86IFRoaXMgYXNzdW1lcyB0aGF0IHdlJ3JlIGFib3V0IHRvIGV2YWx1YXRlIHRoZSBjb21wb25lbnQgYW5kIHByb2Nlc3Ncblx0ICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuXHQgIC8vIHNvbWV0aW1lcyBiYWlscyBvdXQgbGF0ZXIgaW4gdGhlIGJlZ2luIHBoYXNlLiBUaGlzIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZFxuXHQgIC8vIG1vdmUgdGhpcyBhc3NpZ25tZW50IG91dCBvZiB0aGUgY29tbW9uIHBhdGggYW5kIGludG8gZWFjaCBicmFuY2guXG5cblxuXHQgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuXHQgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG5cdCAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cdCAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cdCAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblx0ICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBDb21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcblx0ICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cdCAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cblx0ICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudCA/IF91bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQsIF91bnJlc29sdmVkUHJvcHMpO1xuXG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50LCBfcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG5cdCAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgIGNhc2UgSG9zdFRleHQ6XG5cdCAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG5cdCAgICBjYXNlIEhvc3RQb3J0YWw6XG5cdCAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuXHQgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXHQgICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuXHQgICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG5cblx0ICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgX3Jlc29sdmVkUHJvcHMyLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBGcmFnbWVudDpcblx0ICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgIGNhc2UgTW9kZTpcblx0ICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuXHQgICAgY2FzZSBQcm9maWxlcjpcblx0ICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuXHQgICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuXHQgICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cblx0ICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXHQgICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxuXG5cdCAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLCBfdW5yZXNvbHZlZFByb3BzMyk7XG5cblx0ICAgICAgICB7XG5cdCAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcblx0ICAgICAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gX3R5cGUyLnByb3BUeXBlcztcblxuXHQgICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcblx0ICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgX3Jlc29sdmVkUHJvcHMzLCAvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuXHQgICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlMikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIudHlwZSwgX3Jlc29sdmVkUHJvcHMzKTtcblx0ICAgICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX3R5cGUyLCBfcmVzb2x2ZWRQcm9wczMsIHJlbmRlckxhbmVzKTtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCByZW5kZXJMYW5lcyk7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgX0NvbXBvbmVudDIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXHQgICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuXHQgICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudDIgPyBfdW5yZXNvbHZlZFByb3BzNCA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHM0KTtcblxuXHQgICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDIsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG5cdCAgICAgIHtcblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXHQgICAgICB9XG5cdCAgfVxuXG5cdCAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcblx0ICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG5cdCAgLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG5cdCAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKSB7XG5cdCAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmO1xuXG5cdCAge1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmU3RhdGljO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhZE5vTXV0YXRpb25zRWZmZWN0cyhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG5cdCAgdmFyIGRpZEJhaWxvdXQgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cblx0ICBpZiAoZGlkQmFpbG91dCkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgaWYgKChjb21wbGV0ZWRXb3JrLmZsYWdzICYgQ2hpbGREZWxldGlvbikgIT09IE5vRmxhZ3MpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9IC8vIFRPRE86IElmIHdlIG1vdmUgdGhlIGBoYWROb011dGF0aW9uc0VmZmVjdHNgIGNhbGwgYWZ0ZXIgYGJ1YmJsZVByb3BlcnRpZXNgXG5cdCAgLy8gdGhlbiB3ZSBvbmx5IGhhdmUgdG8gY2hlY2sgdGhlIGBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFnc2AuXG5cblxuXHQgIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cblx0ICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgIGlmICgoY2hpbGQuZmxhZ3MgJiBNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzIHx8IChjaGlsZC5zdWJ0cmVlRmxhZ3MgJiBNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0dmFyIGFwcGVuZEFsbENoaWxkcmVuO1xuXHR2YXIgdXBkYXRlSG9zdENvbnRhaW5lcjtcblx0dmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMTtcblx0dmFyIHVwZGF0ZUhvc3RUZXh0JDE7XG5cblx0aWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcblx0ICAvLyBNdXRhdGlvbiBtb2RlXG5cdCAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuXHQgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG5cdCAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cdCAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG5cdCAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG5cdCAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuXHQgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG5cdCAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcblx0ICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3Bcblx0ICB9O1xuXG5cdCAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG5cdCAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuXHQgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblx0ICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuXHQgICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuXHQgICAgICAvLyBJbiBtdXRhdGlvbiBtb2RlLCB0aGlzIGlzIHN1ZmZpY2llbnQgZm9yIGEgYmFpbG91dCBiZWNhdXNlXG5cdCAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG5cdCAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cblx0ICAgIC8vIFRPRE86IFNwbGl0IHRoZSB1cGRhdGUgQVBJIGFzIHNlcGFyYXRlIGZvciB0aGUgcHJvcHMgdnMuIGNoaWxkcmVuLlxuXHQgICAgLy8gRXZlbiBiZXR0ZXIgd291bGQgYmUgaWYgY2hpbGRyZW4gd2VyZW4ndCBzcGVjaWFsIGNhc2VkIGF0IGFsbCB0aG8uXG5cblxuXHQgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXHQgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3Rcblx0ICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG5cdCAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG5cdCAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpOyAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkOyAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcblx0ICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG5cdCAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuXHQgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuXHQgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG5cdCAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuXHQgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcblx0ICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG5cdCAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuXHQgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG5cdCAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cdCAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG5cdCAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG5cdCAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcblx0ICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuXHQgICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcblx0ICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG5cdCAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG5cdCAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcblx0ICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIG5vZGUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcblx0ICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcblx0ICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cblx0ICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG5cdCAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuXHQgICAgICAgICAgdmFyIHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG5cdCAgICAgICAgICBfaW5zdGFuY2UgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UsIHRleHQsIG5vZGUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIF9pbnN0YW5jZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSBpZiAobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcblx0ICAgICAgICAvLyBUaGUgY2hpbGRyZW4gaW4gdGhpcyBib3VuZGFyeSBhcmUgaGlkZGVuLiBUb2dnbGUgdGhlaXIgdmlzaWJpbGl0eVxuXHQgICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG5cdCAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuXHQgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIG5vZGUsIHRydWUsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG5cdCAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH0gLy8gJEZsb3dGaXhNZSBUaGlzIGlzIGNvcnJlY3QgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGxhYmVsZWQgYnJlYWsuXG5cblxuXHQgICAgICBub2RlID0gbm9kZTtcblxuXHQgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcblx0ICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcblx0ICAgIH1cblx0ICB9OyAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuXG5cdCAgdmFyIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyQ2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG5cdCAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcblx0ICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblx0ICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cblx0ICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcblx0ICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuXHQgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG5cdCAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuXHQgICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cblx0ICAgICAgICAgIHZhciBwcm9wcyA9IG5vZGUubWVtb2l6ZWRQcm9wcztcblx0ICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuXHQgICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgbm9kZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG5cdCAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBub2RlLnN0YXRlTm9kZTtcblxuXHQgICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcblx0ICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG5cdCAgICAgICAgICB2YXIgdGV4dCA9IG5vZGUubWVtb2l6ZWRQcm9wcztcblx0ICAgICAgICAgIF9pbnN0YW5jZTIgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UyLCB0ZXh0LCBub2RlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIF9pbnN0YW5jZTIpO1xuXHQgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgICAgLy8gVGhlIGNoaWxkcmVuIGluIHRoaXMgYm91bmRhcnkgYXJlIGhpZGRlbi4gVG9nZ2xlIHRoZWlyIHZpc2liaWxpdHlcblx0ICAgICAgICAvLyBiZWZvcmUgYXBwZW5kaW5nLlxuXHQgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cblx0ICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihjb250YWluZXJDaGlsZFNldCwgbm9kZSwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcblx0ICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfSAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgY29ycmVjdCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgbGFiZWxlZCBicmVhay5cblxuXG5cdCAgICAgIG5vZGUgPSBub2RlO1xuXG5cdCAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcblx0ICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuXHQgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG5cdCAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXHQgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gaGFkTm9NdXRhdGlvbnNFZmZlY3RzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuXHQgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSA7IGVsc2Uge1xuXHQgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG5cdCAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7IC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cblxuXHQgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcblx0ICAgICAgcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0OyAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuXG5cdCAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcblx0ICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcblx0ICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG5cdCAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG5cblx0ICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IGhhZE5vTXV0YXRpb25zRWZmZWN0cyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiBvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcblx0ICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG5cdCAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cblx0ICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cdCAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcblx0ICAgIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuXHQgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuXHQgICAgICB1cGRhdGVQYXlsb2FkID0gcHJlcGFyZVVwZGF0ZShyZWN5Y2xhYmxlSW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cblx0ICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuXG5cdCAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcblx0ICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICB9XG5cblx0ICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuXG5cdCAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcblx0ICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG5cdCAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIG5vdCBnb2luZyB0byB1c2UgaXQgZm9yIGFueXRoaW5nLlxuXHQgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cblx0ICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG5cdCAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuXHQgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcblx0ICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG5cdCAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXHQgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG5cdCAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuXG5cdCAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cdCAgICB9XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICAvLyBObyBob3N0IG9wZXJhdGlvbnNcblx0ICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7Ly8gTm9vcFxuXHQgIH07XG5cblx0ICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHsvLyBOb29wXG5cdCAgfTtcblxuXHQgIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHsvLyBOb29wXG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG5cdCAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcblx0ICAgIC8vIElmIHdlJ3JlIGh5ZHJhdGluZywgd2Ugc2hvdWxkIGNvbnN1bWUgYXMgbWFueSBpdGVtcyBhcyB3ZSBjYW5cblx0ICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuXHQgICAgY2FzZSAnaGlkZGVuJzpcblx0ICAgICAge1xuXHQgICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG5cdCAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG5cdCAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuXHQgICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuXHQgICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG5cdCAgICAgICAgdmFyIHRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcblx0ICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuXHQgICAgICAgIHdoaWxlICh0YWlsTm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgaWYgKHRhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5zaWJsaW5nO1xuXHQgICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuXHQgICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG5cdCAgICAgICAgaWYgKGxhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cblx0ICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcblx0ICAgICAgICAgIC8vIGluc2VydGVkLlxuXHQgICAgICAgICAgbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG5cdCAgICAgIHtcblx0ICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuXHQgICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuXHQgICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cblx0ICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcblx0ICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuXHQgICAgICAgIHZhciBfdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuXHQgICAgICAgIHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuXHQgICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgIGlmIChfdGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIF9sYXN0VGFpbE5vZGUgPSBfdGFpbE5vZGU7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIF90YWlsTm9kZSA9IF90YWlsTm9kZS5zaWJsaW5nO1xuXHQgICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuXHQgICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG5cdCAgICAgICAgaWYgKF9sYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcblx0ICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG5cdCAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIC8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcblx0ICAgICAgICAgICAgLy8gcm93IGF0IHRoZSB0YWlsLiBTbyB3ZSdsbCBrZWVwIG9uIGFuZCBjdXQgb2ZmIHRoZSByZXN0LlxuXHQgICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuXHQgICAgICAgICAgLy8gaW5zZXJ0ZWQuXG5cdCAgICAgICAgICBfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYnViYmxlUHJvcGVydGllcyhjb21wbGV0ZWRXb3JrKSB7XG5cdCAgdmFyIGRpZEJhaWxvdXQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZDtcblx0ICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgdmFyIHN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG5cblx0ICBpZiAoIWRpZEJhaWxvdXQpIHtcblx0ICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuXHQgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcblx0ICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuXHQgICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuXHQgICAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcblx0ICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuXHQgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKGNoaWxkLmxhbmVzLCBjaGlsZC5jaGlsZExhbmVzKSk7XG5cdCAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcblx0ICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3M7IC8vIFdoZW4gYSBmaWJlciBpcyBjbG9uZWQsIGl0cyBhY3R1YWxEdXJhdGlvbiBpcyByZXNldCB0byAwLiBUaGlzIHZhbHVlIHdpbGxcblx0ICAgICAgICAvLyBvbmx5IGJlIHVwZGF0ZWQgaWYgd29yayBpcyBkb25lIG9uIHRoZSBmaWJlciAoaS5lLiBpdCBkb2Vzbid0IGJhaWxvdXQpLlxuXHQgICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcblx0ICAgICAgICAvLyB0aGUgZmliZXIgaGFzIG5vdCBiZWVuIGNsb25lZCB0aG91Z2gsIChtZWFuaW5nIG5vIHdvcmsgd2FzIGRvbmUpLCB0aGVuXG5cdCAgICAgICAgLy8gdGhpcyB2YWx1ZSB3aWxsIHJlZmxlY3QgdGhlIGFtb3VudCBvZiB0aW1lIHNwZW50IHdvcmtpbmcgb24gYSBwcmV2aW91c1xuXHQgICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcblx0ICAgICAgICAvLyBjbG9uZWQgYnkgY29tcGFyaW5nIHRoZSBjaGlsZCBwb2ludGVyLlxuXG5cdCAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG5cdCAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuXHQgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcblx0ICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG5cdCAgICAgIHdoaWxlIChfY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcblx0ICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcblx0ICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLmZsYWdzOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG5cdCAgICAgICAgLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG5cdCAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cblx0ICAgICAgICBfY2hpbGQucmV0dXJuID0gY29tcGxldGVkV29yaztcblx0ICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuXHQgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcblx0ICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuXHQgICAgICB2YXIgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247XG5cdCAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuXHQgICAgICB3aGlsZSAoX2NoaWxkMiAhPT0gbnVsbCkge1xuXHQgICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkMi5sYW5lcywgX2NoaWxkMi5jaGlsZExhbmVzKSk7IC8vIFwiU3RhdGljXCIgZmxhZ3Mgc2hhcmUgdGhlIGxpZmV0aW1lIG9mIHRoZSBmaWJlci9ob29rIHRoZXkgYmVsb25nIHRvLFxuXHQgICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG5cdCAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcblx0ICAgICAgICAvLyBpZ25vcmUgdGhlbS5cblxuXHQgICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG5cdCAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuZmxhZ3MgJiBTdGF0aWNNYXNrO1xuXHQgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uICs9IF9jaGlsZDIudHJlZUJhc2VEdXJhdGlvbjtcblx0ICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgX2NoaWxkMyA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cblx0ICAgICAgd2hpbGUgKF9jaGlsZDMgIT09IG51bGwpIHtcblx0ICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcblx0ICAgICAgICAvLyBzbyB3ZSBzaG91bGQgYnViYmxlIHRob3NlIHVwIGV2ZW4gZHVyaW5nIGEgYmFpbG91dC4gQWxsIHRoZSBvdGhlclxuXHQgICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG5cdCAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cblx0ICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMy5zdWJ0cmVlRmxhZ3MgJiBTdGF0aWNNYXNrO1xuXHQgICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQzLmZsYWdzICYgU3RhdGljTWFzazsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuXHQgICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuXHQgICAgICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuXG5cdCAgICAgICAgX2NoaWxkMy5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrO1xuXHQgICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuXHQgIH1cblxuXHQgIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG5cdCAgcmV0dXJuIGRpZEJhaWxvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpIHtcblx0ICBpZiAoaGFzVW5oeWRyYXRlZFRhaWxOb2RlcygpICYmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcblx0ICAgIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXIgfCBJbmNvbXBsZXRlIHwgU2hvdWxkQ2FwdHVyZTtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICBpZiAobmV4dFN0YXRlICE9PSBudWxsICYmIG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG5cdCAgICAvLyBXZSBtaWdodCBiZSBpbnNpZGUgYSBoeWRyYXRpb24gc3RhdGUgdGhlIGZpcnN0IHRpbWUgd2UncmUgcGlja2luZyB1cCB0aGlzXG5cdCAgICAvLyBTdXNwZW5zZSBib3VuZGFyeSwgYW5kIGFsc28gYWZ0ZXIgd2UndmUgcmVlbnRlcmVkIGl0IGZvciBmdXJ0aGVyIGh5ZHJhdGlvbi5cblx0ICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICAgIGlmICghd2FzSHlkcmF0ZWQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgd2FzIGNvbXBsZXRlZCB3aXRob3V0IGEgaHlkcmF0ZWQgbm9kZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgICAge1xuXHQgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXG5cdCAgICAgICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG5cdCAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuXHQgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuXHQgICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuXHQgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgcmVlbnRlcmVkIHRoaXMgYm91bmRhcnkgdG8gaHlkcmF0ZSBpdC4gSWYgc28sIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGh5ZHJhdGlvblxuXHQgICAgICAvLyBzdGF0ZSBzaW5jZSB3ZSdyZSBub3cgZXhpdGluZyBvdXQgb2YgaXQuIHBvcEh5ZHJhdGlvblN0YXRlIGRvZXNuJ3QgZG8gdGhhdCBmb3IgdXMuXG5cdCAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcblxuXHQgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcblx0ICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGRpZCBub3Qgc3VzcGVuZCBzbyBpdCdzIG5vdyBoeWRyYXRlZCBhbmQgdW5zdXNwZW5kZWQuXG5cdCAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cdCAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gZWZmZWN0IHRvIG1hcmsgdGhpcyBib3VuZGFyeVxuXHQgICAgICAvLyBhcyBoYXZpbmcgaHlkcmF0ZWQgc28gZXZlbnRzIGtub3cgdGhhdCB0aGV5J3JlIGZyZWUgdG8gYmUgaW52b2tlZC5cblx0ICAgICAgLy8gSXQncyBhbHNvIGEgc2lnbmFsIHRvIHJlcGxheSBldmVudHMgYW5kIHRoZSBzdXNwZW5zZSBjYWxsYmFjay5cblx0ICAgICAgLy8gSWYgc29tZXRoaW5nIHN1c3BlbmRlZCwgc2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCByZXRyeSBsaXN0ZW5lcnMuXG5cdCAgICAgIC8vIFNvIHdlIG1pZ2h0IGFzIHdlbGwgYWx3YXlzIG1hcmsgdGhpcy5cblxuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcblx0ICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgICAge1xuXHQgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICB2YXIgX2lzVGltZWRPdXRTdXNwZW5zZSA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuXHQgICAgICAgICAgaWYgKF9pc1RpbWVkT3V0U3VzcGVuc2UpIHtcblx0ICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG5cdCAgICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuXHQgICAgICAgICAgICBpZiAoX3ByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3Jcblx0ICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IF9wcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBTdWNjZXNzZnVsbHkgY29tcGxldGVkIHRoaXMgdHJlZS4gSWYgdGhpcyB3YXMgYSBmb3JjZWQgY2xpZW50IHJlbmRlcixcblx0ICAgIC8vIHRoZXJlIG1heSBoYXZlIGJlZW4gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb25cblx0ICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcblx0ICAgIC8vIGNvbW1pdCBwaGFzZS5cblx0ICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7IC8vIEZhbGwgdGhyb3VnaCB0byBub3JtYWwgU3VzcGVuc2UgcGF0aFxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cdCAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcblx0ICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cblx0ICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG5cdCAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuXHQgIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuXHQgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG5cdCAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG5cdCAgICBjYXNlIExhenlDb21wb25lbnQ6XG5cdCAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgY2FzZSBGcmFnbWVudDpcblx0ICAgIGNhc2UgTW9kZTpcblx0ICAgIGNhc2UgUHJvZmlsZXI6XG5cdCAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcblx0ICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcblx0ICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXG5cdCAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cblx0ICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuXHQgICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cdCAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcblxuXHQgICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcblx0ICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuXHQgICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG5cdCAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgcG9wIHNvIHRoYXQgd2UgY2FuIGRlbGV0ZSBhbnkgcmVtYWluaW5nIGNoaWxkcmVuXG5cdCAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG5cdCAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuXHQgICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3Jcblx0ICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG5cdCAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICAgICAgICAgICAgaWYgKCAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2xpZW50IHJvb3Rcblx0ICAgICAgICAgICAgICAhcHJldlN0YXRlLmlzRGVoeWRyYXRlZCB8fCAvLyBDaGVjayBpZiB3ZSByZXZlcnRlZCB0byBjbGllbnQgcmVuZGVyaW5nIChlLmcuIGR1ZSB0byBhbiBlcnJvcilcblx0ICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikgIT09IE5vRmxhZ3MpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlXG5cdCAgICAgICAgICAgICAgICAvLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcblx0ICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5lciB3aXRoIHByZXZpb3VzIGNoaWxkcmVuLiBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3Jcblx0ICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdG9vLCBiZWNhdXNlIGN1cnJlbnQuY2hpbGQgd291bGQgb25seSBiZSBudWxsIGlmIHRoZVxuXHQgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcblx0ICAgICAgICAgICAgICAgIC8vIGJlIGVtcHR5KS5cblx0ICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90OyAvLyBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLCB0aGVyZSBtYXkgaGF2ZSBiZWVuXG5cdCAgICAgICAgICAgICAgICAvLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG5cdCAgICAgICAgICAgICAgICAvLyB0aGVtIHRvIGEgcXVldWUgc28gd2UgY2FuIGxvZyB0aGVtIGluIHRoZSBjb21taXQgcGhhc2UuXG5cblx0ICAgICAgICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG5cdCAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG5cdCAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcblx0ICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cblx0ICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG5cdCAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcblx0ICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblxuXHQgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcblx0ICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcblx0ICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSB3YW50IHRvIGFkZCB0aGVtIHRvcC0+ZG93biBvclxuXHQgICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG5cdCAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG5cdCAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG5cdCAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG5cdCAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuXHQgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG5cdCAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG5cdCAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuXHQgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuXHQgICAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuXHQgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcblx0ICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuXHQgICAgICAgICAgICBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgSG9zdFRleHQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG5cdCAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcblx0ICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzOyAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuXHQgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuXHQgICAgICAgICAgdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG5cdCAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG5cblx0ICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQyID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG5cdCAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuXHQgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG5cdCAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7IC8vIFNwZWNpYWwgcGF0aCBmb3IgZGVoeWRyYXRlZCBib3VuZGFyaWVzLiBXZSBtYXkgZXZlbnR1YWxseSBtb3ZlIHRoaXNcblx0ICAgICAgICAvLyB0byBpdHMgb3duIGZpYmVyIHR5cGUgc28gdGhhdCB3ZSBjYW4gYWRkIG90aGVyIGtpbmRzIG9mIGh5ZHJhdGlvblxuXHQgICAgICAgIC8vIGJvdW5kYXJpZXMgdGhhdCBhcmVuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgU3VzcGVuc2UgdHJlZS4gSW4gYW50aWNpcGF0aW9uXG5cdCAgICAgICAgLy8gb2Ygc3VjaCBhIHJlZmFjdG9yLCBhbGwgdGhlIGh5ZHJhdGlvbiBsb2dpYyBpcyBjb250YWluZWQgaW5cblx0ICAgICAgICAvLyB0aGlzIGJyYW5jaC5cblxuXHQgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgdmFyIGZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGggPSBjb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpO1xuXG5cdCAgICAgICAgICBpZiAoIWZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGgpIHtcblx0ICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuXHQgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZS4gVGhlcmUgd2VyZSByZW1haW5pbmcgdW5oeWRyYXRlZCBub2Rlcy4gV2UgdHJlYXRcblx0ICAgICAgICAgICAgICAvLyB0aGlzIGFzIGEgbWlzbWF0Y2guIFJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlxuXHQgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAvLyBEaWQgbm90IGZpbmlzaCBoeWRyYXRpbmcsIGVpdGhlciBiZWNhdXNlIHRoaXMgaXMgdGhlIGluaXRpYWxcblx0ICAgICAgICAgICAgICAvLyByZW5kZXIgb3IgYmVjYXVzZSBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXHQgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IC8vIENvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCBTdXNwZW5zZSBwYXRoLlxuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG5cdCAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzOyAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuXG5cdCAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgICB9IC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuXG5cdCAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG5leHREaWRUaW1lb3V0ID0gbmV4dFN0YXRlICE9PSBudWxsO1xuXHQgICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXHQgICAgICAgIC8vIGEgcGFzc2l2ZSBlZmZlY3QsIHdoaWNoIGlzIHdoZW4gd2UgcHJvY2VzcyB0aGUgdHJhbnNpdGlvbnNcblxuXG5cdCAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICE9PSBwcmV2RGlkVGltZW91dCkge1xuXHQgICAgICAgICAgLy8gYW4gZWZmZWN0IHRvIHRvZ2dsZSB0aGUgc3VidHJlZSdzIHZpc2liaWxpdHkuIFdoZW4gd2Ugc3dpdGNoIGZyb21cblx0ICAgICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG5cdCAgICAgICAgICAvLyBhcyBwYXJ0IG9mIGl0cyBub3JtYWwgY29tcGxldGUgcGhhc2UuIEJ1dCB3aGVuIHdlIHN3aXRjaCBmcm9tXG5cdCAgICAgICAgICAvLyBwcmltYXJ5IC0+IGZhbGxiYWNrLCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIGRvZXMgbm90IGhhdmUgYSBjb21wbGV0ZVxuXHQgICAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuXHQgICAgICAgICAgLy9cblx0ICAgICAgICAgIC8vIFdlIGFsc28gdXNlIHRoaXMgZmxhZyB0byBjb25uZWN0L2Rpc2Nvbm5lY3QgdGhlIGVmZmVjdHMsIGJ1dCB0aGUgc2FtZVxuXHQgICAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcblx0ICAgICAgICAgIC8vIHBoYXNlIHdpbGwgaGFuZGxlIHNjaGVkdWxpbmcgdGhlIGVmZmVjdC4gSXQncyBvbmx5IHdoZW4gdGhlIGZhbGxiYWNrXG5cdCAgICAgICAgICAvLyBpcyBhY3RpdmUgdGhhdCB3ZSBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwuXG5cblxuXHQgICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG5cdCAgICAgICAgICAgIHZhciBfb2Zmc2NyZWVuRmliZXIyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cdCAgICAgICAgICAgIF9vZmZzY3JlZW5GaWJlcjIuZmxhZ3MgfD0gVmlzaWJpbGl0eTsgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG5cdCAgICAgICAgICAgIC8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIGEga25vd24gYnVnLlxuXG5cdCAgICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGJhY2sgdG8gdGhyb3dFeGNlcHRpb24gYmVjYXVzZSB0aGlzIGlzIHRvbyBsYXRlXG5cdCAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxhcmdlIHRyZWUgd2hpY2ggaXMgY29tbW9uIGZvciBpbml0aWFsIGxvYWRzLiBXZVxuXHQgICAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuXHQgICAgICAgICAgICAgIC8vIHRoaXMgbWFya2VyLCBhbmQgdGhpcyBpcyB0b28gbGF0ZS5cblx0ICAgICAgICAgICAgICAvLyBJZiB0aGlzIHJlbmRlciBhbHJlYWR5IGhhZCBhIHBpbmcgb3IgbG93ZXIgcHJpIHVwZGF0ZXMsXG5cdCAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG5cdCAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFibGUgdG8gaW1tZWRpYXRlbHkgcmVzdGFydCBmcm9tIHdpdGhpbiB0aHJvd0V4Y2VwdGlvbi5cblx0ICAgICAgICAgICAgICB2YXIgaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0ID0gY3VycmVudCA9PT0gbnVsbCAmJiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZSB8fCAhZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayk7XG5cblx0ICAgICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcblx0ICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG5cdCAgICAgICAgICAgICAgICAvLyB0aGlzIGJvdW5kYXJ5IGlzIG9rLlxuXHQgICAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gaGlkZSBjb250ZW50IHNvIHdlIHNob3VsZFxuXHQgICAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuXHQgICAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciB3YWtlYWJsZXMgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblxuXHQgICAgICAgIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcblx0ICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYSByZXRyeSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZS5cblx0ICAgICAgICAgIC8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxuXHQgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG5cdCAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG5cdCAgICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cblx0ICAgICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG5cdCAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0UG9ydGFsOlxuXHQgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcblx0ICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuXHQgICAgICB9XG5cblx0ICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXG5cdCAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcblx0ICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG5cdCAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcblx0ICAgICAgcG9wUHJvdmlkZXIoY29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cblx0ICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgLy8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG5cdCAgICAgICAgLy8gc2VxdWVudGlhbCB0byBlbnN1cmUgdGhpcyBzd2l0Y2ggaXMgY29tcGlsZWQgdG8gYSBqdW1wIHRhYmxlLlxuXHQgICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuXHQgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuXHQgICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cblx0ICAgICAgICBpZiAocmVuZGVyU3RhdGUgPT09IG51bGwpIHtcblx0ICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuXHQgICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuXHQgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZGlkU3VzcGVuZEFscmVhZHkgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblx0ICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG5cdCAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gV2UganVzdCByZW5kZXJlZCB0aGUgaGVhZC5cblx0ICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcblx0ICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG5cdCAgICAgICAgICAgIC8vIHN1c3BlbmRlZCBpbiB0aGUgcmVuZGVyZWQgc2V0LlxuXHQgICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcblx0ICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG5cdCAgICAgICAgICAgIC8vIHRvIGtlZXAgc2hvd2luZyB0aGVpciBmYWxsYmFja3MuXG5cdCAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG5cdCAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG5cdCAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gY2hhbmNlIHNvIHdlIGNhbiBza2lwIHRoZSBleHBlbnNpdmUgY2FsbCB0b1xuXHQgICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG5cdCAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG5cdCAgICAgICAgICAgIGlmICghY2Fubm90QmVTdXNwZW5kZWQpIHtcblx0ICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cblx0ICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJvdyk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuXHQgICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuXHQgICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cblx0ICAgICAgICAgICAgICAgICAgLy8gaXRzIHRoZW5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5hYmxlcyB0byB0aGVcblx0ICAgICAgICAgICAgICAgICAgLy8gU3VzcGVuc2VMaXN0IHNvIHRoYXQgaXQgY2FuIHJldHJ5IGlmIHRoZXkgcmVzb2x2ZS5cblx0ICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG5cdCAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIHdhaXQgZm9yIGFsbCBvZiB0aGVtIGFueXdheSwgaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG5cdCAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG9uZXMgZ2V0cyB0byBwaW5nLiBJbiB0aGVvcnkgd2UgY291bGQgZ2V0IGNsZXZlciBhbmQga2VlcFxuXHQgICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG5cdCAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtZWFudGltZSwgd2UgY2FuIGFkZC9yZW1vdmUvY2hhbmdlIGl0ZW1zIGFuZCBkZXBlbmRlbmNpZXMuXG5cdCAgICAgICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJhaWwgb3V0IG9mIHRoZSBsb29wIGJlZm9yZSBmaW5kaW5nIGFueSBidXQgdGhhdFxuXHQgICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuXHQgICAgICAgICAgICAgICAgICAvLyB3ZSBkaWQgZmluZCBhbHJlYWR5IGhhcyB0aGVpciBsaXN0ZW5lcnMgYXR0YWNoZWQuXG5cblx0ICAgICAgICAgICAgICAgICAgdmFyIG5ld1RoZW5hYmxlcyA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuXHQgICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBuZXdUaGVuYWJsZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXHQgICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3Ncblx0ICAgICAgICAgICAgICAgICAgLy8gdG8gc3RheSBpbiBwbGFjZS5cblx0ICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBiZWZvcmUgZG9pbmcgdGhlIHNlY29uZCBwYXNzIHNpbmNlIHRoYXQncyBub3cgaW52YWxpZC5cblx0ICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuXG5cdCAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG5cdCAgICAgICAgICAgICAgICAgIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTsgLy8gU2V0IHVwIHRoZSBTdXNwZW5zZSBDb250ZXh0IHRvIGZvcmNlIHN1c3BlbnNlIGFuZCBpbW1lZGlhdGVseVxuXHQgICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cblx0ICAgICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpOyAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByb3cgPSByb3cuc2libGluZztcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCAmJiBub3coKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuXHQgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBidXQgd2Ugc3RpbGwgaGF2ZSByb3dzXG5cdCAgICAgICAgICAgICAgLy8gbGVmdCBpbiB0aGUgdGFpbC4gV2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gcmVuZGVyXG5cdCAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuXHQgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG5cdCAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuXHQgICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuXHQgICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcblx0ICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcblx0ICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuXHQgICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cblx0ICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuXHQgICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuXHQgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG5cdCAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuXHQgICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuXHQgICAgICAgICAgICB2YXIgX3N1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyZW5kZXJlZFRhaWwpO1xuXG5cdCAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcblx0ICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7IC8vIEVuc3VyZSB3ZSB0cmFuc2ZlciB0aGUgdXBkYXRlIHF1ZXVlIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBkb2Vzbid0XG5cdCAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG5cdCAgICAgICAgICAgICAgdmFyIF9uZXdUaGVuYWJsZXMgPSBfc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG5cdCAgICAgICAgICAgICAgaWYgKF9uZXdUaGVuYWJsZXMgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gX25ld1RoZW5hYmxlcztcblx0ICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuXHQgICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuXHQgICAgICAgICAgICAgICkge1xuXHQgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lLlxuXHQgICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG5cdCAgICAgICAgICAgIC8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG5cdCAgICAgICAgICAgIC8vIGV4Y2VlZCBpdC5cblx0ICAgICAgICAgICAgbm93KCkgKiAyIC0gcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpICYmIHJlbmRlckxhbmVzICE9PSBPZmZzY3JlZW5MYW5lKSB7XG5cdCAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG5cdCAgICAgICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVuZGVyIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cblx0ICAgICAgICAgICAgICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG5cdCAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcblx0ICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG5cdCAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG5cdCAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuXHQgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuXHQgICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG5cdCAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuXHQgICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG5cdCAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG5cdCAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuXHQgICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGxpc3Qgb2YgdGhlIGJhY2t3YXJkcyB0YWlsIHdpbGwgaGF2ZSBiZWVuIGFkZGVkXG5cdCAgICAgICAgICAgIC8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG5cdCAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuXHQgICAgICAgICAgICAvLyBFc3BlY2lhbGx5IHNpbmNlIHRoZXNlIG1pZ2h0IGFsc28ganVzdCBwb3AgaW4gZHVyaW5nIGZ1dHVyZSBjb21taXRzLlxuXHQgICAgICAgICAgICAvLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cblx0ICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblx0ICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuXHQgICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJlZFRhaWw7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIHRhaWwgcm93cyB0byByZW5kZXIuXG5cdCAgICAgICAgICAvLyBQb3AgYSByb3cuXG5cdCAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG5cdCAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBuZXh0O1xuXHQgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG5leHQuc2libGluZztcblx0ICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdygpO1xuXHQgICAgICAgICAgbmV4dC5zaWJsaW5nID0gbnVsbDsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC5cblx0ICAgICAgICAgIC8vIFRPRE86IFdlIGNhbiBwcm9iYWJseSBqdXN0IGF2b2lkIHBvcHBpbmcgaXQgaW5zdGVhZCBhbmQgb25seVxuXHQgICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG5cdCAgICAgICAgICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuXG5cdCAgICAgICAgICBpZiAoZGlkU3VzcGVuZEFscmVhZHkpIHtcblx0ICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBEbyBhIHBhc3Mgb3ZlciB0aGUgbmV4dCByb3cuXG5cdCAgICAgICAgICAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblx0ICAgICAgICAgIHJldHVybiBuZXh0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG5cdCAgICAgIHtcblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuXHQgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG5cdCAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXHQgICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsO1xuXG5cdCAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgIHZhciBfcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXHQgICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUgIT09IG51bGw7XG5cblx0ICAgICAgICAgIGlmIChwcmV2SXNIaWRkZW4gIT09IG5leHRJc0hpZGRlbiAmJiAoIC8vIExlZ2FjeUhpZGRlbiBkb2Vzbid0IGRvIGFueSBoaWRpbmcg4oCUIGl0IG9ubHkgcHJlLXJlbmRlcnMuXG5cdCAgICAgICAgICAhZW5hYmxlTGVnYWN5SGlkZGVuICkpIHtcblx0ICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIW5leHRJc0hpZGRlbiB8fCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgZm9yIGhpZGRlbiBjaGlsZHJlbiB1bmxlc3Mgd2UncmUgcmVuZGVyaW5nXG5cdCAgICAgICAgICAvLyBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuXG5cdCAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG5cdCAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG5cdCAgICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG5cdCAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGFuIGluc2VydGlvbiBvciB1cGRhdGUgaW4gdGhlIGhpZGRlbiBzdWJ0cmVlLlxuXHQgICAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBuZWVkIHRvIGhpZGUgdGhvc2Ugbm9kZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSwgc29cblx0ICAgICAgICAgICAgICAvLyBzY2hlZHVsZSBhIHZpc2liaWxpdHkgZWZmZWN0LlxuXHQgICAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG5cdCAgICAgIHtcblxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcblx0ICAgICAge1xuXG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblx0ICB9XG5cblx0ICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcblx0ICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcblx0ICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cblx0ICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG5cdCAgLy8gZm9yIGh5ZHJhdGlvbi5cblx0ICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cblx0ICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuXHQgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG5cdCAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcblx0ICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG5cdCAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuXHQgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBmbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcblxuXHQgICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAge1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblx0ICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuXHQgICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuXHQgICAgICAgIGlmICgoX2ZsYWdzICYgU2hvdWxkQ2FwdHVyZSkgIT09IE5vRmxhZ3MgJiYgKF9mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG5cdCAgICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3IgZHVyaW5nIHJlbmRlciB0aGF0IHdhc24ndCBjYXB0dXJlZCBieSBhIHN1c3BlbnNlXG5cdCAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cblx0ICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXHQgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuXHQgICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgSG9zdENvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIC8vIFRPRE86IHBvcEh5ZHJhdGlvblN0YXRlXG5cdCAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuXHQgICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuXHQgICAgICAgIGlmIChfZmxhZ3MyICYgU2hvdWxkQ2FwdHVyZSkge1xuXHQgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MyICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlOyAvLyBDYXB0dXJlZCBhIHN1c3BlbnNlIGVmZmVjdC4gUmUtcmVuZGVyIHRoZSBib3VuZGFyeS5cblxuXHQgICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cblx0ICAgICAgICAvLyBjYXVnaHQgYnkgYSBuZXN0ZWQgYm91bmRhcnkuIElmIG5vdCwgaXQgc2hvdWxkIGJ1YmJsZSB0aHJvdWdoLlxuXG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0UG9ydGFsOlxuXHQgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cblx0ICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuXHQgICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG5cdCAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cblx0ICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuXHQgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG5cdCAgICAgIHBvcFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzKTtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cblx0ICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG5cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmssIHJlbmRlckxhbmVzKSB7XG5cdCAgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG5cdCAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG5cdCAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuXHQgIC8vIGZvciBoeWRyYXRpb24uXG5cdCAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblxuXHQgIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuXHQgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG5cdCAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEhvc3RSb290OlxuXHQgICAgICB7XG5cdCAgICAgICAgaW50ZXJydXB0ZWRXb3JrLnN0YXRlTm9kZTtcblx0ICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG5cdCAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7XG5cdCAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEhvc3RQb3J0YWw6XG5cdCAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG5cdCAgICAgIHZhciBjb250ZXh0ID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuX2NvbnRleHQ7XG5cdCAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcblx0ICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuXHQgICAgICBwb3BSZW5kZXJMYW5lcyhpbnRlcnJ1cHRlZFdvcmspO1xuXHQgICAgICBicmVhaztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcblx0ICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG5cdCAgdHJ5IHtcblx0ICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxuXHR7XG5cdCAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cblx0ICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcblx0ICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuXHQgIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG5cdCAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcblx0ICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG5cdCAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcblx0ICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG5cdCAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG5cdCAgLy9cblx0ICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG5cdCAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG5cdCAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcblx0ICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG5cdCAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcblx0ICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cblx0ICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuXHQgIC8vIHRyeS1jYXRjaC4gTmVhdCFcblx0ICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG5cdCAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG5cdCAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuXHQgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG5cdCAgICAgIC8vIElmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3Qgd2Uga25vdyBmb3Igc3VyZSB3ZSB3aWxsIGNyYXNoIGluIHRoaXMgbWV0aG9kXG5cdCAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuXHQgICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG5cdCAgICAgIC8vIFNvIHdlIHByZWVtcHRpdmVseSB0aHJvdyB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UgaW5zdGVhZC5cblx0ICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnICsgJ2RlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCAnICsgJ3NjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSAnICsgJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnICsgJ3RoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCAnICsgJ2NhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgJyArICd0byBiZSBhc3luY2hyb25vdXMuJyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cdCAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG5cdCAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcblx0ICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuXHQgICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcblx0ICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG5cdCAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG5cblx0ICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuXHQgICAgICAvLyBkdXJpbmcgdGhlIGNhbGxiYWNrIHRvIGxldCB1c2VyIGNvZGUgYWNjZXNzIHdpbmRvdy5ldmVudCBpbiB0aGVcblx0ICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuXG5cdCAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcblx0ICAgICAgLy8gZGlzcGF0Y2hpbmc6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2ODhcblxuXHQgICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG5cdCAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuXHQgICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuXHQgICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuXHQgICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG5cdCAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuXHQgICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFdlIGNoZWNrIGZvciB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykgdG8gcHJldmVudCB0aGVcblx0ICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3Jcblx0ICAgICAgICAvLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3Rcblx0ICAgICAgICAvLyBzdXBwb3J0IHdpbmRvdy5ldmVudC5cblxuXHQgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcblx0ICAgICAgICAgIHdpbmRvdy5ldmVudCA9IHdpbmRvd0V2ZW50O1xuXHQgICAgICAgIH1cblx0ICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuXHQgICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2Vcblx0ICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cblxuXG5cdCAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cblx0ICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuXHQgICAgICAgIGRpZENhbGwgPSB0cnVlO1xuXHQgICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG5cdCAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG5cdCAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcblx0ICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcblx0ICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG5cdCAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG5cdCAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2Zcblx0ICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuXHQgICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcblx0ICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuXHQgICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG5cdCAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuXHQgICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cblx0ICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG5cblxuXHQgICAgICB2YXIgZXJyb3I7IC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuXG5cdCAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuXHQgICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cblx0ICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcblx0ICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuXHQgICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcblx0ICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcblx0ICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG5cdCAgICAgICAgICAvLyBCcm93c2VycyBzaWxlbmNlIHRoZSBlcnJvciByZXBvcnQgaWYgdGhpcyBoYXBwZW5zLlxuXHQgICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuXHQgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG5cblxuXHQgICAgICB2YXIgZXZ0VHlwZSA9IFwicmVhY3QtXCIgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7IC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcblxuXHQgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG5cdCAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG5cdCAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cblxuXHQgICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG5cdCAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuXHQgICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChkaWRDYWxsICYmIGRpZEVycm9yKSB7XG5cdCAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuXHQgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG5cdCAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuXHQgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcblx0ICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cdCAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuXHQgICAgICB9IC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG5cblxuXHQgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG5cblx0ICAgICAgaWYgKCFkaWRDYWxsKSB7XG5cdCAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nLCBhbmQgb3VyIGV2ZW50IHdhcyBub3QgZGlzcGF0Y2hlZC5cblx0ICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NzM0XG5cdCAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuXHQgICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgcHJvZHVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cblx0ICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuXHQgICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cblx0dmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cblx0dmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cdHZhciBjYXVnaHRFcnJvciA9IG51bGw7IC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG5cdHZhciByZXBvcnRlciA9IHtcblx0ICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgIGhhc0Vycm9yID0gdHJ1ZTtcblx0ICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG5cdCAgfVxuXHR9O1xuXHQvKipcblx0ICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG5cdCAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cblx0ICpcblx0ICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuXHQgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcblx0ICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuXHQgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cblx0ICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cblx0ICovXG5cblx0ZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcblx0ICBoYXNFcnJvciA9IGZhbHNlO1xuXHQgIGNhdWdodEVycm9yID0gbnVsbDtcblx0ICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG5cdH1cblx0ZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKSB7XG5cdCAgcmV0dXJuIGhhc0Vycm9yO1xuXHR9XG5cdGZ1bmN0aW9uIGNsZWFyQ2F1Z2h0RXJyb3IoKSB7XG5cdCAgaWYgKGhhc0Vycm9yKSB7XG5cdCAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcblx0ICAgIGhhc0Vycm9yID0gZmFsc2U7XG5cdCAgICBjYXVnaHRFcnJvciA9IG51bGw7XG5cdCAgICByZXR1cm4gZXJyb3I7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuXG5cdHtcblx0ICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcblx0fSAvLyBVc2VkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCBzdGFjay5cblx0Ly8gQWxsb3dzIHVzIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHJldHVybiBwYXRoIHRvIGZpbmQgdGhlIG5lYXJlc3QgT2Zmc2NyZWVuIGFuY2VzdG9yLlxuXHQvLyBPbmx5IHVzZWQgd2hlbiBlbmFibGVTdXNwZW5zZUxheW91dEVmZmVjdFNlbWFudGljcyBpcyBlbmFibGVkLlxuXG5cblx0dmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGZhbHNlO1xuXHR2YXIgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGZhbHNlO1xuXHR2YXIgUG9zc2libHlXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgPyBXZWFrU2V0IDogU2V0O1xuXHR2YXIgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG5cblx0dmFyIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG5cdHZhciBpblByb2dyZXNzUm9vdCA9IG51bGw7XG5cdGZ1bmN0aW9uIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcikge1xuXHQgIC8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG5cdCAgLy8gY2FsbGJhY2sgaXMgYSBiaXQgdG9vIHNsb3cgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIxNjY2KS5cblx0ICAvLyBCdXQgd2UgcmVseSBvbiBpdCB0byBzdXJmYWNlIGVycm9ycyB0byBERVYgdG9vbHMgbGlrZSBvdmVybGF5c1xuXHQgIC8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cblx0ICAvLyBBcyBhIGNvbXByb21pc2UsIHJldGhyb3cgb25seSBjYXVnaHQgZXJyb3JzIGluIGEgZ3VhcmQuXG5cdCAge1xuXHQgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICB9KTtcblx0ICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG5cdCAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cdCAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cblx0ICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG5cdCAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdCAgICB9IGZpbmFsbHkge1xuXHQgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0ICB9XG5cdH07IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cblx0ZnVuY3Rpb24gc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuXHQgIHRyeSB7XG5cdCAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCwgY3VycmVudCk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcblx0ICB9XG5cdH0gLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cblxuXG5cdGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSkge1xuXHQgIHRyeSB7XG5cdCAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIoY3VycmVudCwgaW5zdGFuY2UpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG5cdCAgfVxuXHR9IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cblx0ZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudERpZE1vdW50KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGluc3RhbmNlKSB7XG5cdCAgdHJ5IHtcblx0ICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcblx0ICB9XG5cdH0gLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgbW91bnRpbmcuXG5cblxuXHRmdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuXHQgIHRyeSB7XG5cdCAgICBjb21taXRBdHRhY2hSZWYoY3VycmVudCk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuXHQgIHZhciByZWYgPSBjdXJyZW50LnJlZjtcblxuXHQgIGlmIChyZWYgIT09IG51bGwpIHtcblx0ICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhciByZXRWYWw7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzICYmIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG5cdCAgICAgICAgICAgIHJldFZhbCA9IHJlZihudWxsKTtcblx0ICAgICAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXRWYWwgPSByZWYobnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHtcblx0ICAgICAgICBpZiAodHlwZW9mIHJldFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KSB7XG5cdCAgdHJ5IHtcblx0ICAgIGRlc3Ryb3koKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuXHQgIH1cblx0fVxuXHR2YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG5cdGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG5cdCAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXHQgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuXHQgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cblx0ICB2YXIgc2hvdWxkRmlyZSA9IHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcblx0ICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcblx0ICByZXR1cm4gc2hvdWxkRmlyZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpIHtcblx0ICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDsgLy8gVGhpcyBwaGFzZSBpcyBvbmx5IHVzZWQgZm9yIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ci5cblxuXHQgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cblx0ICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgQmVmb3JlTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyAmJiBjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICBjaGlsZC5yZXR1cm4gPSBmaWJlcjtcblx0ICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCkge1xuXHQgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuXHQgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG5cdCAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG5cdCAgICB9XG5cblx0ICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG5cdCAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cblx0ICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG5cdCAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuXHQgICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrKSB7XG5cdCAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXHQgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuXHQgIGlmICgoZmxhZ3MgJiBTbmFwc2hvdCkgIT09IE5vRmxhZ3MpIHtcblx0ICAgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG5cdCAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcblx0ICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblx0ICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblx0ICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuXHQgICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cblx0ICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuXHQgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGUgPyBwcmV2UHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBwcmV2UHJvcHMpLCBwcmV2U3RhdGUpO1xuXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICB2YXIgZGlkV2FyblNldCA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuXG5cdCAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuXHQgICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG5cdCAgICAgICAgICAgICAgICBlcnJvcignJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgJyArICdtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuXHQgICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cdCAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIGNhc2UgSG9zdFRleHQ6XG5cdCAgICAgIGNhc2UgSG9zdFBvcnRhbDpcblx0ICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChmbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG5cdCAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXHQgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuXHQgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG5cdCAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgaWYgKChlZmZlY3QudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuXHQgICAgICAgIC8vIFVubW91bnRcblx0ICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXHQgICAgICAgIGVmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG5cdCAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG5cdCAgICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCh0cnVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuXG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzJDEpIHtcblx0ICAgICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcblx0ICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuXHQgICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG5cdCAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXHQgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuXHQgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG5cdCAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgaWYgKChlZmZlY3QudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcblx0ICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG5cdCAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IC8vIE1vdW50XG5cblxuXHQgICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUoKTtcblxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzJDEpIHtcblx0ICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB7XG5cdCAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG5cdCAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFyIGRlc3Ryb3kgPSBlZmZlY3QuZGVzdHJveTtcblxuXHQgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG5cblx0ICAgICAgICAgICAgaWYgKChlZmZlY3QudGFnICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuXHQgICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoKGVmZmVjdC50YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlSW5zZXJ0aW9uRWZmZWN0Jztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VFZmZlY3QnO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG5cdCAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgYWRkZW5kdW0gPSAnIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuICcgKyAndXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLic7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlICcgKyBob29rTmFtZSArICcoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyBob29rTmFtZSArICcoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGVycm9yKCclcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgaG9va05hbWUsIGFkZGVuZHVtKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcblx0ICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcblx0ICB7XG5cdCAgICAvLyBPbmx5IFByb2ZpbGVycyB3aXRoIHdvcmsgaW4gdGhlaXIgc3VidHJlZSB3aWxsIGhhdmUgYW4gVXBkYXRlIGVmZmVjdCBzY2hlZHVsZWQuXG5cdCAgICBpZiAoKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkgIT09IE5vRmxhZ3MpIHtcblx0ICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG5cdCAgICAgICAgY2FzZSBQcm9maWxlcjpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuXHQgICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG5cdCAgICAgICAgICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcblx0ICAgICAgICAgICAgICAgIG9uUG9zdENvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblBvc3RDb21taXQ7IC8vIFRoaXMgdmFsdWUgd2lsbCBzdGlsbCByZWZsZWN0IHRoZSBwcmV2aW91cyBjb21taXQgcGhhc2UuXG5cdCAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IGdldCByZXNldCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0IHBoYXNlLlxuXG5cdCAgICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuXHQgICAgICAgICAgICB2YXIgcGhhc2UgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpIHtcblx0ICAgICAgICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Qb3N0Q29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0KGlkLCBwaGFzZSwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcblx0ICAgICAgICAgICAgfSAvLyBCdWJibGUgdGltZXMgdG8gdGhlIG5leHQgbmVhcmVzdCBhbmNlc3RvciBQcm9maWxlci5cblx0ICAgICAgICAgICAgLy8gQWZ0ZXIgd2UgcHJvY2VzcyB0aGF0IFByb2ZpbGVyLCB3ZSdsbCBidWJibGUgZnVydGhlciB1cC5cblxuXG5cdCAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cblx0ICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuXHQgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblx0ICAgICAgICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gcGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcblxuXHQgICAgICAgICAgICAgICAgY2FzZSBQcm9maWxlcjpcblx0ICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblx0ICAgICAgICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuXHQgIGlmICgoZmluaXNoZWRXb3JrLmZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MpIHtcblx0ICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuXHQgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIEZvcndhcmRSZWY6XG5cdCAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBpZiAoICFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG5cdCAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgbGF5b3V0IGVmZmVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIChkdXJpbmcgbXV0YXRpb24gcGhhc2UpLlxuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcHJldmVudCBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuXHQgICAgICAgICAgICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcblx0ICAgICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cblx0ICAgICAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG5cdCAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcblx0ICAgICAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgICAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG5cdCAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuXHQgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG5cdCAgICAgICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cblx0ICAgICAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblx0ICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcblx0ICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG5cdCAgICAgICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cblx0ICAgICAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXHQgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuXHQgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSAvLyBUT0RPOiBJIHRoaW5rIHRoaXMgaXMgbm93IGFsd2F5cyBub24tbnVsbCBieSB0aGUgdGltZSBpdCByZWFjaGVzIHRoZVxuXHQgICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cblxuXG5cdCAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cblx0ICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcblx0ICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG5cdCAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuXHQgICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cblxuXHQgICAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIEhvc3RSb290OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG5cdCAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuXHQgICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuXHQgICAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbnVsbDtcblxuXHQgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO1xuXHQgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcblx0ICAgICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcblx0ICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcblx0ICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG5cdCAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG5cdCAgICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuXHQgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG5cdCAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuXHQgICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgSG9zdFRleHQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIEhvc3RQb3J0YWw6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIFByb2ZpbGVyOlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcblx0ICAgICAgICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcblx0ICAgICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcblx0ICAgICAgICAgICAgdmFyIGVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbjtcblx0ICAgICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG5cdCAgICAgICAgICAgIHZhciBwaGFzZSA9IGN1cnJlbnQgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cblx0ICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgIG9uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBwaGFzZSwgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgY29tbWl0VGltZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgb25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBlZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG5cdCAgICAgICAgICAgICAgfSAvLyBTY2hlZHVsZSBhIHBhc3NpdmUgZWZmZWN0IGZvciB0aGlzIFByb2ZpbGVyIHRvIGNhbGwgb25Qb3N0Q29tbWl0IGhvb2tzLlxuXHQgICAgICAgICAgICAgIC8vIFRoaXMgZWZmZWN0IHNob3VsZCBiZSBzY2hlZHVsZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBvblBvc3RDb21taXQgY2FsbGJhY2sgZm9yIHRoaXMgUHJvZmlsZXIsXG5cdCAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5cblxuXHQgICAgICAgICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpbmlzaGVkV29yayk7IC8vIFByb3BhZ2F0ZSBsYXlvdXQgZWZmZWN0IGR1cmF0aW9ucyB0byB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yLlxuXHQgICAgICAgICAgICAgIC8vIERvIG5vdCByZXNldCB0aGVzZSB2YWx1ZXMgdW50aWwgdGhlIG5leHQgcmVuZGVyIHNvIERldlRvb2xzIGhhcyBhIGNoYW5jZSB0byByZWFkIHRoZW0gZmlyc3QuXG5cblx0ICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG5cdCAgICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcblx0ICAgICAgICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblx0ICAgICAgICAgICAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IGVmZmVjdER1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG5cdCAgICAgICAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcblx0ICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG5cdCAgICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKCAhb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuXHQgICAge1xuXHQgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgUmVmKSB7XG5cdCAgICAgICAgY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yayk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyKG5vZGUpIHtcblx0ICAvLyBUdXJuIG9uIGxheW91dCBlZmZlY3RzIGluIGEgdHJlZSB0aGF0IHByZXZpb3VzbHkgZGlzYXBwZWFyZWQuXG5cdCAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBMYXlvdXRTdGF0aWNcblx0ICBzd2l0Y2ggKG5vZGUudGFnKSB7XG5cdCAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgaWYgKCBub2RlLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuXHQgICAgICAgICAgICBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLCBub2RlLnJldHVybik7XG5cdCAgICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihub2RlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuXHQgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnREaWRNb3VudChub2RlLCBub2RlLnJldHVybiwgaW5zdGFuY2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHNhZmVseUF0dGFjaFJlZihub2RlLCBub2RlLnJldHVybik7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgc2FmZWx5QXR0YWNoUmVmKG5vZGUsIG5vZGUucmV0dXJuKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pIHtcblx0ICAvLyBPbmx5IGhpZGUgb3IgdW5oaWRlIHRoZSB0b3AtbW9zdCBob3N0IG5vZGVzLlxuXHQgIHZhciBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuXG5cdCAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcblx0ICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcblx0ICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblx0ICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG5cdCAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcblx0ICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG5cdCAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBub2RlO1xuXG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcblx0ICAgICAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHVuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG5cdCAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTMgPSBub2RlLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcblx0ICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHVuaGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UzLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuXHQgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcblx0ICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcblx0ICAgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbm9kZSkge1xuXHQgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG5cdCAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuXHQgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuXG5cdCAgaWYgKHJlZiAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblx0ICAgIHZhciBpbnN0YW5jZVRvVXNlO1xuXG5cdCAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcblx0ICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICBpbnN0YW5jZVRvVXNlID0gaW5zdGFuY2U7XG5cdCAgICB9IC8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuXG5cdCAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICB2YXIgcmV0VmFsO1xuXG5cdCAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG5cdCAgICAgICAgICByZXRWYWwgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG5cdCAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldFZhbCA9IHJlZihpbnN0YW5jZVRvVXNlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHtcblx0ICAgICAgICBpZiAodHlwZW9mIHJldFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAge1xuXHQgICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcblx0ICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcblx0ICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlciB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuXG5cdCAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIGRldGVjdCBhbmQgd2FybiBhZ2FpbnN0IHN0YXRlIHVwZGF0ZXMgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cblx0ICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuXHQgIC8vXG5cdCAgLy8gSWRlYWxseSwgd2Ugc2hvdWxkIGFsc28gY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcblx0ICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG5cdCAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuXG5cdCAgLy8gVGhpcyBjaGlsZCBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuXHQgIC8vXG5cdCAgLy8gTm90ZSB0aGF0IHdlIGNhbid0IGNsZWFyIGNoaWxkIG9yIHNpYmxpbmcgcG9pbnRlcnMgeWV0LlxuXHQgIC8vIFRoZXkncmUgbmVlZGVkIGZvciBwYXNzaXZlIGVmZmVjdHMgYW5kIGZvciBmaW5kRE9NTm9kZS5cblx0ICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG5cdCAgLy9cblx0ICAvLyBEb24ndCByZXNldCB0aGUgYWx0ZXJuYXRlIHlldCwgZWl0aGVyLiBXZSBuZWVkIHRoYXQgc28gd2UgY2FuIGRldGFjaCB0aGVcblx0ICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuXHQgIC8vIHN1ZmZpY2llbnQgZm9yIGZpbmRET01Ob2RlIHNlbWFudGljcy5cblx0ICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG5cdCAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuXHQgICAgYWx0ZXJuYXRlLnJldHVybiA9IG51bGw7XG5cdCAgfVxuXG5cdCAgZmliZXIucmV0dXJuID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG5cdCAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuXHQgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcblx0ICAgIGZpYmVyLmFsdGVybmF0ZSA9IG51bGw7XG5cdCAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuXHQgIH0gLy8gTm90ZTogRGVmZW5zaXZlbHkgdXNpbmcgbmVnYXRpb24gaW5zdGVhZCBvZiA8IGluIGNhc2Vcblx0ICAvLyBgZGVsZXRlZFRyZWVDbGVhblVwTGV2ZWxgIGlzIHVuZGVmaW5lZC5cblxuXG5cdCAge1xuXHQgICAgLy8gQ2xlYXIgY3ljbGljYWwgRmliZXIgZmllbGRzLiBUaGlzIGxldmVsIGFsb25lIGlzIGRlc2lnbmVkIHRvIHJvdWdobHlcblx0ICAgIC8vIGFwcHJveGltYXRlIHRoZSBwbGFubmVkIEZpYmVyIHJlZmFjdG9yLiBJbiB0aGF0IHdvcmxkLCBgc2V0U3RhdGVgIHdpbGwgYmVcblx0ICAgIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG5cdCAgICAvLyBvYmplY3Qgd2lsbCBub3QgaGF2ZSBhbnkgb2YgdGhlc2UgZmllbGRzLiBJdCB3aWxsIG9ubHkgYmUgY29ubmVjdGVkIHRvXG5cdCAgICAvLyB0aGUgZmliZXIgdHJlZSB2aWEgYSBzaW5nbGUgbGluayBhdCB0aGUgcm9vdC4gU28gaWYgdGhpcyBsZXZlbCBhbG9uZSBpc1xuXHQgICAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG5cdCAgICBmaWJlci5jaGlsZCA9IG51bGw7XG5cdCAgICBmaWJlci5kZWxldGlvbnMgPSBudWxsO1xuXHQgICAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG5cdCAgICAvLyB0cmVlLCB3aGljaCBoYXMgaXRzIG93biBwb2ludGVycyB0byBjaGlsZHJlbiwgcGFyZW50cywgYW5kIHNpYmxpbmdzLlxuXHQgICAgLy8gVGhlIG90aGVyIGhvc3Qgbm9kZXMgYWxzbyBwb2ludCBiYWNrIHRvIGZpYmVycywgc28gd2Ugc2hvdWxkIGRldGFjaCB0aGF0XG5cdCAgICAvLyBvbmUsIHRvby5cblxuXHQgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuXHQgICAgICB2YXIgaG9zdEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcblx0ICAgICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBJJ20gaW50ZW50aW9uYWxseSBub3QgY2xlYXJpbmcgdGhlIGByZXR1cm5gIGZpZWxkIGluIHRoaXMgbGV2ZWwuIFdlXG5cdCAgICAvLyBhbHJlYWR5IGRpc2Nvbm5lY3QgdGhlIGByZXR1cm5gIHBvaW50ZXIgYXQgdGhlIHJvb3Qgb2YgdGhlIGRlbGV0ZWRcblx0ICAgIC8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3Rcblx0ICAgIC8vIGN5Y2xpY2FsIOKAlCBpdCdzIG9ubHkgY3ljbGljYWwgd2hlbiBjb21iaW5lZCB3aXRoIGBjaGlsZGAsIGBzaWJsaW5nYCwgYW5kXG5cdCAgICAvLyBgYWx0ZXJuYXRlYC4gQnV0IHdlJ2xsIGNsZWFyIGl0IGluIHRoZSBuZXh0IGxldmVsIGFueXdheSwganVzdCBpbiBjYXNlLlxuXG5cdCAgICB7XG5cdCAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAge1xuXHQgICAgICAvLyBUaGVvcmV0aWNhbGx5LCBub3RoaW5nIGluIGhlcmUgc2hvdWxkIGJlIG5lY2Vzc2FyeSwgYmVjYXVzZSB3ZSBhbHJlYWR5XG5cdCAgICAgIC8vIGRpc2Nvbm5lY3RlZCB0aGUgZmliZXIgZnJvbSB0aGUgdHJlZS4gU28gZXZlbiBpZiBzb21ldGhpbmcgbGVha3MgdGhpc1xuXHQgICAgICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2Vcblx0ICAgICAgLy9cblx0ICAgICAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhpcyBicmFuY2ggaXMgdG8gYmUgc3VwZXIgYWdncmVzc2l2ZSBzbyB3ZSBjYW4gbWVhc3VyZVxuXHQgICAgICAvLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG5cdCAgICAgIC8vIGluZGljYXRlIGEgUmVhY3QgbGVhayB3ZSBkb24ndCBrbm93IGFib3V0LlxuXHQgICAgICBmaWJlci5yZXR1cm4gPSBudWxsO1xuXHQgICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuXHQgICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcblx0ICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cdCAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG5cdCAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7IC8vIFRPRE86IE1vdmUgdG8gYGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyYCBpbnN0ZWFkLlxuXG5cdCAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KSB7XG5cdCAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXHQgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cdCAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcblx0ICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcblx0ICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG5cdCAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHQgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG5cdCAgICAgIHJldHVybiBwYXJlbnQ7XG5cdCAgICB9XG5cblx0ICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG5cdCAgfVxuXG5cdCAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuXHQgIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuXHQgIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuXHQgIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuXHQgIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuXHQgIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cblx0ICB2YXIgbm9kZSA9IGZpYmVyO1xuXG5cdCAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG5cdCAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG5cdCAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG5cdCAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG5cdCAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuXHQgICAgICAgIC8vIGxhc3Qgc2libGluZy5cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblx0ICAgIH1cblxuXHQgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuXHQgICAgbm9kZSA9IG5vZGUuc2libGluZztcblxuXHQgICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCAmJiBub2RlLnRhZyAhPT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG5cdCAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cblx0ICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuXHQgICAgICBpZiAobm9kZS5mbGFncyAmIFBsYWNlbWVudCkge1xuXHQgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuXHQgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuXHQgICAgICB9IC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuXHQgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuXG5cblx0ICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcblx0ICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG5cdCAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG5cdCAgICBpZiAoIShub2RlLmZsYWdzICYgUGxhY2VtZW50KSkge1xuXHQgICAgICAvLyBGb3VuZCBpdCFcblx0ICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcblx0ICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcblx0ICAgIHJldHVybjtcblx0ICB9IC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG5cblxuXHQgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspOyAvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cblxuXHQgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG5cdCAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG5cdCAgICAgICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG5cdCAgICAgICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7IC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG5cblx0ICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7IC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcblx0ICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cblx0ICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgIGNhc2UgSG9zdFBvcnRhbDpcblx0ICAgICAge1xuXHQgICAgICAgIHZhciBfcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cblx0ICAgICAgICB2YXIgX2JlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG5cblx0ICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG5cdCAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXHQgIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuXHQgIGlmIChpc0hvc3QpIHtcblx0ICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuXHQgICAgaWYgKGJlZm9yZSkge1xuXHQgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBzdGF0ZU5vZGUpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuXHQgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuXHQgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcblx0ICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG5cdCAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG5cdCAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG5cdCAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuXHQgIHZhciB0YWcgPSBub2RlLnRhZztcblx0ICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cblx0ICBpZiAoaXNIb3N0KSB7XG5cdCAgICB2YXIgc3RhdGVOb2RlID0gbm9kZS5zdGF0ZU5vZGU7XG5cblx0ICAgIGlmIChiZWZvcmUpIHtcblx0ICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBzdGF0ZU5vZGUpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuXHQgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuXHQgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuXHQgICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cblx0ICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcblx0ICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuXHQgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH0gLy8gVGhlc2UgYXJlIHRyYWNrZWQgb24gdGhlIHN0YWNrIGFzIHdlIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFcblx0Ly8gZGVsZXRlZCBzdWJ0cmVlLlxuXHQvLyBUT0RPOiBVcGRhdGUgdGhlc2UgZHVyaW5nIHRoZSB3aG9sZSBtdXRhdGlvbiBwaGFzZSwgbm90IGp1c3QgZHVyaW5nXG5cdC8vIGEgZGVsZXRpb24uXG5cblxuXHR2YXIgaG9zdFBhcmVudCA9IG51bGw7XG5cdHZhciBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcikge1xuXHQgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG5cdCAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcblx0ICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblx0ICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQsIGRldGFjaCByZWZzLCBjbGVhblxuXHQgICAgLy8gdXAgbW91bnRlZCBsYXlvdXQgZWZmZWN0cywgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQuXG5cdCAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcmVtb3ZlIHRoZSB0b3Btb3N0IGhvc3QgY2hpbGQgaW4gZWFjaCBicmFuY2guIEJ1dCB0aGVuIHdlXG5cdCAgICAvLyBzdGlsbCBuZWVkIHRvIGtlZXAgdHJhdmVyc2luZyB0byB1bm1vdW50IGVmZmVjdHMsIHJlZnMsIGFuZCBjV1UuIFRPRE86IFdlXG5cdCAgICAvLyBjb3VsZCBzcGxpdCB0aGlzIGludG8gdHdvIHNlcGFyYXRlIHRyYXZlcnNhbHMgZnVuY3Rpb25zLCB3aGVyZSB0aGUgc2Vjb25kXG5cdCAgICAvLyBvbmUgZG9lc24ndCBpbmNsdWRlIGFueSByZW1vdmVDaGlsZCBsb2dpYy4gVGhpcyBpcyBtYXliZSB0aGUgc2FtZVxuXHQgICAgLy8gZnVuY3Rpb24gYXMgXCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzXCIgKG9yIHdoYXRldmVyIHRoYXQgdHVybnMgaW50byBhZnRlclxuXHQgICAgLy8gdGhlIGxheW91dCBwaGFzZSBpcyByZWZhY3RvcmVkIHRvIHVzZSByZWN1cnNpb24pLlxuXHQgICAgLy8gQmVmb3JlIHN0YXJ0aW5nLCBmaW5kIHRoZSBuZWFyZXN0IGhvc3QgcGFyZW50IG9uIHRoZSBzdGFjayBzbyB3ZSBrbm93XG5cdCAgICAvLyB3aGljaCBpbnN0YW5jZS9jb250YWluZXIgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuXHQgICAgLy8gVE9ETzogSW5zdGVhZCBvZiBzZWFyY2hpbmcgdXAgdGhlIGZpYmVyIHJldHVybiBwYXRoIG9uIGV2ZXJ5IGRlbGV0aW9uLCB3ZVxuXHQgICAgLy8gY2FuIHRyYWNrIHRoZSBuZWFyZXN0IGhvc3QgY29tcG9uZW50IG9uIHRoZSBKUyBzdGFjayBhcyB3ZSB0cmF2ZXJzZSB0aGVcblx0ICAgIC8vIHRyZWUgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgd291bGQgbWFrZSBpbnNlcnRpb25zIGZhc3RlciwgdG9vLlxuXHQgICAgdmFyIHBhcmVudCA9IHJldHVybkZpYmVyO1xuXG5cdCAgICBmaW5kUGFyZW50OiB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuXHQgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG5cdCAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuXHQgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblx0ICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcblx0ICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblx0ICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcblx0ICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmIChob3N0UGFyZW50ID09PSBudWxsKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArICdhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgICB9XG5cblx0ICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG5cdCAgICBob3N0UGFyZW50ID0gbnVsbDtcblx0ICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuXHQgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcblx0ICB9XG5cblx0ICBkZXRhY2hGaWJlck11dGF0aW9uKGRlbGV0ZWRGaWJlcik7XG5cdH1cblxuXHRmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgcGFyZW50KSB7XG5cdCAgLy8gVE9ETzogVXNlIGEgc3RhdGljIGZsYWcgdG8gc2tpcCB0cmVlcyB0aGF0IGRvbid0IGhhdmUgdW5tb3VudCBlZmZlY3RzXG5cdCAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkO1xuXG5cdCAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgY2hpbGQpO1xuXHQgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpIHtcblx0ICBvbkNvbW1pdFVubW91bnQoZGVsZXRlZEZpYmVyKTsgLy8gVGhlIGNhc2VzIGluIHRoaXMgb3V0ZXIgc3dpdGNoIG1vZGlmeSB0aGUgc3RhY2sgYmVmb3JlIHRoZXkgdHJhdmVyc2Vcblx0ICAvLyBpbnRvIHRoZWlyIHN1YnRyZWUuIFRoZXJlIGFyZSBzaW1wbGVyIGNhc2VzIGluIHRoZSBpbm5lciBzd2l0Y2hcblx0ICAvLyB0aGF0IGRvbid0IG1vZGlmeSB0aGUgc3RhY2suXG5cblx0ICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcblx0ICAgIGNhc2UgSG9zdENvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuXHQgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG5cdCAgICAgICAgfSAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaCB0byBuZXh0IGJyYW5jaFxuXG5cdCAgICAgIH1cblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG5cdCAgICBjYXNlIEhvc3RUZXh0OlxuXHQgICAgICB7XG5cdCAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGUgbmVhcmVzdCBob3N0IGNoaWxkLiBTZXQgdGhlIGhvc3QgcGFyZW50XG5cdCAgICAgICAgLy8gdG8gYG51bGxgIG9uIHRoZSBzdGFjayB0byBpbmRpY2F0ZSB0aGF0IG5lc3RlZCBjaGlsZHJlbiBkb24ndFxuXHQgICAgICAgIC8vIG5lZWQgdG8gYmUgcmVtb3ZlZC5cblx0ICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuXHQgICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcblx0ICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuXHQgICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG5cdCAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcblx0ICAgICAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcblx0ICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG5cblx0ICAgICAgICAgIGlmIChob3N0UGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIC8vIE5vdyB0aGF0IGFsbCB0aGUgY2hpbGQgZWZmZWN0cyBoYXZlIHVubW91bnRlZCwgd2UgY2FuIHJlbW92ZSB0aGVcblx0ICAgICAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuXHQgICAgICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHJlbW92ZUNoaWxkKGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcblx0ICAgICAge1xuXHQgICAgICAgIC8vIERlbGV0ZSB0aGUgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50LlxuXG5cblx0ICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuXHQgICAgICAgICAgaWYgKGhvc3RQYXJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcikge1xuXHQgICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgSG9zdFBvcnRhbDpcblx0ICAgICAge1xuXHQgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG5cdCAgICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cblx0ICAgICAgICAgIHZhciBfcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuXHQgICAgICAgICAgdmFyIF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuXHQgICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblx0ICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG5cdCAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcblx0ICAgICAgICAgIGhvc3RQYXJlbnQgPSBfcHJldkhvc3RQYXJlbnQ7XG5cdCAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoZGVsZXRlZEZpYmVyKTtcblx0ICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuXHQgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG5cdCAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBkZWxldGVkRmliZXIudXBkYXRlUXVldWU7XG5cblx0ICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cblx0ICAgICAgICAgICAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG5cdCAgICAgICAgICAgICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG5cdCAgICAgICAgICAgICAgZG8ge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9lZmZlY3QgPSBlZmZlY3QsXG5cdCAgICAgICAgICAgICAgICAgICAgZGVzdHJveSA9IF9lZmZlY3QuZGVzdHJveSxcblx0ICAgICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0LnRhZztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG5cdCAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChkZWxldGVkRmliZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICggZGVsZXRlZEZpYmVyLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcblx0ICAgICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGRlbGV0ZWRGaWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuXHQgICAgICAgICAgICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcblx0ICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuXHQgICAgICAgICAgdmFyIGluc3RhbmNlID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG5cdCAgICAgIHtcblxuXHQgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIGlmICggLy8gVE9ETzogUmVtb3ZlIHRoaXMgZGVhZCBmbGFnXG5cdCAgICAgICAgIGRlbGV0ZWRGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcblx0ICAgICAgICAgIC8vIElmIHRoaXMgb2Zmc2NyZWVuIGNvbXBvbmVudCBpcyBoaWRkZW4sIHdlIGFscmVhZHkgdW5tb3VudGVkIGl0LiBCZWZvcmVcblx0ICAgICAgICAgIC8vIGRlbGV0aW5nIHRoZSBjaGlsZHJlbiwgdHJhY2sgdGhhdCBpdCdzIGFscmVhZHkgdW5tb3VudGVkIHNvIHRoYXQgd2Vcblx0ICAgICAgICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gdW5tb3VudCB0aGUgZWZmZWN0cyBhZ2Fpbi5cblx0ICAgICAgICAgIC8vIFRPRE86IElmIHRoZSB0cmVlIGlzIGhpZGRlbiwgaW4gbW9zdCBjYXNlcyB3ZSBzaG91bGQgYmUgYWJsZSB0byBza2lwXG5cdCAgICAgICAgICAvLyBvdmVyIHRoZSBuZXN0ZWQgY2hpbGRyZW4gZW50aXJlbHkuIEFuIGV4Y2VwdGlvbiBpcyB3ZSBoYXZlbid0IHlldCBmb3VuZFxuXHQgICAgICAgICAgLy8gdGhlIHRvcG1vc3QgaG9zdCBub2RlIHRvIGRlbGV0ZSwgd2hpY2ggd2UgYWxyZWFkeSB0cmFjayBvbiB0aGUgc3RhY2suXG5cdCAgICAgICAgICAvLyBCdXQgdGhlIG90aGVyIGNhc2UgaXMgcG9ydGFscywgd2hpY2ggbmVlZCB0byBiZSBkZXRhY2hlZCBubyBtYXR0ZXIgaG93XG5cdCAgICAgICAgICAvLyBkZWVwbHkgdGhleSBhcmUgbmVzdGVkLiBXZSBzaG91bGQgdXNlIGEgc3VidHJlZSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgYVxuXHQgICAgICAgICAgLy8gc3VidHJlZSBpbmNsdWRlcyBhIG5lc3RlZCBwb3J0YWwuXG5cdCAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXHQgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXHQgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG5cdCAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHtcblx0ICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yaykge1xuXHQgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG5cdCAgZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuXHQgIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuXHQgIGlmIChuZXdTdGF0ZSA9PT0gbnVsbCkge1xuXHQgICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG5cdCAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuXHQgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblx0ICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG5cdCAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcblx0ICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuXHQgIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHRoZW4gaXQgd2lsbCBoYXZlIGEgc2V0IG9mIHdha2VhYmxlcy5cblx0ICAvLyBGb3IgZWFjaCB3YWtlYWJsZSwgYXR0YWNoIGEgbGlzdGVuZXIgc28gdGhhdCB3aGVuIGl0IHJlc29sdmVzLCBSZWFjdFxuXHQgIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cblx0ICB2YXIgd2FrZWFibGVzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG5cdCAgaWYgKHdha2VhYmxlcyAhPT0gbnVsbCkge1xuXHQgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblx0ICAgIHZhciByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuXHQgICAgaWYgKHJldHJ5Q2FjaGUgPT09IG51bGwpIHtcblx0ICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG5cdCAgICB9XG5cblx0ICAgIHdha2VhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YWtlYWJsZSkge1xuXHQgICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG5cdCAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG5cblx0ICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcblx0ICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG5cblx0ICAgICAgICB7XG5cdCAgICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3NMYW5lcyAhPT0gbnVsbCAmJiBpblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCBhc3NvY2lhdGUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzIHdpdGggaXQuXG5cdCAgICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB0aHJvdyBFcnJvcignRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cdH0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5cdGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG5cdCAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG5cdCAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuXHQgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXHQgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KTtcblx0ICBzZXRDdXJyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcblx0ICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuXHQgIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIsIGxhbmVzKSB7XG5cdCAgLy8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuXHQgIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYWUgZmlyZWQuXG5cdCAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcblxuXHQgIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBwYXJlbnRGaWJlciwgZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG5cblx0ICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgTXV0YXRpb25NYXNrKSB7XG5cdCAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuXHQgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgIHNldEN1cnJlbnRGaWJlcihjaGlsZCk7XG5cdCAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoY2hpbGQsIHJvb3QpO1xuXHQgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgc2V0Q3VycmVudEZpYmVyKHByZXZEZWJ1Z0ZpYmVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcykge1xuXHQgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcblx0ICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7IC8vIFRoZSBlZmZlY3QgZmxhZyBzaG91bGQgYmUgY2hlY2tlZCAqYWZ0ZXIqIHdlIHJlZmluZSB0aGUgdHlwZSBvZiBmaWJlcixcblx0ICAvLyBiZWNhdXNlIHRoZSBmaWJlciB0YWcgaXMgbW9yZSBzcGVjaWZpYy4gQW4gZXhjZXB0aW9uIGlzIGFueSBmbGFnIHJlbGF0ZWRcblx0ICAvLyB0byByZWNvbmNpbGF0aW9uLCBiZWNhdXNlIHRob3NlIGNhbiBiZSBzZXQgb24gYWxsIGZpYmVyIHR5cGVzLlxuXG5cdCAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG5cdCAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuXHQgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG5cdCAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuXHQgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgfSAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcblx0ICAgICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuXHQgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuXHQgICAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG5cdCAgICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuXG5cblx0ICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcblx0ICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG5cdCAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG5cdCAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cblx0ICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcblx0ICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcblx0ICAgICAgICAgIC8vIFRPRE86IENvbnRlbnRSZXNldCBnZXRzIGNsZWFyZWQgYnkgdGhlIGNoaWxkcmVuIGR1cmluZyB0aGUgY29tbWl0XG5cdCAgICAgICAgICAvLyBwaGFzZS4gVGhpcyBpcyBhIHJlZmFjdG9yIGhhemFyZCBiZWNhdXNlIGl0IG1lYW5zIHdlIG11c3QgcmVhZFxuXHQgICAgICAgICAgLy8gZmxhZ3MgdGhlIGZsYWdzIGFmdGVyIGBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHNgIGhhcyBhbHJlYWR5IHJ1bjtcblx0ICAgICAgICAgIC8vIHRoZSBvcmRlciBtYXR0ZXJzLiBXZSBzaG91bGQgcmVmYWN0b3Igc28gdGhhdCBDb250ZW50UmVzZXQgZG9lcyBub3Rcblx0ICAgICAgICAgIC8vIHJlbHkgb24gbXV0YXRpbmcgdGhlIGZsYWcgZHVyaW5nIGNvbW1pdC4gTGlrZSBieSBzZXR0aW5nIGEgZmxhZ1xuXHQgICAgICAgICAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UgaW5zdGVhZC5cblx0ICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcblx0ICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQoaW5zdGFuY2UpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuXHQgICAgICAgICAgICB2YXIgX2luc3RhbmNlNCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cblx0ICAgICAgICAgICAgaWYgKF9pbnN0YW5jZTQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuXHQgICAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG5cdCAgICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG5cdCAgICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG5cdCAgICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuXHQgICAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuXHQgICAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXHQgICAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKF9pbnN0YW5jZTQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIEhvc3RUZXh0OlxuXHQgICAgICB7XG5cdCAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG5cdCAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG5cdCAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuXHQgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cdCAgICAgICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcblx0ICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG5cdCAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cblxuXHQgICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuXG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgIHtcblx0ICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cblx0ICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcblx0ICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uICYmIHN1cHBvcnRzSHlkcmF0aW9uKSB7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgdmFyIHByZXZSb290U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cblx0ICAgICAgICAgICAgICBpZiAocHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcblx0ICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSByb290LmNvbnRhaW5lckluZm87XG5cdCAgICAgICAgICAgIHZhciBwZW5kaW5nQ2hpbGRyZW4gPSByb290LnBlbmRpbmdDaGlsZHJlbjtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgSG9zdFBvcnRhbDpcblx0ICAgICAge1xuXHQgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuXHQgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuXHQgICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcblx0ICAgICAgICAgICAgdmFyIHBvcnRhbCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cdCAgICAgICAgICAgIHZhciBfY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuXHQgICAgICAgICAgICB2YXIgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbC5wZW5kaW5nQ2hpbGRyZW47XG5cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oX2NvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgdmFyIG9mZnNjcmVlbkZpYmVyID0gZmluaXNoZWRXb3JrLmNoaWxkO1xuXG5cdCAgICAgICAgaWYgKG9mZnNjcmVlbkZpYmVyLmZsYWdzICYgVmlzaWJpbGl0eSkge1xuXHQgICAgICAgICAgdmFyIG9mZnNjcmVlbkluc3RhbmNlID0gb2Zmc2NyZWVuRmliZXIuc3RhdGVOb2RlO1xuXHQgICAgICAgICAgdmFyIG5ld1N0YXRlID0gb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZTtcblx0ICAgICAgICAgIHZhciBpc0hpZGRlbiA9IG5ld1N0YXRlICE9PSBudWxsOyAvLyBUcmFjayB0aGUgY3VycmVudCBzdGF0ZSBvbiB0aGUgT2Zmc2NyZWVuIGluc3RhbmNlIHNvIHdlIGNhblxuXHQgICAgICAgICAgLy8gcmVhZCBpdCBkdXJpbmcgYW4gZXZlbnRcblxuXHQgICAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuaXNIaWRkZW4gPSBpc0hpZGRlbjtcblxuXHQgICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG5cdCAgICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cblx0ICAgICAgICAgICAgaWYgKCF3YXNIaWRkZW4pIHtcblx0ICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRvIHBhc3NpdmUgcGhhc2Vcblx0ICAgICAgICAgICAgICBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgX3dhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG5cdCAgICAgICAgaWYgKCAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZWFkIGZsYWdcblx0ICAgICAgICAgZmluaXNoZWRXb3JrLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuXHQgICAgICAgICAgLy8gQmVmb3JlIGNvbW1pdHRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayBvbiB0aGUgc3RhY2sgd2hldGhlciB0aGlzXG5cdCAgICAgICAgICAvLyBvZmZzY3JlZW4gc3VidHJlZSB3YXMgYWxyZWFkeSBoaWRkZW4sIHNvIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVcblx0ICAgICAgICAgIC8vIGVmZmVjdHMgYWdhaW4uXG5cdCAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXHQgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IF93YXNIaWRkZW47XG5cdCAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuXHQgICAgICAgIGlmIChmbGFncyAmIFZpc2liaWxpdHkpIHtcblx0ICAgICAgICAgIHZhciBfb2Zmc2NyZWVuSW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXHQgICAgICAgICAgdmFyIF9uZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICAgICAgICB2YXIgX2lzSGlkZGVuID0gX25ld1N0YXRlICE9PSBudWxsO1xuXG5cdCAgICAgICAgICB2YXIgb2Zmc2NyZWVuQm91bmRhcnkgPSBmaW5pc2hlZFdvcms7IC8vIFRyYWNrIHRoZSBjdXJyZW50IHN0YXRlIG9uIHRoZSBPZmZzY3JlZW4gaW5zdGFuY2Ugc28gd2UgY2FuXG5cdCAgICAgICAgICAvLyByZWFkIGl0IGR1cmluZyBhbiBldmVudFxuXG5cdCAgICAgICAgICBfb2Zmc2NyZWVuSW5zdGFuY2UuaXNIaWRkZW4gPSBfaXNIaWRkZW47XG5cblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaWYgKF9pc0hpZGRlbikge1xuXHQgICAgICAgICAgICAgIGlmICghX3dhc0hpZGRlbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKChvZmZzY3JlZW5Cb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG9mZnNjcmVlbkJvdW5kYXJ5O1xuXHQgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2NyZWVuQ2hpbGQgPSBvZmZzY3JlZW5Cb3VuZGFyeS5jaGlsZDtcblxuXHQgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2NyZWVuQ2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gb2Zmc2NyZWVuQ2hpbGQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihvZmZzY3JlZW5DaGlsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuQ2hpbGQgPSBvZmZzY3JlZW5DaGlsZC5zaWJsaW5nO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG5cdCAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbmVlZHMgdG8gcnVuIHdoZW5ldmVyIHRoZXJlJ3MgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZVxuXHQgICAgICAgICAgICAvLyBpbnNpZGUgYSBoaWRkZW4gT2Zmc2NyZWVuIHRyZWUuXG5cdCAgICAgICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKG9mZnNjcmVlbkJvdW5kYXJ5LCBfaXNIaWRkZW4pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuXHQgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuXHQgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuXHQgICAgICB7XG5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAge1xuXHQgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG5cdCAgLy8gUGxhY2VtZW50IGVmZmVjdHMgKGluc2VydGlvbnMsIHJlb3JkZXJzKSBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlclxuXHQgIC8vIHR5cGUuIFRoZXkgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQsIGJ1dFxuXHQgIC8vIGJlZm9yZSB0aGUgZWZmZWN0cyBvbiB0aGlzIGZpYmVyIGhhdmUgZmlyZWQuXG5cdCAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG5cdCAgaWYgKGZsYWdzICYgUGxhY2VtZW50KSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTtcblx0ICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuXHQgICAgfSAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuXHQgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cblx0ICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWQgZG9lc1xuXHQgICAgLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5cblxuXHQgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG5cdCAgfVxuXG5cdCAgaWYgKGZsYWdzICYgSHlkcmF0aW5nKSB7XG5cdCAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblx0ICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcblx0ICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG5cdCAgbmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcblx0ICBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuXHQgIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG5cdCAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblx0ICAvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG5cdCAgdmFyIGlzTW9kZXJuUm9vdCA9IChzdWJ0cmVlUm9vdC5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGU7XG5cblx0ICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblx0ICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7XG5cblx0ICAgIGlmICggZmliZXIudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgaXNNb2Rlcm5Sb290KSB7XG5cdCAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG5cdCAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cdCAgICAgIHZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBpc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG5cblx0ICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuXHQgICAgICAgIC8vIFRoZSBPZmZzY3JlZW4gdHJlZSBpcyBoaWRkZW4uIFNraXAgb3ZlciBpdHMgbGF5b3V0IGVmZmVjdHMuXG5cdCAgICAgICAgY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcyk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBBbHNvIGNoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRNYXNrXG5cdCAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cdCAgICAgICAgdmFyIHdhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXHQgICAgICAgIHZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gd2FzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG5cdCAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG5cdCAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjsgLy8gVHJhdmVyc2UgdGhlIE9mZnNjcmVlbiBzdWJ0cmVlIHdpdGggdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIGFzIHRoZSByb290LlxuXG5cdCAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gbmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuXHQgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG5cdCAgICAgICAgaWYgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gJiYgIXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG5cdCAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByb290IG9mIGEgcmVhcHBlYXJpbmcgYm91bmRhcnkuIFR1cm4gaXRzIGxheW91dCBlZmZlY3RzXG5cdCAgICAgICAgICAvLyBiYWNrIG9uLlxuXHQgICAgICAgICAgbmV4dEVmZmVjdCA9IGZpYmVyO1xuXHQgICAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKGZpYmVyKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY2hpbGQgPSBmaXJzdENoaWxkO1xuXG5cdCAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG5cdCAgICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKGNoaWxkLCAvLyBOZXcgcm9vdDsgYnViYmxlIGJhY2sgdXAgdG8gaGVyZSBhbmQgc3RvcC5cblx0ICAgICAgICAgIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcblx0ICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcblx0ICAgICAgICB9IC8vIFJlc3RvcmUgT2Zmc2NyZWVuIHN0YXRlIGFuZCByZXN1bWUgaW4gb3VyLXByb2dyZXNzIHRyYXZlcnNhbC5cblxuXG5cdCAgICAgICAgbmV4dEVmZmVjdCA9IGZpYmVyO1xuXHQgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG5cdCAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXHQgICAgICAgIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MgJiYgZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuXHQgICAgICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblx0ICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuXHQgICAgaWYgKChmaWJlci5mbGFncyAmIExheW91dE1hc2spICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuXHQgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBjdXJyZW50LCBmaWJlciwgY29tbWl0dGVkTGFuZXMpO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcblx0ICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG5cdCAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuXHQgICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcblx0ICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290KSB7XG5cdCAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcblx0ICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cdCAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkOyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG5cblx0ICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG5cdCAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKCBmaWJlci5tb2RlICYgUHJvZmlsZU1vZGUpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG5cdCAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmliZXIsIGZpYmVyLnJldHVybik7XG5cdCAgICAgICAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmliZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LCBmaWJlciwgZmliZXIucmV0dXJuKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBSZWZTdGF0aWNcblx0ICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcblx0ICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFcblx0ICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cblx0ICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuXHQgICAgICAgICAgICAvLyBOZXN0ZWQgT2Zmc2NyZWVuIHRyZWUgaXMgYWxyZWFkeSBoaWRkZW4uIERvbid0IGRpc2FwcGVhclxuXHQgICAgICAgICAgICAvLyBpdHMgZWZmZWN0cy5cblx0ICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuXG5cblx0ICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgIGZpcnN0Q2hpbGQucmV0dXJuID0gZmliZXI7XG5cdCAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCkge1xuXHQgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuXG5cdCAgICBpZiAoZmliZXIgPT09IHN1YnRyZWVSb290KSB7XG5cdCAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuXHQgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcblx0ICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG5cdCAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290KSB7XG5cdCAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcblx0ICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cdCAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG5cdCAgICBpZiAoZmliZXIudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpIHtcblx0ICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuXHQgICAgICBpZiAoaXNIaWRkZW4pIHtcblx0ICAgICAgICAvLyBOZXN0ZWQgT2Zmc2NyZWVuIHRyZWUgaXMgc3RpbGwgaGlkZGVuLiBEb24ndCByZS1hcHBlYXIgaXRzIGVmZmVjdHMuXG5cdCAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRTdGF0aWNcblxuXG5cdCAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAvLyBUaGlzIG5vZGUgbWF5IGhhdmUgYmVlbiByZXVzZWQgZnJvbSBhIHByZXZpb3VzIHJlbmRlciwgc28gd2UgY2FuJ3Rcblx0ICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuXHQgICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuXHQgICAgICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KSB7XG5cdCAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcblx0ICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG5cblx0ICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIoZmliZXIpO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuXHQgICAgfVxuXG5cdCAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG5cdCAgICBpZiAoZmliZXIgPT09IHN1YnRyZWVSb290KSB7XG5cdCAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuXHQgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcblx0ICAgICAgLy8gVGhpcyBub2RlIG1heSBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIsIHNvIHdlIGNhbid0XG5cdCAgICAgIC8vIGFzc3VtZSBpdHMgcmV0dXJuIHBvaW50ZXIgaXMgY29ycmVjdC5cblx0ICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG5cdCAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuXHQgIG5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG5cdCAgY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcblx0ICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblx0ICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7XG5cblx0ICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzICYmIGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcblx0ICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuXHQgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuXG5cdCAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcblx0ICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmliZXIsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cdCAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuXHQgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cblx0ICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG5cdCAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuXHQgICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuXHQgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuXHQgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmlyc3RDaGlsZCkge1xuXHQgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuXHQgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luKCkge1xuXHQgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuXHQgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cblx0ICAgIGlmICgobmV4dEVmZmVjdC5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgIHZhciBkZWxldGlvbnMgPSBmaWJlci5kZWxldGlvbnM7XG5cblx0ICAgICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgZmliZXJUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcblx0ICAgICAgICAgIG5leHRFZmZlY3QgPSBmaWJlclRvRGVsZXRlO1xuXHQgICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihmaWJlclRvRGVsZXRlLCBmaWJlcik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgLy8gQSBmaWJlciB3YXMgZGVsZXRlZCBmcm9tIHRoaXMgcGFyZW50IGZpYmVyLCBidXQgaXQncyBzdGlsbCBwYXJ0IG9mXG5cdCAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgKGFsdGVybmF0ZSkgcGFyZW50IGZpYmVyJ3MgbGlzdCBvZiBjaGlsZHJlbi4gQmVjYXVzZVxuXHQgICAgICAgICAgLy8gY2hpbGRyZW4gYXJlIGEgbGlua2VkIGxpc3QsIGFuIGVhcmxpZXIgc2libGluZyB0aGF0J3Mgc3RpbGwgYWxpdmVcblx0ICAgICAgICAgIC8vIHdpbGwgYmUgY29ubmVjdGVkIHRvIHRoZSBkZWxldGVkIGZpYmVyIHZpYSBpdHMgYGFsdGVybmF0ZWA6XG5cdCAgICAgICAgICAvL1xuXHQgICAgICAgICAgLy8gICBsaXZlIGZpYmVyXG5cdCAgICAgICAgICAvLyAgIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXJcblx0ICAgICAgICAgIC8vICAgLS1zaWJsaW5nLS0+IGRlbGV0ZWQgZmliZXJcblx0ICAgICAgICAgIC8vXG5cdCAgICAgICAgICAvLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWRcblx0ICAgICAgICAgIC8vIHlldCwgYnV0IHdlIGNhbiBkaXNjb25uZWN0IHRoZSBgc2libGluZ2AgYW5kIGBjaGlsZGAgcG9pbnRlcnMuXG5cdCAgICAgICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcblxuXHQgICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGRldGFjaGVkQ2hpbGQgPSBwcmV2aW91c0ZpYmVyLmNoaWxkO1xuXG5cdCAgICAgICAgICAgIGlmIChkZXRhY2hlZENoaWxkICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG5cblx0ICAgICAgICAgICAgICBkbyB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGV0YWNoZWRTaWJsaW5nID0gZGV0YWNoZWRDaGlsZC5zaWJsaW5nO1xuXHQgICAgICAgICAgICAgICAgZGV0YWNoZWRDaGlsZC5zaWJsaW5nID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGRldGFjaGVkQ2hpbGQgPSBkZXRhY2hlZFNpYmxpbmc7XG5cdCAgICAgICAgICAgICAgfSB3aGlsZSAoZGV0YWNoZWRDaGlsZCAhPT0gbnVsbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG5cdCAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpIHtcblx0ICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuXHQgICAgaWYgKChmaWJlci5mbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzKSB7XG5cdCAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cdCAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7XG5cdCAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuXHQgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcblx0ICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG5cdCAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuXHQgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuXHQgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcblx0ICAgICAge1xuXHQgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblx0ICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG5cdCAgICAgICAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oZGVsZXRlZFN1YnRyZWVSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG5cdCAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcblx0ICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIERlbGV0aW9uIGVmZmVjdHMgZmlyZSBpbiBwYXJlbnQgLT4gY2hpbGQgb3JkZXJcblx0ICAgIC8vIFRPRE86IENoZWNrIGlmIGZpYmVyIGhhcyBhIFBhc3NpdmVTdGF0aWMgZmxhZ1xuXG5cdCAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXHQgICAgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoZmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuXHQgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblx0ICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkOyAvLyBUT0RPOiBPbmx5IHRyYXZlcnNlIHN1YnRyZWUgaWYgaXQgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnLiAoQnV0LCBpZiB3ZVxuXHQgICAgLy8gZG8gdGhpcywgc3RpbGwgbmVlZCB0byBoYW5kbGUgYGRlbGV0ZWRUcmVlQ2xlYW5VcExldmVsYCBjb3JyZWN0bHkuKVxuXG5cdCAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG5cdCAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCkge1xuXHQgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuXHQgICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXHQgICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuO1xuXG5cdCAgICB7XG5cdCAgICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgZGVsZXRlZCB0cmVlIGFuZCBjbGVhbiB1cCBmaWJlciBmaWVsZHMuXG5cdCAgICAgIC8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaWRlYWwsIGFuZCB0aGUgbG9uZyB0ZXJtIGdvYWwgaXMgdG8gb25seVxuXHQgICAgICAvLyBoYXZlIHRvIGRldGFjaCB0aGUgZGVsZXRlZCB0cmVlIGF0IHRoZSByb290LlxuXHQgICAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcik7XG5cblx0ICAgICAgaWYgKGZpYmVyID09PSBkZWxldGVkU3VidHJlZVJvb3QpIHtcblx0ICAgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcblx0ICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblx0ICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcblx0ICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG5cdCAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICB7XG5cdCAgICAgICAgaWYgKCBjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblx0ICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuXHQgICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxLCBjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgIH1cblx0fSAvLyBUT0RPOiBSZXVzZSByZWFwcGVhckxheW91dEVmZmVjdHMgdHJhdmVyc2FsIGhlcmU/XG5cblxuXHRmdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWKGZpYmVyKSB7XG5cdCAge1xuXHQgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuXHQgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cblx0ICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG5cdCAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaWJlcik7XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWKGZpYmVyKSB7XG5cdCAge1xuXHQgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuXHQgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cblx0ICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG5cdCAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaWJlcik7XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcblx0ICB7XG5cdCAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG5cdCAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuXHQgICAgc3dpdGNoIChmaWJlci50YWcpIHtcblx0ICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmliZXIsIGZpYmVyLnJldHVybik7XG5cdCAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICAgIHtcblx0ICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFVihmaWJlcikge1xuXHQgIHtcblx0ICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cblx0ICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG5cdCAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuXHQgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIEZvcndhcmRSZWY6XG5cdCAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaWJlciwgZmliZXIucmV0dXJuKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIENPTVBPTkVOVF9UWVBFID0gMDtcblx0dmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG5cdHZhciBST0xFX1RZUEUgPSAyO1xuXHR2YXIgVEVTVF9OQU1FX1RZUEUgPSAzO1xuXHR2YXIgVEVYVF9UWVBFID0gNDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG5cdCAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG5cdCAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuXHQgIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1xuXHQgIFJPTEVfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3Iucm9sZScpO1xuXHQgIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG5cdCAgVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXh0Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTZWxlY3Rvcihjb21wb25lbnQpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgJCR0eXBlb2Y6IENPTVBPTkVOVF9UWVBFLFxuXHQgICAgdmFsdWU6IGNvbXBvbmVudFxuXHQgIH07XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcihzZWxlY3RvcnMpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgJCR0eXBlb2Y6IEhBU19QU0VVRE9fQ0xBU1NfVFlQRSxcblx0ICAgIHZhbHVlOiBzZWxlY3RvcnNcblx0ICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVJvbGVTZWxlY3Rvcihyb2xlKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgICQkdHlwZW9mOiBST0xFX1RZUEUsXG5cdCAgICB2YWx1ZTogcm9sZVxuXHQgIH07XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdG9yKHRleHQpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgJCR0eXBlb2Y6IFRFWFRfVFlQRSxcblx0ICAgIHZhbHVlOiB0ZXh0XG5cdCAgfTtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yKGlkKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgICQkdHlwZW9mOiBURVNUX05BTUVfVFlQRSxcblx0ICAgIHZhbHVlOiBpZFxuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcblx0ICB2YXIgbWF5YmVGaWJlciA9IGdldEluc3RhbmNlRnJvbU5vZGUoaG9zdFJvb3QpO1xuXG5cdCAgaWYgKG1heWJlRmliZXIgIT0gbnVsbCkge1xuXHQgICAgaWYgKHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvc3Qgcm9vdCBzcGVjaWZpZWQuIFNob3VsZCBiZSBlaXRoZXIgYSBSZWFjdCBjb250YWluZXIgb3IgYSBub2RlIHdpdGggYSB0ZXN0bmFtZSBhdHRyaWJ1dGUuJyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXliZUZpYmVyO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgZmliZXJSb290ID0gZmluZEZpYmVyUm9vdChob3N0Um9vdCk7XG5cblx0ICAgIGlmIChmaWJlclJvb3QgPT09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBSZWFjdCBjb250YWluZXIgd2l0aGluIHNwZWNpZmllZCBob3N0IHN1YnRyZWUuJyk7XG5cdCAgICB9IC8vIFRoZSBGbG93IHR5cGUgZm9yIEZpYmVyUm9vdCBpcyBhIGxpdHRsZSBmdW5reS5cblx0ICAgIC8vIGNyZWF0ZUZpYmVyUm9vdCgpIGNoZWF0cyB0aGlzIGJ5IHRyZWF0aW5nIHRoZSByb290IGFzIDphbnkgYW5kIGFkZGluZyBzdGF0ZU5vZGUgbGF6aWx5LlxuXG5cblx0ICAgIHJldHVybiBmaWJlclJvb3Quc3RhdGVOb2RlLmN1cnJlbnQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpIHtcblx0ICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG5cdCAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuXHQgICAgICBpZiAoZmliZXIudHlwZSA9PT0gc2VsZWN0b3IudmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcblx0ICAgICAgcmV0dXJuIGhhc01hdGNoaW5nUGF0aHMoZmliZXIsIHNlbGVjdG9yLnZhbHVlKTtcblxuXHQgICAgY2FzZSBST0xFX1RZUEU6XG5cdCAgICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgIGlmIChtYXRjaEFjY2Vzc2liaWxpdHlSb2xlKG5vZGUsIHNlbGVjdG9yLnZhbHVlKSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgVEVYVF9UWVBFOlxuXHQgICAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFRleHQpIHtcblx0ICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChmaWJlcik7XG5cblx0ICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgdGV4dENvbnRlbnQuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkgPj0gMCkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG5cdCAgICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcblx0ICAgICAgICB2YXIgZGF0YVRlc3RJRCA9IGZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXTtcblxuXHQgICAgICAgIGlmICh0eXBlb2YgZGF0YVRlc3RJRCA9PT0gJ3N0cmluZycgJiYgZGF0YVRlc3RJRC50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvci52YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBicmVhaztcblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLicpO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcblx0ICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG5cdCAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuXHQgICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8ICdVbmtub3duJztcblx0ICAgICAgcmV0dXJuIFwiPFwiICsgZGlzcGxheU5hbWUgKyBcIj5cIjtcblxuXHQgICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG5cdCAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgJycpICsgXCIpXCI7XG5cblx0ICAgIGNhc2UgUk9MRV9UWVBFOlxuXHQgICAgICByZXR1cm4gXCJbcm9sZT1cXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIl1cIjtcblxuXHQgICAgY2FzZSBURVhUX1RZUEU6XG5cdCAgICAgIHJldHVybiBcIlxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXCI7XG5cblx0ICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG5cdCAgICAgIHJldHVybiBcIltkYXRhLXRlc3RuYW1lPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuJyk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuXHQgIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuXHQgIHZhciBzdGFjayA9IFtyb290LCAwXTtcblx0ICB2YXIgaW5kZXggPSAwO1xuXG5cdCAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG5cdCAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcblx0ICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG5cdCAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cblx0ICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHdoaWxlIChzZWxlY3RvciAhPSBudWxsICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuXHQgICAgICAgIHNlbGVjdG9ySW5kZXgrKztcblx0ICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuXHQgICAgICBtYXRjaGluZ0ZpYmVycy5wdXNoKGZpYmVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG5cdCAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgIHN0YWNrLnB1c2goY2hpbGQsIHNlbGVjdG9ySW5kZXgpO1xuXHQgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBtYXRjaGluZ0ZpYmVycztcblx0fSAvLyBTYW1lIGFzIGZpbmRQYXRocyBidXQgd2l0aCBlYWdlciBiYWlsb3V0IG9uIGZpcnN0IG1hdGNoXG5cblxuXHRmdW5jdGlvbiBoYXNNYXRjaGluZ1BhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuXHQgIHZhciBzdGFjayA9IFtyb290LCAwXTtcblx0ICB2YXIgaW5kZXggPSAwO1xuXG5cdCAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG5cdCAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcblx0ICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG5cdCAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cblx0ICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHdoaWxlIChzZWxlY3RvciAhPSBudWxsICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuXHQgICAgICAgIHNlbGVjdG9ySW5kZXgrKztcblx0ICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG5cdCAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgIHN0YWNrLnB1c2goY2hpbGQsIHNlbGVjdG9ySW5kZXgpO1xuXHQgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG5cdCAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuXHQgIH1cblxuXHQgIHZhciByb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcblx0ICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcblx0ICB2YXIgaW5zdGFuY2VSb290cyA9IFtdO1xuXHQgIHZhciBzdGFjayA9IEFycmF5LmZyb20obWF0Y2hpbmdGaWJlcnMpO1xuXHQgIHZhciBpbmRleCA9IDA7XG5cblx0ICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcblx0ICAgIHZhciBub2RlID0gc3RhY2tbaW5kZXgrK107XG5cblx0ICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuXHQgICAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKG5vZGUpKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpbnN0YW5jZVJvb3RzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuXHQgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICBzdGFjay5wdXNoKGNoaWxkKTtcblx0ICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gaW5zdGFuY2VSb290cztcblx0fVxuXHRmdW5jdGlvbiBnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuXHQgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcblx0ICB9XG5cblx0ICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG5cdCAgdmFyIG1heFNlbGVjdG9ySW5kZXggPSAwO1xuXHQgIHZhciBtYXRjaGVkTmFtZXMgPSBbXTsgLy8gVGhlIGxvZ2ljIG9mIHRoaXMgbG9vcCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggZmluZFBhdGhzKClcblxuXHQgIHZhciBzdGFjayA9IFtyb290LCAwXTtcblx0ICB2YXIgaW5kZXggPSAwO1xuXG5cdCAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG5cdCAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcblx0ICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG5cdCAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cblx0ICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH0gZWxzZSBpZiAobWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpKSB7XG5cdCAgICAgIG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKTtcblx0ICAgICAgc2VsZWN0b3JJbmRleCsrO1xuXG5cdCAgICAgIGlmIChzZWxlY3RvckluZGV4ID4gbWF4U2VsZWN0b3JJbmRleCkge1xuXHQgICAgICAgIG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4O1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuXHQgICAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuXHQgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcblx0ICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAobWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGgpIHtcblx0ICAgIHZhciB1bm1hdGNoZWROYW1lcyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gbWF4U2VsZWN0b3JJbmRleDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB1bm1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3JzW2ldKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAnZmluZEFsbE5vZGVzIHdhcyBhYmxlIHRvIG1hdGNoIHBhcnQgb2YgdGhlIHNlbGVjdG9yOlxcbicgKyAoXCIgIFwiICsgbWF0Y2hlZE5hbWVzLmpvaW4oJyA+ICcpICsgXCJcXG5cXG5cIikgKyAnTm8gbWF0Y2hpbmcgY29tcG9uZW50IHdhcyBmb3VuZCBmb3I6XFxuJyArIChcIiAgXCIgKyB1bm1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gZmluZEJvdW5kaW5nUmVjdHMoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuXHQgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcblx0ICB9XG5cblx0ICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcblx0ICB2YXIgYm91bmRpbmdSZWN0cyA9IFtdO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZVJvb3RzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBib3VuZGluZ1JlY3RzLnB1c2goZ2V0Qm91bmRpbmdSZWN0KGluc3RhbmNlUm9vdHNbaV0pKTtcblx0ICB9XG5cblx0ICBmb3IgKHZhciBfaSA9IGJvdW5kaW5nUmVjdHMubGVuZ3RoIC0gMTsgX2kgPiAwOyBfaS0tKSB7XG5cdCAgICB2YXIgdGFyZ2V0UmVjdCA9IGJvdW5kaW5nUmVjdHNbX2ldO1xuXHQgICAgdmFyIHRhcmdldExlZnQgPSB0YXJnZXRSZWN0Lng7XG5cdCAgICB2YXIgdGFyZ2V0UmlnaHQgPSB0YXJnZXRMZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aDtcblx0ICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0Lnk7XG5cdCAgICB2YXIgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0VG9wICsgdGFyZ2V0UmVjdC5oZWlnaHQ7XG5cblx0ICAgIGZvciAodmFyIGogPSBfaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdCAgICAgIGlmIChfaSAhPT0gaikge1xuXHQgICAgICAgIHZhciBvdGhlclJlY3QgPSBib3VuZGluZ1JlY3RzW2pdO1xuXHQgICAgICAgIHZhciBvdGhlckxlZnQgPSBvdGhlclJlY3QueDtcblx0ICAgICAgICB2YXIgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aDtcblx0ICAgICAgICB2YXIgb3RoZXJUb3AgPSBvdGhlclJlY3QueTtcblx0ICAgICAgICB2YXIgb3RoZXJCb3R0b20gPSBvdGhlclRvcCArIG90aGVyUmVjdC5oZWlnaHQ7IC8vIE1lcmdpbmcgYWxsIHJlY3RzIHRvIHRoZSBtaW5pbXVtcyBzZXQgd291bGQgYmUgY29tcGxpY2F0ZWQsXG5cdCAgICAgICAgLy8gYnV0IHdlIGNhbiBoYW5kbGUgdGhlIG1vc3QgY29tbW9uIGNhc2VzOlxuXHQgICAgICAgIC8vIDEuIGNvbXBsZXRlbHkgb3ZlcmxhcHBpbmcgcmVjdHNcblx0ICAgICAgICAvLyAyLiBhZGphY2VudCByZWN0cyB0aGF0IGFyZSB0aGUgc2FtZSB3aWR0aCBvciBoZWlnaHQgKGUuZy4gaXRlbXMgaW4gYSBsaXN0KVxuXHQgICAgICAgIC8vXG5cdCAgICAgICAgLy8gRXZlbiBnaXZlbiB0aGUgYWJvdmUgY29uc3RyYWludHMsXG5cdCAgICAgICAgLy8gd2Ugc3RpbGwgd29uJ3QgZW5kIHVwIHdpdGggdGhlIGZld2VzdCBwb3NzaWJsZSByZWN0cyB3aXRob3V0IGRvaW5nIG11bHRpcGxlIHBhc3Nlcyxcblx0ICAgICAgICAvLyBidXQgaXQncyBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlLlxuXG5cdCAgICAgICAgaWYgKHRhcmdldExlZnQgPj0gb3RoZXJMZWZ0ICYmIHRhcmdldFRvcCA+PSBvdGhlclRvcCAmJiB0YXJnZXRSaWdodCA8PSBvdGhlclJpZ2h0ICYmIHRhcmdldEJvdHRvbSA8PSBvdGhlckJvdHRvbSkge1xuXHQgICAgICAgICAgLy8gQ29tcGxldGUgb3ZlcmxhcHBpbmcgcmVjdHM7IHJlbW92ZSB0aGUgaW5uZXIgb25lLlxuXHQgICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRMZWZ0ID09PSBvdGhlckxlZnQgJiYgdGFyZ2V0UmVjdC53aWR0aCA9PT0gb3RoZXJSZWN0LndpZHRoICYmICEob3RoZXJCb3R0b20gPCB0YXJnZXRUb3ApICYmICEob3RoZXJUb3AgPiB0YXJnZXRCb3R0b20pKSB7XG5cdCAgICAgICAgICAvLyBBZGphY2VudCB2ZXJ0aWNhbCByZWN0czsgbWVyZ2UgdGhlbS5cblx0ICAgICAgICAgIGlmIChvdGhlclRvcCA+IHRhcmdldFRvcCkge1xuXHQgICAgICAgICAgICBvdGhlclJlY3QuaGVpZ2h0ICs9IG90aGVyVG9wIC0gdGFyZ2V0VG9wO1xuXHQgICAgICAgICAgICBvdGhlclJlY3QueSA9IHRhcmdldFRvcDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKG90aGVyQm90dG9tIDwgdGFyZ2V0Qm90dG9tKSB7XG5cdCAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUb3AgPT09IG90aGVyVG9wICYmIHRhcmdldFJlY3QuaGVpZ2h0ID09PSBvdGhlclJlY3QuaGVpZ2h0ICYmICEob3RoZXJSaWdodCA8IHRhcmdldExlZnQpICYmICEob3RoZXJMZWZ0ID4gdGFyZ2V0UmlnaHQpKSB7XG5cdCAgICAgICAgICAvLyBBZGphY2VudCBob3Jpem9udGFsIHJlY3RzOyBtZXJnZSB0aGVtLlxuXHQgICAgICAgICAgaWYgKG90aGVyTGVmdCA+IHRhcmdldExlZnQpIHtcblx0ICAgICAgICAgICAgb3RoZXJSZWN0LndpZHRoICs9IG90aGVyTGVmdCAtIHRhcmdldExlZnQ7XG5cdCAgICAgICAgICAgIG90aGVyUmVjdC54ID0gdGFyZ2V0TGVmdDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKG90aGVyUmlnaHQgPCB0YXJnZXRSaWdodCkge1xuXHQgICAgICAgICAgICBvdGhlclJlY3Qud2lkdGggPSB0YXJnZXRSaWdodCAtIG90aGVyTGVmdDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJvdW5kaW5nUmVjdHM7XG5cdH1cblx0ZnVuY3Rpb24gZm9jdXNXaXRoaW4oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuXHQgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcblx0ICB9XG5cblx0ICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG5cdCAgdmFyIG1hdGNoaW5nRmliZXJzID0gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycyk7XG5cdCAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG5cdCAgdmFyIGluZGV4ID0gMDtcblxuXHQgIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuXHQgICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG5cblx0ICAgIGlmIChpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG5cdCAgICAgIHZhciBub2RlID0gZmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgIGlmIChzZXRGb2N1c0lmRm9jdXNhYmxlKG5vZGUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cblx0ICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICBzdGFjay5wdXNoKGNoaWxkKTtcblx0ICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgY29tbWl0SG9va3MgPSBbXTtcblx0ZnVuY3Rpb24gb25Db21taXRSb290JDEoKSB7XG5cdCAgaWYgKHN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuXHQgICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuXHQgICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIG9ic2VydmVWaXNpYmxlUmVjdHMoaG9zdFJvb3QsIHNlbGVjdG9ycywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0ICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG5cdCAgfVxuXG5cdCAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG5cblx0ICB2YXIgX3NldHVwSW50ZXJzZWN0aW9uT2JzID0gc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcihpbnN0YW5jZVJvb3RzLCBjYWxsYmFjaywgb3B0aW9ucyksXG5cdCAgICAgIGRpc2Nvbm5lY3QgPSBfc2V0dXBJbnRlcnNlY3Rpb25PYnMuZGlzY29ubmVjdCxcblx0ICAgICAgb2JzZXJ2ZSA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5vYnNlcnZlLFxuXHQgICAgICB1bm9ic2VydmUgPSBfc2V0dXBJbnRlcnNlY3Rpb25PYnMudW5vYnNlcnZlOyAvLyBXaGVuIFJlYWN0IG11dGF0ZXMgdGhlIGhvc3QgZW52aXJvbm1lbnQsIHdlIG1heSBuZWVkIHRvIGNoYW5nZSB3aGF0IHdlJ3JlIGxpc3RlbmluZyB0by5cblxuXG5cdCAgdmFyIGNvbW1pdEhvb2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgbmV4dEluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG5cdCAgICBpbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgICAgICBpZiAobmV4dEluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuXHQgICAgICAgIHVub2JzZXJ2ZSh0YXJnZXQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIG5leHRJbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgICAgICBpZiAoaW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG5cdCAgICAgICAgb2JzZXJ2ZSh0YXJnZXQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcblx0ICByZXR1cm4ge1xuXHQgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgUmVhY3QgbXV0YXRpb25zOlxuXHQgICAgICB2YXIgaW5kZXggPSBjb21taXRIb29rcy5pbmRleE9mKGNvbW1pdEhvb2spO1xuXG5cdCAgICAgIGlmIChpbmRleCA+PSAwKSB7XG5cdCAgICAgICAgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgfSAvLyBEaXNjb25uZWN0IHRoZSBob3N0IG9ic2VydmVyOlxuXG5cblx0ICAgICAgZGlzY29ubmVjdCgpO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblxuXHR2YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTtcblx0ZnVuY3Rpb24gaXNMZWdhY3lBY3RFbnZpcm9ubWVudChmaWJlcikge1xuXHQgIHtcblx0ICAgIC8vIExlZ2FjeSBtb2RlLiBXZSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2YgUmVhY3QgMTcncyBhY3QuIEl0IGFzc3VtZXMgYW5cblx0ICAgIC8vIGFjdCBlbnZpcm9ubWVudCB3aGVuZXZlciBgamVzdGAgaXMgZGVmaW5lZCwgYnV0IHlvdSBjYW4gc3RpbGwgdHVybiBvZmZcblx0ICAgIC8vIHNwdXJpb3VzIHdhcm5pbmdzIGJ5IHNldHRpbmcgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGV4cGxpY2l0bHlcblx0ICAgIC8vIHRvIGZhbHNlLlxuXHQgICAgdmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCA9IC8vICRGbG93RXhwZWN0ZWRFcnJvciDigJMgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGdsb2JhbFxuXHQgICAgdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCAhPT0gJ3VuZGVmaW5lZCcgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgOiB1bmRlZmluZWQ7IC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IGplc3RcblxuXHQgICAgdmFyIGplc3RJc0RlZmluZWQgPSB0eXBlb2YgamVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cdCAgICByZXR1cm4gd2FybnNJZk5vdEFjdGluZyAmJiBqZXN0SXNEZWZpbmVkICYmIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCAhPT0gZmFsc2U7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkge1xuXHQgIHtcblx0ICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcblx0ICAgIHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgIT09ICd1bmRlZmluZWQnID8gSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIDogdW5kZWZpbmVkO1xuXG5cdCAgICBpZiAoIWlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCAmJiBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG5cdCAgICAgIGVycm9yKCdUaGUgY3VycmVudCB0ZXN0aW5nIGVudmlyb25tZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIHN1cHBvcnQgJyArICdhY3QoLi4uKScpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuXHQgIH1cblx0fVxuXG5cdHZhciBjZWlsID0gTWF0aC5jZWlsO1xuXHR2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcblx0ICAgIFJlYWN0Q3VycmVudE93bmVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcixcblx0ICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcblx0ICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTtcblx0dmFyIE5vQ29udGV4dCA9XG5cdC8qICAgICAgICAgICAgICovXG5cdDA7XG5cdHZhciBCYXRjaGVkQ29udGV4dCA9XG5cdC8qICAgICAgICAgICAgICAgKi9cblx0MTtcblx0dmFyIFJlbmRlckNvbnRleHQgPVxuXHQvKiAgICAgICAgICAgICAgICAqL1xuXHQyO1xuXHR2YXIgQ29tbWl0Q29udGV4dCA9XG5cdC8qICAgICAgICAgICAgICAgICovXG5cdDQ7XG5cdHZhciBSb290SW5Qcm9ncmVzcyA9IDA7XG5cdHZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcblx0dmFyIFJvb3RFcnJvcmVkID0gMjtcblx0dmFyIFJvb3RTdXNwZW5kZWQgPSAzO1xuXHR2YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG5cdHZhciBSb290Q29tcGxldGVkID0gNTtcblx0dmFyIFJvb3REaWROb3RDb21wbGV0ZSA9IDY7IC8vIERlc2NyaWJlcyB3aGVyZSB3ZSBhcmUgaW4gdGhlIFJlYWN0IGV4ZWN1dGlvbiBzdGFja1xuXG5cdHZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cblx0dmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7IC8vIFRoZSBmaWJlciB3ZSdyZSB3b3JraW5nIG9uXG5cblx0dmFyIHdvcmtJblByb2dyZXNzID0gbnVsbDsgLy8gVGhlIGxhbmVzIHdlJ3JlIHJlbmRlcmluZ1xuXG5cdHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG5cdC8vIFRoaXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCB3b3JraW5nIG9uIGF0IHRoZSByb290LiBUaGUgb25seVxuXHQvLyBjYXNlIHdoZXJlIGl0J3MgZGlmZmVyZW50IGZyb20gYHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzYCBpcyB3aGVuIHdlXG5cdC8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuXHQvLyBPZmZzY3JlZW4gY29tcG9uZW50LlxuXHQvL1xuXHQvLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG5cdC8vIE1vc3QgdGhpbmdzIGluIGJlZ2luL2NvbXBsZXRlIHBoYXNlcyBzaG91bGQgZGVhbCB3aXRoIHN1YnRyZWVSZW5kZXJMYW5lcy5cblxuXHR2YXIgc3VidHJlZVJlbmRlckxhbmVzID0gTm9MYW5lcztcblx0dmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cblx0dmFyIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzczsgLy8gQSBmYXRhbCBlcnJvciwgaWYgb25lIGlzIHRocm93blxuXG5cdHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gbnVsbDsgLy8gXCJJbmNsdWRlZFwiIGxhbmVzIHJlZmVyIHRvIGxhbmVzIHRoYXQgd2VyZSB3b3JrZWQgb24gZHVyaW5nIHRoaXMgcmVuZGVyLiBJdCdzXG5cdC8vIGluY2x1ZGVzIHVucHJvY2Vzc2VkIHVwZGF0ZXMsIG5vdCB3b3JrIGluIGJhaWxlZCBvdXQgY2hpbGRyZW4uXG5cblx0dmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG5cdHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlICgqbm90KiBhbiBpbnRlcmxlYXZlZCBldmVudCkuXG5cblx0dmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lczsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblxuXHR2YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cblx0Ly8gV2Ugd2lsbCBsb2cgdGhlbSBvbmNlIHRoZSB0cmVlIGNvbW1pdHMuXG5cblx0dmFyIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDsgLy8gVGhlIG1vc3QgcmVjZW50IHRpbWUgd2UgY29tbWl0dGVkIGEgZmFsbGJhY2suIFRoaXMgbGV0cyB1cyBlbnN1cmUgYSB0cmFpblxuXHQvLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxuXG5cdHZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMDtcblx0dmFyIEZBTExCQUNLX1RIUk9UVExFX01TID0gNTAwOyAvLyBUaGUgYWJzb2x1dGUgdGltZSBmb3Igd2hlbiB3ZSBzaG91bGQgc3RhcnQgZ2l2aW5nIHVwIG9uIHJlbmRlcmluZ1xuXHQvLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxuXHR2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5OyAvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG5cdC8vIHN1c3BlbnNlIGhldXJpc3RpY3MgYW5kIG9wdCBvdXQgb2YgcmVuZGVyaW5nIG1vcmUgY29udGVudC5cblxuXHR2YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG5cdHZhciB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbDtcblxuXHRmdW5jdGlvbiByZXNldFJlbmRlclRpbWVyKCkge1xuXHQgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3coKSArIFJFTkRFUl9USU1FT1VUX01TO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpIHtcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZTtcblx0fVxuXHR2YXIgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuXHR2YXIgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcblx0dmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDsgLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVTY2hlZHVsZWRIb29rIGlzIHRydWU7XG5cdHZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuXHR2YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xuXHR2YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXHR2YXIgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMgPSBbXTtcblx0dmFyIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cblx0dmFyIE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MDtcblx0dmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblx0dmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5cdHZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcblx0dmFyIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcblx0dmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xuXHR2YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcblx0dmFyIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsOyAvLyBJZiB0d28gdXBkYXRlcyBhcmUgc2NoZWR1bGVkIHdpdGhpbiB0aGUgc2FtZSBldmVudCwgd2Ugc2hvdWxkIHRyZWF0IHRoZWlyXG5cdC8vIGV2ZW50IHRpbWVzIGFzIHNpbXVsdGFuZW91cywgZXZlbiBpZiB0aGUgYWN0dWFsIGNsb2NrIHRpbWUgaGFzIGFkdmFuY2VkXG5cdC8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxuXHR2YXIgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXHR2YXIgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBOb0xhbmVzO1xuXHR2YXIgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gZmFsc2U7XG5cdGZ1bmN0aW9uIGdldFdvcmtJblByb2dyZXNzUm9vdCgpIHtcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xuXHR9XG5cdGZ1bmN0aW9uIHJlcXVlc3RFdmVudFRpbWUoKSB7XG5cdCAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuXHQgICAgLy8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG5cdCAgICByZXR1cm4gbm93KCk7XG5cdCAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuXHQgIGlmIChjdXJyZW50RXZlbnRUaW1lICE9PSBOb1RpbWVzdGFtcCkge1xuXHQgICAgLy8gVXNlIHRoZSBzYW1lIHN0YXJ0IHRpbWUgZm9yIGFsbCB1cGRhdGVzIHVudGlsIHdlIGVudGVyIFJlYWN0IGFnYWluLlxuXHQgICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG5cdCAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgc2luY2UgUmVhY3QgeWllbGRlZC4gQ29tcHV0ZSBhIG5ldyBzdGFydCB0aW1lLlxuXG5cblx0ICBjdXJyZW50RXZlbnRUaW1lID0gbm93KCk7XG5cdCAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpIHtcblx0ICAvLyBTcGVjaWFsIGNhc2VzXG5cdCAgdmFyIG1vZGUgPSBmaWJlci5tb2RlO1xuXG5cdCAgaWYgKChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcblx0ICAgIHJldHVybiBTeW5jTGFuZTtcblx0ICB9IGVsc2UgaWYgKCAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IE5vTGFuZXMpIHtcblx0ICAgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBUaGVzZSBhcmUgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLiBUaGVcblx0ICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG5cdCAgICAvLyB3aGF0ZXZlciBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLiBTbyBpZiB5b3UgY2FsbCBgc2V0U3RhdGVgIG9uIGEgY29tcG9uZW50XG5cdCAgICAvLyB0aGF0IGhhcHBlbnMgbGF0ZXIgaW4gdGhlIHNhbWUgcmVuZGVyLCBpdCB3aWxsIGZsdXNoLiBJZGVhbGx5LCB3ZSB3YW50IHRvXG5cdCAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuXHQgICAgLy8gaW50ZXJsZWF2ZWQgZXZlbnQuIFJlZ2FyZGxlc3MsIHRoaXMgcGF0dGVybiBpcyBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuXG5cdCAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG9ubHkgYSBmYWxsYmFjay4gVGhlIGZsYWcgb25seSBleGlzdHMgdW50aWwgd2UgY2FuIHJvbGxcblx0ICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuXHQgICAgLy8gdGhlIGN1cnJlbnQgYmVoYXZpb3IuXG5cdCAgICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmUod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuXHQgIH1cblxuXHQgIHZhciBpc1RyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSAhPT0gTm9UcmFuc2l0aW9uO1xuXG5cdCAgaWYgKGlzVHJhbnNpdGlvbikge1xuXHQgICAgaWYgKCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gIT09IG51bGwpIHtcblx0ICAgICAgdmFyIHRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG5cblx0ICAgICAgaWYgKCF0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG5cdCAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuYWRkKGZpYmVyKTtcblx0ICAgIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG5cdCAgICAvLyB1cGRhdGVzIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGhpbiB0aGUgc2FtZSBldmVudC4gVG8gZG8gdGhpcywgdGhlXG5cdCAgICAvLyBpbnB1dHMgdG8gdGhlIGFsZ29yaXRobSBtdXN0IGJlIHRoZSBzYW1lLlxuXHQgICAgLy9cblx0ICAgIC8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuXHQgICAgLy8gZXZlbnQuIFRoZW4gcmVzZXQgdGhlIGNhY2hlZCB2YWx1ZXMgb25jZSB3ZSBjYW4gYmUgc3VyZSB0aGUgZXZlbnQgaXNcblx0ICAgIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cblxuXG5cdCAgICBpZiAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPT09IE5vTGFuZSkge1xuXHQgICAgICAvLyBBbGwgdHJhbnNpdGlvbnMgd2l0aGluIHRoZSBzYW1lIGV2ZW50IGFyZSBhc3NpZ25lZCB0aGUgc2FtZSBsYW5lLlxuXHQgICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcblx0ICB9IC8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcblx0ICAvLyB0aGVpciBwcmlvcml0eSBzZXQgYnkgdHJhY2tpbmcgaXQgd2l0aCBhIGNvbnRleHQgdmFyaWFibGUuXG5cdCAgLy9cblx0ICAvLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cblx0ICAvLyB1c2UgdGhhdCBkaXJlY3RseS5cblx0ICAvLyBUT0RPOiBNb3ZlIHRoaXMgdHlwZSBjb252ZXJzaW9uIHRvIHRoZSBldmVudCBwcmlvcml0eSBtb2R1bGUuXG5cblxuXHQgIHZhciB1cGRhdGVMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cblx0ICBpZiAodXBkYXRlTGFuZSAhPT0gTm9MYW5lKSB7XG5cdCAgICByZXR1cm4gdXBkYXRlTGFuZTtcblx0ICB9IC8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuXHQgIC8vIGFwcHJvcHJpYXRlIHByaW9yaXR5LCBiYXNlZCBvbiB0aGUgdHlwZSBvZiBldmVudC5cblx0ICAvL1xuXHQgIC8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuXHQgIC8vIHVzZSB0aGF0IGRpcmVjdGx5LlxuXHQgIC8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cblxuXG5cdCAgdmFyIGV2ZW50TGFuZSA9IGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7XG5cdCAgcmV0dXJuIGV2ZW50TGFuZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcblx0ICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgcmVxdWVzdFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2Vcblx0ICAvLyBcInJldHJpZXNcIiDigJQgYSBzcGVjaWFsIHVwZGF0ZSB0aGF0IGF0dGVtcHRzIHRvIGZsaXAgYSBTdXNwZW5zZSBib3VuZGFyeVxuXHQgIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuXHQgIC8vIFNwZWNpYWwgY2FzZXNcblx0ICB2YXIgbW9kZSA9IGZpYmVyLm1vZGU7XG5cblx0ICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuXHQgICAgcmV0dXJuIFN5bmNMYW5lO1xuXHQgIH1cblxuXHQgIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSwgZXZlbnRUaW1lKSB7XG5cdCAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG5cblx0ICB7XG5cdCAgICBpZiAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KSB7XG5cdCAgICAgIGVycm9yKCd1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy4nKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB7XG5cdCAgICBpZiAoaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG5cdCAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cblx0ICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcblxuXHQgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0xhbmVzICYmIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuXHQgICAgLy8gVGhpcyB1cGRhdGUgd2FzIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXMgaXMgYSBtaXN0YWtlXG5cdCAgICAvLyBpZiB0aGUgdXBkYXRlIG9yaWdpbmF0ZXMgZnJvbSB1c2VyIHNwYWNlICh3aXRoIHRoZSBleGNlcHRpb24gb2YgbG9jYWxcblx0ICAgIC8vIGhvb2sgdXBkYXRlcywgd2hpY2ggYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IHJlYWNoIHRoaXNcblx0ICAgIC8vIGZ1bmN0aW9uKSwgYnV0IHRoZXJlIGFyZSBzb21lIGludGVybmFsIFJlYWN0IGZlYXR1cmVzIHRoYXQgdXNlIHRoaXMgYXNcblx0ICAgIC8vIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgbGlrZSBzZWxlY3RpdmUgaHlkcmF0aW9uLlxuXHQgICAgd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpOyAvLyBUcmFjayBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBUaGlzIGlzIGEgbm9ybWFsIHVwZGF0ZSwgc2NoZWR1bGVkIGZyb20gb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLiBGb3Jcblx0ICAgIC8vIGV4YW1wbGUsIGR1cmluZyBhbiBpbnB1dCBldmVudC5cblx0ICAgIHtcblx0ICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG5cdCAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpO1xuXG5cdCAgICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG5cdCAgICAgIC8vIFJlY2VpdmVkIGFuIHVwZGF0ZSB0byBhIHRyZWUgdGhhdCdzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLiBNYXJrXG5cdCAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuXHQgICAgICAvLyBgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoYCBmbGFnIGlzIG9mZiBhbmQgdGhpcyBpcyBhIHJlbmRlclxuXHQgICAgICAvLyBwaGFzZSB1cGRhdGUuIEluIHRoYXQgY2FzZSwgd2UgZG9uJ3QgdHJlYXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXMgaWZcblx0ICAgICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuXHQgICAgICBpZiAoIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCkge1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcywgbGFuZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuXHQgICAgICAgIC8vIFRoZSByb290IGFscmVhZHkgc3VzcGVuZGVkIHdpdGggYSBkZWxheSwgd2hpY2ggbWVhbnMgdGhpcyByZW5kZXJcblx0ICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcblx0ICAgICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcblx0ICAgICAgICAvLyBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHJlbmRlciBhbmQgc3dpdGNoaW5nIHRvIHRoZSB1cGRhdGUuXG5cdCAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuXHQgICAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG5cdCAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG5cblx0ICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuXHQgICAgISggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5pc0JhdGNoaW5nTGVnYWN5KSkge1xuXHQgICAgICAvLyBGbHVzaCB0aGUgc3luY2hyb25vdXMgd29yayBub3csIHVubGVzcyB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb3IgaW5zaWRlXG5cdCAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2Zcblx0ICAgICAgLy8gc2NoZWR1bGVDYWxsYmFja0ZvckZpYmVyIHRvIHByZXNlcnZlIHRoZSBhYmlsaXR5IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcblx0ICAgICAgLy8gd2l0aG91dCBpbW1lZGlhdGVseSBmbHVzaGluZyBpdC4gV2Ugb25seSBkbyB0aGlzIGZvciB1c2VyLWluaXRpYXRlZFxuXHQgICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuXHQgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG5cdCAgICAgIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSkge1xuXHQgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGZvcmsgb2Ygc2NoZWR1bGVVcGRhdGVPbkZpYmVyIHRoYXQgaXMgb25seSB1c2VkIHRvXG5cdCAgLy8gc2NoZWR1bGUgdGhlIGluaXRpYWwgaHlkcmF0aW9uIG9mIGEgcm9vdCB0aGF0IGhhcyBqdXN0IGJlZW4gY3JlYXRlZC4gTW9zdFxuXHQgIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG5cdCAgLy9cblx0ICAvLyBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXMgc2VwYXJhdGUgcGF0aCwgdGhvdWdoLCBpcyB0byBkaXN0aW5ndWlzaCB0aGVcblx0ICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcblx0ICAvLyAoY3JlYXRlUm9vdCBpbnN0ZWFkIG9mIGh5ZHJhdGVSb290KSwgYWxsIHRvcC1sZXZlbCByZW5kZXJzIGFyZSBtb2RlbGVkIGFzXG5cdCAgLy8gdXBkYXRlcywgYnV0IGh5ZHJhdGlvbiByb290cyBhcmUgc3BlY2lhbCBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0XG5cdCAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cblx0ICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcblx0ICBjdXJyZW50LmxhbmVzID0gbGFuZTtcblx0ICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcblx0ICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblx0fVxuXHRmdW5jdGlvbiBpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcblx0ICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gT25seSBjYWxsZWQgYnkgY2xhc3MgY29tcG9uZW50cyxcblx0ICAvLyB3aGljaCBzcGVjaWFsIChkZXByZWNhdGVkKSBiZWhhdmlvciBmb3IgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlIHByb3BzLlxuXHQgIHJldHVybiAoLy8gVE9ETzogUmVtb3ZlIG91dGRhdGVkIGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaCBleHBlcmltZW50LiBXZVxuXHQgICAgLy8gZGVjaWRlZCBub3QgdG8gZW5hYmxlIGl0LlxuXHQgICAgIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dFxuXHQgICk7XG5cdH0gLy8gVXNlIHRoaXMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSB0YXNrIGZvciBhIHJvb3QuIFRoZXJlJ3Mgb25seSBvbmUgdGFzayBwZXJcblx0Ly8gcm9vdDsgaWYgYSB0YXNrIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCwgd2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBwcmlvcml0eVxuXHQvLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcblx0Ly8gcm9vdCBoYXMgd29yayBvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgdXBkYXRlLCBhbmQgcmlnaHQgYmVmb3JlXG5cdC8vIGV4aXRpbmcgYSB0YXNrLlxuXG5cdGZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBjdXJyZW50VGltZSkge1xuXHQgIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlOyAvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuXHQgIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cblx0ICBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKTsgLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIGFuZCB0aGVpciBwcmlvcml0eS5cblxuXHQgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuXHQgIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcblx0ICAgIC8vIFNwZWNpYWwgY2FzZTogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG5cdCAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcblx0ICAgICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG5cdCAgICB9XG5cblx0ICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcblx0ICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcblx0ICAgIHJldHVybjtcblx0ICB9IC8vIFdlIHVzZSB0aGUgaGlnaGVzdCBwcmlvcml0eSBsYW5lIHRvIHJlcHJlc2VudCB0aGUgcHJpb3JpdHkgb2YgdGhlIGNhbGxiYWNrLlxuXG5cblx0ICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuXHQgIHZhciBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPSByb290LmNhbGxiYWNrUHJpb3JpdHk7XG5cblx0ICBpZiAoZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID09PSBuZXdDYWxsYmFja1ByaW9yaXR5ICYmIC8vIFNwZWNpYWwgY2FzZSByZWxhdGVkIHRvIGBhY3RgLiBJZiB0aGUgY3VycmVudGx5IHNjaGVkdWxlZCB0YXNrIGlzIGFcblx0ICAvLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZWRcblx0ICAvLyBvbiB0aGUgYGFjdGAgcXVldWUuXG5cdCAgISggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ICE9PSBudWxsICYmIGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBmYWtlQWN0Q2FsbGJhY2tOb2RlKSkge1xuXHQgICAge1xuXHQgICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byByZS11c2UgYW4gZXhpc3RpbmcgdGFzaywgaXQgbmVlZHMgdG8gZXhpc3QuXG5cdCAgICAgIC8vIEFzc3VtZSB0aGF0IGRpc2NyZXRlIHVwZGF0ZSBtaWNyb3Rhc2tzIGFyZSBub24tY2FuY2VsbGFibGUgYW5kIG51bGwuXG5cdCAgICAgIC8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCB3ZSBjb25maXJtIHRoaXMgd2FybmluZyBpcyBub3QgZmlyZWQuXG5cdCAgICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSA9PSBudWxsICYmIGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSAhPT0gU3luY0xhbmUpIHtcblx0ICAgICAgICBlcnJvcignRXhwZWN0ZWQgc2NoZWR1bGVkIGNhbGxiYWNrIHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIFRoZSBwcmlvcml0eSBoYXNuJ3QgY2hhbmdlZC4gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyB0YXNrLiBFeGl0LlxuXG5cblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT0gbnVsbCkge1xuXHQgICAgLy8gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXcgb25lIGJlbG93LlxuXHQgICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG5cdCAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cblxuXG5cdCAgdmFyIG5ld0NhbGxiYWNrTm9kZTtcblxuXHQgIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jTGFuZSkge1xuXHQgICAgLy8gU3BlY2lhbCBjYXNlOiBTeW5jIFJlYWN0IGNhbGxiYWNrcyBhcmUgc2NoZWR1bGVkIG9uIGEgc3BlY2lhbFxuXHQgICAgLy8gaW50ZXJuYWwgcXVldWVcblx0ICAgIGlmIChyb290LnRhZyA9PT0gTGVnYWN5Um9vdCkge1xuXHQgICAgICBpZiAoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSAhPT0gbnVsbCkge1xuXHQgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSB0cnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2NoZWR1bGVTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc3VwcG9ydHNNaWNyb3Rhc2tzKSB7XG5cdCAgICAgIC8vIEZsdXNoIHRoZSBxdWV1ZSBpbiBhIG1pY3JvdGFzay5cblx0ICAgICAgaWYgKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAvLyBJbnNpZGUgYGFjdGAsIHVzZSBvdXIgaW50ZXJuYWwgYGFjdGAgcXVldWUgc28gdGhhdCB0aGVzZSBnZXQgZmx1c2hlZFxuXHQgICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NvcGUgZXZlbiB3aGVuIHVzaW5nIHRoZSBzeW5jIHZlcnNpb25cblx0ICAgICAgICAvLyBvZiBgYWN0YC5cblx0ICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQucHVzaChmbHVzaFN5bmNDYWxsYmFja3MpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIC8vIEluIFNhZmFyaSwgYXBwZW5kaW5nIGFuIGlmcmFtZSBmb3JjZXMgbWljcm90YXNrcyB0byBydW4uXG5cdCAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG5cdCAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJ1bm5pbmcgY2FsbGJhY2tzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyXG5cdCAgICAgICAgICAvLyBvciBjb21taXQgc28gd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0IHRoYXQuXG5cdCAgICAgICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG5cdCAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHN0aWxsIHByZW1hdHVyZWx5IGZsdXNoIHRoZSBjYWxsYmFja3Ncblx0ICAgICAgICAgICAgLy8gaWYgdGhpcyBoYXBwZW5zIG91dHNpZGUgcmVuZGVyIG9yIGNvbW1pdCBwaGFzZSAoZS5nLiBpbiBhbiBldmVudCkuXG5cdCAgICAgICAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBGbHVzaCB0aGUgcXVldWUgaW4gYW4gSW1tZWRpYXRlIHRhc2suXG5cdCAgICAgIHNjaGVkdWxlQ2FsbGJhY2skMShJbW1lZGlhdGVQcmlvcml0eSwgZmx1c2hTeW5jQ2FsbGJhY2tzKTtcblx0ICAgIH1cblxuXHQgICAgbmV3Q2FsbGJhY2tOb2RlID0gbnVsbDtcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5TGV2ZWw7XG5cblx0ICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSkge1xuXHQgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcblx0ICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcblx0ICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpcblx0ICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcblx0ICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gSWRsZVByaW9yaXR5O1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrJDEoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCwgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuXHQgIH1cblxuXHQgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IG5ld0NhbGxiYWNrUHJpb3JpdHk7XG5cdCAgcm9vdC5jYWxsYmFja05vZGUgPSBuZXdDYWxsYmFja05vZGU7XG5cdH0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG5cdC8vIGdvZXMgdGhyb3VnaCBTY2hlZHVsZXIuXG5cblxuXHRmdW5jdGlvbiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3Qocm9vdCwgZGlkVGltZW91dCkge1xuXHQgIHtcblx0ICAgIHJlc2V0TmVzdGVkVXBkYXRlRmxhZygpO1xuXHQgIH0gLy8gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBhIFJlYWN0IGV2ZW50LCB3ZSBjYW4gY2xlYXIgdGhlIGN1cnJlbnRcblx0ICAvLyBldmVudCB0aW1lLiBUaGUgbmV4dCB1cGRhdGUgd2lsbCBjb21wdXRlIGEgbmV3IGV2ZW50IHRpbWUuXG5cblxuXHQgIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcblx0ICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZXM7XG5cblx0ICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO1xuXHQgIH0gLy8gRmx1c2ggYW55IHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGJlZm9yZSBkZWNpZGluZyB3aGljaCBsYW5lcyB0byB3b3JrIG9uLFxuXHQgIC8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG5cblxuXHQgIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuXHQgIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG5cdCAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcblx0ICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cblx0ICAgIC8vIENoZWNrIGlmIHRoZSB0YXNrIG5vZGUgZm9yIHRoaXMgcm9vdCB3YXMgY2hhbmdlZC5cblx0ICAgIGlmIChyb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcblx0ICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuXHQgICAgICAvLyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBiZWNhdXNlIHRoZSBjaGVjayBhYm92ZSBpbXBsaWVzIGVpdGhlciB0aGF0XG5cdCAgICAgIC8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgfSAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcblx0ICAvLyBvbiB0aGUgcm9vdC5cblxuXG5cdCAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG5cblx0ICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcblx0ICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSAvLyBXZSBkaXNhYmxlIHRpbWUtc2xpY2luZyBpbiBzb21lIGNhc2VzOiBpZiB0aGUgd29yayBoYXMgYmVlbiBDUFUtYm91bmRcblx0ICAvLyBmb3IgdG9vIGxvbmcgKFwiZXhwaXJlZFwiIHdvcmssIHRvIHByZXZlbnQgc3RhcnZhdGlvbiksIG9yIHdlJ3JlIGluXG5cdCAgLy8gc3luYy11cGRhdGVzLWJ5LWRlZmF1bHQgbW9kZS5cblx0ICAvLyBUT0RPOiBXZSBvbmx5IGNoZWNrIGBkaWRUaW1lb3V0YCBkZWZlbnNpdmVseSwgdG8gYWNjb3VudCBmb3IgYSBTY2hlZHVsZXJcblx0ICAvLyBidWcgd2UncmUgc3RpbGwgaW52ZXN0aWdhdGluZy4gT25jZSB0aGUgYnVnIGluIFNjaGVkdWxlciBpcyBmaXhlZCxcblx0ICAvLyB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIHRyYWNrIGV4cGlyYXRpb24gb3Vyc2VsdmVzLlxuXG5cblx0ICB2YXIgc2hvdWxkVGltZVNsaWNlID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSAmJiAhaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykgJiYgKCAhZGlkVGltZW91dCk7XG5cdCAgdmFyIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2UgPyByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykgOiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cblx0ICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEluUHJvZ3Jlc3MpIHtcblx0ICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuXHQgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGxcblx0ICAgICAgLy8gcmVuZGVyIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsXG5cdCAgICAgIC8vIGluY2x1ZGVzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlclxuXHQgICAgICAvLyB0aGUgc2Vjb25kIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cdCAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuXHQgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG5cdCAgICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG5cdCAgICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcblx0ICAgICAgdmFyIGZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuXHQgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcblx0ICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG5cdCAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cdCAgICAgIHRocm93IGZhdGFsRXJyb3I7XG5cdCAgICB9XG5cblx0ICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcblx0ICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcblx0ICAgICAgLy8gY2FzZXMgd2hlcmUgbmVlZCB0byBleGl0IHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHByb2R1Y2luZyBhXG5cdCAgICAgIC8vIGNvbnNpc3RlbnQgdHJlZSBvciBjb21taXR0aW5nLlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBkdXJpbmcgYSBjb25jdXJyZW50IHJlbmRlciwgbm90IGEgZGlzY3JldGUgb3Jcblx0ICAgICAgLy8gc3luY2hyb25vdXMgdXBkYXRlLiBXZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGNoZWNrZWQgZm9yIHRoaXMgd2hlbiB3ZVxuXHQgICAgICAvLyB1bndvdW5kIHRoZSBzdGFjay5cblx0ICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cblx0ICAgICAgLy8gQ2hlY2sgaWYgdGhpcyByZW5kZXIgbWF5IGhhdmUgeWllbGRlZCB0byBhIGNvbmN1cnJlbnQgZXZlbnQsIGFuZCBpZiBzbyxcblx0ICAgICAgLy8gY29uZmlybSB0aGF0IGFueSBuZXdseSByZW5kZXJlZCBzdG9yZXMgYXJlIGNvbnNpc3RlbnQuXG5cdCAgICAgIC8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuXHQgICAgICAvLyB0byB0aGUgbWFpbiB0aHJlYWQsIGlmIGl0IHdhcyBmYXN0IGVub3VnaCwgb3IgaWYgaXQgZXhwaXJlZC4gV2UgY291bGRcblx0ICAgICAgLy8gc2tpcCB0aGUgY29uc2lzdGVuY3kgY2hlY2sgaW4gdGhhdCBjYXNlLCB0b28uXG5cdCAgICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKTtcblx0ICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG5cblx0ICAgICAgaWYgKHJlbmRlcldhc0NvbmN1cnJlbnQgJiYgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspKSB7XG5cdCAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuXHQgICAgICAgIC8vIHN5bmNocm9ub3VzbHksIHRvIGJsb2NrIGZ1cnRoZXIgbXV0YXRpb25zLlxuXHQgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7IC8vIFdlIG5lZWQgdG8gY2hlY2sgYWdhaW4gaWYgc29tZXRoaW5nIHRocmV3XG5cblx0ICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcblx0ICAgICAgICAgIHZhciBfZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cblx0ICAgICAgICAgIGlmIChfZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG5cdCAgICAgICAgICAgIGxhbmVzID0gX2Vycm9yUmV0cnlMYW5lcztcblx0ICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIF9lcnJvclJldHJ5TGFuZXMpOyAvLyBXZSBhc3N1bWUgdGhlIHRyZWUgaXMgbm93IGNvbnNpc3RlbnQgYmVjYXVzZSB3ZSBkaWRuJ3QgeWllbGQgdG8gYW55XG5cdCAgICAgICAgICAgIC8vIGNvbmN1cnJlbnQgZXZlbnRzLlxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG5cdCAgICAgICAgICB2YXIgX2ZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuXHQgICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG5cdCAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcblx0ICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cdCAgICAgICAgICB0aHJvdyBfZmF0YWxFcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIFRoZSBuZXh0IHN0ZXAgaXMgZWl0aGVyIHRvIGNvbW1pdCBpdCxcblx0ICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG5cdCAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuXHQgICAgICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcblx0ICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblxuXHQgIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcblx0ICAgIC8vIFRoZSB0YXNrIG5vZGUgc2NoZWR1bGVkIGZvciB0aGlzIHJvb3QgaXMgdGhlIHNhbWUgb25lIHRoYXQnc1xuXHQgICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cblx0ICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcykge1xuXHQgIC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sIGRpc2NhcmQgc2VydmVyIHJlc3BvbnNlIGFuZCBmYWxsXG5cdCAgLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG5cdCAgLy8gQmVmb3JlIHJlbmRlcmluZyBhZ2Fpbiwgc2F2ZSB0aGUgZXJyb3JzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuXG5cdCAgdmFyIGVycm9yc0Zyb21GaXJzdEF0dGVtcHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuXG5cdCAgaWYgKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpIHtcblx0ICAgIC8vIFRoZSBzaGVsbCBmYWlsZWQgdG8gaHlkcmF0ZS4gU2V0IGEgZmxhZyB0byBmb3JjZSBhIGNsaWVudCByZW5kZXJpbmdcblx0ICAgIC8vIGR1cmluZyB0aGUgbmV4dCBhdHRlbXB0LiBUbyBkbyB0aGlzLCB3ZSBjYWxsIHByZXBhcmVGcmVzaFN0YWNrIG5vd1xuXHQgICAgLy8gdG8gY3JlYXRlIHRoZSByb290IHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoaXMgaXMgYSBiaXQgd2VpcmQgaW4gdGVybXNcblx0ICAgIC8vIG9mIGZhY3RvcmluZywgYmVjYXVzZSBpdCByZWxpZXMgb24gcmVuZGVyUm9vdFN5bmMgbm90IGNhbGxpbmdcblx0ICAgIC8vIHByZXBhcmVGcmVzaFN0YWNrIGFnYWluIGluIHRoZSBjYWxsIGJlbG93LCB3aGljaCBoYXBwZW5zIGJlY2F1c2UgdGhlXG5cdCAgICAvLyByb290IGFuZCBsYW5lcyBoYXZlbid0IGNoYW5nZWQuXG5cdCAgICAvL1xuXHQgICAgLy8gVE9ETzogSSB0aGluayB3aGF0IHdlIHNob3VsZCBkbyBpcyBzZXQgRm9yY2VDbGllbnRSZW5kZXIgaW5zaWRlXG5cdCAgICAvLyB0aHJvd0V4Y2VwdGlvbiwgbGlrZSB3ZSBkbyBmb3IgbmVzdGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMuIFRoZSByZWFzb25cblx0ICAgIC8vIGl0J3MgaGVyZSBpbnN0ZWFkIGlzIHNvIHdlIGNhbiBzd2l0Y2ggdG8gdGhlIHN5bmNocm9ub3VzIHdvcmsgbG9vcCwgdG9vLlxuXHQgICAgLy8gU29tZXRoaW5nIHRvIGNvbnNpZGVyIGZvciBhIGZ1dHVyZSByZWZhY3Rvci5cblx0ICAgIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuXHQgICAgcm9vdFdvcmtJblByb2dyZXNzLmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyO1xuXG5cdCAgICB7XG5cdCAgICAgIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuXG5cdCAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSB7XG5cdCAgICAvLyBTdWNjZXNzZnVsbHkgZmluaXNoZWQgcmVuZGVyaW5nIG9uIHJldHJ5XG5cdCAgICAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuXHQgICAgLy8gdGhlbSB0byB0aGUgY29sbGVjdGlvbiBvZiByZWNvdmVyYWJsZSBlcnJvcnMuIFdlJ2xsIGxvZyB0aGVtIGluIHRoZVxuXHQgICAgLy8gY29tbWl0IHBoYXNlLlxuXHQgICAgdmFyIGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG5cdCAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yc0Zyb21GaXJzdEF0dGVtcHQ7IC8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgc2Vjb25kIGF0dGVtcHQgc2hvdWxkIGJlIHF1ZXVlZCBhZnRlciB0aGUgZXJyb3JzXG5cdCAgICAvLyBmcm9tIHRoZSBmaXJzdCBhdHRlbXB0LCB0byBwcmVzZXJ2ZSB0aGUgY2F1c2FsIHNlcXVlbmNlLlxuXG5cdCAgICBpZiAoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgIT09IG51bGwpIHtcblx0ICAgICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGV4aXRTdGF0dXM7XG5cdH1cblxuXHRmdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuXHQgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9PT0gbnVsbCkge1xuXHQgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnM7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIGVycm9ycyk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcykge1xuXHQgIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuXHQgICAgY2FzZSBSb290SW5Qcm9ncmVzczpcblx0ICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcblx0ICAgICAge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuXHQgICAgICB9XG5cdCAgICAvLyBGbG93IGtub3dzIGFib3V0IGludmFyaWFudCwgc28gaXQgY29tcGxhaW5zIGlmIEkgYWRkIGEgYnJlYWtcblx0ICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcblx0ICAgIC8vIGlmIEkgZG8uIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG5cdCAgICBjYXNlIFJvb3RFcnJvcmVkOlxuXHQgICAgICB7XG5cdCAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmV0cnkgdGhpcyB0cmVlLiBJZiB3ZSByZWFjaGVkXG5cdCAgICAgICAgLy8gdGhpcyBwb2ludCwgaXQgZXJyb3JlZCBhZ2Fpbi4gQ29tbWl0IGl0LlxuXHQgICAgICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcblx0ICAgICAge1xuXHQgICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpOyAvLyBXZSBoYXZlIGFuIGFjY2VwdGFibGUgbG9hZGluZyBzdGF0ZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHdlXG5cdCAgICAgICAgLy8gc2hvdWxkIGltbWVkaWF0ZWx5IGNvbW1pdCBpdCBvciB3YWl0IGEgYml0LlxuXG5cdCAgICAgICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIC8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcblx0ICAgICAgICAhc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcblx0ICAgICAgICAgIC8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuXHQgICAgICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG5cdCAgICAgICAgICB2YXIgbXNVbnRpbFRpbWVvdXQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLSBub3coKTsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cblx0ICAgICAgICAgIGlmIChtc1VudGlsVGltZW91dCA+IDEwKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cblx0ICAgICAgICAgICAgaWYgKG5leHRMYW5lcyAhPT0gTm9MYW5lcykge1xuXHQgICAgICAgICAgICAgIC8vIFRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdC5cblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG5cblx0ICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuXHQgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBwcmVmZXIgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBvZiBhdCB0aGUgbGFzdFxuXHQgICAgICAgICAgICAgIC8vIHN1c3BlbmRlZCBsZXZlbC4gUGluZyB0aGUgbGFzdCBzdXNwZW5kZWQgbGV2ZWwgdG8gdHJ5XG5cdCAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuXHQgICAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IGlmIHRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIElkbGU/IFNob3VsZCBub3QgcmVzdGFydC5cblx0ICAgICAgICAgICAgICByZXF1ZXN0RXZlbnRUaW1lKCk7XG5cdCAgICAgICAgICAgICAgbWFya1Jvb3RQaW5nZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuXHQgICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB3b3JrIHRvIGRvLiBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrXG5cdCAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGEgdG8gYXJyaXZlLlxuXG5cblx0ICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyksIG1zVW50aWxUaW1lb3V0KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSAvLyBUaGUgd29yayBleHBpcmVkLiBDb21taXQgaW1tZWRpYXRlbHkuXG5cblxuXHQgICAgICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcblx0ICAgICAge1xuXHQgICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG5cdCAgICAgICAgaWYgKGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSkge1xuXHQgICAgICAgICAgLy8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG5cdCAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG5cdCAgICAgICAgICAvLyB1bnRpbCB3ZSByZWNlaXZlIG1vcmUgZGF0YS5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcblx0ICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgdHJhbnNpdGlvbiwgYnV0IHdlIGRpZCB0cmlnZ2VyIGFuIGF2b2lkZWQgc3RhdGUuXG5cdCAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3Rcblx0ICAgICAgICAgIC8vIE5vdGljZWFibGUgRGlmZmVyZW5jZS5cblx0ICAgICAgICAgIC8vIFRPRE86IElzIHRoZSBKTkQgb3B0aW1pemF0aW9uIHdvcnRoIHRoZSBhZGRlZCBjb21wbGV4aXR5PyBJZiB0aGlzIGlzXG5cdCAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuXHQgICAgICAgICAgLy8gQ29uc2lkZXIgcmVtb3ZpbmcuXG5cdCAgICAgICAgICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCwgbGFuZXMpO1xuXHQgICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcblx0ICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE1zID0gbm93KCkgLSBldmVudFRpbWVNcztcblxuXHQgICAgICAgICAgdmFyIF9tc1VudGlsVGltZW91dCA9IGpuZCh0aW1lRWxhcHNlZE1zKSAtIHRpbWVFbGFwc2VkTXM7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG5cblx0ICAgICAgICAgIGlmIChfbXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuXHQgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGFcblx0ICAgICAgICAgICAgLy8gdG8gYXJyaXZlLlxuXHQgICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKSwgX21zVW50aWxUaW1lb3V0KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cblx0ICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG5cdCAgICAgIHtcblx0ICAgICAgICAvLyBUaGUgd29yayBjb21wbGV0ZWQuIFJlYWR5IHRvIGNvbW1pdC5cblx0ICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuJyk7XG5cdCAgICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG5cdCAgLy8gU2VhcmNoIHRoZSByZW5kZXJlZCB0cmVlIGZvciBleHRlcm5hbCBzdG9yZSByZWFkcywgYW5kIGNoZWNrIHdoZXRoZXIgdGhlXG5cdCAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZCBpbiBhIGNvbmN1cnJlbnQgZXZlbnQuIEludGVudGlvbmFsbHkgdXNpbmcgYW4gaXRlcmF0aXZlXG5cdCAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cblx0ICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcblxuXHQgIHdoaWxlICh0cnVlKSB7XG5cdCAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcblx0ICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gbm9kZS51cGRhdGVRdWV1ZTtcblxuXHQgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcblx0ICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG5cdCAgICAgICAgaWYgKGNoZWNrcyAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGVja3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuXHQgICAgICAgICAgICB2YXIgZ2V0U25hcHNob3QgPSBjaGVjay5nZXRTbmFwc2hvdDtcblx0ICAgICAgICAgICAgdmFyIHJlbmRlcmVkVmFsdWUgPSBjaGVjay52YWx1ZTtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIGlmICghb2JqZWN0SXMoZ2V0U25hcHNob3QoKSwgcmVuZGVyZWRWYWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGluY29uc2lzdGVudCBzdG9yZS5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcblx0ICAgICAgICAgICAgICAvLyBhIHJlLXJlbmRlciwgYW5kIHRoZSBlcnJvciB3aWxsIGJlIHJldGhyb3duIGR1cmluZyByZW5kZXIuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cblx0ICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcblx0ICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcblx0ICAgICAgbm9kZSA9IGNoaWxkO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuXHQgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG5cdCAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXHQgIH0gLy8gRmxvdyBkb2Vzbid0IGtub3cgdGhpcyBpcyB1bnJlYWNoYWJsZSwgYnV0IGVzbGludCBkb2VzXG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBzdXNwZW5kZWRMYW5lcykge1xuXHQgIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcblx0ICAvLyByYXJlbHksIHNpbmNlIHdlIHRyeSB0byBhdm9pZCBpdCkgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblx0ICAvLyBUT0RPOiBMb2wgbWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gZmFjdG9yIHRoaXMgYmVzaWRlcyB0aGlzXG5cdCAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcblx0ICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyk7XG5cdCAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpO1xuXHQgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcblx0fSAvLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3Igc3luY2hyb25vdXMgdGFza3MgdGhhdCBkb24ndCBnb1xuXHQvLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cblx0ZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcblx0ICB7XG5cdCAgICBzeW5jTmVzdGVkVXBkYXRlRmxhZygpO1xuXHQgIH1cblxuXHQgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG5cdCAgfVxuXG5cdCAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXHQgIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuXHQgIGlmICghaW5jbHVkZXNTb21lTGFuZShsYW5lcywgU3luY0xhbmUpKSB7XG5cdCAgICAvLyBUaGVyZSdzIG5vIHJlbWFpbmluZyBzeW5jIHdvcmsgbGVmdC5cblx0ICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuXHQgIGlmIChyb290LnRhZyAhPT0gTGVnYWN5Um9vdCAmJiBleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuXHQgICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuXHQgICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcblx0ICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG5cdCAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuXHQgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG5cdCAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG5cdCAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuXHQgICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuXHQgICAgdmFyIGZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuXHQgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG5cdCAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcblx0ICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cdCAgICB0aHJvdyBmYXRhbEVycm9yO1xuXHQgIH1cblxuXHQgIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuXHQgIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuXHQgIC8vIHdpbGwgY29tbWl0IGl0IGV2ZW4gaWYgc29tZXRoaW5nIHN1c3BlbmRlZC5cblxuXG5cdCAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG5cdCAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG5cdCAgcm9vdC5maW5pc2hlZExhbmVzID0gbGFuZXM7XG5cdCAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyk7IC8vIEJlZm9yZSBleGl0aW5nLCBtYWtlIHN1cmUgdGhlcmUncyBhIGNhbGxiYWNrIHNjaGVkdWxlZCBmb3IgdGhlIG5leHRcblx0ICAvLyBwZW5kaW5nIGxldmVsLlxuXG5cdCAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuXHQgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuXHQgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbWVyZ2VMYW5lcyhsYW5lcywgU3luY0xhbmUpKTtcblx0ICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cblx0ICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcblx0ICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuXHQgICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG5cdCAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblx0ICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG5cblx0ICB0cnkge1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcblx0ICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEZWZhdWx0RXZlbnRQcmlvcml0eSk7XG5cdCAgICByZXR1cm4gZm4oKTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG5cdCAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblx0ICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBmbihhKTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBJZiB0aGVyZSB3ZXJlIGxlZ2FjeSBzeW5jIHVwZGF0ZXMsIGZsdXNoIHRoZW0gYXQgdGhlIGVuZCBvZiB0aGUgb3V0ZXJcblx0ICAgIC8vIG1vc3QgYmF0Y2hlZFVwZGF0ZXMtbGlrZSBtZXRob2QuXG5cblx0ICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgLy8gVHJlYXQgYGFjdGAgYXMgaWYgaXQncyBpbnNpZGUgYGJhdGNoZWRVcGRhdGVzYCwgZXZlbiBpbiBsZWdhY3kgbW9kZS5cblx0ICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcblx0ICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuXHQgICAgICBmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuXHQgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cdCAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXG5cdCAgdHJ5IHtcblx0ICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG5cdCAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcblx0ICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cblx0ICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcblx0ICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuXHQgICAgfVxuXHQgIH1cblx0fSAvLyBPdmVybG9hZCB0aGUgZGVmaW5pdGlvbiB0byB0aGUgdHdvIHZhbGlkIHNpZ25hdHVyZXMuXG5cdC8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXHRmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcblx0ICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcblx0ICAvLyBuZXh0IGV2ZW50LCBub3QgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgb25lLlxuXHQgIGlmIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCAmJiByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy50YWcgPT09IExlZ2FjeVJvb3QgJiYgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG5cdCAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cdCAgfVxuXG5cdCAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblx0ICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXHQgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblx0ICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG5cdCAgdHJ5IHtcblx0ICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG5cdCAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcblxuXHQgICAgaWYgKGZuKSB7XG5cdCAgICAgIHJldHVybiBmbigpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICB9IGZpbmFsbHkge1xuXHQgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cdCAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG5cdCAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuXHQgICAgLy8gdGhlIHN0YWNrLlxuXG5cdCAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG5cdCAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBpc0FscmVhZHlSZW5kZXJpbmcoKSB7XG5cdCAgLy8gVXNlZCBieSB0aGUgcmVuZGVyZXIgdG8gcHJpbnQgYSB3YXJuaW5nIGlmIGNlcnRhaW4gQVBJcyBhcmUgY2FsbGVkIGZyb21cblx0ICAvLyB0aGUgd3JvbmcgY29udGV4dC5cblx0ICByZXR1cm4gIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dDtcblx0fVxuXHRmdW5jdGlvbiBmbHVzaENvbnRyb2xsZWQoZm4pIHtcblx0ICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuXHQgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cdCAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXHQgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cblx0ICB0cnkge1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcblx0ICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuXHQgICAgZm4oKTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cdCAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cblx0ICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcblx0ICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuXHQgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG5cdCAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsIGxhbmVzKSB7XG5cdCAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuXHQgIHN1YnRyZWVSZW5kZXJMYW5lcyA9IG1lcmdlTGFuZXMoc3VidHJlZVJlbmRlckxhbmVzLCBsYW5lcyk7XG5cdH1cblx0ZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpIHtcblx0ICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcblx0ICBwb3Aoc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLCBmaWJlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuXHQgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcblx0ICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG5cdCAgaWYgKHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCkge1xuXHQgICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG5cdCAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cblx0ICAgIHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDsgLy8gJEZsb3dGaXhNZSBDb21wbGFpbnMgbm9UaW1lb3V0IGlzIG5vdCBhIFRpbWVvdXRJRCwgZGVzcGl0ZSB0aGUgY2hlY2sgYWJvdmVcblxuXHQgICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcblx0ICB9XG5cblx0ICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcblx0ICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cblx0ICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcblx0ICAgICAgdmFyIGN1cnJlbnQgPSBpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlO1xuXHQgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrKTtcblx0ICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuXHQgIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuXHQgIHdvcmtJblByb2dyZXNzID0gcm9vdFdvcmtJblByb2dyZXNzO1xuXHQgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gbGFuZXM7XG5cdCAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzO1xuXHQgIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuXHQgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcblx0ICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbDtcblx0ICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG5cdCAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuXG5cdCAge1xuXHQgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuXHQgIH1cblxuXHQgIHJldHVybiByb290V29ya0luUHJvZ3Jlc3M7XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSkge1xuXHQgIGRvIHtcblx0ICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuXG5cdCAgICB0cnkge1xuXHQgICAgICAvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXHQgICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblx0ICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTtcblx0ICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogSSBmb3VuZCBhbmQgYWRkZWQgdGhpcyBtaXNzaW5nIGxpbmUgd2hpbGUgaW52ZXN0aWdhdGluZyBhXG5cdCAgICAgIC8vIHNlcGFyYXRlIGlzc3VlLiBXcml0ZSBhIHJlZ3Jlc3Npb24gdGVzdCB1c2luZyBzdHJpbmcgcmVmcy5cblxuXHQgICAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG5cdCAgICAgIGlmIChlcnJvcmVkV29yayA9PT0gbnVsbCB8fCBlcnJvcmVkV29yay5yZXR1cm4gPT09IG51bGwpIHtcblx0ICAgICAgICAvLyBFeHBlY3RlZCB0byBiZSB3b3JraW5nIG9uIGEgbm9uLXJvb3QgZmliZXIuIFRoaXMgaXMgYSBmYXRhbCBlcnJvclxuXHQgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgaXQ7IHRoZSByb290IGlzXG5cdCAgICAgICAgLy8gc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndCBjYXVnaHQgYnkgYW4gZXJyb3Jcblx0ICAgICAgICAvLyBib3VuZGFyeS5cblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gdGhyb3duVmFsdWU7IC8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcblx0ICAgICAgICAvLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG5cdCAgICAgICAgLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuXHQgICAgICAgIC8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcblx0ICAgICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuXHQgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG5cblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG5cdCAgICAgICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuXHQgICAgICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG5cdCAgICAgICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cblx0ICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLCB0cnVlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIpIHtcblx0ICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuXG5cdCAgICAgICAgaWYgKHRocm93blZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIHZhciB3YWtlYWJsZSA9IHRocm93blZhbHVlO1xuXHQgICAgICAgICAgbWFya0NvbXBvbmVudFN1c3BlbmRlZChlcnJvcmVkV29yaywgd2FrZWFibGUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbWFya0NvbXBvbmVudEVycm9yZWQoZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhyb3dFeGNlcHRpb24ocm9vdCwgZXJyb3JlZFdvcmsucmV0dXJuLCBlcnJvcmVkV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcblx0ICAgICAgY29tcGxldGVVbml0T2ZXb3JrKGVycm9yZWRXb3JrKTtcblx0ICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuXHQgICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHJldHVybiBwYXRoIGFsc28gdGhyZXcuXG5cdCAgICAgIHRocm93blZhbHVlID0geWV0QW5vdGhlclRocm93blZhbHVlO1xuXG5cdCAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcblx0ICAgICAgICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGhhcyBhbHJlYWR5IGVycm9yZWQsIHRoZW4gd2UgaGFkIHRyb3VibGUgcHJvY2Vzc2luZ1xuXHQgICAgICAgIC8vIHRoZSBlcnJvci4gQnViYmxlIGl0IHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuXHQgICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzID0gZXJyb3JlZFdvcms7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuXHQgICAgcmV0dXJuO1xuXHQgIH0gd2hpbGUgKHRydWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG5cdCAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQ7XG5cdCAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cblx0ICBpZiAocHJldkRpc3BhdGNoZXIgPT09IG51bGwpIHtcblx0ICAgIC8vIFRoZSBSZWFjdCBpc29tb3JwaGljIHBhY2thZ2UgZG9lcyBub3QgaW5jbHVkZSBhIGRlZmF1bHQgZGlzcGF0Y2hlci5cblx0ICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcblx0ICAgIC8vIG5pY2VyIGVycm9yIG1lc3NhZ2VzLlxuXHQgICAgcmV0dXJuIENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHByZXZEaXNwYXRjaGVyO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpIHtcblx0ICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCkge1xuXHQgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKTtcblx0fVxuXHRmdW5jdGlvbiBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGxhbmUpIHtcblx0ICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZCgpIHtcblx0ICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcblx0ICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuXHQgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG5cdCAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcblx0ICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcblx0ICAvLyB0aGlzIHJlbmRlci5cblxuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCAmJiAoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpKSkge1xuXHQgICAgLy8gTWFyayB0aGUgY3VycmVudCByZW5kZXIgYXMgc3VzcGVuZGVkIHNvIHRoYXQgd2Ugc3dpdGNoIHRvIHdvcmtpbmcgb25cblx0ICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG5cdCAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLlxuXHQgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGFsd2F5cyBtYXJrIHRoZSByb290IGFzIHN1c3BlbmRlZCBpbW1lZGlhdGVseVxuXHQgICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcblx0ICAgIC8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuXHQgICAgLy8gcGluZ2VkIG9yIHVwZGF0ZWQgd2hpbGUgd2Ugd2VyZSByZW5kZXJpbmcuXG5cdCAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiByZW5kZXJEaWRFcnJvcihlcnJvcikge1xuXHQgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG5cdCAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG5cdCAgfVxuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPT09IG51bGwpIHtcblx0ICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO1xuXHQgIH1cblx0fSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cblx0Ly8gUmV0dXJucyBmYWxzZSBpZiB3ZSdyZSBub3Qgc3VyZS5cblxuXHRmdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG5cdCAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcblx0ICAvLyBzbyB0aG9zZSBhcmUgZmFsc2UuXG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpIHtcblx0ICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuXHQgIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcblx0ICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpOyAvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcblx0ICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcblx0ICAgIHtcblx0ICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG5cdCAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cblx0ICAgICAgICBpZiAobWVtb2l6ZWRVcGRhdGVycy5zaXplID4gMCkge1xuXHQgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG5cdCAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG5cdCAgICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cblx0ICAgICAgICAvLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuXHQgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuXHQgICAgICAgIC8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5cblxuXHQgICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IGdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtcblx0ICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG5cdCAgfVxuXG5cdCAgZG8ge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgd29ya0xvb3BTeW5jKCk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcblx0ICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuXHQgICAgfVxuXHQgIH0gd2hpbGUgKHRydWUpO1xuXG5cdCAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG5cdCAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXHQgIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG5cdCAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgJyArICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG5cdCAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cblx0ICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuXHQgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcblx0ICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcblx0fSAvLyBUaGUgd29yayBsb29wIGlzIGFuIGV4dHJlbWVseSBob3QgcGF0aC4gVGVsbCBDbG9zdXJlIG5vdCB0byBpbmxpbmUgaXQuXG5cblx0LyoqIEBub2lubGluZSAqL1xuXG5cblx0ZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuXHQgIC8vIEFscmVhZHkgdGltZWQgb3V0LCBzbyBwZXJmb3JtIHdvcmsgd2l0aG91dCBjaGVja2luZyBpZiB3ZSBuZWVkIHRvIHlpZWxkLlxuXHQgIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuXHQgICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG5cdCAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblx0ICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG5cdCAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG5cdCAgLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cblxuXHQgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG5cdCAgICB7XG5cdCAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuXHQgICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXG5cdCAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcblx0ICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuXHQgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuXHQgICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG5cdCAgICAgICAgLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cblx0ICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cblx0ICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cblx0ICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7XG5cdCAgICByZXNldFJlbmRlclRpbWVyKCk7XG5cdCAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuXHQgIH1cblxuXHQgIGRvIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuXHQgICAgICBicmVhaztcblx0ICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG5cdCAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcblx0ICAgIH1cblx0ICB9IHdoaWxlICh0cnVlKTtcblxuXHQgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuXHQgIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuXHQgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG5cdCAgICAvLyBTdGlsbCB3b3JrIHJlbWFpbmluZy5cblx0ICAgIHtcblx0ICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFJvb3RJblByb2dyZXNzO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBDb21wbGV0ZWQgdGhlIHRyZWUuXG5cdCAgICB7XG5cdCAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG5cdCAgICB9IC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcblx0ICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuXHQgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG5cdCAgfVxuXHR9XG5cdC8qKiBAbm9pbmxpbmUgKi9cblxuXG5cdGZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcblx0ICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcblx0ICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcblx0ICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG5cdCAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuXHQgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG5cdCAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuXHQgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG5cdCAgc2V0Q3VycmVudEZpYmVyKHVuaXRPZldvcmspO1xuXHQgIHZhciBuZXh0O1xuXG5cdCAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcblx0ICAgIG5leHQgPSBiZWdpbldvcmskMShjdXJyZW50LCB1bml0T2ZXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuXHQgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG5cdCAgfVxuXG5cdCAgcmVzZXRDdXJyZW50RmliZXIoKTtcblx0ICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuXHQgIGlmIChuZXh0ID09PSBudWxsKSB7XG5cdCAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG5cdCAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcblx0ICB9XG5cblx0ICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcblx0ICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG5cdCAgLy8gc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGUgcGFyZW50IGZpYmVyLlxuXHQgIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuXHQgIGRvIHtcblx0ICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcblx0ICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG5cdCAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG5cdCAgICB2YXIgY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlO1xuXHQgICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47IC8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5cblx0ICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG5cdCAgICAgIHNldEN1cnJlbnRGaWJlcihjb21wbGV0ZWRXb3JrKTtcblx0ICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cblx0ICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcblx0ICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuXHQgICAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTsgLy8gVXBkYXRlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgZXJyb3IuXG5cblx0ICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG5cblx0ICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcblx0ICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG5cdCAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuXHQgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcblx0ICAgICAgLy8gY2FwdHVyZSB2YWx1ZXMgaWYgcG9zc2libGUuXG5cdCAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsoY3VycmVudCwgY29tcGxldGVkV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgbGFuZXMuXG5cblxuXHQgICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcblx0ICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcblx0ICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG5cdCAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3Rcblx0ICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuXHQgICAgICAgIF9uZXh0LmZsYWdzICY9IEhvc3RFZmZlY3RNYXNrO1xuXHQgICAgICAgIHdvcmtJblByb2dyZXNzID0gX25leHQ7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcblx0ICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cblx0ICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTsgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cblxuXHQgICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG5cdCAgICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuXHQgICAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG5cdCAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG5cdCAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuXHQgICAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG5cdCAgICAgICAgcmV0dXJuRmliZXIuc3VidHJlZUZsYWdzID0gTm9GbGFncztcblx0ICAgICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIFdlJ3ZlIHVud291bmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QuXG5cdCAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcblx0ICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cblx0ICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcblx0ICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cblx0ICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gdG8gdGhlIHBhcmVudFxuXG5cblx0ICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG5cdCAgfSB3aGlsZSAoY29tcGxldGVkV29yayAhPT0gbnVsbCk7IC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG5cblxuXHQgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuXHQgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMpIHtcblx0ICAvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG5cdCAgLy8gbGF5b3V0IHBoYXNlcy4gU2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlLlxuXHQgIHZhciBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXHQgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuXHQgIHRyeSB7XG5cdCAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuXHQgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cdCAgICBjb21taXRSb290SW1wbChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cdCAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG5cdCAgZG8ge1xuXHQgICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG5cdCAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcblx0ICAgIC8vIHBhc3NpdmUgZWZmZWN0cy4gU28gd2UgbmVlZCB0byBrZWVwIGZsdXNoaW5nIGluIGEgbG9vcCB1bnRpbCB0aGVyZSBhcmVcblx0ICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuXHQgICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcblx0ICAgIC8vIGZsdXNoIHN5bmNocm9ub3VzIHdvcmsgYXQgdGhlIGVuZCwgdG8gYXZvaWQgZmFjdG9yaW5nIGhhemFyZHMgbGlrZSB0aGlzLlxuXHQgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXHQgIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuXHQgIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpO1xuXG5cdCAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcblx0ICB9XG5cblx0ICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG5cdCAgdmFyIGxhbmVzID0gcm9vdC5maW5pc2hlZExhbmVzO1xuXG5cdCAge1xuXHQgICAgbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO1xuXHQgIH1cblxuXHQgIGlmIChmaW5pc2hlZFdvcmsgPT09IG51bGwpIHtcblxuXHQgICAge1xuXHQgICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9IGVsc2Uge1xuXHQgICAge1xuXHQgICAgICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcblx0ICAgICAgICBlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG5cdCAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcblxuXHQgIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArICdhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cdCAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuXHQgIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cblx0ICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG5cdCAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lOyAvLyBVcGRhdGUgdGhlIGZpcnN0IGFuZCBsYXN0IHBlbmRpbmcgdGltZXMgb24gdGhpcyByb290LiBUaGUgbmV3IGZpcnN0XG5cdCAgLy8gcGVuZGluZyB0aW1lIGlzIHdoYXRldmVyIGlzIGxlZnQgb24gdGhlIHJvb3QgZmliZXIuXG5cblx0ICB2YXIgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcywgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpO1xuXHQgIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuXG5cdCAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuXHQgICAgLy8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxuXHQgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcblx0ICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcblx0ICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcblx0ICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cywgc2NoZWR1bGUgYSBjYWxsYmFjayB0byBwcm9jZXNzIHRoZW0uXG5cdCAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcblx0ICAvLyBtaWdodCBnZXQgc2NoZWR1bGVkIGluIHRoZSBjb21taXQgcGhhc2UuIChTZWUgIzE2NzE0Lilcblx0ICAvLyBUT0RPOiBEZWxldGUgYWxsIG90aGVyIHBsYWNlcyB0aGF0IHNjaGVkdWxlIHRoZSBwYXNzaXZlIGVmZmVjdCBjYWxsYmFja1xuXHQgIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cblx0ICBpZiAoKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MgfHwgKGZpbmlzaGVkV29yay5mbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncykge1xuXHQgICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuXHQgICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG5cdCAgICAgIC8vIHRvIHN0b3JlIGl0IGluIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgdW50aWwgdGhleSBnZXQgcHJvY2Vzc2VkXG5cdCAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGlzIHRocm91Z2ggYXMgYW4gYXJndW1lbnQgdG8gY29tbWl0Um9vdFxuXHQgICAgICAvLyBiZWNhdXNlIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgbWlnaHQgaGF2ZSBjaGFuZ2VkIGJldHdlZW5cblx0ICAgICAgLy8gdGhlIHByZXZpb3VzIHJlbmRlciBhbmQgY29tbWl0IGlmIHdlIHRocm90dGxlIHRoZSBjb21taXRcblx0ICAgICAgLy8gd2l0aCBzZXRUaW1lb3V0XG5cblx0ICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuXHQgICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7IC8vIFRoaXMgcmVuZGVyIHRyaWdnZXJlZCBwYXNzaXZlIGVmZmVjdHM6IHJlbGVhc2UgdGhlIHJvb3QgY2FjaGUgcG9vbFxuXHQgICAgICAgIC8vICphZnRlciogcGFzc2l2ZSBlZmZlY3RzIGZpcmUgdG8gYXZvaWQgZnJlZWluZyBhIGNhY2hlIHBvb2wgdGhhdCBtYXlcblx0ICAgICAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGEgbm9kZSBpbiB0aGUgdHJlZSAoSG9zdFJvb3QsIENhY2hlIGJvdW5kYXJ5IGV0YylcblxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgZWZmZWN0cyBpbiB0aGUgd2hvbGUgdHJlZS5cblx0ICAvLyBUT0RPOiBUaGlzIGlzIGxlZnQgb3ZlciBmcm9tIHRoZSBlZmZlY3QgbGlzdCBpbXBsZW1lbnRhdGlvbiwgd2hlcmUgd2UgaGFkXG5cdCAgLy8gdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYGZpcnN0RWZmZWN0YCB0byBzYXRpc2Z5IEZsb3cuIEkgdGhpbmsgdGhlXG5cdCAgLy8gb25seSBvdGhlciByZWFzb24gdGhpcyBvcHRpbWl6YXRpb24gZXhpc3RzIGlzIGJlY2F1c2UgaXQgYWZmZWN0cyBwcm9maWxpbmcuXG5cdCAgLy8gUmVjb25zaWRlciB3aGV0aGVyIHRoaXMgaXMgbmVjZXNzYXJ5LlxuXG5cblx0ICB2YXIgc3VidHJlZUhhc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncztcblx0ICB2YXIgcm9vdEhhc0VmZmVjdCA9IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAoQmVmb3JlTXV0YXRpb25NYXNrIHwgTXV0YXRpb25NYXNrIHwgTGF5b3V0TWFzayB8IFBhc3NpdmVNYXNrKSkgIT09IE5vRmxhZ3M7XG5cblx0ICBpZiAoc3VidHJlZUhhc0VmZmVjdHMgfHwgcm9vdEhhc0VmZmVjdCkge1xuXHQgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcblx0ICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cdCAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcblx0ICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG5cdCAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7IC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG5cblx0ICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3Ncblx0ICAgIC8vIG9mIHRoZSBlZmZlY3QgbGlzdCBmb3IgZWFjaCBwaGFzZTogYWxsIG11dGF0aW9uIGVmZmVjdHMgY29tZSBiZWZvcmUgYWxsXG5cdCAgICAvLyBsYXlvdXQgZWZmZWN0cywgYW5kIHNvIG9uLlxuXHQgICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcblx0ICAgIC8vIHN0YXRlIG9mIHRoZSBob3N0IHRyZWUgcmlnaHQgYmVmb3JlIHdlIG11dGF0ZSBpdC4gVGhpcyBpcyB3aGVyZVxuXHQgICAgLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgaXMgY2FsbGVkLlxuXG5cdCAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblxuXHQgICAge1xuXHQgICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcblx0ICAgICAgLy8gYmF0Y2guIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG5cdCAgICAgIHJlY29yZENvbW1pdFRpbWUoKTtcblx0ICAgIH1cblxuXG5cdCAgICBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG5cblx0ICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcblx0ICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuXHQgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIGxheW91dCBwaGFzZSwgc28gdGhhdCB0aGUgZmluaXNoZWRcblx0ICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG5cdCAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcblxuXHQgICAge1xuXHQgICAgICBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuXHQgICAgfVxuXG5cdCAgICBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgbGFuZXMpO1xuXG5cdCAgICB7XG5cdCAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuXHQgICAgfVxuXHQgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcGFpbnQuXG5cblxuXHQgICAgcmVxdWVzdFBhaW50KCk7XG5cdCAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIFJlc2V0IHRoZSBwcmlvcml0eSB0byB0aGUgcHJldmlvdXMgbm9uLXN5bmMgdmFsdWUuXG5cblx0ICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcblx0ICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBObyBlZmZlY3RzLlxuXHQgICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuXHQgICAgLy8gbm8gZWZmZWN0cy5cblx0ICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG5cdCAgICB7XG5cdCAgICAgIHJlY29yZENvbW1pdFRpbWUoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyA9IHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzO1xuXG5cdCAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG5cdCAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3Rcblx0ICAgIC8vIHNjaGVkdWxlIGEgY2FsbGJhY2sgdW50aWwgYWZ0ZXIgZmx1c2hpbmcgbGF5b3V0IHdvcmsuXG5cdCAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuXHQgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuXHQgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBsYW5lcztcblx0ICB9IGVsc2Uge1xuXG5cdCAgICB7XG5cdCAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG5cdCAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuXHQgIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG5cdCAgLy8gVE9ETzogVGhpcyBpcyBwYXJ0IG9mIHRoZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGltcGxlbWVudGF0aW9uLiBJdHMgcHVycG9zZVxuXHQgIC8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcblx0ICAvLyBgY29tcG9uZW50RGlkQ2F0Y2hgLiBUaGUgbWVjaGFuaXNtIGlzIGtub3duIHRvIGJlIGZsYXdlZCBiZWNhdXNlIGBzZXRTdGF0ZWBcblx0ICAvLyBpbnNpZGUgYGNvbXBvbmVudERpZENhdGNoYCBpcyBpdHNlbGYgZmxhd2VkIOKAlCB0aGF0J3Mgd2h5IHdlIHJlY29tbWVuZFxuXHQgIC8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG5cdCAgLy8gY2hlY2tpbmcgaWYgcmVtYWluaW5nTGFuZXMgaW5jbHVkZXMgU3luYyB3b3JrLCBpbnN0ZWFkIG9mIHdoZXRoZXIgdGhlcmUnc1xuXHQgIC8vIGFueSB3b3JrIHJlbWFpbmluZyBhdCBhbGwgKHdoaWNoIHdvdWxkIGFsc28gaW5jbHVkZSBzdHVmZiBsaWtlIFN1c3BlbnNlXG5cdCAgLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG5cdCAgLy8gaXQgcHJvYmFibHkgaXNuJ3QgdGhhdCB1cmdlbnQuXG5cblx0ICBpZiAocmVtYWluaW5nTGFuZXMgPT09IE5vTGFuZXMpIHtcblx0ICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG5cdCAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuXHQgICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIGlmICghcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cykge1xuXHQgICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG5cdCAge1xuXHQgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG5cdCAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHtcblx0ICAgIG9uQ29tbWl0Um9vdCQxKCk7XG5cdCAgfSAvLyBBbHdheXMgY2FsbCB0aGlzIGJlZm9yZSBleGl0aW5nIGBjb21taXRSb290YCwgdG8gZW5zdXJlIHRoYXQgYW55XG5cdCAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuXHQgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cblx0ICBpZiAocmVjb3ZlcmFibGVFcnJvcnMgIT09IG51bGwpIHtcblx0ICAgIC8vIFRoZXJlIHdlcmUgZXJyb3JzIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHJlY292ZXJlZCBmcm9tIHRoZW0gd2l0aG91dFxuXHQgICAgLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cblx0ICAgIHZhciBvblJlY292ZXJhYmxlRXJyb3IgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvcjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ldO1xuXHQgICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSByZWNvdmVyYWJsZUVycm9yLnN0YWNrO1xuXHQgICAgICB2YXIgZGlnZXN0ID0gcmVjb3ZlcmFibGVFcnJvci5kaWdlc3Q7XG5cdCAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcihyZWNvdmVyYWJsZUVycm9yLnZhbHVlLCB7XG5cdCAgICAgICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrLFxuXHQgICAgICAgIGRpZ2VzdDogZGlnZXN0XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG5cdCAgICBoYXNVbmNhdWdodEVycm9yID0gZmFsc2U7XG5cdCAgICB2YXIgZXJyb3IkMSA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblx0ICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cdCAgICB0aHJvdyBlcnJvciQxO1xuXHQgIH0gLy8gSWYgdGhlIHBhc3NpdmUgZWZmZWN0cyBhcmUgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIHJlbmRlciwgZmx1c2ggdGhlbVxuXHQgIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuXHQgIC8vIGltbWVkaWF0ZWx5IG9ic2VydmFibGUuIE90aGVyd2lzZSwgd2UgYXNzdW1lIHRoYXQgdGhleSBhcmUgbm90XG5cdCAgLy8gb3JkZXItZGVwZW5kZW50IGFuZCBkbyBub3QgbmVlZCB0byBiZSBvYnNlcnZlZCBieSBleHRlcm5hbCBzeXN0ZW1zLCBzbyB3ZVxuXHQgIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuXHQgIC8vIFRPRE86IFdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IG5vdCBzY2hlZHVsaW5nIHRoZSBjYWxsYmFjayBlYXJsaWVyLiBTaW5jZSB3ZVxuXHQgIC8vIGN1cnJlbnRseSBzY2hlZHVsZSB0aGUgY2FsbGJhY2sgaW4gbXVsdGlwbGUgcGxhY2VzLCB3aWxsIHdhaXQgdW50aWwgdGhvc2Vcblx0ICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cblx0ICBpZiAoaW5jbHVkZXNTb21lTGFuZShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcywgU3luY0xhbmUpICYmIHJvb3QudGFnICE9PSBMZWdhY3lSb290KSB7XG5cdCAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cdCAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuXHQgIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cblx0ICBpZiAoaW5jbHVkZXNTb21lTGFuZShyZW1haW5pbmdMYW5lcywgU3luY0xhbmUpKSB7XG5cdCAgICB7XG5cdCAgICAgIG1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKTtcblx0ICAgIH0gLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuXHQgICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG5cdCAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzKSB7XG5cdCAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cdCAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IHJvb3Q7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblx0ICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG5cdCAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7XG5cblx0ICB7XG5cdCAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuXHQgIH1cblxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcblx0ICAvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cblx0ICAvLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcblx0ICAvLyBwcm9iYWJseSBqdXN0IGNvbWJpbmUgdGhlIHR3byBmdW5jdGlvbnMuIEkgYmVsaWV2ZSB0aGV5IHdlcmUgb25seSBzZXBhcmF0ZVxuXHQgIC8vIGluIHRoZSBmaXJzdCBwbGFjZSBiZWNhdXNlIHdlIHVzZWQgdG8gd3JhcCBpdCB3aXRoXG5cdCAgLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG5cdCAgLy8gcHJpb3JpdHkgd2l0aGluIFJlYWN0IGl0c2VsZiwgc28gd2UgY2FuIG11dGF0ZSB0aGUgdmFyaWFibGUgZGlyZWN0bHkuXG5cdCAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKSB7XG5cdCAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7XG5cdCAgICB2YXIgcHJpb3JpdHkgPSBsb3dlckV2ZW50UHJpb3JpdHkoRGVmYXVsdEV2ZW50UHJpb3JpdHksIHJlbmRlclByaW9yaXR5KTtcblx0ICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblx0ICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG5cdCAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG5cdCAgICAgIHJldHVybiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpO1xuXHQgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuXHQgICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjsgLy8gT25jZSBwYXNzaXZlIGVmZmVjdHMgaGF2ZSBydW4gZm9yIHRoZSB0cmVlIC0gZ2l2aW5nIGNvbXBvbmVudHMgYVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXHRmdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcikge1xuXHQgIHtcblx0ICAgIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzLnB1c2goZmliZXIpO1xuXG5cdCAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG5cdCAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcblx0ICAgICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcblx0ICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPT09IG51bGwpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9IC8vIENhY2hlIGFuZCBjbGVhciB0aGUgdHJhbnNpdGlvbnMgZmxhZ1xuXG5cblx0ICB2YXIgdHJhbnNpdGlvbnMgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuXHQgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuXHQgIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM7XG5cdCAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG5cdCAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsOyAvLyBUT0RPOiBUaGlzIGlzIHNvbWV0aW1lcyBvdXQgb2Ygc3luYyB3aXRoIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLlxuXHQgIC8vIEZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIEl0J3Mgbm90IGNhdXNpbmcgYW55IGtub3duIGlzc3VlcyAocHJvYmFibHlcblx0ICAvLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cblxuXHQgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcblxuXHQgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuXHQgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuXHQgIH1cblxuXHQgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG5cdCAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuXHQgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyhyb290LmN1cnJlbnQpO1xuXHQgIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcm9vdC5jdXJyZW50LCBsYW5lcywgdHJhbnNpdGlvbnMpOyAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuXHQgIHtcblx0ICAgIHZhciBwcm9maWxlckVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztcblx0ICAgIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZmlsZXJFZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBfZmliZXIgPSBwcm9maWxlckVmZmVjdHNbaV07XG5cdCAgICAgIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMocm9vdCwgX2ZpYmVyKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB7XG5cdCAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QuY3VycmVudCwgdHJ1ZSk7XG5cdCAgfVxuXG5cdCAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXHQgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXG5cdCAge1xuXHQgICAgLy8gSWYgYWRkaXRpb25hbCBwYXNzaXZlIGVmZmVjdHMgd2VyZSBzY2hlZHVsZWQsIGluY3JlbWVudCBhIGNvdW50ZXIuIElmIHRoaXNcblx0ICAgIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblx0ICAgIGlmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzKSB7XG5cdCAgICAgIGlmIChyb290ID09PSByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzKSB7XG5cdCAgICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Kys7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcblx0ICAgICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcblx0ICAgIH1cblxuXHQgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG5cdCAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG5cdCAgfSAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuXG5cdCAgb25Qb3N0Q29tbWl0Um9vdChyb290KTtcblxuXHQgIHtcblx0ICAgIHZhciBzdGF0ZU5vZGUgPSByb290LmN1cnJlbnQuc3RhdGVOb2RlO1xuXHQgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcblx0ICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuXHQgIH1cblxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuXHQgIHJldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO1xuXHR9XG5cdGZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcblx0ICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcblx0ICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcblx0ICBpZiAoIWhhc1VuY2F1Z2h0RXJyb3IpIHtcblx0ICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSB0cnVlO1xuXHQgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG5cdCAgfVxuXHR9XG5cblx0dmFyIG9uVW5jYXVnaHRFcnJvciA9IHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcjtcblxuXHRmdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuXHQgIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuXHQgIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcblx0ICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUsIFN5bmNMYW5lKTtcblx0ICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuXG5cdCAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcblx0ICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQxKSB7XG5cdCAge1xuXHQgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yJDEpO1xuXHQgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcblx0ICB9XG5cblx0ICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuXHQgICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuXHQgICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuXHQgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgZmliZXIgPSBudWxsO1xuXG5cdCAge1xuXHQgICAgZmliZXIgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yO1xuXHQgIH1cblxuXHQgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuXHQgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcblx0ICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG5cdCAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcblx0ICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuXHQgICAgICAgIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLCBzb3VyY2VGaWJlcik7XG5cdCAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgU3luY0xhbmUpO1xuXHQgICAgICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBTeW5jTGFuZSk7XG5cdCAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuXHQgICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG5cdCAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgLy8gVE9ETzogVW50aWwgd2UgcmUtbGFuZCBza2lwVW5tb3VudGVkQm91bmRhcmllcyAoc2VlICMyMDE0NyksIHRoaXMgd2FybmluZ1xuXHQgICAgLy8gd2lsbCBmaXJlIGZvciBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGRlc3Ryb3kgZnVuY3Rpb25zIGluc2lkZSBkZWxldGVkXG5cdCAgICAvLyB0cmVlcy4gV2hhdCBpdCBzaG91bGQgaW5zdGVhZCBkbyBpcyBwcm9wYWdhdGUgdGhlIGVycm9yIHRvIHRoZSBwYXJlbnQgb2Zcblx0ICAgIC8vIHRoZSBkZWxldGVkIHRyZWUuIEluIHRoZSBtZWFudGltZSwgZG8gbm90IGFkZCB0aGlzIHdhcm5pbmcgdG8gdGhlXG5cdCAgICAvLyBhbGxvd2xpc3Q7IHRoaXMgaXMgb25seSBmb3Igb3VyIGludGVybmFsIHVzZS5cblx0ICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgJyArICdpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gTGlrZWx5ICcgKyAnY2F1c2VzIGluY2x1ZGUgZGVsZXRpbmcgdGhlIHNhbWUgZmliZXIgbW9yZSB0aGFuIG9uY2UsIGNvbW1pdHRpbmcgYW4gJyArICdhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG4nICsgJ0Vycm9yIG1lc3NhZ2U6XFxuXFxuJXMnLCBlcnJvciQxKTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG5cdCAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuXG5cdCAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuXHQgICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcblx0ICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cblx0ICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuXHQgIH1cblxuXHQgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG5cdCAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuXHQgIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKHJvb3QpO1xuXG5cdCAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJiBpc1N1YnNldE9mTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHBpbmdlZExhbmVzKSkge1xuXHQgICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuXHQgICAgLy8gcmVuZGVyaW5nLiBXZSBtaWdodCB3YW50IHRvIHJlc3RhcnQgdGhpcyByZW5kZXIuIFRoaXMgc2hvdWxkIG1pcnJvclxuXHQgICAgLy8gdGhlIGxvZ2ljIG9mIHdoZXRoZXIgb3Igbm90IGEgcm9vdCBzdXNwZW5kcyBvbmNlIGl0IGNvbXBsZXRlcy5cblx0ICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuXHQgICAgLy8gd2Ugc2hvdWxkIHByb2JhYmx5IG5ldmVyIHJlc3RhcnQuXG5cdCAgICAvLyBJZiB3ZSdyZSBzdXNwZW5kZWQgd2l0aCBkZWxheSwgb3IgaWYgaXQncyBhIHJldHJ5LCB3ZSdsbCBhbHdheXMgc3VzcGVuZFxuXHQgICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuXHQgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCAmJiBpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSAmJiBub3coKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuXHQgICAgICAvLyBSZXN0YXJ0IGZyb20gdGhlIHJvb3QuXG5cdCAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gRXZlbiB0aG91Z2ggd2UgY2FuJ3QgcmVzdGFydCByaWdodCBub3csIHdlIG1pZ2h0IGdldCBhblxuXHQgICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuXHQgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcblx0ICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG5cdCAgLy8gcHJldmlvdXNseSB3YXMgcmVuZGVyZWQgaW4gaXRzIGZhbGxiYWNrIHN0YXRlLiBPbmUgb2YgdGhlIHByb21pc2VzIHRoYXRcblx0ICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuXHQgIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuXHQgIGlmIChyZXRyeUxhbmUgPT09IE5vTGFuZSkge1xuXHQgICAgLy8gVE9ETzogQXNzaWduIHRoaXMgdG8gYHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lYD8gdG8gYXZvaWRcblx0ICAgIC8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cblx0ICAgIHJldHJ5TGFuZSA9IHJlcXVlc3RSZXRyeUxhbmUoYm91bmRhcnlGaWJlcik7XG5cdCAgfSAvLyBUT0RPOiBTcGVjaWFsIGNhc2UgaWRsZSBwcmlvcml0eT9cblxuXG5cdCAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblx0ICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXG5cdCAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgIG1hcmtSb290VXBkYXRlZChyb290LCByZXRyeUxhbmUsIGV2ZW50VGltZSk7XG5cdCAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcblx0ICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcblx0ICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lO1xuXG5cdCAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcblx0ICAgIHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO1xuXHQgIH1cblxuXHQgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXHR9XG5cdGZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG5cdCAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG5cdCAgdmFyIHJldHJ5Q2FjaGU7XG5cblx0ICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG5cdCAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuXHQgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG5cdCAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuXG5cdCAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG5cdCAgICAgIH1cblxuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG5cdCAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuXHQgIH1cblxuXHQgIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG5cdCAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuXHQgICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuXHQgICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuXHQgIH1cblxuXHQgIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXHR9IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuXHQvLyBUaGUgdGhlb3J5IGlzIHRoYXQgYSBwZXJzb24gY2FuJ3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuXG5cdC8vIFRoZXJlZm9yZSwgaWYgd2Ugd2FpdCBhIGJpdCBsb25nZXIgdGhhbiBuZWNlc3NhcnkgdGhhdCB3b24ndCB0cmFuc2xhdGUgdG8gYSBub3RpY2VhYmxlXG5cdC8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG5cdC8vIHNob3dpbmcgYW4gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFRoZSBsb25nZXIgd2UgaGF2ZSBhbHJlYWR5IHdhaXRlZCwgdGhlIGhhcmRlciBpdFxuXHQvLyBpcyB0byB0ZWxsIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuIFRoZXJlZm9yZSwgdGhlIGxvbmdlciB3ZSd2ZSBhbHJlYWR5IHdhaXRlZCxcblx0Ly8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cblx0Ly8gV2UgcGljayBhIHRyYWluIG1vZGVsIHdoZXJlIHRoZSBuZXh0IGJvdW5kYXJ5IGNvbW1pdHMgYXQgYSBjb25zaXN0ZW50IHNjaGVkdWxlLlxuXHQvLyBUaGVzZSBwYXJ0aWN1bGFyIG51bWJlcnMgYXJlIHZhZ3VlIGVzdGltYXRlcy4gV2UgZXhwZWN0IHRvIGFkanVzdCB0aGVtIGJhc2VkIG9uIHJlc2VhcmNoLlxuXG5cdGZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuXHQgIHJldHVybiB0aW1lRWxhcHNlZCA8IDEyMCA/IDEyMCA6IHRpbWVFbGFwc2VkIDwgNDgwID8gNDgwIDogdGltZUVsYXBzZWQgPCAxMDgwID8gMTA4MCA6IHRpbWVFbGFwc2VkIDwgMTkyMCA/IDE5MjAgOiB0aW1lRWxhcHNlZCA8IDMwMDAgPyAzMDAwIDogdGltZUVsYXBzZWQgPCA0MzIwID8gNDMyMCA6IGNlaWwodGltZUVsYXBzZWQgLyAxOTYwKSAqIDE5NjA7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG5cdCAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuXHQgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXHQgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblx0ICAgIHRocm93IG5ldyBFcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyAncmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gJyArICdwcmV2ZW50IGluZmluaXRlIGxvb3BzLicpO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIGlmIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpIHtcblx0ICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcblx0ICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5cblx0ICAgICAgZXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgXCJjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IFwiICsgJ2hhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uICcgKyAnZXZlcnkgcmVuZGVyLicpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpIHtcblx0ICB7XG5cdCAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG5cblx0ICAgIHtcblx0ICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoZmliZXIsIGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG5cdCAge1xuXHQgICAgLy8gVE9ETyAoU3RyaWN0RWZmZWN0cykgU2hvdWxkIHdlIHNldCBhIG1hcmtlciBvbiB0aGUgcm9vdCBpZiBpdCBjb250YWlucyBzdHJpY3QgZWZmZWN0c1xuXHQgICAgLy8gc28gd2UgZG9uJ3QgdHJhdmVyc2UgdW5uZWNlc3NhcmlseT8gc2ltaWxhciB0byBzdWJ0cmVlRmxhZ3MgYnV0IGp1c3QgYXQgdGhlIHJvb3QgbGV2ZWwuXG5cdCAgICAvLyBNYXliZSBub3QgYSBiaWcgZGVhbCBzaW5jZSB0aGlzIGlzIERFViBvbmx5IGJlaGF2aW9yLlxuXHQgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblx0ICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRMYXlvdXREZXYsIGludm9rZUxheW91dEVmZmVjdFVubW91bnRJbkRFVik7XG5cblx0ICAgIGlmIChoYXNQYXNzaXZlRWZmZWN0cykge1xuXHQgICAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50UGFzc2l2ZURldiwgaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFVik7XG5cdCAgICB9XG5cblx0ICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRMYXlvdXREZXYsIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYpO1xuXG5cdCAgICBpZiAoaGFzUGFzc2l2ZUVmZmVjdHMpIHtcblx0ICAgICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudFBhc3NpdmVEZXYsIGludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWKTtcblx0ICAgIH1cblxuXHQgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZva2VFZmZlY3RzSW5EZXYoZmlyc3RDaGlsZCwgZmliZXJGbGFncywgaW52b2tlRWZmZWN0Rm4pIHtcblx0ICB7XG5cdCAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG5cdCAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuXHQgICAgdmFyIGN1cnJlbnQgPSBmaXJzdENoaWxkO1xuXHQgICAgdmFyIHN1YnRyZWVSb290ID0gbnVsbDtcblxuXHQgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgdmFyIHByaW1hcnlTdWJ0cmVlRmxhZyA9IGN1cnJlbnQuc3VidHJlZUZsYWdzICYgZmliZXJGbGFncztcblxuXHQgICAgICBpZiAoY3VycmVudCAhPT0gc3VidHJlZVJvb3QgJiYgY3VycmVudC5jaGlsZCAhPT0gbnVsbCAmJiBwcmltYXJ5U3VidHJlZUZsYWcgIT09IE5vRmxhZ3MpIHtcblx0ICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBmaWJlckZsYWdzKSAhPT0gTm9GbGFncykge1xuXHQgICAgICAgICAgaW52b2tlRWZmZWN0Rm4oY3VycmVudCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGN1cnJlbnQuc2libGluZyAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY3VycmVudCA9IHN1YnRyZWVSb290ID0gY3VycmVudC5yZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXHRmdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG5cdCAge1xuXHQgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCkge1xuXHQgICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICghKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG5cdCAgICBpZiAodGFnICE9PSBJbmRldGVybWluYXRlQ29tcG9uZW50ICYmIHRhZyAhPT0gSG9zdFJvb3QgJiYgdGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiB0YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIHRhZyAhPT0gRm9yd2FyZFJlZiAmJiB0YWcgIT09IE1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50KSB7XG5cdCAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuXHQgICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG5cdCAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cblx0ICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ICE9PSBudWxsKSB7XG5cdCAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW2NvbXBvbmVudE5hbWVdKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG5cdCAgICB0cnkge1xuXHQgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG5cdCAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcblx0ICAgIH0gZmluYWxseSB7XG5cdCAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG5cdCAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdHZhciBiZWdpbldvcmskMTtcblxuXHR7XG5cdCAgdmFyIGR1bW15RmliZXIgPSBudWxsO1xuXG5cdCAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcblx0ICAgIC8vIElmIGEgY29tcG9uZW50IHRocm93cyBhbiBlcnJvciwgd2UgcmVwbGF5IGl0IGFnYWluIGluIGEgc3luY2hyb25vdXNseVxuXHQgICAgLy8gZGlzcGF0Y2hlZCBldmVudCwgc28gdGhhdCB0aGUgZGVidWdnZXIgd2lsbCB0cmVhdCBpdCBhcyBhbiB1bmNhdWdodFxuXHQgICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICAgIC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNvcHkgdGhlIHdvcmstaW4tcHJvZ3Jlc3Mgb250byBhIGR1bW15XG5cdCAgICAvLyBmaWJlci4gSWYgYmVnaW5Xb3JrIHRocm93cywgd2UnbGwgdXNlIHRoaXMgdG8gcmVzZXQgdGhlIHN0YXRlLlxuXHQgICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXHQgICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuXHQgICAgICBpZiAoZGlkU3VzcGVuZE9yRXJyb3JXaGlsZUh5ZHJhdGluZ0RFVigpIHx8IG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuXG5cdCAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IGVycm9ycyBpZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCBoYXZlIGFscmVhZHkgc3VzcGVuZGVkIG9yIGhhbmRsZWQgYW4gZXJyb3Jcblx0ICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuXHQgICAgICB9IC8vIEtlZXAgdGhpcyBjb2RlIGluIHN5bmMgd2l0aCBoYW5kbGVFcnJvcjsgYW55IGNoYW5nZXMgaGVyZSBtdXN0IGhhdmVcblx0ICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cblx0ICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG5cdCAgICAgIHJlc2V0SG9va3NBZnRlclRocm93KCk7IC8vIERvbid0IHJlc2V0IGN1cnJlbnQgZGVidWcgZmliZXIsIHNpbmNlIHdlJ3JlIGFib3V0IHRvIHdvcmsgb24gdGhlXG5cdCAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG5cdCAgICAgIC8vIFVud2luZCB0aGUgZmFpbGVkIHN0YWNrIGZyYW1lXG5cblx0ICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIHVuaXRPZldvcmspOyAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0aWVzIG9mIHRoZSBmaWJlci5cblxuXHQgICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cblx0ICAgICAgaWYgKCB1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuXHQgICAgICAgIC8vIFJlc2V0IHRoZSBwcm9maWxlciB0aW1lci5cblx0ICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG5cdCAgICAgIH0gLy8gUnVuIGJlZ2luV29yayBhZ2Fpbi5cblxuXG5cdCAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBiZWdpbldvcmssIG51bGwsIGN1cnJlbnQsIHVuaXRPZldvcmssIGxhbmVzKTtcblxuXHQgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuXHQgICAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuXHQgICAgICAgIGlmICh0eXBlb2YgcmVwbGF5RXJyb3IgPT09ICdvYmplY3QnICYmIHJlcGxheUVycm9yICE9PSBudWxsICYmIHJlcGxheUVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgIW9yaWdpbmFsRXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuXHQgICAgICAgICAgLy8gSWYgc3VwcHJlc3NlZCwgbGV0IHRoZSBmbGFnIGNhcnJ5IG92ZXIgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHdoaWNoIGlzIHRoZSBvbmUgd2UnbGwgcmV0aHJvdy5cblx0ICAgICAgICAgIG9yaWdpbmFsRXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IC8vIFdlIGFsd2F5cyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gY2FzZSB0aGUgc2Vjb25kIHJlbmRlciBwYXNzIGlzIG5vdCBpZGVtcG90ZW50LlxuXHQgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgYSBtZW1vaXplZCBmdW5jdGlvbiBvciBDb21tb25KUyBtb2R1bGUgZG9lc24ndCB0aHJvdyBhZnRlciBmaXJzdCBpbnZvY2F0aW9uLlxuXG5cblx0ICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0dmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG5cdHZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQ7XG5cblx0e1xuXHQgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKSB7XG5cdCAge1xuXHQgICAgaWYgKGlzUmVuZGVyaW5nICYmICFnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYoKSkge1xuXHQgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuXHQgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUgPSB3b3JrSW5Qcm9ncmVzcyAmJiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7IC8vIERlZHVwZSBieSB0aGUgcmVuZGVyaW5nIGNvbXBvbmVudCBiZWNhdXNlIGl0J3MgdGhlIG9uZSB0aGF0IG5lZWRzIHRvIGJlIGZpeGVkLlxuXG5cdCAgICAgICAgICAgIHZhciBkZWR1cGVLZXkgPSByZW5kZXJpbmdDb21wb25lbnROYW1lO1xuXG5cdCAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG5cdCAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChkZWR1cGVLZXkpO1xuXHQgICAgICAgICAgICAgIHZhciBzZXRTdGF0ZUNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cblx0ICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLCBzZXRTdGF0ZUNvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICAgICAge1xuXHQgICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKSB7XG5cdCAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcgKyAnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO1xuXG5cdCAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSB7XG5cdCAge1xuXHQgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG5cdCAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXHQgICAgICBtZW1vaXplZFVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxpbmdGaWJlcikge1xuXHQgICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcblx0ICAgICAgfSk7IC8vIFRoaXMgZnVuY3Rpb24gaW50ZW50aW9uYWxseSBkb2VzIG5vdCBjbGVhciBtZW1vaXplZCB1cGRhdGVycy5cblx0ICAgICAgLy8gVGhvc2UgbWF5IHN0aWxsIGJlIHJlbGV2YW50IHRvIHRoZSBjdXJyZW50IGNvbW1pdFxuXHQgICAgICAvLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cblx0ICAgIH1cblx0ICB9XG5cdH1cblx0dmFyIGZha2VBY3RDYWxsYmFja05vZGUgPSB7fTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrJDEocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcblx0ICB7XG5cdCAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBieXBhc3MgU2NoZWR1bGVyIGFuZCBwdXNoIHRvXG5cdCAgICAvLyB0aGUgYGFjdGAgcXVldWUgaW5zdGVhZC5cblx0ICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudDtcblxuXHQgICAgaWYgKGFjdFF1ZXVlICE9PSBudWxsKSB7XG5cdCAgICAgIGFjdFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuXHQgICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSkge1xuXHQgIGlmICggY2FsbGJhY2tOb2RlID09PSBmYWtlQWN0Q2FsbGJhY2tOb2RlKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfSAvLyBJbiBwcm9kdWN0aW9uLCBhbHdheXMgY2FsbCBTY2hlZHVsZXIuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBvdXQuXG5cblxuXHQgIHJldHVybiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkge1xuXHQgIC8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG5cdCAgcmV0dXJuICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpIHtcblx0ICB7XG5cdCAgICBpZiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG5cdCAgICAgIGlmICghaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSkge1xuXHQgICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIExlZ2FjeSBtb2RlIGhhcyBhZGRpdGlvbmFsIGNhc2VzIHdoZXJlIHdlIHN1cHByZXNzIGEgd2FybmluZy5cblx0ICAgICAgaWYgKCFpc0xlZ2FjeUFjdEVudmlyb25tZW50KCkpIHtcblx0ICAgICAgICAvLyBOb3QgaW4gYW4gYWN0IGVudmlyb25tZW50LiBObyBuZWVkIHRvIHdhcm4uXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgIT09IE5vQ29udGV4dCkge1xuXHQgICAgICAgIC8vIExlZ2FjeSBtb2RlIGRvZXNuJ3Qgd2FybiBpZiB0aGUgdXBkYXRlIGlzIGJhdGNoZWQsIGkuZS5cblx0ICAgICAgICAvLyBiYXRjaGVkVXBkYXRlcyBvciBmbHVzaFN5bmMuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGZpYmVyLnRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgZmliZXIudGFnICE9PSBGb3J3YXJkUmVmICYmIGZpYmVyLnRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuXHQgICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHByZS1ob29rcyBjb2RlLCBsZWdhY3kgbW9kZSBvbmx5XG5cdCAgICAgICAgLy8gd2FybnMgZm9yIHVwZGF0ZXMgdGhhdCBvcmlnaW5hdGUgZnJvbSBhIGhvb2suXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgPT09IG51bGwpIHtcblx0ICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuXHQgICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuXHQgICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KSB7XG5cdCAge1xuXHQgICAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG5cdCAgICAgIGVycm9yKCdBIHN1c3BlbmRlZCByZXNvdXJjZSBmaW5pc2hlZCBsb2FkaW5nIGluc2lkZSBhIHRlc3QsIGJ1dCB0aGUgZXZlbnQgJyArICd3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCAnICsgJ2ludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChpc1J1bm5pbmcpIHtcblx0ICB7XG5cdCAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSBpc1J1bm5pbmc7XG5cdCAgfVxuXHR9XG5cblx0LyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2RlcyAqL1xuXHR2YXIgcmVzb2x2ZUZhbWlseSA9IG51bGw7IC8vICRGbG93Rml4TWUgRmxvdyBnZXRzIGNvbmZ1c2VkIGJ5IGEgV2Vha1NldCBmZWF0dXJlIGNoZWNrIGJlbG93LlxuXG5cdHZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcblx0dmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0ICB7XG5cdCAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcblx0ICB9XG5cdH07XG5cdGZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG5cdCAge1xuXHQgICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcblx0ICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cblx0ICAgICAgcmV0dXJuIHR5cGU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG5cdCAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmV0dXJuIHR5cGU7XG5cdCAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cblx0ICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcblx0ICAvLyBObyBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcy5cblx0ICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xuXHR9XG5cdGZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcblx0ICB7XG5cdCAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuXHQgICAgICByZXR1cm4gdHlwZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cblx0ICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG5cdCAgICAgIGlmICh0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuXHQgICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cblx0ICAgICAgICAvLyBJZiB0aGF0IGlubmVyIHJlbmRlciBmdW5jdGlvbiBpcyBkaWZmZXJlbnQsIHdlJ2xsIGJ1aWxkIGEgbmV3IGZvcndhcmRSZWYgdHlwZS5cblx0ICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cblx0ICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcblx0ICAgICAgICAgIHZhciBzeW50aGV0aWNUeXBlID0ge1xuXHQgICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcblx0ICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG5cdCAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gdHlwZTtcblx0ICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuXHQgICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcblx0ICB7XG5cdCAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuXHQgICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG5cdCAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcblx0ICAgIHZhciAkJHR5cGVvZk5leHRUeXBlID0gdHlwZW9mIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBuZXh0VHlwZSAhPT0gbnVsbCA/IG5leHRUeXBlLiQkdHlwZW9mIDogbnVsbDtcblxuXHQgICAgc3dpdGNoIChmaWJlci50YWcpIHtcblx0ICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuXHQgICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cblx0ICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gYXNzdW1lIHRoYXQgdGhlIGxhenkgaW5uZXIgdHlwZSBpcyBzdGFibGUsXG5cdCAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG5cdCAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuXHQgICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBjYXNlIEZvcndhcmRSZWY6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcblx0ICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcblx0ICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuXHQgICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuXHQgICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3Qgc2V0IHRoaXMuXG5cdCAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG5cdCAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSAvLyBDaGVjayBpZiBib3RoIHR5cGVzIGhhdmUgYSBmYW1pbHkgYW5kIGl0J3MgdGhlIHNhbWUgb25lLlxuXG5cblx0ICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuXHQgICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG5cdCAgICAgIC8vIFRoaXMgbWVhbnMgYm90aCBvZiB0aGVtIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCB0byBwcmVzZXJ2ZSBzdGF0ZS5cblx0ICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG5cdCAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG5cdCAgICAgIC8vIGNhbGxzIGFyZSBlcXVpdmFsZW50IGJlY2F1c2UgdGhleSB3cmFwIHRoZSBzYW1lIEZvbyBmdW5jdGlvbi5cblx0ICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtcblxuXHQgICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcikge1xuXHQgIHtcblx0ICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG5cdCAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBXZWFrU2V0ICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgPT09IG51bGwpIHtcblx0ICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG5cdCAgICB9XG5cblx0ICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGZpYmVyKTtcblx0ICB9XG5cdH1cblx0dmFyIHNjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uIChyb290LCB1cGRhdGUpIHtcblx0ICB7XG5cdCAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuXHQgICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXMsXG5cdCAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcblx0ICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblx0ICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9O1xuXHR2YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcblx0ICB7XG5cdCAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcblx0ICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG5cdCAgICAgIC8vIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSBwYXJlbnRDb21wb25lbnQgc28gd2UgY2FuJ3QgcGFzcyBpdC5cblx0ICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblx0ICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LCByb290LCBudWxsLCBudWxsKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcblx0ICB7XG5cdCAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlLFxuXHQgICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG5cdCAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG5cdCAgICAgICAgdGFnID0gZmliZXIudGFnLFxuXHQgICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXHQgICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG5cdCAgICBzd2l0Y2ggKHRhZykge1xuXHQgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG5cdCAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG5cdCAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuXHQgICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcblx0ICAgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG5cdCAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cblx0ICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG5cdCAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmIChzdGFsZUZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG5cdCAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG5cdCAgICAgICAgICBpZiAodGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuXHQgICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbmVlZHNSZW5kZXIgPSB0cnVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhhbHRlcm5hdGUpKSB7XG5cdCAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAobmVlZHNSZW1vdW50KSB7XG5cdCAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcblx0ICAgICAgdmFyIF9yb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cblx0ICAgICAgaWYgKF9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKF9yb290LCBmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuXHQgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuXHQgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCA9IGZ1bmN0aW9uIChyb290LCBmYW1pbGllcykge1xuXHQgIHtcblx0ICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuXHQgICAgdmFyIHR5cGVzID0gbmV3IFNldChmYW1pbGllcy5tYXAoZnVuY3Rpb24gKGZhbWlseSkge1xuXHQgICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG5cdCAgICB9KSk7XG5cdCAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG5cdCAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuXHQgIHtcblx0ICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuXHQgICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuXHQgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcblx0ICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcblx0ICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuXHQgICAgc3dpdGNoICh0YWcpIHtcblx0ICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgRm9yd2FyZFJlZjpcblx0ICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkaWRNYXRjaCA9IGZhbHNlO1xuXG5cdCAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG5cdCAgICAgICAgZGlkTWF0Y2ggPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChkaWRNYXRjaCkge1xuXHQgICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG5cdCAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuXHQgICAgICAvLyB2aXN1YWwgZmVlZGJhY2ssIFwiZmxhc2hpbmdcIiBvdXRlcm1vc3QgcGFyZW50IHJlY3RhbmdsZXMgaXMgc3VmZmljaWVudC5cblx0ICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoLCBtYXliZSB0aGVyZSB3aWxsIGJlIG9uZSBmdXJ0aGVyIGRvd24gaW4gdGhlIGNoaWxkIHRyZWUuXG5cdCAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG5cdCAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShzaWJsaW5nLCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuXHQgIHtcblx0ICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpO1xuXG5cdCAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0gLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGhvc3QgY2hpbGRyZW4sIGZhbGxiYWNrIHRvIGNsb3Nlc3QgaG9zdCBwYXJlbnQuXG5cblxuXHQgICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuXHQgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuXHQgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcblx0ICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcblx0ICAgICAgICAgIHJldHVybjtcblxuXHQgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcblx0ICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXG5cdCAgICAgICAgY2FzZSBIb3N0Um9vdDpcblx0ICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byByZWFjaCByb290IGZpcnN0LicpO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuXHQgIHtcblx0ICAgIHZhciBub2RlID0gZmliZXI7XG5cdCAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmFsc2U7XG5cblx0ICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuXHQgICAgICAgIC8vIFdlIGdvdCBhIG1hdGNoLlxuXHQgICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG5cdCAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG5cdCAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuXHQgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcblx0ICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuXHQgICAgICAgIHJldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7XG5cdCAgICAgIH1cblxuXHQgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaWJlcikge1xuXHQgICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG5cdCAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG5cdHtcblx0ICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG5cdCAgdHJ5IHtcblx0ICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcblx0ICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG5cdCAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcblx0ICAgIG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcblx0ICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG5cdCAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcblx0ICAvLyBJbnN0YW5jZVxuXHQgIHRoaXMudGFnID0gdGFnO1xuXHQgIHRoaXMua2V5ID0ga2V5O1xuXHQgIHRoaXMuZWxlbWVudFR5cGUgPSBudWxsO1xuXHQgIHRoaXMudHlwZSA9IG51bGw7XG5cdCAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsOyAvLyBGaWJlclxuXG5cdCAgdGhpcy5yZXR1cm4gPSBudWxsO1xuXHQgIHRoaXMuY2hpbGQgPSBudWxsO1xuXHQgIHRoaXMuc2libGluZyA9IG51bGw7XG5cdCAgdGhpcy5pbmRleCA9IDA7XG5cdCAgdGhpcy5yZWYgPSBudWxsO1xuXHQgIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXHQgIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG5cdCAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cdCAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblx0ICB0aGlzLmRlcGVuZGVuY2llcyA9IG51bGw7XG5cdCAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG5cdCAgdGhpcy5mbGFncyA9IE5vRmxhZ3M7XG5cdCAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuXHQgIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcblx0ICB0aGlzLmxhbmVzID0gTm9MYW5lcztcblx0ICB0aGlzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuXHQgIHtcblx0ICAgIC8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgaXMgZG9uZSB0byBhdm9pZCBhIHY4IHBlcmZvcm1hbmNlIGNsaWZmLlxuXHQgICAgLy9cblx0ICAgIC8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuXHQgICAgLy8gZG91YmxlIHZhbHVlcyB3aWxsIGNhdXNlIEZpYmVycyB0byBlbmQgdXAgaGF2aW5nIHNlcGFyYXRlIHNoYXBlcy5cblx0ICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuXHQgICAgLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cblx0ICAgIC8vIFVuZm9ydHVuYXRlbHkgaXQgbWFrZXMgUmVhY3QgdW51c2FibHkgc2xvdyBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG5cdCAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuXHQgICAgLy9cblx0ICAgIC8vIExlYXJuIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuXHQgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxuXHQgICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IE51bWJlci5OYU47XG5cdCAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG5cdCAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuXHQgICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjsgLy8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG5cdCAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcblx0ICAgIC8vIGFuZCBpdCBzaW1wbGlmaWVzIG90aGVyIHByb2ZpbGVyIGNvZGUgKGluY2x1ZGluZyBEZXZUb29scykuXG5cblx0ICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuXHQgICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcblx0ICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG5cdCAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIC8vIFRoaXMgaXNuJ3QgZGlyZWN0bHkgdXNlZCBidXQgaXMgaGFuZHkgZm9yIGRlYnVnZ2luZyBpbnRlcm5hbHM6XG5cdCAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG5cdCAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcblx0ICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cdCAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG5cblx0ICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG5cdCAgICB9XG5cdCAgfVxuXHR9IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuXHQvLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG5cdC8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG5cdC8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuXHQvLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG5cdC8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG5cdC8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cblx0Ly8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuXHQvLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG5cdC8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuXHQvLyAgICBpcyBmYXN0ZXIuXG5cdC8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuXHQvLyAgICBjb21wYXRpYmxlLlxuXG5cblx0dmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcblx0ICAvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcblx0ICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcblx0fTtcblxuXHRmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpIHtcblx0ICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblx0ICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuXHQgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2hvdWxkQ29uc3RydWN0JDEodHlwZSkgJiYgdHlwZS5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZDtcblx0fVxuXHRmdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcblx0ICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgcmV0dXJuIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkgPyBDbGFzc0NvbXBvbmVudCA6IEZ1bmN0aW9uQ29tcG9uZW50O1xuXHQgIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgJCR0eXBlb2YgPSBDb21wb25lbnQuJCR0eXBlb2Y7XG5cblx0ICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuXHQgICAgICByZXR1cm4gRm9yd2FyZFJlZjtcblx0ICAgIH1cblxuXHQgICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcblx0ICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG5cdH0gLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cblxuXHRmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcblx0ICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuXHQgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuXHQgICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuXHQgICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG5cdCAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG5cdCAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuXHQgICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cblx0ICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGU7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuXHQgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cblx0ICAgIHtcblx0ICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuXHQgICAgfVxuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuXHQgICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcblx0ICB9IGVsc2Uge1xuXHQgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuXHQgICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG5cblx0ICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gTm9GbGFnczsgLy8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcblx0ICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG5cblx0ICAgIHtcblx0ICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG5cdCAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG5cdCAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcblx0ICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG5cdCAgICB9XG5cdCAgfSAvLyBSZXNldCBhbGwgZWZmZWN0cyBleGNlcHQgc3RhdGljIG9uZXMuXG5cdCAgLy8gU3RhdGljIGVmZmVjdHMgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlci5cblxuXG5cdCAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaztcblx0ICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuXHQgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcblx0ICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG5cdCAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblx0ICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXHQgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cblx0ICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cblx0ICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuXHQgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuXHQgICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG5cdCAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG5cdCAgfTsgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cblxuXHQgIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG5cdCAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuXHQgIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG5cdCAge1xuXHQgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcblx0ICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG5cdCAgfVxuXG5cdCAge1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG5cblx0ICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG5cdCAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcblx0ICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcblx0ICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuXHQgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuXHQgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIEZvcndhcmRSZWY6XG5cdCAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuXHR9IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuXHRmdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuXHQgIC8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG5cdCAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3Rcblx0ICAvLyBiZSBuZWNlc3NhcnkgYnV0IHVuZm9ydHVuYXRlbHkgbWFueSBjb2RlIHBhdGhzIHJlYWRzIGZyb20gdGhlIHdvcmtJblByb2dyZXNzXG5cdCAgLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cblx0ICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG5cdCAgLy8gYXZvaWQgZG9pbmcgYW5vdGhlciByZWNvbmNpbGlhdGlvbi5cblx0ICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuXHQgIC8vIHRoYXQgY2hpbGQgZmliZXIgaXMgc2V0dGluZywgbm90IHRoZSByZWNvbmNpbGlhdGlvbi5cblx0ICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSBTdGF0aWNNYXNrIHwgUGxhY2VtZW50OyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG5cdCAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cblx0ICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgLy8gUmVzZXQgdG8gY3JlYXRlRmliZXIncyBpbml0aWFsIHZhbHVlcy5cblx0ICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcztcblx0ICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcblx0ICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbDtcblx0ICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbDtcblx0ICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cblx0ICAgIHtcblx0ICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG5cdCAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuXHQgICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcblx0ICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJlc2V0IHRvIHRoZSBjbG9uZWQgdmFsdWVzIHRoYXQgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGQndmUuXG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuXHQgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcblx0ICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG5cdCAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXHQgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblx0ICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuXHQgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cblx0ICAgIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuXHQgICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcblx0ICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuXHQgICAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcblx0ICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuXHQgICAgfTtcblxuXHQgICAge1xuXHQgICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcblx0ICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG5cdCAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG5cdCAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUpIHtcblx0ICB2YXIgbW9kZTtcblxuXHQgIGlmICh0YWcgPT09IENvbmN1cnJlbnRSb290KSB7XG5cdCAgICBtb2RlID0gQ29uY3VycmVudE1vZGU7XG5cblx0ICAgIGlmIChpc1N0cmljdE1vZGUgPT09IHRydWUpIHtcblx0ICAgICAgbW9kZSB8PSBTdHJpY3RMZWdhY3lNb2RlO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIG1vZGUgPSBOb01vZGU7XG5cdCAgfVxuXG5cdCAgaWYgKCBpc0RldlRvb2xzUHJlc2VudCkge1xuXHQgICAgLy8gQWx3YXlzIGNvbGxlY3QgcHJvZmlsZSB0aW1pbmdzIHdoZW4gRGV2VG9vbHMgYXJlIHByZXNlbnQuXG5cdCAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcblx0ICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cblx0ICAgIG1vZGUgfD0gUHJvZmlsZU1vZGU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcblx0a2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuXHQgIHZhciBmaWJlclRhZyA9IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7IC8vIFRoZSByZXNvbHZlZCB0eXBlIGlzIHNldCBpZiB3ZSBrbm93IHdoYXQgdGhlIGZpbmFsIHR5cGUgd2lsbCBiZS4gSS5lLiBpdCdzIG5vdCBsYXp5LlxuXG5cdCAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cblx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGlmIChzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSkge1xuXHQgICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG5cdCAgICAgIHtcblx0ICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAge1xuXHQgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcblx0ICB9IGVsc2Uge1xuXHQgICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuXHQgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG5cdCAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcblx0ICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG5cdCAgICAgICAgbW9kZSB8PSBTdHJpY3RMZWdhY3lNb2RlO1xuXG5cdCAgICAgICAgaWYgKCAobW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG5cdCAgICAgICAgICAvLyBTdHJpY3QgZWZmZWN0cyBzaG91bGQgbmV2ZXIgcnVuIG9uIGxlZ2FjeSByb290c1xuXHQgICAgICAgICAgbW9kZSB8PSBTdHJpY3RFZmZlY3RzTW9kZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG5cdCAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cblx0ICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuXHQgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG5cdCAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuXHQgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuXHQgICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuXHQgICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuXHQgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcblxuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuXHQgICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG5cblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cblx0ICAgICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuXG5cdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG5cdCAgICAgIGNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTpcblxuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuXHQgICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuXG5cdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuXHQgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcblx0ICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuXHQgICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG5cdCAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcblx0ICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuXHQgICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG5cdCAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuXHQgICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuXG5cdCAgICAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuXHQgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuXHQgICAgICAgICAgICAgICAgZmliZXJUYWcgPSBNZW1vQ29tcG9uZW50O1xuXHQgICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG5cdCAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdCAgICAgICAgICAgICAgICBmaWJlclRhZyA9IExhenlDb21wb25lbnQ7XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHZhciBpbmZvID0gJyc7XG5cblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKSA6IG51bGw7XG5cblx0ICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuXHQgICAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluICcgKyAnY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSAnICsgKFwiYnV0IGdvdDogXCIgKyAodHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlKSArIFwiLlwiICsgaW5mbykpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXHQgIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcblx0ICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXHQgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cblx0ICB7XG5cdCAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuXHQgIH1cblxuXHQgIHJldHVybiBmaWJlcjtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG5cdCAgdmFyIG93bmVyID0gbnVsbDtcblxuXHQgIHtcblx0ICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cdCAgfVxuXG5cdCAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cdCAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuXHQgIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXHQgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuXHQgIHtcblx0ICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblx0ICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZpYmVyO1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBsYW5lcywga2V5KSB7XG5cdCAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuXHQgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cdCAgcmV0dXJuIGZpYmVyO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG5cdCAge1xuXHQgICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJywgdHlwZW9mIHBlbmRpbmdQcm9wcy5pZCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpO1xuXHQgIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcblx0ICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG5cdCAge1xuXHQgICAgZmliZXIuc3RhdGVOb2RlID0ge1xuXHQgICAgICBlZmZlY3REdXJhdGlvbjogMCxcblx0ICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIHJldHVybiBmaWJlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuXHQgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG5cdCAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuXHQgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cdCAgcmV0dXJuIGZpYmVyO1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcblx0ICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUxpc3RDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcblx0ICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcblx0ICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXHQgIHJldHVybiBmaWJlcjtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG5cdCAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG5cdCAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcblx0ICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXHQgIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcblx0ICAgIGlzSGlkZGVuOiBmYWxzZVxuXHQgIH07XG5cdCAgZmliZXIuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG5cdCAgcmV0dXJuIGZpYmVyO1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcblx0ICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG5cdCAgZmliZXIubGFuZXMgPSBsYW5lcztcblx0ICByZXR1cm4gZmliZXI7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG5cdCAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcblx0ICBmaWJlci5lbGVtZW50VHlwZSA9ICdERUxFVEVEJztcblx0ICByZXR1cm4gZmliZXI7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50KGRlaHlkcmF0ZWROb2RlKSB7XG5cdCAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRGVoeWRyYXRlZEZyYWdtZW50LCBudWxsLCBudWxsLCBOb01vZGUpO1xuXHQgIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuXHQgIHJldHVybiBmaWJlcjtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuXHQgIHZhciBwZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gIT09IG51bGwgPyBwb3J0YWwuY2hpbGRyZW4gOiBbXTtcblx0ICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuXHQgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cdCAgZmliZXIuc3RhdGVOb2RlID0ge1xuXHQgICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG5cdCAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG5cdCAgICAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuXHQgICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuXHQgIH07XG5cdCAgcmV0dXJuIGZpYmVyO1xuXHR9IC8vIFVzZWQgZm9yIHN0YXNoaW5nIFdJUCBwcm9wZXJ0aWVzIHRvIHJlcGxheSBmYWlsZWQgd29yayBpbiBERVYuXG5cblx0ZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcblx0ICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG5cdCAgICAvLyBUaGlzIEZpYmVyJ3MgaW5pdGlhbCBwcm9wZXJ0aWVzIHdpbGwgYWx3YXlzIGJlIG92ZXJ3cml0dGVuLlxuXHQgICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuXHQgICAgdGFyZ2V0ID0gY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcblx0ICB9IC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIGFzIGEgbGlzdCBvZiBhbGwgcHJvcGVydGllcy5cblx0ICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG5cdCAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwMlxuXHQgIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuXHQgIHRhcmdldC50YWcgPSBzb3VyY2UudGFnO1xuXHQgIHRhcmdldC5rZXkgPSBzb3VyY2Uua2V5O1xuXHQgIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcblx0ICB0YXJnZXQudHlwZSA9IHNvdXJjZS50eXBlO1xuXHQgIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuXHQgIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuXHQgIHRhcmdldC5jaGlsZCA9IHNvdXJjZS5jaGlsZDtcblx0ICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuXHQgIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcblx0ICB0YXJnZXQucmVmID0gc291cmNlLnJlZjtcblx0ICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcblx0ICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuXHQgIHRhcmdldC51cGRhdGVRdWV1ZSA9IHNvdXJjZS51cGRhdGVRdWV1ZTtcblx0ICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuXHQgIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuXHQgIHRhcmdldC5tb2RlID0gc291cmNlLm1vZGU7XG5cdCAgdGFyZ2V0LmZsYWdzID0gc291cmNlLmZsYWdzO1xuXHQgIHRhcmdldC5zdWJ0cmVlRmxhZ3MgPSBzb3VyY2Uuc3VidHJlZUZsYWdzO1xuXHQgIHRhcmdldC5kZWxldGlvbnMgPSBzb3VyY2UuZGVsZXRpb25zO1xuXHQgIHRhcmdldC5sYW5lcyA9IHNvdXJjZS5sYW5lcztcblx0ICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuXHQgIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuXG5cdCAge1xuXHQgICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuXHQgICAgdGFyZ2V0LmFjdHVhbFN0YXJ0VGltZSA9IHNvdXJjZS5hY3R1YWxTdGFydFRpbWU7XG5cdCAgICB0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbiA9IHNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO1xuXHQgICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcblx0ICB9XG5cblx0ICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcblx0ICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG5cdCAgdGFyZ2V0Ll9kZWJ1Z05lZWRzUmVtb3VudCA9IHNvdXJjZS5fZGVidWdOZWVkc1JlbW91bnQ7XG5cdCAgdGFyZ2V0Ll9kZWJ1Z0hvb2tUeXBlcyA9IHNvdXJjZS5fZGVidWdIb29rVHlwZXM7XG5cdCAgcmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdGZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpIHtcblx0ICB0aGlzLnRhZyA9IHRhZztcblx0ICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuXHQgIHRoaXMucGVuZGluZ0NoaWxkcmVuID0gbnVsbDtcblx0ICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuXHQgIHRoaXMucGluZ0NhY2hlID0gbnVsbDtcblx0ICB0aGlzLmZpbmlzaGVkV29yayA9IG51bGw7XG5cdCAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuXHQgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cdCAgdGhpcy5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG5cdCAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuXHQgIHRoaXMuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcblx0ICB0aGlzLmV2ZW50VGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuXHQgIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7XG5cdCAgdGhpcy5wZW5kaW5nTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHRoaXMuc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHRoaXMucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHRoaXMuZXhwaXJlZExhbmVzID0gTm9MYW5lcztcblx0ICB0aGlzLm11dGFibGVSZWFkTGFuZXMgPSBOb0xhbmVzO1xuXHQgIHRoaXMuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG5cdCAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcblx0ICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuXHQgIHRoaXMub25SZWNvdmVyYWJsZUVycm9yID0gb25SZWNvdmVyYWJsZUVycm9yO1xuXG5cdCAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uKSB7XG5cdCAgICB0aGlzLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBudWxsO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIHRoaXMuZWZmZWN0RHVyYXRpb24gPSAwO1xuXHQgICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuXHQgIH1cblxuXHQgIHtcblx0ICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcblx0ICAgIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gdGhpcy5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gW107XG5cblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBUb3RhbExhbmVzOyBfaSsrKSB7XG5cdCAgICAgIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAucHVzaChuZXcgU2V0KCkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHtcblx0ICAgIHN3aXRjaCAodGFnKSB7XG5cdCAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG5cdCAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyAnaHlkcmF0ZVJvb3QoKScgOiAnY3JlYXRlUm9vdCgpJztcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIExlZ2FjeVJvb3Q6XG5cdCAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyAnaHlkcmF0ZSgpJyA6ICdyZW5kZXIoKSc7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcblx0Ly8gaG9zdCBjb25maWcsIGJ1dCBiZWNhdXNlIHRoZXkgYXJlIHBhc3NlZCBpbiBhdCBydW50aW1lLCB3ZSBoYXZlIHRvIHRocmVhZFxuXHQvLyB0aGVtIHRocm91Z2ggdGhlIHJvb3QgY29uc3RydWN0b3IuIFBlcmhhcHMgd2Ugc2hvdWxkIHB1dCB0aGVtIGFsbCBpbnRvIGFcblx0Ly8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuXHRpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MpIHtcblx0ICB2YXIgcm9vdCA9IG5ldyBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcblx0ICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cblx0ICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSk7XG5cdCAgcm9vdC5jdXJyZW50ID0gdW5pbml0aWFsaXplZEZpYmVyO1xuXHQgIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG5cdCAge1xuXHQgICAgdmFyIF9pbml0aWFsU3RhdGUgPSB7XG5cdCAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcblx0ICAgICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuXHQgICAgICBjYWNoZTogbnVsbCxcblx0ICAgICAgLy8gbm90IGVuYWJsZWQgeWV0XG5cdCAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuXHQgICAgICBwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOiBudWxsXG5cdCAgICB9O1xuXHQgICAgdW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGUgPSBfaW5pdGlhbFN0YXRlO1xuXHQgIH1cblxuXHQgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuXHQgIHJldHVybiByb290O1xuXHR9XG5cblx0dmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4yLjAnO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cblx0aW1wbGVtZW50YXRpb24pIHtcblx0ICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG5cdCAge1xuXHQgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihrZXkpO1xuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG5cdCAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG5cdCAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuXHQgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuXHQgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcblx0ICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuXHQgIH07XG5cdH1cblxuXHR2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcztcblx0dmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlO1xuXG5cdHtcblx0ICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG5cdCAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUgPSB7fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuXHQgIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG5cdCAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuXHQgIH1cblxuXHQgIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuXHQgIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG5cdCAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcblx0ICAgIHZhciBDb21wb25lbnQgPSBmaWJlci50eXBlO1xuXG5cdCAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuXHQgICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcGFyZW50Q29udGV4dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG5cdCAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cblx0ICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG5cdCAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50LCBtZXRob2ROYW1lKSB7XG5cdCAge1xuXHQgICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cblx0ICAgIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKCcsJyk7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG5cdCAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaG9zdEZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG5cdCAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cblx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuXHQgICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGhvc3RGaWJlcik7XG5cblx0ICAgICAgICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuXHQgICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZXJyb3IoJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJyArICclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIHJlbmRlcnMgU3RyaWN0TW9kZSBjaGlsZHJlbi4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJywgbWV0aG9kTmFtZSwgbWV0aG9kTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgIC8vIElkZWFsbHkgdGhpcyBzaG91bGQgcmVzZXQgdG8gcHJldmlvdXMgYnV0IHRoaXMgc2hvdWxkbid0IGJlIGNhbGxlZCBpblxuXHQgICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG5cdCAgICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuXHQgICAgICAgICAgICBzZXRDdXJyZW50RmliZXIocHJldmlvdXNGaWJlcik7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG5cdCAgdmFyIGh5ZHJhdGUgPSBmYWxzZTtcblx0ICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcblx0ICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25Db250YWluZXIoaW5pdGlhbENoaWxkcmVuLCAvLyBUT0RPOiBSZW1vdmUgYGNhbGxiYWNrYCB3aGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZS5cblx0Y2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuXHQgIHZhciBoeWRyYXRlID0gdHJ1ZTtcblx0ICB2YXIgcm9vdCA9IGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcik7IC8vIFRPRE86IE1vdmUgdGhpcyB0byBGaWJlclJvb3QgY29uc3RydWN0b3JcblxuXHQgIHJvb3QuY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOyAvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cblx0ICAvLyBhIHJlZ3VsYXIgdXBkYXRlIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3QgbWF0Y2ggd2FzIHdhcyByZW5kZXJlZFxuXHQgIC8vIG9uIHRoZSBzZXJ2ZXIuXG5cdCAgLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG5cdCAgLy8gdGhlIHVwZGF0ZSB0byBzY2hlZHVsZSB3b3JrIG9uIHRoZSByb290IGZpYmVyIChhbmQsIGZvciBsZWdhY3kgcm9vdHMsIHRvXG5cdCAgLy8gZW5xdWV1ZSB0aGUgY2FsbGJhY2sgaWYgb25lIGlzIHByb3ZpZGVkKS5cblxuXHQgIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuXHQgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG5cdCAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTtcblx0ICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG5cdCAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCA/IGNhbGxiYWNrIDogbnVsbDtcblx0ICBlbnF1ZXVlVXBkYXRlKGN1cnJlbnQsIHVwZGF0ZSwgbGFuZSk7XG5cdCAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG5cdCAgcmV0dXJuIHJvb3Q7XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuXHQgIHtcblx0ICAgIG9uU2NoZWR1bGVSb290KGNvbnRhaW5lciwgZWxlbWVudCk7XG5cdCAgfVxuXG5cdCAgdmFyIGN1cnJlbnQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuXHQgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG5cdCAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50JDEpO1xuXG5cdCAge1xuXHQgICAgbWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcblx0ICB9XG5cblx0ICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG5cblx0ICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcblx0ICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcblx0ICB9IGVsc2Uge1xuXHQgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcblx0ICB9XG5cblx0ICB7XG5cdCAgICBpZiAoaXNSZW5kZXJpbmcgJiYgY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuXHQgICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuXHQgICAgICBlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkgfHwgJ1Vua25vd24nKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcblx0ICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cblx0ICB1cGRhdGUucGF5bG9hZCA9IHtcblx0ICAgIGVsZW1lbnQ6IGVsZW1lbnRcblx0ICB9O1xuXHQgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuXHQgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuXHQgICAge1xuXHQgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHQgIH1cblxuXHQgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShjdXJyZW50JDEsIHVwZGF0ZSwgbGFuZSk7XG5cblx0ICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGN1cnJlbnQkMSwgbGFuZSwgZXZlbnRUaW1lKTtcblx0ICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgY3VycmVudCQxLCBsYW5lKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbGFuZTtcblx0fVxuXHRmdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG5cdCAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cblx0ICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuXHQgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuXHQgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKSB7XG5cdCAgc3dpdGNoIChmaWJlci50YWcpIHtcblx0ICAgIGNhc2UgSG9zdFJvb3Q6XG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgcm9vdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuXHQgICAgICAgIGlmIChpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKSB7XG5cdCAgICAgICAgICAvLyBGbHVzaCB0aGUgZmlyc3Qgc2NoZWR1bGVkIFwidXBkYXRlXCIuXG5cdCAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCk7XG5cdCAgICAgICAgICBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG5cdCAgICAgIHtcblx0ICAgICAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuXHQgICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblx0ICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTsgLy8gSWYgd2UncmUgc3RpbGwgYmxvY2tlZCBhZnRlciB0aGlzLCB3ZSBuZWVkIHRvIGluY3JlYXNlXG5cdCAgICAgICAgLy8gdGhlIHByaW9yaXR5IG9mIGFueSBwcm9taXNlcyByZXNvbHZpbmcgd2l0aGluIHRoaXNcblx0ICAgICAgICAvLyBib3VuZGFyeSBzbyB0aGF0IHRoZXkgbmV4dCBhdHRlbXB0IGFsc28gaGFzIGhpZ2hlciBwcmkuXG5cblx0ICAgICAgICB2YXIgcmV0cnlMYW5lID0gU3luY0xhbmU7XG5cdCAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG5cdCAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG5cdCAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG5cdCAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGhpZ2hlclByaW9yaXR5TGFuZShzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSwgcmV0cnlMYW5lKTtcblx0ICB9XG5cdH0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVuYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5cblxuXHRmdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG5cdCAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG5cdCAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuXHQgIGlmIChhbHRlcm5hdGUpIHtcblx0ICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBhdHRlbXB0RGlzY3JldGVIeWRyYXRpb24oZmliZXIpIHtcblx0ICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuXHQgICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2Vcblx0ICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG5cdCAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuXHQgICAgLy8gU3VzcGVuc2UuXG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIGxhbmUgPSBTeW5jTGFuZTtcblx0ICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG5cblx0ICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblx0ICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblx0ICB9XG5cblx0ICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG5cdH1cblx0ZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZmliZXIpIHtcblx0ICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuXHQgICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2Vcblx0ICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG5cdCAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuXHQgICAgLy8gU3VzcGVuc2UuXG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIGxhbmUgPSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuXHQgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcblxuXHQgIGlmIChyb290ICE9PSBudWxsKSB7XG5cdCAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuXHQgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXHQgIH1cblxuXHQgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcblx0fVxuXHRmdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZmliZXIpIHtcblx0ICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuXHQgICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2Vcblx0ICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcblx0ICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG5cblx0ICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblx0ICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblx0ICB9XG5cblx0ICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG5cdH1cblx0ZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcblx0ICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuXHQgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuXHR9XG5cblx0dmFyIHNob3VsZEVycm9ySW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuXHQgIHJldHVybiBudWxsO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHNob3VsZEVycm9yKGZpYmVyKSB7XG5cdCAgcmV0dXJuIHNob3VsZEVycm9ySW1wbChmaWJlcik7XG5cdH1cblxuXHR2YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcblx0ICByZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0ZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuXHQgIHJldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7XG5cdH1cblx0dmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcblx0dmFyIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGw7XG5cdHZhciBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsO1xuXHR2YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG5cdHZhciBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGw7XG5cdHZhciBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGw7XG5cdHZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG5cdHZhciBzZXRFcnJvckhhbmRsZXIgPSBudWxsO1xuXHR2YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxuXHR7XG5cdCAgdmFyIGNvcHlXaXRoRGVsZXRlSW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4KSB7XG5cdCAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG5cdCAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG5cdCAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuXHQgICAgICBpZiAoaXNBcnJheSh1cGRhdGVkKSkge1xuXHQgICAgICAgIHVwZGF0ZWQuc3BsaWNlKGtleSwgMSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZGVsZXRlIHVwZGF0ZWRba2V5XTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB1cGRhdGVkO1xuXHQgICAgfSAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cblxuXHQgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuXHQgICAgcmV0dXJuIHVwZGF0ZWQ7XG5cdCAgfTtcblxuXHQgIHZhciBjb3B5V2l0aERlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcblx0ICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcblx0ICB9O1xuXG5cdCAgdmFyIGNvcHlXaXRoUmVuYW1lSW1wbCA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG5cdCAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG5cdCAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG5cdCAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuXHQgICAgICB2YXIgbmV3S2V5ID0gbmV3UGF0aFtpbmRleF07IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuXHQgICAgICB1cGRhdGVkW25ld0tleV0gPSB1cGRhdGVkW29sZEtleV07XG5cblx0ICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcblx0ICAgICAgICB1cGRhdGVkLnNwbGljZShvbGRLZXksIDEpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblx0ICAgICAgdXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKCAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cdCAgICAgIG9ialtvbGRLZXldLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCArIDEpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdXBkYXRlZDtcblx0ICB9O1xuXG5cdCAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuXHQgICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aCkge1xuXHQgICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuXHQgICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG5cdCAgICAgICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXknKTtcblxuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG5cdCAgfTtcblxuXHQgIHZhciBjb3B5V2l0aFNldEltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcblx0ICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcblx0ICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuXHQgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcblx0ICAgIHJldHVybiB1cGRhdGVkO1xuXHQgIH07XG5cblx0ICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuXHQgICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuXHQgICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuXHQgICAgLy8gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgd2l0aCBlLmcuIG5lc3RlZCBob29rcy5cblx0ICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cblx0ICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcblx0ICAgICAgY3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuXHQgICAgICBpZC0tO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY3VycmVudEhvb2s7XG5cdCAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cblx0ICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG5cdCAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cblx0ICAgIGlmIChob29rICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuXHQgICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcblx0ICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuXHQgICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cblx0ICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG5cdCAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuXHQgICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG5cdCAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuXHQgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG5cdCAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcblx0ICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuXHQgICAgaWYgKGhvb2sgIT09IG51bGwpIHtcblx0ICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcblx0ICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG5cdCAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcblx0ICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG5cdCAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuXHQgICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cblx0ICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuXHQgICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcblx0ICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuXHQgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG5cdCAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cblx0ICAgIGlmIChob29rICE9PSBudWxsKSB7XG5cdCAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoUmVuYW1lKGhvb2subWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG5cdCAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuXHQgICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG5cdCAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuXHQgICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcblx0ICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG5cdCAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cblx0ICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG5cdCAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cblx0ICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG5cdCAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcblx0ICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0KGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIHZhbHVlKTtcblxuXHQgICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuXHQgICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG5cdCAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoKSB7XG5cdCAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuXHQgICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuXHQgICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG5cdCAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG5cdCAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuXHQgICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuXHQgICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG5cdCAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG5cdCAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG5cdCAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcblx0ICAgIHNob3VsZEVycm9ySW1wbCA9IG5ld1Nob3VsZEVycm9ySW1wbDtcblx0ICB9O1xuXG5cdCAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG5cdCAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcikge1xuXHQgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cblx0ICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcblx0ICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuXHQgIHJldHVybiBjdXJyZW50O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG5cdCAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG5cdCAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuXHQgIHJldHVybiBpbmplY3RJbnRlcm5hbHMoe1xuXHQgICAgYnVuZGxlVHlwZTogZGV2VG9vbHNDb25maWcuYnVuZGxlVHlwZSxcblx0ICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG5cdCAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuXHQgICAgcmVuZGVyZXJDb25maWc6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyQ29uZmlnLFxuXHQgICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuXHQgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG5cdCAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxcblx0ICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG5cdCAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDogb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG5cdCAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDogb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG5cdCAgICBzZXRFcnJvckhhbmRsZXI6IHNldEVycm9ySGFuZGxlcixcblx0ICAgIHNldFN1c3BlbnNlSGFuZGxlcjogc2V0U3VzcGVuc2VIYW5kbGVyLFxuXHQgICAgc2NoZWR1bGVVcGRhdGU6IHNjaGVkdWxlVXBkYXRlLFxuXHQgICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG5cdCAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsXG5cdCAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgfHwgZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcblx0ICAgIC8vIFJlYWN0IFJlZnJlc2hcblx0ICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDogIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCAsXG5cdCAgICBzY2hlZHVsZVJlZnJlc2g6ICBzY2hlZHVsZVJlZnJlc2ggLFxuXHQgICAgc2NoZWR1bGVSb290OiAgc2NoZWR1bGVSb290ICxcblx0ICAgIHNldFJlZnJlc2hIYW5kbGVyOiAgc2V0UmVmcmVzaEhhbmRsZXIgLFxuXHQgICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBhcHBlbmQgb3duZXIgc3RhY2tzIHRvIGVycm9yIG1lc3NhZ2VzIGluIERFViBtb2RlLlxuXHQgICAgZ2V0Q3VycmVudEZpYmVyOiAgZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMgLFxuXHQgICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBkZXRlY3QgcmVjb25jaWxlciB2ZXJzaW9uIHJhdGhlciB0aGFuIHJlbmRlcmVyIHZlcnNpb25cblx0ICAgIC8vIHdoaWNoIG1heSBub3QgbWF0Y2ggZm9yIHRoaXJkIHBhcnR5IHJlbmRlcmVycy5cblx0ICAgIHJlY29uY2lsZXJWZXJzaW9uOiBSZWFjdFZlcnNpb25cblx0ICB9KTtcblx0fVxuXG5cdGV4cG9ydHMuYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbjtcblx0ZXhwb3J0cy5hdHRlbXB0RGlzY3JldGVIeWRyYXRpb24gPSBhdHRlbXB0RGlzY3JldGVIeWRyYXRpb247XG5cdGV4cG9ydHMuYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O1xuXHRleHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbjtcblx0ZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGJhdGNoZWRVcGRhdGVzO1xuXHRleHBvcnRzLmNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yID0gY3JlYXRlQ29tcG9uZW50U2VsZWN0b3I7XG5cdGV4cG9ydHMuY3JlYXRlQ29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyO1xuXHRleHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yO1xuXHRleHBvcnRzLmNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciA9IGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcjtcblx0ZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWw7XG5cdGV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gY3JlYXRlUm9sZVNlbGVjdG9yO1xuXHRleHBvcnRzLmNyZWF0ZVRlc3ROYW1lU2VsZWN0b3IgPSBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yO1xuXHRleHBvcnRzLmNyZWF0ZVRleHRTZWxlY3RvciA9IGNyZWF0ZVRleHRTZWxlY3Rvcjtcblx0ZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBkZWZlcnJlZFVwZGF0ZXM7XG5cdGV4cG9ydHMuZGlzY3JldGVVcGRhdGVzID0gZGlzY3JldGVVcGRhdGVzO1xuXHRleHBvcnRzLmZpbmRBbGxOb2RlcyA9IGZpbmRBbGxOb2Rlcztcblx0ZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZpbmRCb3VuZGluZ1JlY3RzO1xuXHRleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlO1xuXHRleHBvcnRzLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzID0gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM7XG5cdGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nO1xuXHRleHBvcnRzLmZsdXNoQ29udHJvbGxlZCA9IGZsdXNoQ29udHJvbGxlZDtcblx0ZXhwb3J0cy5mbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cztcblx0ZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5cdGV4cG9ydHMuZm9jdXNXaXRoaW4gPSBmb2N1c1dpdGhpbjtcblx0ZXhwb3J0cy5nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHk7XG5cdGV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uO1xuXHRleHBvcnRzLmdldFB1YmxpY1Jvb3RJbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZTtcblx0ZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHM7XG5cdGV4cG9ydHMuaXNBbHJlYWR5UmVuZGVyaW5nID0gaXNBbHJlYWR5UmVuZGVyaW5nO1xuXHRleHBvcnRzLm9ic2VydmVWaXNpYmxlUmVjdHMgPSBvYnNlcnZlVmlzaWJsZVJlY3RzO1xuXHRleHBvcnRzLnJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbiA9IHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbjtcblx0ZXhwb3J0cy5ydW5XaXRoUHJpb3JpdHkgPSBydW5XaXRoUHJpb3JpdHk7XG5cdGV4cG9ydHMuc2hvdWxkRXJyb3IgPSBzaG91bGRFcnJvcjtcblx0ZXhwb3J0cy5zaG91bGRTdXNwZW5kID0gc2hvdWxkU3VzcGVuZDtcblx0ZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSB1cGRhdGVDb250YWluZXI7XG5cdCAgICByZXR1cm4gZXhwb3J0cztcblx0ICB9O1xuXHR9XG5cdHJldHVybiByZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnRFeHBvcnRzO1xufVxuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXG5cdHtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdFJlY29uY2lsZXJfZGV2ZWxvcG1lbnQoKTtcblx0fVxufSAocmVhY3RSZWNvbmNpbGVyKSk7XG5cbnZhciBSZWNvbmNpbGVyID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHJlYWN0UmVjb25jaWxlckV4cG9ydHMpO1xuXG52YXIgbmFtZSA9IFwicm9vdFwiO1xudmFyIHdvcmtzcGFjZXMgPSBbXG5cdFwicGFja2FnZXMvKlwiXG5dO1xudmFyIHNjcmlwdHMgPSB7XG5cdGJ1aWxkOiBcIm54IHJ1bi1tYW55IC0tdGFyZ2V0PWJ1aWxkIC0tYWxsIC0tcGFyYWxsZWxcIixcblx0XCJidWlsZDpmb3JjZVwiOiBcIm54IHJ1bi1tYW55IC0tdGFyZ2V0PWJ1aWxkIC0tYWxsIC0tcGFyYWxsZWwgLS1za2lwLW54LWNhY2hlXCIsXG5cdFwiYnVpbGQ6ZG9jc1wiOiBcIm54IHJ1biBAcGl4aS9yZWFjdC1kb2NzOmRlcGxveVwiLFxuXHRjbGVhbjogXCJyaW1yYWYgcGFja2FnZXMvKi9kaXN0IHBhY2thZ2VzLyovYnVpbGRcIixcblx0bGludDogXCJlc2xpbnQgLlwiLFxuXHRwcmVwYXJlOiBcImh1c2t5IGluc3RhbGxcIixcblx0cHJlcmVsZWFzZTogXCIuL3NjcmlwdHMvY2hlY2tSZWxlYXNlQnJhbmNoLm1qcyAmJiBucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biB0ZXN0OmZvcmNlICYmIG5wbSBydW4gYnVpbGQ6Zm9yY2VcIixcblx0cmVsZWFzZTogXCJsZXJuYSBwdWJsaXNoIC0tbm8tcHJpdmF0ZVwiLFxuXHR0ZXN0OiBcIm54IHJ1bi1tYW55IC0tdGFyZ2V0PXRlc3QgLS1hbGwgLS1wYXJhbGxlbFwiLFxuXHRcInRlc3Q6Zm9yY2VcIjogXCJueCBydW4tbWFueSAtLXRhcmdldD10ZXN0IC0tYWxsIC0tcGFyYWxsZWwgLS1za2lwLW54LWNhY2hlXCIsXG5cdFwidGVzdDp0eXBlc1wiOiBcIm54IHJ1bi1tYW55IC0tdGFyZ2V0PXRlc3Q6dHlwZXMgLS1hbGwgLS1wYXJhbGxlbFwiLFxuXHRcInRlc3Q6dHlwZXM6Zm9yY2VcIjogXCJueCBydW4tbWFueSAtLXRhcmdldD10ZXN0OnR5cGVzIC0tYWxsIC0tcGFyYWxsZWwgLS1za2lwLW54LWNhY2hlXCJcbn07XG52YXIgaHVza3kgPSB7XG5cdGhvb2tzOiB7XG5cdFx0XCJwcmUtY29tbWl0XCI6IFwibGludC1zdGFnZWRcIlxuXHR9XG59O1xudmFyIHJlc29sdXRpb25zID0ge1xuXHRcImdldC1wa2ctcmVwb1wiOiBcIjQuMS4xXCIsXG5cdFwiaG9zdGVkLWdpdC1pbmZvXCI6IFwiXjIuMS40XCJcbn07XG52YXIgZGVwZW5kZW5jaWVzID0ge1xuXHRcIkBiYWJlbC9ydW50aW1lXCI6IFwiXjcuMTQuOFwiLFxuXHRcIkBwaXhpL2FwcFwiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL2NvbnN0YW50c1wiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL2NvcmVcIjogXCJeNy4xLjFcIixcblx0XCJAcGl4aS9kaXNwbGF5XCI6IFwiXjcuMS4xXCIsXG5cdFwiQHBpeGkvZXh0ZW5zaW9uc1wiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL2dyYXBoaWNzXCI6IFwiXjcuMS4xXCIsXG5cdFwiQHBpeGkvbWF0aFwiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL21lc2hcIjogXCJeNy4xLjFcIixcblx0XCJAcGl4aS9tZXNoLWV4dHJhc1wiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL3BhcnRpY2xlLWNvbnRhaW5lclwiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL3Nwcml0ZVwiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL3Nwcml0ZS1hbmltYXRlZFwiOiBcIl43LjEuMVwiLFxuXHRcIkBwaXhpL3Nwcml0ZS10aWxpbmdcIjogXCJeNy4xLjFcIixcblx0XCJAcGl4aS90ZXh0XCI6IFwiXjcuMS4xXCIsXG5cdFwiQHBpeGkvdGV4dC1iaXRtYXBcIjogXCJeNy4xLjFcIixcblx0XCJAcGl4aS90aWNrZXJcIjogXCJeNy4xLjFcIixcblx0XCJAcmVhY3Qtc3ByaW5nL2FuaW1hdGVkXCI6IFwiXjkuNi4xXCIsXG5cdFwiQHJlYWN0LXNwcmluZy90eXBlc1wiOiBcIl45LjYuMVwiLFxuXHRyZWFjdDogXCJeMTguMC4wXCIsXG5cdFwicmVhY3QtZG9tXCI6IFwiXjE4LjAuMFwiLFxuXHRcInJlYWN0LXJlY29uY2lsZXJcIjogXCIwLjI5LjBcIixcblx0XCJyZWFjdC1zcHJpbmdcIjogXCJeOS42LjFcIlxufTtcbnZhciBkZXZEZXBlbmRlbmNpZXMgPSB7XG5cdFwiQGJhYmVsL2NsaVwiOiBcIl43LjIwLjdcIixcblx0XCJAYmFiZWwvY29yZVwiOiBcIl43LjIwLjdcIixcblx0XCJAYmFiZWwvZXNsaW50LXBhcnNlclwiOiBcIl43LjE5LjFcIixcblx0XCJAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1ydW50aW1lXCI6IFwiXjcuMTkuNlwiLFxuXHRcIkBiYWJlbC9wcmVzZXQtZW52XCI6IFwiXjcuMjAuMlwiLFxuXHRcIkBiYWJlbC9wcmVzZXQtcmVhY3RcIjogXCJeNy4xOC42XCIsXG5cdFwiQG5yd2wvbngtY2xvdWRcIjogXCJsYXRlc3RcIixcblx0XCJAcGl4aS9lc2xpbnQtY29uZmlnXCI6IFwiXjQuMC4xXCIsXG5cdFwiQHJvbGx1cC9wbHVnaW4tYWxpYXNcIjogXCJeNC4wLjJcIixcblx0XCJAcm9sbHVwL3BsdWdpbi1iYWJlbFwiOiBcIl42LjAuM1wiLFxuXHRcIkByb2xsdXAvcGx1Z2luLWNvbW1vbmpzXCI6IFwiXjI0LjAuMFwiLFxuXHRcIkByb2xsdXAvcGx1Z2luLWpzb25cIjogXCJeNi4wLjBcIixcblx0XCJAcm9sbHVwL3BsdWdpbi1ub2RlLXJlc29sdmVcIjogXCJeMTUuMC4xXCIsXG5cdFwiQHJvbGx1cC9wbHVnaW4tcmVwbGFjZVwiOiBcIl41LjAuMlwiLFxuXHRcIkByb2xsdXAvcGx1Z2luLXRlcnNlclwiOiBcIl4wLjIuMVwiLFxuXHRcIkByb2xsdXAvcGx1Z2luLXR5cGVzY3JpcHRcIjogXCJeMTAuMC4xXCIsXG5cdFwiQHR5cGVzL2plc3RcIjogXCJeMjkuMi40XCIsXG5cdFwiQHR5cGVzL3JlYWN0XCI6IFwiMTcuMC4xNVwiLFxuXHRcIkB0eXBlcy9yZWFjdC1kb21cIjogXCIxNy4wLjlcIixcblx0XCJAdHlwZXMvcmVhY3QtcmVjb25jaWxlclwiOiBcIjAuMjguMlwiLFxuXHRcImJhYmVsLWplc3RcIjogXCJeMjkuMy4xXCIsXG5cdFwiYmFiZWwtcGx1Z2luLW1vZHVsZS1yZXNvbHZlclwiOiBcIjQuMS4wXCIsXG5cdFwiY3Jvc3MtZW52XCI6IFwiXjcuMC4zXCIsXG5cdGVzbGludDogXCJeOC4yOS4wXCIsXG5cdFwiZXNsaW50LXBsdWdpbi1yZWFjdFwiOiBcIl43LjMxLjExXCIsXG5cdGh1c2t5OiBcIl44LjAuMlwiLFxuXHRqZXN0OiBcIl4yOS4zLjFcIixcblx0XCJqZXN0LWVudmlyb25tZW50LWpzZG9tXCI6IFwiXjI5LjMuMVwiLFxuXHRcImplc3QtZXh0ZW5kZWRcIjogXCJeMy4yLjBcIixcblx0XCJqZXN0LXdhdGNoLXR5cGVhaGVhZFwiOiBcIl4yLjIuMVwiLFxuXHRsZXJuYTogXCJeNi4wLjNcIixcblx0XCJsaW50LXN0YWdlZFwiOiBcIl4xMy4xLjBcIixcblx0bng6IFwiMTUuMy4wXCIsXG5cdHJpbXJhZjogXCJeMy4wLjJcIixcblx0cm9sbHVwOiBcIl4zLjcuMFwiLFxuXHRcInJvbGx1cC1wbHVnaW4tZmlsZXNpemVcIjogXCJeOS4xLjJcIixcblx0XCJyb2xsdXAtcGx1Z2luLXZpc3VhbGl6ZXJcIjogXCJeNS45LjBcIixcblx0XCJ0cy1qZXN0XCI6IFwiXjI5LjAuM1wiLFxuXHRcInRzLW5vZGVcIjogXCJeMTAuOS4xXCIsXG5cdHR5cGVzY3JpcHQ6IFwiXjQuOS40XCJcbn07XG52YXIgcGtnID0ge1xuXHRuYW1lOiBuYW1lLFxuXHRcInByaXZhdGVcIjogdHJ1ZSxcblx0d29ya3NwYWNlczogd29ya3NwYWNlcyxcblx0c2NyaXB0czogc2NyaXB0cyxcblx0aHVza3k6IGh1c2t5LFxuXHRcImxpbnQtc3RhZ2VkXCI6IHtcblx0XCIqLnt0cyxqcyxtanN9XCI6IFtcblx0XHRcImVzbGludCAtLWNhY2hlIC0tZml4XCJcblx0XVxufSxcblx0cmVzb2x1dGlvbnM6IHJlc29sdXRpb25zLFxuXHRkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcblx0ZGV2RGVwZW5kZW5jaWVzOiBkZXZEZXBlbmRlbmNpZXNcbn07XG5cbnZhciBwZXJmb3JtYW5jZU5vd0V4cG9ydHMgPSB7fTtcbnZhciBwZXJmb3JtYW5jZU5vdyA9IHtcbiAgZ2V0IGV4cG9ydHMoKXsgcmV0dXJuIHBlcmZvcm1hbmNlTm93RXhwb3J0czsgfSxcbiAgc2V0IGV4cG9ydHModil7IHBlcmZvcm1hbmNlTm93RXhwb3J0cyA9IHY7IH0sXG59O1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWUsIG1vZHVsZUxvYWRUaW1lLCBub2RlTG9hZFRpbWUsIHVwVGltZTtcblxuICBpZiAoKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwZXJmb3JtYW5jZSAhPT0gbnVsbCkgJiYgcGVyZm9ybWFuY2Uubm93KSB7XG4gICAgcGVyZm9ybWFuY2VOb3cuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgIT09IG51bGwpICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgcGVyZm9ybWFuY2VOb3cuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIHBlcmZvcm1hbmNlTm93LmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybWFuY2VOb3cuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbG9hZFRpbWU7XG4gICAgfTtcbiAgICBsb2FkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbn0pLmNhbGwoY29tbW9uanNHbG9iYWwpO1xuXG52YXIgY29uc3RhbnRzRXhwb3J0cyA9IHt9O1xudmFyIGNvbnN0YW50cyA9IHtcbiAgZ2V0IGV4cG9ydHMoKXsgcmV0dXJuIGNvbnN0YW50c0V4cG9ydHM7IH0sXG4gIHNldCBleHBvcnRzKHYpeyBjb25zdGFudHNFeHBvcnRzID0gdjsgfSxcbn07XG5cbnZhciByZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQgPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRSZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQpIHJldHVybiByZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQ7XG5cdGhhc1JlcXVpcmVkUmVhY3RSZWNvbmNpbGVyQ29uc3RhbnRzX2RldmVsb3BtZW50ID0gMTtcblxuXHR7XG5cdCAgKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBTeW5jTGFuZSA9XG5cdC8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0MTtcblx0dmFyIElucHV0Q29udGludW91c0xhbmUgPVxuXHQvKiAgICAgICAgICAgICAqL1xuXHQ0O1xuXHR2YXIgRGVmYXVsdExhbmUgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICovXG5cdDE2O1xuXHR2YXIgSWRsZUxhbmUgPVxuXHQvKiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdDUzNjg3MDkxMjtcblxuXHR2YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG5cdHZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG5cdHZhciBEZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRMYW5lO1xuXHR2YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcblxuXHR2YXIgTGVnYWN5Um9vdCA9IDA7XG5cdHZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cblx0cmVhY3RSZWNvbmNpbGVyQ29uc3RhbnRzX2RldmVsb3BtZW50LkNvbmN1cnJlbnRSb290ID0gQ29uY3VycmVudFJvb3Q7XG5cdHJlYWN0UmVjb25jaWxlckNvbnN0YW50c19kZXZlbG9wbWVudC5Db250aW51b3VzRXZlbnRQcmlvcml0eSA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuXHRyZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQuRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0RXZlbnRQcmlvcml0eTtcblx0cmVhY3RSZWNvbmNpbGVyQ29uc3RhbnRzX2RldmVsb3BtZW50LkRpc2NyZXRlRXZlbnRQcmlvcml0eSA9IERpc2NyZXRlRXZlbnRQcmlvcml0eTtcblx0cmVhY3RSZWNvbmNpbGVyQ29uc3RhbnRzX2RldmVsb3BtZW50LklkbGVFdmVudFByaW9yaXR5ID0gSWRsZUV2ZW50UHJpb3JpdHk7XG5cdHJlYWN0UmVjb25jaWxlckNvbnN0YW50c19kZXZlbG9wbWVudC5MZWdhY3lSb290ID0gTGVnYWN5Um9vdDtcblx0ICB9KSgpO1xuXHR9XG5cdHJldHVybiByZWFjdFJlY29uY2lsZXJDb25zdGFudHNfZGV2ZWxvcG1lbnQ7XG59XG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cblx0e1xuXHQgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZVJlYWN0UmVjb25jaWxlckNvbnN0YW50c19kZXZlbG9wbWVudCgpO1xuXHR9XG59IChjb25zdGFudHMpKTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfd2luZG93LCBfd2luZG93JGV2ZW50O1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzRXhwb3J0cy5EZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuICB2YXIgbmFtZSA9IChfd2luZG93ID0gd2luZG93KSA9PT0gbnVsbCB8fCBfd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3dpbmRvdyRldmVudCA9IF93aW5kb3cuZXZlbnQpID09PSBudWxsIHx8IF93aW5kb3ckZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckZXZlbnQudHlwZTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnY2xpY2snOlxuICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAncG9pbnRlcmNhbmNlbCc6XG4gICAgY2FzZSAncG9pbnRlcmRvd24nOlxuICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICByZXR1cm4gY29uc3RhbnRzRXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyZW50ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIGNvbnN0YW50c0V4cG9ydHMuQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb25zdGFudHNFeHBvcnRzLkRlZmF1bHRFdmVudFByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBfYXBwZW5kQ2hpbGQocGFyZW50LCBjaGlsZCkge1xuICBpZiAocGFyZW50LmFkZENoaWxkKSB7XG4gICAgcGFyZW50LmFkZENoaWxkKGNoaWxkKTtcbiAgICBpZiAodHlwZW9mIGNoaWxkLmRpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjaGlsZC5kaWRNb3VudChjaGlsZCwgcGFyZW50KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdpbGxVbm1vdW50UmVjdXJzaXZlKGNoaWxkLCBwYXJlbnQpIHtcbiAgdmFyIF9jaGlsZCR3aWxsVW5tb3VudCwgX2NoaWxkJGNvbmZpZywgX2NoaWxkJGNoaWxkcmVuO1xuICAoX2NoaWxkJHdpbGxVbm1vdW50ID0gY2hpbGQud2lsbFVubW91bnQpID09PSBudWxsIHx8IF9jaGlsZCR3aWxsVW5tb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NoaWxkJHdpbGxVbm1vdW50LmNhbGwoY2hpbGQsIGNoaWxkLCBwYXJlbnQpO1xuXG4gIC8vIGVuc3VyZSB3aWxsVW5tb3VudCBpcyBjYWxsZWQgb24gY2hpbGRyZW4sIGJ1dCBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW1cbiAgaWYgKCgoX2NoaWxkJGNvbmZpZyA9IGNoaWxkLmNvbmZpZykgPT09IG51bGwgfHwgX2NoaWxkJGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NoaWxkJGNvbmZpZy5kZXN0cm95Q2hpbGRyZW4pICE9PSBmYWxzZSAmJiAoX2NoaWxkJGNoaWxkcmVuID0gY2hpbGQuY2hpbGRyZW4pICE9PSBudWxsICYmIF9jaGlsZCRjaGlsZHJlbiAhPT0gdm9pZCAwICYmIF9jaGlsZCRjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGQuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBjYWxsIHdpbGxVbm1vdW50IGFueXdheSBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlciBkZXN0cm95Q2hpbGRyZW4gaXMgdHJ1ZT9cbiAgICAgIHdpbGxVbm1vdW50UmVjdXJzaXZlKGMsIGNoaWxkKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gX3JlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIF9jaGlsZCRjb25maWcyO1xuICAvLyBjYWxsIHdpbGxVbm1vdW50IG9uIGNoaWxkIGFuZCBpdGVyYXRpdmVseSBvbiBpdHMgZGVzY2VuZGFudHNcbiAgd2lsbFVubW91bnRSZWN1cnNpdmUoY2hpbGQsIHBhcmVudCk7XG4gIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIHZhciBfcmVmID0gKF9jaGlsZCRjb25maWcyID0gY2hpbGQuY29uZmlnKSAhPT0gbnVsbCAmJiBfY2hpbGQkY29uZmlnMiAhPT0gdm9pZCAwID8gX2NoaWxkJGNvbmZpZzIgOiB7fSxcbiAgICBfcmVmJGRlc3Ryb3kgPSBfcmVmLmRlc3Ryb3ksXG4gICAgZGVzdHJveSA9IF9yZWYkZGVzdHJveSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkZGVzdHJveSxcbiAgICBfcmVmJGRlc3Ryb3lDaGlsZHJlbiA9IF9yZWYuZGVzdHJveUNoaWxkcmVuLFxuICAgIGRlc3Ryb3lDaGlsZHJlbiA9IF9yZWYkZGVzdHJveUNoaWxkcmVuID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRkZXN0cm95Q2hpbGRyZW4sXG4gICAgX3JlZiRkZXN0cm95VGV4dHVyZSA9IF9yZWYuZGVzdHJveVRleHR1cmUsXG4gICAgZGVzdHJveVRleHR1cmUgPSBfcmVmJGRlc3Ryb3lUZXh0dXJlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGVzdHJveVRleHR1cmUsXG4gICAgX3JlZiRkZXN0cm95QmFzZVRleHR1ID0gX3JlZi5kZXN0cm95QmFzZVRleHR1cmUsXG4gICAgZGVzdHJveUJhc2VUZXh0dXJlID0gX3JlZiRkZXN0cm95QmFzZVRleHR1ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGVzdHJveUJhc2VUZXh0dTtcbiAgaWYgKGRlc3Ryb3kpIHtcbiAgICAvLyBkZWZlciB0byBQSVhJIHRvIGFjdHVhbGx5IGRlc3Ryb3kgY2hpbGRyZW5cbiAgICBjaGlsZC5kZXN0cm95KHtcbiAgICAgIGNoaWxkcmVuOiBkZXN0cm95Q2hpbGRyZW4sXG4gICAgICB0ZXh0dXJlOiBkZXN0cm95VGV4dHVyZSxcbiAgICAgIGJhc2VUZXh0dXJlOiBkZXN0cm95QmFzZVRleHR1cmVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudCwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGludmFyaWFudChjaGlsZCAhPT0gYmVmb3JlQ2hpbGQsICdwaXhpLXJlYWN0OiBQaXhpRmliZXIgY2Fubm90IGluc2VydCBub2RlIGJlZm9yZSBpdHNlbGYnKTtcbiAgdmFyIGNoaWxkRXhpc3RzID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpICE9PSAtMTtcbiAgaWYgKGNoaWxkRXhpc3RzKSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICB2YXIgaW5kZXggPSBwYXJlbnQuZ2V0Q2hpbGRJbmRleChiZWZvcmVDaGlsZCk7XG4gIHBhcmVudC5hZGRDaGlsZEF0KGNoaWxkLCBpbmRleCk7XG59XG5cbi8vIGdldCBkaWZmIGJldHdlZW4gMiBvYmplY3RzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi85N2UyOTExL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvY2xpZW50L1JlYWN0RE9NRmliZXJDb21wb25lbnQuanMjTDU0NlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMocGl4aUVsZW1lbnQsIHR5cGUsIGxhc3RQcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSA7IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIF9wcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1tfcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9PSBudWxsID8gbGFzdFByb3BzW19wcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09PSBudWxsICYmIGxhc3RQcm9wID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKF9wcm9wS2V5ID09PSBDSElMRFJFTikgOyBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgICB1cGRhdGVQYXlsb2FkLnB1c2goX3Byb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG52YXIgcHJlcGFyZUNoYW5nZWQgPSBudWxsO1xudmFyIEhvc3RDb25maWcgPSB7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250ZXh0KCkge1xuICAgIHJldHVybiBOT19DT05URVhUO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcmVudEhvc3RDb250ZXh0O1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0Rm9yRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHRGb3JFdmVudENvbXBvbmVudChwYXJlbnRIb3N0Q29udGV4dCkge1xuICAgIHJldHVybiBwYXJlbnRIb3N0Q29udGV4dDtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuICAvLyBUT0RPOiBJbXBsZW1lbnQgYSBwcm9wZXIgdmVyc2lvbiBvZiBnZXRDdXJyZW50RXZlbnRQcmlvcml0eVxuICBnZXRDdXJyZW50RXZlbnRQcmlvcml0eTogZnVuY3Rpb24gZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIGdldEV2ZW50UHJpb3JpdHkoKTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gcHJlcGFyZUZvckNvbW1pdCgpIHtcbiAgICAvLyBub29wXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoKSB7XG4gICAgLy8gbm9vcFxuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogY3JlYXRlRWxlbWVudCxcbiAgaGlkZUluc3RhbmNlOiBmdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gIH0sXG4gIHVuaGlkZUluc3RhbmNlOiBmdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgdmlzaWJsZSA9IHByb3BzICE9PSB1bmRlZmluZWQgJiYgcHJvcHMgIT09IG51bGwgJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoJ3Zpc2libGUnKSA/IHByb3BzLnZpc2libGUgOiB0cnVlO1xuICAgIGluc3RhbmNlLnZpc2libGUgPSB2aXNpYmxlO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gZmluYWxpemVJbml0aWFsQ2hpbGRyZW4od29yZEVsZW1lbnQsIHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiBwcmVwYXJlVXBkYXRlKHBpeGlFbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICBwcmVwYXJlQ2hhbmdlZCA9IGRpZmZQcm9wZXJ0aWVzKHBpeGlFbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIHJldHVybiBwcmVwYXJlQ2hhbmdlZDtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIHByb3BzKSB7XG4gICAgdmFyIGlzQWxwaGFWaXNpYmxlID0gdHlwZW9mIHByb3BzLmFscGhhID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy5hbHBoYSA+IDA7XG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9IHR5cGVvZiBwcm9wcy5yZW5kZXJhYmxlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy5yZW5kZXJhYmxlID09PSB0cnVlO1xuICAgIHZhciBpc1Zpc2libGUgPSB0eXBlb2YgcHJvcHMudmlzaWJsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMudmlzaWJsZSA9PT0gdHJ1ZTtcbiAgICByZXR1cm4gIShpc0FscGhhVmlzaWJsZSAmJiBpc1JlbmRlcmFibGUgJiYgaXNWaXNpYmxlKTtcbiAgfSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlcikge1xuICAgIGludmFyaWFudChmYWxzZSwgXCJwaXhpLXJlYWN0OiBFcnJvciB0cnlpbmcgdG8gYWRkIHRleHQgbm9kZSBcXFwiXCIuY29uY2F0KHRleHQsIFwiXFxcIlwiKSwgJ1BpeGlGaWJlciBkb2VzIG5vdCBzdXBwb3J0IHRleHQgbm9kZXMgYXMgY2hpbGRyZW4gb2YgYSBQaXhpIGNvbXBvbmVudC4gJyArICdUbyBwYXNzIGEgc3RyaW5nIHZhbHVlIHRvIHlvdXIgY29tcG9uZW50LCB1c2UgYSBwcm9wZXJ0eSBvdGhlciB0aGFuIGNoaWxkcmVuLiAnICsgJ0lmIHlvdSB3aXNoIHRvIGRpc3BsYXkgc29tZSB0ZXh0LCB5b3UgY2FuIHVzZSAmbHQ7VGV4dCB0ZXh0PXtzdHJpbmd9IC8mZ3Q7IGluc3RlYWQuJyk7XG4gIH0sXG4gIHVuaGlkZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gdW5oaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgIC8vIG5vb3BcbiAgfSxcbiAgbW91bnRFdmVudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRFdmVudENvbXBvbmVudCgpIHtcbiAgICAvLyBub29wXG4gIH0sXG4gIHVwZGF0ZUV2ZW50Q29tcG9uZW50OiBmdW5jdGlvbiB1cGRhdGVFdmVudENvbXBvbmVudCgpIHtcbiAgICAvLyBub29wXG4gIH0sXG4gIGhhbmRsZUV2ZW50VGFyZ2V0OiBmdW5jdGlvbiBoYW5kbGVFdmVudFRhcmdldCgpIHtcbiAgICAvLyBub29wXG4gIH0sXG4gIHNjaGVkdWxlVGltZW91dDogc2V0VGltZW91dCxcbiAgY2FuY2VsVGltZW91dDogY2xlYXJUaW1lb3V0LFxuICBub1RpbWVvdXQ6IC0xLFxuICB3YXJuc0lmTm90QWN0aW5nOiBmYWxzZSxcbiAgbm93OiBwZXJmb3JtYW5jZU5vd0V4cG9ydHMsXG4gIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gIHN1cHBvcnRzSHlkcmF0aW9uOiBmYWxzZSxcbiAgc3VwcG9ydHNNaWNyb3Rhc2tzOiB0cnVlLFxuICBzY2hlZHVsZU1pY3JvdGFzazogcXVldWVNaWNyb3Rhc2ssXG4gIC8qKlxuICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKiBNdXRhdGlvblxuICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgKi9cbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBmdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQoKSB7XG4gICAgdmFyIF9hcmdzJDAkX19yZWFjdHBpeGksIF9hcmdzJDAkX19yZWFjdHBpeGkkcjtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHZhciByZXMgPSBfYXBwZW5kQ2hpbGQuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgKF9hcmdzJDAkX19yZWFjdHBpeGkgPSBhcmdzWzBdLl9fcmVhY3RwaXhpKSA9PT0gbnVsbCB8fCBfYXJncyQwJF9fcmVhY3RwaXhpID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2FyZ3MkMCRfX3JlYWN0cGl4aSRyID0gX2FyZ3MkMCRfX3JlYWN0cGl4aS5yb290KSA9PT0gbnVsbCB8fCBfYXJncyQwJF9fcmVhY3RwaXhpJHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hcmdzJDAkX19yZWFjdHBpeGkkci5lbWl0KFwiX19SRUFDVF9QSVhJX1JFUVVFU1RfUkVOREVSX19cIiwge1xuICAgICAgZGV0YWlsOiAnYXBwZW5kSW5pdGlhbENoaWxkJ1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbiBhcHBlbmRDaGlsZCgpIHtcbiAgICB2YXIgX2FyZ3MkMCRfX3JlYWN0cGl4aTIsIF9hcmdzJDAkX19yZWFjdHBpeGkyJDtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IF9hcHBlbmRDaGlsZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAoX2FyZ3MkMCRfX3JlYWN0cGl4aTIgPSBhcmdzWzBdLl9fcmVhY3RwaXhpKSA9PT0gbnVsbCB8fCBfYXJncyQwJF9fcmVhY3RwaXhpMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9hcmdzJDAkX19yZWFjdHBpeGkyJCA9IF9hcmdzJDAkX19yZWFjdHBpeGkyLnJvb3QpID09PSBudWxsIHx8IF9hcmdzJDAkX19yZWFjdHBpeGkyJCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZ3MkMCRfX3JlYWN0cGl4aTIkLmVtaXQoXCJfX1JFQUNUX1BJWElfUkVRVUVTVF9SRU5ERVJfX1wiLCB7XG4gICAgICBkZXRhaWw6ICdhcHBlbmRDaGlsZCdcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKCkge1xuICAgIHZhciBfYXJncyQwJF9fcmVhY3RwaXhpMywgX2FyZ3MkMCRfX3JlYWN0cGl4aTMkO1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gX2FwcGVuZENoaWxkLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIChfYXJncyQwJF9fcmVhY3RwaXhpMyA9IGFyZ3NbMF0uX19yZWFjdHBpeGkpID09PSBudWxsIHx8IF9hcmdzJDAkX19yZWFjdHBpeGkzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2FyZ3MkMCRfX3JlYWN0cGl4aTMkID0gX2FyZ3MkMCRfX3JlYWN0cGl4aTMucm9vdCkgPT09IG51bGwgfHwgX2FyZ3MkMCRfX3JlYWN0cGl4aTMkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyQwJF9fcmVhY3RwaXhpMyQuZW1pdChcIl9fUkVBQ1RfUElYSV9SRVFVRVNUX1JFTkRFUl9fXCIsIHtcbiAgICAgIGRldGFpbDogJ2FwcGVuZENoaWxkVG9Db250YWluZXInXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKCkge1xuICAgIHZhciBfYXJncyQwJF9fcmVhY3RwaXhpNCwgX2FyZ3MkMCRfX3JlYWN0cGl4aTQkO1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gX3JlbW92ZUNoaWxkLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIChfYXJncyQwJF9fcmVhY3RwaXhpNCA9IGFyZ3NbMF0uX19yZWFjdHBpeGkpID09PSBudWxsIHx8IF9hcmdzJDAkX19yZWFjdHBpeGk0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2FyZ3MkMCRfX3JlYWN0cGl4aTQkID0gX2FyZ3MkMCRfX3JlYWN0cGl4aTQucm9vdCkgPT09IG51bGwgfHwgX2FyZ3MkMCRfX3JlYWN0cGl4aTQkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyQwJF9fcmVhY3RwaXhpNCQuZW1pdChcIl9fUkVBQ1RfUElYSV9SRVFVRVNUX1JFTkRFUl9fXCIsIHtcbiAgICAgIGRldGFpbDogJ3JlbW92ZUNoaWxkJ1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKCkge1xuICAgIHZhciBfYXJncyQwJF9fcmVhY3RwaXhpNSwgX2FyZ3MkMCRfX3JlYWN0cGl4aTUkO1xuICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gX3JlbW92ZUNoaWxkLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIChfYXJncyQwJF9fcmVhY3RwaXhpNSA9IGFyZ3NbMF0uX19yZWFjdHBpeGkpID09PSBudWxsIHx8IF9hcmdzJDAkX19yZWFjdHBpeGk1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2FyZ3MkMCRfX3JlYWN0cGl4aTUkID0gX2FyZ3MkMCRfX3JlYWN0cGl4aTUucm9vdCkgPT09IG51bGwgfHwgX2FyZ3MkMCRfX3JlYWN0cGl4aTUkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyQwJF9fcmVhY3RwaXhpNSQuZW1pdChcIl9fUkVBQ1RfUElYSV9SRVFVRVNUX1JFTkRFUl9fXCIsIHtcbiAgICAgIGRldGFpbDogJ3JlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcidcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKCkge1xuICAgIHZhciBfYXJncyQwJF9fcmVhY3RwaXhpNiwgX2FyZ3MkMCRfX3JlYWN0cGl4aTYkO1xuICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gaW5zZXJ0QmVmb3JlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIChfYXJncyQwJF9fcmVhY3RwaXhpNiA9IGFyZ3NbMF0uX19yZWFjdHBpeGkpID09PSBudWxsIHx8IF9hcmdzJDAkX19yZWFjdHBpeGk2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2FyZ3MkMCRfX3JlYWN0cGl4aTYkID0gX2FyZ3MkMCRfX3JlYWN0cGl4aTYucm9vdCkgPT09IG51bGwgfHwgX2FyZ3MkMCRfX3JlYWN0cGl4aTYkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyQwJF9fcmVhY3RwaXhpNiQuZW1pdChcIl9fUkVBQ1RfUElYSV9SRVFVRVNUX1JFTkRFUl9fXCIsIHtcbiAgICAgIGRldGFpbDogJ2luc2VydEluQ29udGFpbmVyQmVmb3JlJ1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICB2YXIgYXBwbHlQcm9wcyA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcGx5UHJvcHM7XG4gICAgaWYgKHR5cGVvZiBhcHBseVByb3BzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcHBseVByb3BzID0gYXBwbHlEZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIHZhciBjaGFuZ2VkID0gYXBwbHlQcm9wcyhpbnN0YW5jZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBwcmVwYXJlQ2hhbmdlZCkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3JlYWN0cGl4aSwgX2luc3RhbmNlJF9fcmVhY3RwaXhpMjtcbiAgICAgIChfaW5zdGFuY2UkX19yZWFjdHBpeGkgPSBpbnN0YW5jZS5fX3JlYWN0cGl4aSkgPT09IG51bGwgfHwgX2luc3RhbmNlJF9fcmVhY3RwaXhpID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2luc3RhbmNlJF9fcmVhY3RwaXhpMiA9IF9pbnN0YW5jZSRfX3JlYWN0cGl4aS5yb290KSA9PT0gbnVsbCB8fCBfaW5zdGFuY2UkX19yZWFjdHBpeGkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yZWFjdHBpeGkyLmVtaXQoXCJfX1JFQUNUX1BJWElfUkVRVUVTVF9SRU5ERVJfX1wiLCB7XG4gICAgICAgIGRldGFpbDogJ2NvbW1pdFVwZGF0ZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIGNvbW1pdE1vdW50KGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBub29wXG4gIH0sXG4gIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gbm9vcFxuICB9LFxuICByZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiByZXNldFRleHRDb250ZW50KHBpeGlFbGVtZW50KSB7XG4gICAgLy8gbm9vcFxuICB9LFxuICBjbGVhckNvbnRhaW5lcjogZnVuY3Rpb24gY2xlYXJDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgLy8gVE9ETyBpbXBsZW1lbnQgdGhpc1xuICB9LFxuICBnZXRGdW5kYW1lbnRhbENvbXBvbmVudEluc3RhbmNlOiBmdW5jdGlvbiBnZXRGdW5kYW1lbnRhbENvbXBvbmVudEluc3RhbmNlKGZ1bmRhbWVudGFsSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0sXG4gIG1vdW50RnVuZGFtZW50YWxDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50RnVuZGFtZW50YWxDb21wb25lbnQoZnVuZGFtZW50YWxJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgfSxcbiAgc2hvdWxkVXBkYXRlRnVuZGFtZW50YWxDb21wb25lbnQ6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZUZ1bmRhbWVudGFsQ29tcG9uZW50KGZ1bmRhbWVudGFsSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0sXG4gIHVubW91bnRGdW5kYW1lbnRhbENvbXBvbmVudDogZnVuY3Rpb24gdW5tb3VudEZ1bmRhbWVudGFsQ29tcG9uZW50KGZ1bmRhbWVudGFsSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0sXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgfSxcbiAgaXNPcGFxdWVIeWRyYXRpbmdPYmplY3Q6IGZ1bmN0aW9uIGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG4gIG1ha2VPcGFxdWVIeWRyYXRpbmdPYmplY3Q6IGZ1bmN0aW9uIG1ha2VPcGFxdWVIeWRyYXRpbmdPYmplY3QoYXR0ZW1wdFRvUmVhZFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkLicpO1xuICB9LFxuICBtYWtlQ2xpZW50SWRJbkRFVjogZnVuY3Rpb24gbWFrZUNsaWVudElkSW5ERVYod2Fybk9uQWNjZXNzSW5ERVYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcbiAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyOiBmdW5jdGlvbiBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIC8vIG5vb3BcbiAgfSxcbiAgYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI6IGZ1bmN0aW9uIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyKCkge1xuICAgIC8vIG5vb3BcbiAgfSxcbiAgZGV0YWNoRGVsZXRlZEluc3RhbmNlOiBmdW5jdGlvbiBkZXRhY2hEZWxldGVkSW5zdGFuY2UoKSB7XG4gICAgLy8gbm9vcFxuICB9LFxuICBwcmVwYXJlUG9ydGFsTW91bnQ6IGZ1bmN0aW9uIHByZXBhcmVQb3J0YWxNb3VudChwb3J0YWxJbnN0YW5jZSkge1xuICAgIC8vIG5vb3BcbiAgfVxufTtcbnZhciBob3N0Y29uZmlnID0gSG9zdENvbmZpZztcblxudmFyIFBpeGlGaWJlciA9IFJlY29uY2lsZXIoaG9zdGNvbmZpZyk7XG52YXIgUkVBQ1RfRE9NX1ZFUlNJT04gPSBwa2cuZGVwZW5kZW5jaWVzWydyZWFjdC1kb20nXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbnZhciBQQUNLQUdFX05BTUUgPSBwa2cubmFtZTtcblBpeGlGaWJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBidW5kbGVUeXBlOiAxICxcbiAgdmVyc2lvbjogUkVBQ1RfRE9NX1ZFUlNJT04sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6IFBBQ0tBR0VfTkFNRSxcbiAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IFBpeGlGaWJlci5maW5kSG9zdEluc3RhbmNlXG59KTtcblxuLy8gY2FjaGUgYm90aCByb290IFBpeGlGaWJlciBjb250YWluZXJzIGFuZCBSZWFjdCByb290c1xudmFyIHJvb3RzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29udGFpbmVyfSBjb250YWluZXJcbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudChjb250YWluZXIpIHtcbiAgaW52YXJpYW50KENvbnRhaW5lciQzLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGNvbnRhaW5lciksICdJbnZhbGlkIGFyZ3VtZW50IGBjb250YWluZXJgLCBleHBlY3RlZCBpbnN0YW5jZSBvZiBgUElYSS5Db250YWluZXJgLicpO1xuICBpZiAocm9vdHMuaGFzKGNvbnRhaW5lcikpIHtcbiAgICB2YXIgX3Jvb3RzJGdldCA9IHJvb3RzLmdldChjb250YWluZXIpLFxuICAgICAgcGl4aUZpYmVyQ29udGFpbmVyID0gX3Jvb3RzJGdldC5waXhpRmliZXJDb250YWluZXI7XG5cbiAgICAvLyB1bm1vdW50IGNvbXBvbmVudFxuICAgIFBpeGlGaWJlci51cGRhdGVDb250YWluZXIobnVsbCwgcGl4aUZpYmVyQ29udGFpbmVyLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3RzLmRlbGV0ZShjb250YWluZXIpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ3VzdG9tIFJlbmRlcmVyIHdpdGggcmVhY3QgMTggQVBJXG4gKiBVc2UgdGhpcyB3aXRob3V0IFJlYWN0LURPTVxuICpcbiAqIEBwYXJhbSB7Q29udGFpbmVyfSBjb250YWluZXJcbiAqIEByZXR1cm5zIHt7IHJlbmRlcjogRnVuY3Rpb24sIHVubW91bnQ6IEZ1bmN0aW9ufX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIpIHtcbiAgaW52YXJpYW50KENvbnRhaW5lciQzLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGNvbnRhaW5lciksICdJbnZhbGlkIGFyZ3VtZW50IGBjb250YWluZXJgLCBleHBlY3RlZCBpbnN0YW5jZSBvZiBgUElYSS5Db250YWluZXJgLicpO1xuICB2YXIgcm9vdCA9IHJvb3RzLmdldChjb250YWluZXIpO1xuICBpbnZhcmlhbnQoIXJvb3QsICdQaXhpIFJlYWN0OiBjcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlJyk7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBwaXhpRmliZXJDb250YWluZXIgPSBQaXhpRmliZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIHJlYWN0Um9vdCA9IHtcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gc2NoZWR1bGVzIGEgdG9wIGxldmVsIHVwZGF0ZVxuICAgICAgICBQaXhpRmliZXIudXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHBpeGlGaWJlckNvbnRhaW5lciwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIFBpeGlGaWJlci5nZXRQdWJsaWNSb290SW5zdGFuY2UocGl4aUZpYmVyQ29udGFpbmVyKTtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgICB1bm1vdW50Q29tcG9uZW50KGNvbnRhaW5lcik7XG4gICAgICAgIHJvb3RzLmRlbGV0ZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgcm9vdCA9IHtcbiAgICAgIHBpeGlGaWJlckNvbnRhaW5lcjogcGl4aUZpYmVyQ29udGFpbmVyLFxuICAgICAgcmVhY3RSb290OiByZWFjdFJvb3RcbiAgICB9O1xuICAgIHJvb3RzLnNldChjb250YWluZXIsIHJvb3QpO1xuICB9XG4gIHJldHVybiByb290LnJlYWN0Um9vdDtcbn1cblxuLyoqXG4gKiBDdXN0b20gUmVuZGVyZXJcbiAqIFVzZSB0aGlzIHdpdGhvdXQgUmVhY3QtRE9NXG4gKlxuICogQGRlcHJlY2F0ZWQgdXNlIGNyZWF0ZVJvb3QgaW5zdGVhZFxuICpcbiAqIEBwYXJhbSB7UmVhY3QuUmVhY3ROb2RlfSBlbGVtZW50XG4gKiBAcGFyYW0ge0NvbnRhaW5lcn0gY29udGFpbmVyIChpLmUuIHRoZSBTdGFnZSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcihlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gIGNvbnNvbGUud2FybignUGl4aSBSZWFjdCBEZXByZWNhdGlvbiBXYXJuaW5nOiByZW5kZXIgaXMgZGVwcmVjYXRlZCwgdXNlIGNyZWF0ZVJvb3QgaW5zdGVhZCcpO1xuICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignUGl4aSBSZWFjdCBEZXByZWNhdGlvbiBXYXJuaW5nOiByZW5kZXIgY2FsbGJhY2sgbm8gbG9uZ2VyIGV4aXN0cyBpbiBSZWFjdCAxOCcpO1xuICB9XG4gIHZhciByZWFjdFJvb3Q7XG4gIGlmIChyb290cy5oYXMoY29udGFpbmVyKSkge1xuICAgIHZhciBfcm9vdHMkZ2V0MiA9IHJvb3RzLmdldChjb250YWluZXIpO1xuICAgIHJlYWN0Um9vdCA9IF9yb290cyRnZXQyLnJlYWN0Um9vdDtcbiAgfSBlbHNlIHtcbiAgICByZWFjdFJvb3QgPSBjcmVhdGVSb290KGNvbnRhaW5lcik7XG4gIH1cbiAgcmV0dXJuIHJlYWN0Um9vdC5yZW5kZXIoZWxlbWVudCk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHJvb3QudW5tb3VudCgpIGluc3RlYWRcbiAqIEBwYXJhbSB7Q29udGFpbmVyfSBjb250YWluZXJcbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpIHtcbiAgdW5tb3VudENvbXBvbmVudChjb250YWluZXIpO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxudmFyIENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBBcHBQcm92aWRlciA9IENvbnRleHQuUHJvdmlkZXI7XG52YXIgQXBwQ29uc3VtZXIgPSBDb250ZXh0LkNvbnN1bWVyO1xudmFyIHdpdGhQaXhpQXBwID0gZnVuY3Rpb24gd2l0aFBpeGlBcHAoQmFzZUNvbXBvbmVudCkge1xuICB2YXIgd3JhcHBlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFwcENvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoYXBwKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUNvbXBvbmVudCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBhcHA6IGFwcFxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9KTtcbiAgd3JhcHBlci5kaXNwbGF5TmFtZSA9IFwid2l0aFBJWElBcHAoXCIuY29uY2F0KEJhc2VDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQmFzZUNvbXBvbmVudC5uYW1lLCBcIilcIik7XG4gIHJldHVybiB3cmFwcGVyO1xufTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTdGFnZSBSZWFjdCBDb21wb25lbnQgKHVzZSB0aGlzIGluIHJlYWN0LWRvbSlcbiAqXG4gKiBAdXNhZ2VcbiAqXG4gKiBjb25zdCBBcHAgPSAoKSA9PiAoXG4gKiAgIDxTdGFnZVxuICogICAgIHdpZHRoPXs1MDB9XG4gKiAgICAgaGVpZ2h0PXs1MDB9XG4gKiAgICAgb3B0aW9ucz17IGJhY2tncm91bmRDb2xvcjogMHhmZjAwMDAgfVxuICogICAgIG9uTW91bnQ9eyggcmVuZGVyZXIsIGNhbnZhcyApID0+IHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdQSVhJIHJlbmRlcmVyOiAnLCByZW5kZXJlcilcbiAqICAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZWxlbWVudDogJywgY2FudmFzKVxuICogICAgIH19PlxuICogKTtcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgLy8gZGltZW5zaW9uc1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyB3aWxsIHJldHVybiByZW5kZXJlclxuICBvbk1vdW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Vbm1vdW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgLy8gcnVuIHRpY2tlciBhdCBzdGFydD9cbiAgcmFmOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gcmVuZGVyIGNvbXBvbmVudCBvbiBjb21wb25lbnQgbGlmZWN5Y2xlIGNoYW5nZXM/XG4gIHJlbmRlck9uQ29tcG9uZW50Q2hhbmdlOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvLyBQSVhJIG9wdGlvbnMsIHNlZSBodHRwczovL3BpeGlqcy5kb3dubG9hZC9kZXYvZG9jcy9QSVhJLkFwcGxpY2F0aW9uLmh0bWxcbiAgb3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhdXRvU3RhcnQ6IFByb3BUeXBlcy5ib29sLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB1c2VDb250ZXh0QWxwaGE6IFByb3BUeXBlcy5ib29sLFxuICAgIGJhY2tncm91bmRBbHBoYTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBhdXRvRGVuc2l0eTogUHJvcFR5cGVzLmJvb2wsXG4gICAgYW50aWFsaWFzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IFByb3BUeXBlcy5ib29sLFxuICAgIHJlc29sdXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZm9yY2VDYW52YXM6IFByb3BUeXBlcy5ib29sLFxuICAgIGJhY2tncm91bmRDb2xvcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBjbGVhckJlZm9yZVJlbmRlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgcG93ZXJQcmVmZXJlbmNlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNoYXJlZFRpY2tlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hhcmVkTG9hZGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAvLyByZXNpemVUbyBuZWVkcyB0byBiZSBhIHdpbmRvdyBvciBIVE1MRWxlbWVudFxuICAgIHJlc2l6ZVRvOiBmdW5jdGlvbiByZXNpemVUbyhwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIHZhciBlbCA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGVsICYmIGludmFyaWFudChlbCA9PT0gd2luZG93IHx8IGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQsIFwiSW52YWxpZCBwcm9wIGByZXNpemVUb2Agb2YgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihlbCksIFwiLCBleHBlY3QgYHdpbmRvd2Agb3IgYW4gYEhUTUxFbGVtZW50YC5cIikpO1xuICAgIH0sXG4gICAgLy8gdmlldyBpcyBvcHRpb25hbCwgdXNlIGlmIHByb3ZpZGVkXG4gICAgdmlldzogZnVuY3Rpb24gdmlldyhwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciBlbCA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGVsICYmIGludmFyaWFudChlbCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50LCBcIkludmFsaWQgcHJvcCBgdmlld2Agb2YgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihlbCksIFwiLCBzdXBwbGllZCB0byBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiLCBleHBlY3RlZCBgPGNhbnZhcz4gRWxlbWVudGBcIikpO1xuICAgIH1cbiAgfSlcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDYwMCxcbiAgb25Nb3VudDogbm9vcCxcbiAgb25Vbm1vdW50OiBub29wLFxuICByYWY6IHRydWUsXG4gIHJlbmRlck9uQ29tcG9uZW50Q2hhbmdlOiB0cnVlXG59O1xuZnVuY3Rpb24gZ2V0Q2FudmFzUHJvcHMocHJvcHMpIHtcbiAgdmFyIHJlc2VydmVkID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3Qua2V5cyhwcm9wVHlwZXMpKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5rZXlzKFBST1BTX0RJU1BMQVlfT0JKRUNUKSkpO1xuICByZXR1cm4gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAhcmVzZXJ2ZWQuaW5jbHVkZXMocCk7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBwcm9wKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIGFsbCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIHByb3AsIHByb3BzW3Byb3BdKSk7XG4gIH0sIHt9KTtcbn1cbnZhciBTdGFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RhZ2UsIF9SZWFjdCRDb21wb25lbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFN0YWdlKTtcbiAgZnVuY3Rpb24gU3RhZ2UoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFnZSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9jYW52YXNcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9tZWRpYVF1ZXJ5XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfdGlja2VyXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfbmVlZHNVcGRhdGVcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFwcFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidXBkYXRlU2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMuaGVpZ2h0LFxuICAgICAgICBvcHRpb25zID0gX3RoaXMkcHJvcHMub3B0aW9ucztcbiAgICAgIGlmICghKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMucmVzb2x1dGlvbikpIHtcbiAgICAgICAgX3RoaXMuYXBwLnJlbmRlcmVyLnJlc29sdXRpb24gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgX3RoaXMucmVzZXRJbnRlcmFjdGlvbk1hbmFnZXIoKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmFwcC5yZW5kZXJlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm5lZWRzUmVuZGVyVXBkYXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmRlclN0YWdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgcmVuZGVyT25Db21wb25lbnRDaGFuZ2UgPSBfdGhpcyRwcm9wczIucmVuZGVyT25Db21wb25lbnRDaGFuZ2UsXG4gICAgICAgIHJhZiA9IF90aGlzJHByb3BzMi5yYWY7XG4gICAgICBpZiAoIXJhZiAmJiByZW5kZXJPbkNvbXBvbmVudENoYW5nZSAmJiBfdGhpcy5fbmVlZHNVcGRhdGUpIHtcbiAgICAgICAgX3RoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmFwcC5yZW5kZXJlci5yZW5kZXIoX3RoaXMuYXBwLnN0YWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFN0YWdlLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvbk1vdW50ID0gX3RoaXMkcHJvcHMzLm9uTW91bnQsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczMuaGVpZ2h0LFxuICAgICAgICBvcHRpb25zID0gX3RoaXMkcHJvcHMzLm9wdGlvbnMsXG4gICAgICAgIHJhZiA9IF90aGlzJHByb3BzMy5yYWYsXG4gICAgICAgIHJlbmRlck9uQ29tcG9uZW50Q2hhbmdlID0gX3RoaXMkcHJvcHMzLnJlbmRlck9uQ29tcG9uZW50Q2hhbmdlO1xuICAgICAgdGhpcy5hcHAgPSBuZXcgQXBwbGljYXRpb24oX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHZpZXc6IHRoaXMuX2NhbnZhc1xuICAgICAgfSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIGF1dG9EZW5zaXR5OiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF1dG9EZW5zaXR5KSAhPT0gZmFsc2VcbiAgICAgIH0pKTtcbiAgICAgIHtcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgUmVhY3QgMTggU3RyaWN0IE1vZGUgdW5tb3VudCBjYXVzaW5nIGNhbnZhc1xuICAgICAgICAvLyBjb250ZXh0IHRvIGJlIGxvc3RcbiAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmxvc2VDb250ZXh0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwLnRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXBwLnRpY2tlcltyYWYgPyAnc3RhcnQnIDogJ3N0b3AnXSgpO1xuICAgICAgdGhpcy5hcHAuc3RhZ2UuX19yZWFjdHBpeGkgPSB7XG4gICAgICAgIHJvb3Q6IHRoaXMuYXBwLnN0YWdlXG4gICAgICB9O1xuICAgICAgdGhpcy5tb3VudE5vZGUgPSBQaXhpRmliZXIuY3JlYXRlQ29udGFpbmVyKHRoaXMuYXBwLnN0YWdlKTtcbiAgICAgIFBpeGlGaWJlci51cGRhdGVDb250YWluZXIodGhpcy5nZXRDaGlsZHJlbigpLCB0aGlzLm1vdW50Tm9kZSwgdGhpcyk7XG4gICAgICBvbk1vdW50KHRoaXMuYXBwKTtcblxuICAgICAgLy8gdXBkYXRlIHNpemUgb24gbWVkaWEgcXVlcnkgcmVzb2x1dGlvbiBjaGFuZ2U/XG4gICAgICAvLyBvbmx5IGlmIGF1dG9EZW5zaXR5ID0gdHJ1ZVxuICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYXV0b0RlbnNpdHkgJiYgd2luZG93Lm1hdGNoTWVkaWEgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXNvbHV0aW9uKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcIigtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMyksIChtaW4tcmVzb2x1dGlvbjogMTIwZHBpKVwiKTtcbiAgICAgICAgdGhpcy5fbWVkaWFRdWVyeS5hZGRMaXN0ZW5lcih0aGlzLnVwZGF0ZVNpemUpO1xuICAgICAgfVxuXG4gICAgICAvLyBsaXN0ZW4gZm9yIHJlY29uY2lsZXIgY2hhbmdlc1xuICAgICAgaWYgKHJlbmRlck9uQ29tcG9uZW50Q2hhbmdlICYmICFyYWYpIHtcbiAgICAgICAgdGhpcy5fdGlja2VyID0gbmV3IFRpY2tlcigpO1xuICAgICAgICB0aGlzLl90aWNrZXIuYXV0b1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdGlja2VyLmFkZCh0aGlzLnJlbmRlclN0YWdlKTtcbiAgICAgICAgdGhpcy5hcHAuc3RhZ2Uub24oJ19fUkVBQ1RfUElYSV9SRVFVRVNUX1JFTkRFUl9fJywgdGhpcy5uZWVkc1JlbmRlclVwZGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgIHRoaXMucmVuZGVyU3RhZ2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpIHtcbiAgICAgIHZhciBfcHJldlByb3BzJG9wdGlvbnM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczQud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNC5oZWlnaHQsXG4gICAgICAgIHJhZiA9IF90aGlzJHByb3BzNC5yYWYsXG4gICAgICAgIHJlbmRlck9uQ29tcG9uZW50Q2hhbmdlID0gX3RoaXMkcHJvcHM0LnJlbmRlck9uQ29tcG9uZW50Q2hhbmdlLFxuICAgICAgICBvcHRpb25zID0gX3RoaXMkcHJvcHM0Lm9wdGlvbnM7XG5cbiAgICAgIC8vIHVwZGF0ZSByZXNvbHV0aW9uXG4gICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXNvbHV0aW9uKSAhPT0gdW5kZWZpbmVkICYmIChwcmV2UHJvcHMgPT09IG51bGwgfHwgcHJldlByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2UHJvcHMub3B0aW9ucy5yZXNvbHV0aW9uKSAhPT0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXNvbHV0aW9uKSkge1xuICAgICAgICB0aGlzLmFwcC5yZW5kZXJlci5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25NYW5hZ2VyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBzaXplXG4gICAgICBpZiAocHJldlByb3BzLmhlaWdodCAhPT0gaGVpZ2h0IHx8IHByZXZQcm9wcy53aWR0aCAhPT0gd2lkdGggfHwgKChfcHJldlByb3BzJG9wdGlvbnMgPSBwcmV2UHJvcHMub3B0aW9ucykgPT09IG51bGwgfHwgX3ByZXZQcm9wcyRvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldlByb3BzJG9wdGlvbnMucmVzb2x1dGlvbikgIT09IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzb2x1dGlvbikpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSByYWYgY2hhbmdlXG4gICAgICBpZiAocHJldlByb3BzLnJhZiAhPT0gcmFmKSB7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlcltyYWYgPyAnc3RhcnQnIDogJ3N0b3AnXSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBmbHVzaCBmaWJlclxuICAgICAgUGl4aUZpYmVyLnVwZGF0ZUNvbnRhaW5lcih0aGlzLmdldENoaWxkcmVuKCksIHRoaXMubW91bnROb2RlLCB0aGlzKTtcbiAgICAgIGlmIChwcmV2UHJvcHMud2lkdGggIT09IHdpZHRoIHx8IHByZXZQcm9wcy5oZWlnaHQgIT09IGhlaWdodCB8fCBwcmV2UHJvcHMucmFmICE9PSByYWYgfHwgcHJldlByb3BzLnJlbmRlck9uQ29tcG9uZW50Q2hhbmdlICE9PSByZW5kZXJPbkNvbXBvbmVudENoYW5nZSB8fCBwcmV2UHJvcHMub3B0aW9ucyAhPT0gb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyU3RhZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRJbnRlcmFjdGlvbk1hbmFnZXJcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBwcm92aWRlIHN1cHBvcnQgZm9yIFBpeGkgdjYgc3RpbGxcbiAgICBmdW5jdGlvbiByZXNldEludGVyYWN0aW9uTWFuYWdlcigpIHtcbiAgICAgIC8vIGBpbnRlcmFjdGlvbmAgcHJvcGVydHkgaXMgYWJzZW50IGluIFBpeGkgdjcgYW5kIGluIHY2IGlmIHVzZXIgaGFzIGluc3RhbGxlZCBGZWRlcmF0ZWQgRXZlbnRzIEFQSSBwbHVnaW4uXG4gICAgICAvLyBodHRwczovL2FwaS5waXhpanMuaW8vQHBpeGkvZXZlbnRzLmh0bWxcbiAgICAgIC8vIGluIHY3IGhvd2V2ZXIsIHRoZXJlJ3MgYSBzdHViIG9iamVjdCB3aGljaCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcsIHNvIGFsc28gY2hlY2sgdGhlIHJlc29sdXRpb24gcHJvcGVydHk6XG4gICAgICB2YXIgbWF5YmVJbnRlcmFjdGlvbiA9IHRoaXMuYXBwLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb247XG4gICAgICBpZiAobWF5YmVJbnRlcmFjdGlvbiAhPT0gbnVsbCAmJiBtYXliZUludGVyYWN0aW9uICE9PSB2b2lkIDAgJiYgbWF5YmVJbnRlcmFjdGlvbi5yZXNvbHV0aW9uKSB7XG4gICAgICAgIG1heWJlSW50ZXJhY3Rpb24ucmVzb2x1dGlvbiA9IHRoaXMuYXBwLnJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkcmVuKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBcHBQcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdGhpcy5hcHBcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkQ2F0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9jY3VycmVkIGluIGBTdGFnZWAuXCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9ySW5mbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5hcHApO1xuICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyU3RhZ2UpO1xuICAgICAgICB0aGlzLl90aWNrZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHAuc3RhZ2Uub2ZmKCdfX1JFQUNUX1BJWElfUkVRVUVTVF9SRU5ERVJfXycsIHRoaXMubmVlZHNSZW5kZXJVcGRhdGUpO1xuICAgICAgUGl4aUZpYmVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCB0aGlzLm1vdW50Tm9kZSwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5fbWVkaWFRdWVyeSkge1xuICAgICAgICB0aGlzLl9tZWRpYVF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHRoaXMudXBkYXRlU2l6ZSk7XG4gICAgICAgIHRoaXMuX21lZGlhUXVlcnkgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHAuZGVzdHJveSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMucHJvcHMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudmlldykge1xuICAgICAgICBpbnZhcmlhbnQob3B0aW9ucy52aWV3IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQsICdvcHRpb25zLnZpZXcgbmVlZHMgdG8gYmUgYSBgSFRNTENhbnZhc0VsZW1lbnRgJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIF9leHRlbmRzKHt9LCBnZXRDYW52YXNQcm9wcyh0aGlzLnByb3BzKSwge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihjKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fY2FudmFzID0gYztcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RhZ2U7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5TdGFnZS5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5TdGFnZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG52YXIgU3RhZ2UkMSA9IFN0YWdlO1xuXG5mdW5jdGlvbiB1c2VBcHAoKSB7XG4gIHZhciBhcHAgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICBpbnZhcmlhbnQoYXBwIGluc3RhbmNlb2YgQXBwbGljYXRpb24sICdObyBDb250ZXh0IGZvdW5kIHdpdGggYCVzYC4gTWFrZSBzdXJlIHRvIHdyYXAgY29tcG9uZW50IHdpdGggYCVzYCcsICdQSVhJLkFwcGxpY2F0aW9uJywgJ0FwcFByb3ZpZGVyJyk7XG4gIHJldHVybiBhcHA7XG59XG5cbmZ1bmN0aW9uIHVzZVRpY2soY2FsbGJhY2spIHtcbiAgdmFyIGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBhcHAgPSB1c2VBcHAoKTtcbiAgaW52YXJpYW50KHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ2B1c2VUaWNrYCBuZWVkcyBhIGNhbGxiYWNrIGZ1bmN0aW9uLicpO1xuICBpbnZhcmlhbnQoYXBwIGluc3RhbmNlb2YgQXBwbGljYXRpb24sICdObyBDb250ZXh0IGZvdW5kIHdpdGggYCVzYC4gTWFrZSBzdXJlIHRvIHdyYXAgY29tcG9uZW50IHdpdGggYCVzYCcsICdQSVhJLkFwcGxpY2F0aW9uJywgJ0FwcFByb3ZpZGVyJyk7XG4gIHZhciBzYXZlZFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzYXZlZFJlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0sIFtjYWxsYmFja10pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIHNhdmVkUmVmLmN1cnJlbnQuYXBwbHkoYXBwLnRpY2tlciwgW2RlbHRhLCBhcHAudGlja2VyXSk7XG4gICAgICB9O1xuICAgICAgYXBwLnRpY2tlci5hZGQodGljayk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYXBwLnRpY2tlcikge1xuICAgICAgICAgIGFwcC50aWNrZXIucmVtb3ZlKHRpY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VuYWJsZWRdKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCIsIFwiYXBwbHlcIl07XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciB3aXRoRmlsdGVycyA9IGZ1bmN0aW9uIHdpdGhGaWx0ZXJzKFdyYXBwZXJDb21wb25lbnQsIGZpbHRlcnMpIHtcbiAgaW52YXJpYW50KF90eXBlb2YoZmlsdGVycykgPT09ICdvYmplY3QnLCAnU2Vjb25kIGFyZ3VtZW50IG5lZWRzIHRvIGJlIGFuIGluZGV4ZWQgb2JqZWN0IHdpdGggeyBwcm9wOiBGaWx0ZXIgfScpO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZpbHRlcnMpO1xuICB2YXIgV3JhcHBlciA9IGZ1bmN0aW9uIFdyYXBwZXIoX3JlZikge1xuICAgIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBhcHBseSA9IF9yZWYuYXBwbHksXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICAgIC8vIGNyZWF0ZSBmaWx0ZXJzXG4gICAgdmFyIGZpbHRlckxpc3QgPSB1c2VSZWYodXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ga2V5cy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIF9wcm9wcyRwcm9wO1xuICAgICAgICB2YXIgY29uc3RydWN0b3JBcmdzID0gKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3Byb3BzJHByb3AgPSBwcm9wc1twcm9wXSkgPT09IG51bGwgfHwgX3Byb3BzJHByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wcyRwcm9wLmNvbnN0cnVjdCkgfHwgW107XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KGZpbHRlcnNbcHJvcF0sIF90b0NvbnN1bWFibGVBcnJheShjb25zdHJ1Y3RvckFyZ3MpKTtcbiAgICAgIH0pO1xuICAgIH0sIFtrZXlzXSkpO1xuICAgIHZhciBmaWx0ZXJPYmogPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBjLCBpKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFsbCksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGMsIGZpbHRlckxpc3QuY3VycmVudFtpXSkpO1xuICAgICAgfSwge30pO1xuICAgIH0sIFtrZXlzXSk7XG5cbiAgICAvLyBnZXQgcmVzdCBwcm9wc1xuICAgIHZhciByZXN0UHJvcHMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKG5vdChoYXNLZXkoa2V5cykpKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgYykge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhbGwpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBjLCBwcm9wc1tjXSkpO1xuICAgICAgfSwge30pO1xuICAgIH0sIFtwcm9wcywga2V5c10pO1xuXG4gICAgLy8gdXBkYXRlIGZpbHRlciBwYXJhbXNcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGssIGkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGZpbHRlckxpc3QuY3VycmVudFtpXSwgcHJvcHNba10pO1xuICAgIH0pO1xuXG4gICAgLy8gdXNlIGFwcGx5ID9cbiAgICBpZiAoYXBwbHkgJiYgaXNGdW5jdGlvbihhcHBseSkpIHtcbiAgICAgIGFwcGx5LmNhbGwoV3JhcHBlckNvbXBvbmVudCwgZmlsdGVyT2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZXJDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZXN0UHJvcHMsIHtcbiAgICAgIGZpbHRlcnM6IGZpbHRlckxpc3QuY3VycmVudFxuICAgIH0pLCBjaGlsZHJlbik7XG4gIH07XG4gIFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnRmlsdGVyV3JhcHBlcic7XG4gIFdyYXBwZXIucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBhcHBseTogUHJvcFR5cGVzLmZ1bmNcbiAgfTtcbiAgcmV0dXJuIFdyYXBwZXI7XG59O1xuXG52YXIgQml0bWFwVGV4dCA9IFRZUEVTLkJpdG1hcFRleHQ7XG52YXIgQ29udGFpbmVyID0gVFlQRVMuQ29udGFpbmVyO1xudmFyIEdyYXBoaWNzID0gVFlQRVMuR3JhcGhpY3M7XG52YXIgTmluZVNsaWNlUGxhbmUgPSBUWVBFUy5OaW5lU2xpY2VQbGFuZTtcbnZhciBQYXJ0aWNsZUNvbnRhaW5lciA9IFRZUEVTLlBhcnRpY2xlQ29udGFpbmVyO1xudmFyIFNwcml0ZSA9IFRZUEVTLlNwcml0ZTtcbnZhciBBbmltYXRlZFNwcml0ZSA9IFRZUEVTLkFuaW1hdGVkU3ByaXRlO1xudmFyIFRleHQgPSBUWVBFUy5UZXh0O1xudmFyIFRpbGluZ1Nwcml0ZSA9IFRZUEVTLlRpbGluZ1Nwcml0ZTtcbnZhciBTaW1wbGVNZXNoID0gVFlQRVMuU2ltcGxlTWVzaDtcbnZhciBTaW1wbGVSb3BlID0gVFlQRVMuU2ltcGxlUm9wZTtcblxuZXhwb3J0IHsgQW5pbWF0ZWRTcHJpdGUsIEFwcENvbnN1bWVyLCBDb250ZXh0IGFzIEFwcENvbnRleHQsIEFwcFByb3ZpZGVyLCBCaXRtYXBUZXh0LCBDb250YWluZXIsIEdyYXBoaWNzLCBOaW5lU2xpY2VQbGFuZSwgUGFydGljbGVDb250YWluZXIsIFBpeGlDb21wb25lbnQsIFBpeGlGaWJlciwgU2ltcGxlTWVzaCwgU2ltcGxlUm9wZSwgU3ByaXRlLCBTdGFnZSQxIGFzIFN0YWdlLCBUWVBFUywgVGV4dCwgVGlsaW5nU3ByaXRlLCBhcHBseURlZmF1bHRQcm9wcywgY3JlYXRlUm9vdCwgZXZlbnRIYW5kbGVycywgcmVuZGVyLCB1bm1vdW50Q29tcG9uZW50QXROb2RlLCB1c2VBcHAsIHVzZVRpY2ssIHdpdGhGaWx0ZXJzLCB3aXRoUGl4aUFwcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMtZGV2LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@pixi/react/dist/index.es-dev.js\n"));

/***/ }),

/***/ "./node_modules/@pixi/react/module.js":
/*!********************************************!*\
  !*** ./node_modules/@pixi/react/module.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable global-require */\nif (true)\n{\n    module.exports = __webpack_require__(/*! ./dist/index.es-dev */ \"./node_modules/@pixi/react/dist/index.es-dev.js\");\n}\nelse\n{}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBpeGkvcmVhY3QvbW9kdWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUFzQztBQUMxQztBQUNBLElBQUksa0hBQStDO0FBQ25EO0FBQ0E7QUFDQSxFQUVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcGl4aS9yZWFjdC9tb2R1bGUuanM/ZDhiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBnbG9iYWwtcmVxdWlyZSAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4LmVzLWRldicpO1xufVxuZWxzZVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2luZGV4LmVzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@pixi/react/module.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLHlCQUFzQjs7QUFFdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcz9lN2QxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO1xubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar ref, ref1;\nmodule.exports = ((ref = __webpack_require__.g.process) == null ? void 0 : ref.env) && typeof ((ref1 = __webpack_require__.g.process) == null ? void 0 : ref1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSx5QkFBeUIscUJBQU0seURBQXlELHFCQUFNLHNEQUFzRCxxQkFBTSxXQUFXLG1CQUFPLENBQUMsb0ZBQXdCOztBQUVyTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzP2NhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVmLCByZWYxO1xubW9kdWxlLmV4cG9ydHMgPSAoKHJlZiA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmVudikgJiYgdHlwZW9mICgocmVmMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwiLi4vLi4vY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./src/components/canvas/Scene.tsx":
/*!*****************************************!*\
  !*** ./src/components/canvas/Scene.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": function() { return /* binding */ Scene; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _pixi_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/react */ \"./node_modules/@pixi/react/module.js\");\n/* harmony import */ var _pixi_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_pixi_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst Scene = (param)=>{\n    let { width , height  } = param;\n    const onDragStart = (event)=>{\n        const sprite = event.currentTarget;\n        sprite.alpha = 0.5;\n        sprite.data = event.data;\n        sprite.dragging = true;\n    };\n    const onDragEnd = (event)=>{\n        const sprite = event.currentTarget;\n        sprite.alpha = 1;\n        sprite.dragging = false;\n        sprite.data = null;\n    };\n    const onDragMove = (event)=>{\n        const sprite = event.currentTarget;\n        if (sprite.dragging) {\n            const newPosition = sprite.data.getLocalPosition(sprite.parent);\n            sprite.x = newPosition.x;\n            sprite.y = newPosition.y;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_pixi_react__WEBPACK_IMPORTED_MODULE_2__.Stage, {\n        width: width,\n        height: height,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_pixi_react__WEBPACK_IMPORTED_MODULE_2__.Sprite, {\n            image: \"./img/nike.png\",\n            x: 100,\n            y: 100,\n            anchor: 0.5,\n            interactive: true,\n            buttonMode: true,\n            pointerdown: onDragStart,\n            pointerup: onDragEnd,\n            pointerupoutside: onDragEnd,\n            pointermove: onDragMove\n        }, void 0, false, {\n            fileName: \"/Users/sejinoh/Documents/GitHub/PixiJS-Test/client/src/components/canvas/Scene.tsx\",\n            lineNumber: 35,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/sejinoh/Documents/GitHub/PixiJS-Test/client/src/components/canvas/Scene.tsx\",\n        lineNumber: 34,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Scene;\nvar _c;\n$RefreshReg$(_c, \"Scene\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jYW52YXMvU2NlbmUudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUE2RDtBQUNuQztBQU9uQixNQUFNRyxRQUFRLFNBQXVCO1FBQXRCLEVBQUVDLE1BQUssRUFBRUMsT0FBTSxFQUFFO0lBQ3JDLE1BQU1DLGNBQWMsQ0FBQ0MsUUFBaUM7UUFDcEQsTUFBTUMsU0FBU0QsTUFBTUUsYUFBYTtRQUNsQ0QsT0FBT0UsS0FBSyxHQUFHO1FBQ2ZGLE9BQU9HLElBQUksR0FBR0osTUFBTUksSUFBSTtRQUN4QkgsT0FBT0ksUUFBUSxHQUFHLElBQUk7SUFDeEI7SUFFQSxNQUFNQyxZQUFZLENBQUNOLFFBQWlDO1FBQ2xELE1BQU1DLFNBQVNELE1BQU1FLGFBQWE7UUFDbENELE9BQU9FLEtBQUssR0FBRztRQUNmRixPQUFPSSxRQUFRLEdBQUcsS0FBSztRQUN2QkosT0FBT0csSUFBSSxHQUFHLElBQUk7SUFDcEI7SUFFQSxNQUFNRyxhQUFhLENBQUNQLFFBQWlDO1FBQ25ELE1BQU1DLFNBQVNELE1BQU1FLGFBQWE7UUFDbEMsSUFBSUQsT0FBT0ksUUFBUSxFQUFFO1lBQ25CLE1BQU1HLGNBQWNQLE9BQU9HLElBQUksQ0FBRUssZ0JBQWdCLENBQUNSLE9BQU9TLE1BQU07WUFDL0RULE9BQU9VLENBQUMsR0FBR0gsWUFBWUcsQ0FBQztZQUN4QlYsT0FBT1csQ0FBQyxHQUFHSixZQUFZSSxDQUFDO1FBQzFCLENBQUM7SUFDSDtJQUVBLHFCQUNFLDhEQUFDbkIsOENBQUtBO1FBQUNJLE9BQU9BO1FBQU9DLFFBQVFBO2tCQUMzQiw0RUFBQ0osK0NBQU1BO1lBQ0xtQixPQUFNO1lBQ05GLEdBQUc7WUFDSEMsR0FBRztZQUNIRSxRQUFRO1lBQ1JDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxhQUFhbEI7WUFDYm1CLFdBQVdaO1lBQ1hhLGtCQUFrQmI7WUFDbEJjLGFBQWFiOzs7Ozs7Ozs7OztBQVdyQixFQUFFO0tBL0NXWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9jYW52YXMvU2NlbmUudHN4P2E4NDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhZ2UsIENvbnRhaW5lciwgU3ByaXRlLCBUZXh0IH0gZnJvbSBcIkBwaXhpL3JlYWN0XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBEcmFnZ2FibGUgZXh0ZW5kcyBQSVhJLkRpc3BsYXlPYmplY3Qge1xuICBkYXRhOiBQSVhJLkludGVyYWN0aW9uRGF0YSB8IG51bGw7XG4gIGRyYWdnaW5nOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU2NlbmUgPSAoeyB3aWR0aCwgaGVpZ2h0IH0pID0+IHtcbiAgY29uc3Qgb25EcmFnU3RhcnQgPSAoZXZlbnQ6IFBJWEkuSW50ZXJhY3Rpb25FdmVudCkgPT4ge1xuICAgIGNvbnN0IHNwcml0ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgRHJhZ2dhYmxlO1xuICAgIHNwcml0ZS5hbHBoYSA9IDAuNTtcbiAgICBzcHJpdGUuZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgc3ByaXRlLmRyYWdnaW5nID0gdHJ1ZTtcbiAgfTtcblxuICBjb25zdCBvbkRyYWdFbmQgPSAoZXZlbnQ6IFBJWEkuSW50ZXJhY3Rpb25FdmVudCkgPT4ge1xuICAgIGNvbnN0IHNwcml0ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgRHJhZ2dhYmxlO1xuICAgIHNwcml0ZS5hbHBoYSA9IDE7XG4gICAgc3ByaXRlLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgc3ByaXRlLmRhdGEgPSBudWxsO1xuICB9O1xuXG4gIGNvbnN0IG9uRHJhZ01vdmUgPSAoZXZlbnQ6IFBJWEkuSW50ZXJhY3Rpb25FdmVudCkgPT4ge1xuICAgIGNvbnN0IHNwcml0ZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgRHJhZ2dhYmxlO1xuICAgIGlmIChzcHJpdGUuZHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gc3ByaXRlLmRhdGEhLmdldExvY2FsUG9zaXRpb24oc3ByaXRlLnBhcmVudCk7XG4gICAgICBzcHJpdGUueCA9IG5ld1Bvc2l0aW9uLng7XG4gICAgICBzcHJpdGUueSA9IG5ld1Bvc2l0aW9uLnk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFN0YWdlIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9PlxuICAgICAgPFNwcml0ZVxuICAgICAgICBpbWFnZT1cIi4vaW1nL25pa2UucG5nXCJcbiAgICAgICAgeD17MTAwfVxuICAgICAgICB5PXsxMDB9XG4gICAgICAgIGFuY2hvcj17MC41fVxuICAgICAgICBpbnRlcmFjdGl2ZVxuICAgICAgICBidXR0b25Nb2RlXG4gICAgICAgIHBvaW50ZXJkb3duPXtvbkRyYWdTdGFydH1cbiAgICAgICAgcG9pbnRlcnVwPXtvbkRyYWdFbmR9XG4gICAgICAgIHBvaW50ZXJ1cG91dHNpZGU9e29uRHJhZ0VuZH1cbiAgICAgICAgcG9pbnRlcm1vdmU9e29uRHJhZ01vdmV9XG4gICAgICAvPlxuICAgICAgey8qIDxTcHJpdGVcbiAgICAgICAgaW1hZ2U9XCIuL2ltZy9uaWtlLnBuZ1wiXG4gICAgICAgIHNjYWxlPXswLjJ9XG4gICAgICAgIHg9e3dpZHRoIC8gMn1cbiAgICAgICAgeT17aGVpZ2h0IC8gMn1cbiAgICAgICAgYW5jaG9yPXt7IHg6IDAuNSwgeTogMC41IH19XG4gICAgICAvPiAqL31cbiAgICA8L1N0YWdlPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJTdGFnZSIsIlNwcml0ZSIsIlJlYWN0IiwiU2NlbmUiLCJ3aWR0aCIsImhlaWdodCIsIm9uRHJhZ1N0YXJ0IiwiZXZlbnQiLCJzcHJpdGUiLCJjdXJyZW50VGFyZ2V0IiwiYWxwaGEiLCJkYXRhIiwiZHJhZ2dpbmciLCJvbkRyYWdFbmQiLCJvbkRyYWdNb3ZlIiwibmV3UG9zaXRpb24iLCJnZXRMb2NhbFBvc2l0aW9uIiwicGFyZW50IiwieCIsInkiLCJpbWFnZSIsImFuY2hvciIsImludGVyYWN0aXZlIiwiYnV0dG9uTW9kZSIsInBvaW50ZXJkb3duIiwicG9pbnRlcnVwIiwicG9pbnRlcnVwb3V0c2lkZSIsInBvaW50ZXJtb3ZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/canvas/Scene.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQSxZQUFZLG1CQUFPLENBQUMsdURBQVc7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/MjYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxnRkFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELFVBQVUsbUJBQU8sQ0FBQyx1REFBVztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsQ0FBTTtBQUM3STtBQUNBOztBQUVBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZ0NBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2I3NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELEVBQUUsS0FBSyxFQUlOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzP2JkZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz9lMDk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanM/ZTQ3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/NDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGdJQUF5RDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanM/YjMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n"));

/***/ })

});